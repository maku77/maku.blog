<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>まくろぐ</title><link>https://maku.blog/</link><description>Recent content on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 10 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Svelte を始める (SvelteKit で Hello World）</title><link>https://maku.blog/p/qmy6cdh/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qmy6cdh/</guid><description>Svelte とは Svelte は、コンパイラベースの Web アプリケーションフレームワークです。 特殊なテンプレート言語を使ってコンポーネントを実装することで、高度に最適化された HTML/JavaScript/CSS を出力することができます。 React.js アプリなどは、クライアントサイド JavaScript から共通のライブラリを呼び出す形で動作しますが、Svelte はコンパイル後の最適化された JavaScript のみで動作するようになっており、最終的な成果物が非常にコンパクトになります。 独自のテンプレート構文を学ぶ必要はありますが、ユーザー操作に反応するコンポーネントを、少ないコードで記述できるよう工夫されています。
☝️ ライバル？の Astro との違い Svelte よりも後発のコンパイラベースの Web アプリフレームワークに Astro があります。 Astro は、ビルド時にほとんどの JavaScript コードを実行して、その時点で静的な HTML ファイルを生成するというアプローチをとっています。 最終的にデプロイするのは、HTML (+CSS) だけになるので、初期表示が爆速になるという考え方です。 一方、Svelte はあくまで最適化された JavaScript コードはクライアントサイドで動かすという考え方です。
完全に静的なサイトであれば Astro を使い、インタラクティブなサイトであれば Svelte を使う、という使い分けがよさそうです。
参考: Astro 関連メモ Svelte + SvelteKit プロジェクトの作成 Svelte のプロジェクトは次のように npm create svelte コマンドで簡単に作成できます。 ウィザード形式の質問に答えていくだけで、TypeScript や ESLint、Prettier の導入まで一気にやってくれます。
Svelte プロジェクト (myapp) の作成 $ npm create svelte@latest myapp .</description></item><item><title>Astro と Svelte を使ってみた所感（Web サイト作るときに何を使うか）</title><link>https://maku.blog/p/zays9nw/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zays9nw/</guid><description>Next.js 以外の選択肢 2023 年現在、ある程度の規模の Web アプリを作れと言われたら、間違いなく Next.js (React.js) を使うのですが、小規模でほとんど静的な Web サイトを作れと言われたらちょっと迷ってしまうので、Astro と Svelte を少しだけ触ってみました。 もちろん、HTML や CSS を生でガリガリ書いて Web サイトを作ることもできますが、これらのフレームワークを使うことで、コンポーネント単位で Web ページを組み上げていくことができるのでコードの見通しがよくなります。
参考: Svelte 関連記事 Astro vs. Svelte 感覚としては、完全に静的な Web サイトを作るのであれば Astro がとてもシンプル でよさそうです。 ただし、フォームなどの入力要素が必要な場合は、データバインドを独自構文でサポートしている Svelte の方が便利かもしれません。 Svelte は簡単に使えるというけれど、独自のテンプレート構文などは若干 Vue.js の匂いがするので、そこを嫌う人は多そうです。 一方、Astro であれば、ほとんどドキュメントすら読まなくても理解できるくらい簡単です（React.js 触ったことがあれば即理解できるはず）。
Astro も Svelte も npm でビルドツールをインストールしますが、Astro であれば package.json の dependencies セクションが astro モジュールだけになるくらいシンプルです。
package.json { // ... &amp;#34;dependencies&amp;#34;: { &amp;#34;astro&amp;#34;: &amp;#34;^2.10.7&amp;#34; } } Astro モジュール自体が TypeScript や Vite を内包してくれているので、別途 TypeScript や Vite をインストールする必要はないし、VS Code の Astro 拡張 をポチッとインストールするだけで、Prettier による自動整形や TypeScript の型チェックがかかるようになります。 Svelte の場合は、Svelte 本体の他にも、SvelteKit や Vite や TypeScript などが dependencies にごちゃっと入ってきてしまうので、シンプルさに欠けます（こちらを好む人もいるのかもですが）。 まぁどちらも npm create で雛形生成すれば、ほぼゼロコンフィグで使えるんですが、Hello World レベルのコードで依存ファイルが多くなるのは避けたいところです。</description></item><item><title>D3.js による SVG 描画の基本</title><link>https://maku.blog/p/v38nmhw/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v38nmhw/</guid><description>D3.js は、クライアントサイド JavaScript で SVG 描画を行うためのライブラリです。 素の JavaScript（バニラ JavaScript) だけでも svg 要素を動的に構築していくことはできますが、D3.js を使うことでよりシンプルな API を使って描画処理を記述することができます。 ここでは、D3.js で基礎的な SVG 描画を行う方法を紹介します。
矩形を 1 つ描く D3.js で矩形を描画するには、d3.select() で svg 要素を選択し（D3 セレクションオブジェクトを取得）、そこに append() メソッドで rect 要素を追加します。 そして、メソッドチェーンさせる形で attr() を呼び出し、rect の属性（サイズや色）を設定していきます。
次の例では、svg 要素に緑色の矩形を 1 つ追加しています。 rect 要素の塗り潰し色は fill 属性で指定することに注意してください（CSS の &amp;ldquo;background&amp;rdquo; プロパティとは名前が異なります）。
図: 矩形の表示 &amp;lt;svg id=&amp;#34;mysvg&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;100&amp;#34; /&amp;gt; &amp;lt;script&amp;gt; d3.select(&amp;#34;#mysvg&amp;#34;) // svg 要素を選択 .append(&amp;#34;rect&amp;#34;) // svg 内に rect 要素を追加 .attr(&amp;#34;x&amp;#34;, 10) // rect 要素の属性値を設定 .</description></item><item><title>Deno プログラミングをはじめる</title><link>https://maku.blog/p/d8s6fpz/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d8s6fpz/</guid><description>Deno とは？ Deno（発音: ディーノ）は、Node.js の作者であるライアン・ダール (Ryan Dahl) 氏が作成した JavaScript/TypeScript の実行環境です。 Deno という名前は、Node を逆にしたネーミングになっています。 Node.js での反省を活かした改善が行われており、今後は Node.js ではなく Deno で作成されるアプリケーションが増えていくと思われます。 Deno には次のような特徴があります。
シンプルな 1 つの実行ファイル（deno コマンド）で提供 ネイティブに TypeScript 実行をサポート（tsc コマンドのインストールが不要） ゼロコンフィグで開発を始められる（必要に応じて deno.json を用意することも可能） package.json で依存モジュールを管理する必要がない 各種開発ツールを deno サブコマンドで標準搭載 deno fmt &amp;hellip; フォーマッター deno lint &amp;hellip; Lint ツール deno test &amp;hellip; テストランナー deno bundle &amp;hellip; バンドラー（1 つの JavaScript ファイルにまとめる） deno compile &amp;hellip; コンパイラー（OS ごとの実行ファイルを生成する） クロスプラットフォームな deno task（Node の npm run に相当） Web 標準の JavaScript API と互換性のある API 定義 (Web Platform APIs) Promise ベースの Deno API 実装 Rust 実装による高速動作（当初は Golang 実装だった） npm モジュールのサポート（2022 年に追加） 公式のサーバレス環境 Deno Deploy が提供されている Node.</description></item><item><title>Certbot で Let's Encrypt の SSL 証明書を取得する（Web サーバーの HTTPS 対応）</title><link>https://maku.blog/p/io4gs6h/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/io4gs6h/</guid><description>何をするか？ 数年前に Google が Web サイトの常時 SSL 化を推奨し始めて、今では多くの Web サイトが HTTPS によるアクセスに対応しています。 Web サーバーを HTTPS (SSL) 対応するには、第三者機関となる認証局 (CA: Certificate Authority) から SSL 証明書を発行してもらう必要があるのですが、Let&amp;rsquo;s Encrypt という認証局を使うと、SSL 証明書を無料で発行してもらえます（感謝！）。
図: Let&amp;#39;s Encrypt &amp;#43; Certbot による HTTPS 対応 レンタルサーバー側で提供されている WordPress 環境などを使用している人は、知らないうちに Let&amp;rsquo;s Encrypt を使った HTTPS 化の恩恵を受けているかもしれません。 ここでは、VPS などで自力で Web サーバーを立ち上げている人が、HTTPS (SSL) 対応する方法を説明します。
Let&amp;rsquo;s Encrypt からの SSL 証明書の発行には、Certbot というツールを使うのが一般的です。 Certbot による証明書取得や、Web サーバー (nginx) のヴァーチャルホスト設定をまとめて行ってしまう Docker イメージなども存在しますが、ここでは、Certbot の基本的な振る舞いを理解するために、certbot コマンドを直接実行する前提で説明していきます。
Certbot とは Certbot は、Let&amp;rsquo;s Encrypt 認証局から SSL 証明書を発行してもらうためのクライアントツールで、以下のような作業を自動で行ってくれます。</description></item><item><title>GraphQL ベストプラクティス</title><link>https://maku.blog/p/4reqy9i/</link><pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4reqy9i/</guid><description>GraphQL アプリ開発のノウハウ集です。 GraphQL のスキーマ設計から、サーバー実装、クライアント実装まで、GraphQL を使ったアプリ開発全般にわたるベストプラクティスをまとめています。 業務や趣味での GraphQL アプリ開発を通じて学んだことをまとめていますが、多くの項目は、主要な GraphQL ライブラリ (Apollo や gqlgen）の設計や、『Production Ready GraphQL』、『GraphQL in Action』 などの書籍を参考にしています。
クライアントファースト、スキーマファースト クライアントファースト (Client First) で考える 何よりも、クライアントのユースケースを念頭において考えます。 これは、GraphQL を採用するそもそもの目的でもあります。 バックエンドで使うデータベースや言語などの、実装詳細に引っ張られた API 設計にならないように気を付けます。
できるだけ早い段階でクライアントとのインテグレーションを始めるようにします。組織内での開発であれば、スキーマ定義が終わった段階で すぐにモックサーバーを用意する ことで、クライアント開発チームが実装を開始できます。 クライアントのユースケース以上の API は作らない ようにします。YAGNI (You Aren&amp;rsquo;t Going to Need It) の原則に従いましょう。クライアント要求のない API を提供しようとすると、混沌とした設計になりがちで、パフォーマンスの悪化やセキュリティリスクを招きます。そして、deprecated な API の管理に苦しむことになります。 既存のデータベースから GraphQL API を生成するツールはいろいろありますが、クライアントファーストの考えからするとナンセンスであり、多くの場合は採用すべきではありません。クライアントのニーズを満たす API にはなりませんし、バックエンドの実装詳細に依存した API になってしまいます。必要のない情報まで公開してしまうことによるセキュリティリスクなど、総合的にデメリットが多いです。こういったツールは、本当にデータベースに依存した API がマッチするケースでのみ導入すべきです。REST API 定義から GraphQL スキーマを生成するツールもありますが、そもそも両者はデザインコンセプトから異なるものであり、それでよい API ができると考えてはいけません。 スキーマファーストで実装を進める 多くのケースでは、スキーマ定義を先に考える スキーマファースト で設計を進めると、サーバーとクライアントを並行して開発することができます。 どのような API を実装すればよいか、どのような情報を取得できるのかが、早い段階で全員に明らかになるからです。</description></item><item><title>GraphQL スキーマ仕様: スキーマ定義の基本</title><link>https://maku.blog/p/5s5jvfz/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5s5jvfz/</guid><description>GraphQL スキーマとは GraphQL スキーマは、GraphQL API サーバーがどんなクエリを受け付けてくれるかを示すもので、GraphQL Schema Language という独自言語 (DSL) で記述します。 スキーマは型情報だけを定義したものであり、サーバーの実装ロジックは考慮しません（各型のデータを返すための具体的な実装は「リゾルバー」と呼ばれており、こちらはプログラミング言語に依存した実装を行います）。
GraphQL スキーマは、クライアントのニーズを把握して、クライアントファーストで考えるのがポイントです。 サーバーのバックエンドで使用する技術（RDB など）に影響されたスキーマ定義をしてはいけません。
☝️ .graphql vs .graphqls GraphQL スキーマドキュメントを独立したファイルとして作成する場合は、ファイルの拡張子を .graphqls あるいは .graphql とするのが一般的です。 .graphqls の方は「GraphQL のスキーマ」を表し、.graphql の方は「GraphQL のクエリドキュメント」を表すので明確に分けるべきだという主張もあります。 迷ったら、スキーマファイルには .graphqls を使っておけば間違いないと思います。 スキーマ定義のベストプラクティスに関しては、こちら にまとめています。
オブジェクト型 スキーマの中で基本的な要素となるのはオブジェクト型で、type キーワードを使って次のように定義します。
type オブジェクト型の名前 { フィールド名: 型 フィールド名: 型 フィールド名: 型 } これは、GraphQL クエリによって取得可能なデータの構造を表しています。 例えば、下記は書籍情報を表すオブジェクト型の例です。
type Book { id: ID! year: Int title: String! authors: [String!] tags: [String!]! } Book オブジェクトが持つフィールドは、フィールド名: 型 という形式で定義します。 型には、スカラー型、列挙型、リスト、オブジェクト型などを指定できます。 オブジェクト型のフィールドとして、別のオブジェクト型を指定することができますが、末端のオブジェクト型はスカラー型のフィールドのみで構成されている必要があります。 すべての型は デフォルトで Nullable であり、Non-null なフィールドであることを示すためには、型名の末尾に !</description></item><item><title>protobuf (.proto) ファイルのコーディングスタイル</title><link>https://maku.blog/p/esbs9o5/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/esbs9o5/</guid><description>.proto ファイルでメッセージやサービスを定義するときのコーディング規約をまとめておきます。 Google が Style Guide として指針をまとめていますが、プロジェクト内に既に .proto ファイルがある場合は、一貫性を保つように記述するのがよいとされています。
.proto ファイルの例 syntax = &amp;#34;proto3&amp;#34;; package endpoints.examples.bookstore; option java_multiple_files = true; option java_outer_classname = &amp;#34;BookstoreProto&amp;#34;; option java_package = &amp;#34;com.google.endpoints.examples.bookstore&amp;#34;; import &amp;#34;google/protobuf/empty.proto&amp;#34;; service Bookstore { rpc ListShelves(google.protobuf.Empty) returns (ListShelvesResponse) {} rpc CreateShelf(CreateShelfRequest) returns (Shelf) {} rpc GetShelf(GetShelfRequest) returns (Shelf) {} rpc DeleteShelf(DeleteShelfRequest) returns (google.protobuf.Empty) {} rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) {} rpc CreateBook(CreateBookRequest) returns (Book) {} rpc GetBook(GetBookRequest) returns (Book) {} rpc DeleteBook(DeleteBookRequest) returns (google.</description></item><item><title>GraphQL 関連用語</title><link>https://maku.blog/p/jz78nmk/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jz78nmk/</guid><description>ドキュメント (document) GraphQL リクエストで送る全体の文字列のこと。 HTTP Get リクエストで指定する場合は、query というクエリパラメーターで指定します（これは紛らわしいので、本当は document という名前になっているべきでした）。 HTTP Post リクエストで指定する場合は、ペイロードの JSON 内の query プロパティで指定します。 複数の GraphQL Operation（操作）や Fragment（フラグメント）を含むことができます。 クエリ (query) ドキュメント全体のことを示す場合と、query {...} という個々のクエリ操作を示す場合があります。後者の場合は、データの取得要求を表しています。 操作タイプ (operation type, root type) query {...} などの query というキーワード部分のこと。操作の種類を表しており、query の他には mutation と subscription があります。 操作名 (operation name) query GetHoge {...} などの GetHoge の部分のこと。特に query 操作の場合は query name、mutation 操作の場合は mutation name と呼ぶことがあります。操作名の指定は multi-operation documents じゃない限りオプショナルですが、ログ解析やデバッグをしやすくするために、名前を付けることが推奨されています。 HTTP Get リクエストで指定する場合は、operationName というクエリパラメーターで指定します。 HTTP Post リクエストで指定する場合は、ペイロードの JSON 内の operationName プロパティで指定します。 マルチ操作ドキュメント (multi-operation documents) 複数の query や mutation リクエストを含むドキュメント。どの操作を実行するかは、操作名 (operation name) で指定します。 変数 (variables) query や mutation などの各操作に与えることのできる、キー＆バリューの形で定義する値。query GetUser($id: ID!</description></item><item><title>Amazon Cognito (1) サインイン可能な Web サイトを作る (Cognito User Pool)</title><link>https://maku.blog/p/pufs8kx/</link><pubDate>Fri, 28 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pufs8kx/</guid><description>Cognito とは？ Amazon Cognito は、各種アプリケーションにユーザーの概念を取り入れて、サインアップやサインインなどを行えるようにするサービスです（OpenID Connect 準拠の Identity Provider (IdP) のひとつです）。 Cognito は大きく下記の 2 つの機能から成ります。
ユーザープール: ユーザーを管理する。任意のアプリに、ユーザー登録（サインアップ）や、認証（サインイン）の機能を付けることができる。 ID プール: 上記の仕組みでサインインしたユーザーに対して、AWS サービスへのアクセス権限を付加する。 単純にユーザー管理だけをしたいのであれば、前者の「ユーザープール」の機能だけを使うことができます。 実際には、認証後に AWS のリソースにアクセスさせることが多いと思いますので、後者の「ID プール」の仕組みを使って IAM の権限割り当てを行うことになります。
認証の仕組みに関しては、5 万 MAU（月間アクティブユーザー）まで無料で使えるので、個人で作成しているアプリでも使いやすいと思います。 ただし、無料枠を超えると 1 ユーザーあたり 1 円くらいかかり、多要素認証などを使おうとするともう少しお金がかかります。 詳しくは、Cognito の料金）のページを参照してください。
通常、Web サイトに認証機能を付けたいと思うと、ユーザー管理の仕組みや、サインイン画面などの UI を作成する必要がありますが、Cognito はこれらをまとめて提供してくれます。 ここでは、Cognito のユーザープールの作成から、React アプリでの認証までを説明します。
Cognito にユーザープールを作成する 準備として、Cognito のユーザープールを作成しておきます。
Cognito のマネージメントコンソールにアクセス ユーザープールの管理 → ユーザープールを作成する を選択します ユーザー作成時の条件 (Attribute) などを設定して作成ボタンを押します プール名は、適当に myapp-test とでも付けておけば大丈夫です。 本番環境用のユーザープールと、開発／テスト用のユーザープールは分けて作っておくのがよいので、ここではサフィックスとして -test を付けておきました。 デフォルト設定でサクッと作成してしまうこともできるし、いろいろな条件（メールアドレス必須とかパスワード強度とか）を指定することもできます。 ここでは、とりあえずデフォルト設定で適当に作成してしまいましょう。 ユーザー名でなく、メールアドレスでもログインできるようにしたいときは、属性 (Attribte) のタブで、ユーザー名 - 検証済みの E メールアドレスでのサインインも許可 にチェックをいれておきます。</description></item><item><title>Next.js ですべてのページにグローバルな CSS を適用する (pages/_app.ts)</title><link>https://maku.blog/p/s9iry9g/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s9iry9g/</guid><description>Next.js で、すべてのページコンポーネント (pages/*.tsx) に共通のスタイルシート（いわゆるグローバル CSS）を適用したい場合は、pages/_app.tsx(js) というファイルを作成して、そこで CSS ファイルをインポートします。
例えば、グローバル CSS として次のようなファイルを用意したとします。
styles/global.css * { box-sizing: border-box; } html { margin: 0; padding: 0; } body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif; max-width: 50rem; padding: 0.5rem; margin: 0 auto; font-size: 100%; } a { color: inherit; text-decoration: none; } この CSS ファイルを pages/_app.tsx からインポートすれば、すべてのコンポーネントにスタイルが反映されます。 このファイルが存在しない場合は作成してください。
pages/_app.tsx import type { AppProps } from &amp;#39;next/app&amp;#39; import &amp;#39;.</description></item><item><title>Next.js の API Routes 機能で Web API を作成する</title><link>https://maku.blog/p/qcp2coz/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2coz/</guid><description>Next.js の Web API 機能 Next.js では、pages/api ディレクトリ以下に TypeScript (JavaScript) コードを配置するだけで、クライアントサイド JavaScript から呼び出せる API を定義することができます。
例えば、次のようなファイルを作成します。
pages/api/hello.ts import type { NextApiRequest, NextApiResponse } from &amp;#39;next&amp;#39; type Response = { name: string } export default (req: NextApiRequest, res: NextApiResponse&amp;lt;Response&amp;gt;) =&amp;gt; { res.status(200).json({ name: &amp;#39;John Doe&amp;#39; }) // チェーン呼び出しせずに次のように記述しても OK // res.statusCode = 200 // res.json({ name: &amp;#39;John Doe&amp;#39;}) } あとは、Next.js サーバーを起動した状態で、/api/hello というエンドポイントにアクセスすると、次のような JSON データを取得できます。
{&amp;#34;name&amp;#34;:&amp;#34;John Doe&amp;#34;} API 機能は次のような用途に使用することができます。
フォームに入力された値が POST されたときにサーバーサイドで DB に保存する 3rd パーティ製の Web API の呼び出しを中継する このような機能を実装するには、データベースのパスワードや、3rd パーティ製 Web API のアクセスキーなどが必要になりますが、そういった情報は Next.</description></item><item><title>Next.js で各ページの head 要素をカスタマイズする (next/head)</title><link>https://maku.blog/p/rdr4fq2/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdr4fq2/</guid><description>Next.js で各ページの head 要素をカスタマイズしたいときは、Next.js の Head コンポーネント を使用して、必要な値のみを設定していきます。 典型的なのは、次のような title 要素の設定です。
// import Head from &amp;#39;next/head&amp;#39; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;Page Title&amp;lt;/title&amp;gt; &amp;lt;/Head&amp;gt; ちなみに、head 要素ではなく、html 要素の属性値などを設定したいときは、pages/_document.tsx ファイルを作成します。</description></item><item><title>Next.js のプリレンダリング機能を使用する (getStaticProps)</title><link>https://maku.blog/p/iv4agnt/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iv4agnt/</guid><description>Pre-rendering とは ブログの記事一覧ページなどを生成する場合、なんらかの API で取得した値をもとにページのコンテンツを生成する必要があります。 例えば、次のように取得した値を使ってページを生成することになります。
Web API で取得した値 データベースのクエリ結果 ローカルファイルの内容や、ファイルの一覧情報 Next.js には、Web サイトのビルド時や、Web サーバーへのアクセス時にこういった API を呼び出して、HTML コンテンツを生成する Pre-rendering 機能が備わっています。 Pre-rendering 機能は次の 2 種類があり、どちらか一方を使うこともできますし、両方を組み合わせて使うこともできます。
SSG: Static Generation（静的サイトジェネレーション） Web サイトのビルド時に HTML ファイルを生成します。Web サーバーは静的な HTML ファイルを返すだけでよいので、パフォーマンスが非常に高くなります。すべてのページを事前に列挙できるのであれば、できるだけこの SSG を使って静的に HTML 生成してしまうことが推奨されています。静的な HTML ファイルをホスト可能なサーバー（GitHub Pages など）があれば、Web サイトを公開できます。 SSR: Server-side Rendering（サーバーサイドレンダリング） クライアントが Web サーバーにアクセスしたときに、サーバーサイドで動的に HTML を生成します。この仕組みを使うと、日々増減するデータを扱いやすくなりますが、Web サーバーとして Next.js サーバーを稼働させておく必要があります。感覚的には、PHP サーバーなどが動作しているイメージに近いです。 ちなみに、純粋に React.js のみを使用した場合とはどう違うのでしょうか？ React.js 自体には Pre-rendering 機能は備わっておらず、主に SPA (Single Page Application) を作成するライブラリとして使用されています。 React.js のみを使って上記の例のような記事一覧ページを生成する場合、Web ブラウザ上で JavaScript を実行してコンテンツを動的に生成する必要があります。 これを SSG や SSR と区別するために、CSR: Client-side rendering（クライアントサイドレンダリング） と呼びます。</description></item><item><title>AWS CloudFormation 入門 (Hello World)</title><link>https://maku.blog/p/h7arpdj/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h7arpdj/</guid><description>CloudFormation とは AWS CloudFormation を使用すると、テンプレートファイル (YAML or JSON) で定義した AWS リソース群をまとめて生成（更新）することができます。 いわゆる IaC (Infrastructure as Code) 環境を提供するものであり、Ansible や Chef を使ったことがあれば、それの AWS リソース構築用だと考えると分かりやすいです。
テンプレートから生成されるインフラ（AWS リソース群）は スタック と呼ばれ、テンプレートがあればスタックは何度でも生成することができます。 これはオブジェクト指向プログラミングにおける、クラスとインスタンスの関係に似ています。 必要のなくなったリソース群は、スタック単位でまとめて削除することができます。
CloudFormation の主な特徴は次の通りです。
何度でも同じ構成でリソースをセットアップできる（他のリージョンに複製したり、一時的に使うインフラを自動生成できる） テンプレートはテキストファイル (YAML/JSON) なので、GitHub などでバージョン管理することができ、PullRequest ベースのコードレビューを行える 冪等性が考慮されており、テンプレートには最終的な結果だけを定義しておけばよい（構成のアップデート時に差分を意識する必要はない） 例えば、次のようなテンプレートを使用すると、S3 サービスのバケットリソースを自動で作成することができます。
template.yml AWSTemplateFormatVersion: &amp;#34;2010-09-09&amp;#34; Resources: HelloBucket: Type: AWS::S3::Bucket 必須のルートプロパティは Resources だけですが、テンプレートフォーマットのバージョンを示す AWSTemplateFormatVersion は最低限指定しておくのがよいでしょう（2021年時点で、2010-09-09 が最新バージョンです）。
CloudFormation コンソールからスタックを生成する CloudFormation マネージメントコンソール を使うと、Web サイト上でスタックを生成することができます。
CloudFormation マネージメントコンソールを使ったスタックの生成手順は以下の通りです。
サイドバーから Stacks（スタック）を選択する CloudFormation で管理されているスタックの一覧が表示されます。 （スタックの作成）ボタンを押す テンプレートを指定する S3 上に置いたファイルを指定することもできますが、ここではローカルに作成した YAML ファイルをアップロードします。そのためには、Template is ready（テンプレートの準備完了） → Upload a template file（テンプレートファイルのアップロード）を選択し、YAML ファイルを選択します。 任意のスタック名（mystack など）を入力します テンプレートファイル内にパラメータ (Parameters) を定義している場合は、ここで具体的な値を入力できます。 あとはそのまま進めていって、Create stack（スタックの作成）を押せば、スタックの生成処理が始まります。 スタックの一覧画面に戻ると、作成中のスタックのステータスが CREATE_IN_PROGRESS となって表示されます。 しばらくしてスタックの生成処理が完了すると、ステータスが CREATE_COMPLETE に変わります。 これで、テンプレートで定義した AWS リソース群が使用できる状態になります。</description></item><item><title>AWS S3 をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/4ju5eow/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4ju5eow/</guid><description>AWS CLI で S3 バケットの操作を行う場合、大きく分けて以下の 2 種類のコマンドがあります。
aws s3 &amp;hellip; 高レベルコマンド aws s3api &amp;hellip; API レベルコマンド 基本的には、aws s3 コマンドでカバーできない操作が出てきたときに aws s3api コマンドの方を調べてみるというやり方でいいと思います。 aws s3 コマンドの方は、OS のコマンドラインシェルのファイル操作コマンドのような体系になっています（aws s3 ls とか aws s3 rm とか）。
S3 バケットの操作を行うには、IAM ユーザーに適切な権限が割り当てられている必要がありますが、AmazonS3FulAccess 管理ポリシーがあればほとんどの操作が可能です。
S3 バケットを作成する (s3 mb) $ aws s3 mb s3://&amp;lt;バケット名&amp;gt; 実行例 $ aws s3 mb s3://makutemp-123456789012-bucket-1 make_bucket: makutemp-123456789012-bucket-1 ☝️ 同名バケットの再生成でエラー バケットの削除後に、同名のバケットを再生成しようとすると、次のような conflicting conditional operation のエラーになることがあります。 この場合は、バケットの削除処理が完了するまでしばらく待つ必要があります。
make_bucket failed: s3://makutemp-123456789012-bucket-1 An error occurred (OperationAborted) when calling the CreateBucket operation: A conflicting conditional operation is currently in progress against this resource.</description></item><item><title>AWS の初期設定: AWS CLI と認証情報の設定</title><link>https://maku.blog/p/j5iu7it/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j5iu7it/</guid><description>AWS CLI とは？ AWS CLI (Command Line Interface) を使うと、AWS の各種サービスをコマンドラインから操作することができます。 例えば、次のように様々な処理を実行できます。
S3 にファイルをコピーする $ aws s3 cp ローカルファイル s3://バケット名/ディレクトリ名 IAM ユーザーのアクセスキーを表示する $ aws iam list-access-keys --user-name=ユーザー名 DynamoDB にテーブルを作成する $ aws dynamodb create-table --table-name テーブル名 ... AWS の各種サービスの設定は、それぞれのマネージメントコンソール（Web サイト）上で設定することができますが、AWS CLI を使うことで、Web ブラウザを開かずに設定を済ませられます。 頻繁に行う処理などは、シェルスクリプトなどにして自動化することができます。
AWS CLI を使用するには、下記のような IAM ユーザーのアクセスキー（及びシークレットアクセスキー）が必要です。 以降の説明では、これらの情報が取得できていることを前提とします。
API 用アクセスキー（例）: INMCAKIAQX77PNSXQAGP API 用シークレットアクセスキー（例）: 2ufOA3Q2KAmpNTo2GHPDXFJK7Jiv9yfZGegIdbCW 参考リンク IAM ユーザーのアクセスキーを作成するには - AWS CLI AWS CLI のインストール インストール方法 macOS の場合 &amp;hellip; AWSCLIV2.pkg をダウンロードしてインストールできます。 Windows の場合 &amp;hellip; AWSCLIV2.</description></item><item><title>GitHub の GraphQL API Explorer の使い方</title><link>https://maku.blog/p/sk3rykz/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sk3rykz/</guid><description>GraphQL API Expolorer とは GitHub の GraphQL API (API ver.4) を使用すると、GitHub で管理されているリポジトリの情報やユーザーの情報などを、柔軟な GraphQL クエリを使って取得することができます。 しかし、いろいろなクエリ方法が用意されていて、実際にどのような情報が取得できるのかが分かりにくかったりします。 そんなとき便利なのが、GitHub が Web サイトとして用意してくれている、GraphQL API Explorer です。
GraphQL API Explorer | GitHub Developer Guide GraphQL API Explorer を使用すると、GraphQL API を使ってどのような情報を取得できるのか、実際にクエリを実行して確かめることができます。 GitHub アカウントでサインインした状態であれば、プライベートリポジトリの情報も取得することができます。 GitHub GraphQL API を利用するアプリケーションを作成するときは、このサイトでどのようなクエリを発行すればよいのかを調べながら作っていくことになると思います。
クエリエディタでは、下記のようなショートカットキーを使用することができます。
Ctrl + Space &amp;hellip; 入力補完 Ctrl + Enter &amp;hellip; 実行 History 機能と Explorer 機能 History ボタンを押すと、過去に実行したクエリをロードすることができます。 クエリに次のように名前を付けておくと、History にその名前が表示されるので、後ほど再利用する予定があれば、わかりやすい名前を付けておくとよいでしょう。
query GetApolloRepo { repository(owner: &amp;#34;apollographql&amp;#34;, name: &amp;#34;apollo-client&amp;#34;) { owner { login url } name url } } Explorer ボタンを押すと、スキーマ定義に基づいて、入力可能なフィールドをツリー形式で参照することができます（これを使うより、Ctrl + Space による補完の方が便利ですが）。</description></item><item><title>textlint のインストールと基本的な使い方</title><link>https://maku.blog/p/3veuap5/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3veuap5/</guid><description>textlint とは textlint は、テキストファイルや Markdown ファイル用の記述内容をチェックするための校正ツールです。
textlint · The pluggable linting tool for text and markdown たとえば、「である・ですます調の不一致」、「単語の表記揺れ」、「句読点の使いすぎ」など、様々なルールを定義して文章をチェックすることができます。 多人数で管理する社内ドキュメントはもちろんのこと、個人のブログなどで使用すれば、すべての文章で一定の品質を保つことができるようになります。
textlint のインストール textlint は Node.js のパッケージとして配布されているので、まだインストールされていない場合は先に Node.js をインストールしておく必要があります。
カレントプロジェクト用にインストールする カレントプロジェクト用に textlint をインストールするには、プロジェクト（テキストファイルが入ったディレクトリ）のルートディレクトリに移動し、次のように npm コマンドを実行します。
textlint をインストール $ npm init -y # なければ package.json を作成 $ npm install --save-dev textlint ☝️ ワンポイント この方法でインストールすると、カレントディレクトリの node_modules ディレクトリ以下に、ローカルモジュールとして textlint がインストールされます。 --save-dev (-D) オプションを付けることで、依存パッケージの情報が package.json および pacakge-lock.json ファイルに記録され、他のユーザーが npm install で同じ環境を構築できるようになります。 次のように textlint コマンドを実行できれば成功です。
$ npx textlint -v v11.</description></item><item><title>TypeScriptの型: 基本型（プリミティブタイプ）の一覧</title><link>https://maku.blog/p/2uds9o4/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2uds9o4/</guid><description>プリミティブ型 (primitive types) 下記のプリミティブ型は、JavaScript が内部的な型情報として扱うものであり、TypeScript のタイプアノテーションでも同様に使用することができます。 型名がすべて小文字になっているのが特徴的です。
boolean（真偽値） let isDone: boolean = false; （true または false） number（数値） let decimal: number = 6; （10進数リテラル） let hex: number = 0xf00d; （16進数リテラル） let octal: number = 0o744; （8進数リテラル） let binary: number = 0b1010; （2進数リテラル） string（文字列） let name: string = 'Maku'; （シングルクォートとダブルクォートは同様） let msg: string = `Hello, ${name}`;（変数展開する場合はバッククォート） function（関数） function foo(): number { return 100; } let bar: () =&amp;gt; number = foo bigint（巨大整数） let x: bigint = 1n; （ES2020 移行） symbol（ユニークなシンボル） let sym: symbol = Symbol('key'); （ES2015 移行） undefined（変数が初期化されていないことを示す） オブジェクト型 (object) 上記の型以外は、JavaScript の世界ではすべて object 型とみなされます。 TypeScript のタイプアノテーションでは、変数に格納できる値の型をより明確に示すことができます。</description></item><item><title>Azure のストレージアカウントを作成する</title><link>https://maku.blog/p/7axgzfu/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7axgzfu/</guid><description>Table Storage などのストレージ系サービスを使用するには、Azure ポータル から ストレージアカウント を作成しておく必要があります。 このトレージアカウントは Table Storage 専用ではなく、様々なストレージサービス（BLOB、ファイル、キュー、テーブル）をまとめて扱うものです。
ストレージアカウント → 作成 のような感じで進めば作成用の画面が開くので、ストレージアカウント名などを入力します。 ストレージアカウント名は、Azure 内で一意（要するに世界中で一意）な名前を付ける必要があります。
選択項目によっては、料金が変わってくるものがあるので、情報アイコンの説明を見ながら、安いプランを選択していきます。 例えば、Table Storage のレプリケーションの種類別価格は次のようになっています（こちらから抜粋）。
図: Table Storage の月額 入力が終わったら、作成 のボタンを押して、しばらく待てばストレージアカウントが作成されます（1分くらいかかります）。</description></item><item><title>Azure DevOps で無料のプライベート Git リポジトリ (Repos) を使用する</title><link>https://maku.blog/p/qt5qyzu/</link><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qt5qyzu/</guid><description>Azure DevOps について GitHub は Microsoft によって買収されましたが、Azure ブランドの DevOps サービスでも Git リポジトリを扱う Repos という機能が提供されています。 GitHub は 2019 年から無制限に Private リポジトリを作成できるようになりましたが、Azure DevOps の方も無制限に Private リポジトリを作成することができ、5 ユーザーまでのコラボレーションが無料です（GitHub は 3 ユーザーまで）。 DevOps の Repos でも、GitHub のようにプルリクエストを使ったレビューを行えます。
さらに、DevOps には Pipelines という、継続的インテグレーション/継続的デリバリー (CI/CD) の機能も含まれており、こちらも毎月 1,800 分の実行まで無料で使用できます。 GitHub Actions なども同じような機能を提供する予定であり、これから Azure DevOps とどのような関係で進化していくのかわかりませんが、現状では Azure DevOps は魅力的な選択肢と言えそうです。
Azure DevOps の Git リポジトリ (Repos) を使用する DevOps で Git リポジトリを作成する場合、まずは DevOps のプロジェクトを作成し、その中に Git リポジトリを作成していくという構成になります。 1 つの DevOps プロジェクトには、いくつでも Git リポジトリを作成できます。</description></item><item><title>TypeScript とは</title><link>https://maku.blog/p/tdouo5p/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tdouo5p/</guid><description>TypeScript は、JavaScript に静的な型付けを行えるようにしたプログラミング言語です。 トランスパイラ (tsc コマンド）を使って、TypeScript で記述したコードを JavaScript のコードに変換するのが主な使い方になります。 大規模な JavaScript アプリケーションを開発するときに TypeScript を導入すると、品質の高いコードを効率よく作成できるようになります。
TypeScript はマイクロソフトによって開発が進められており、同じくマイクロソフトによって開発されている Visual Studio Code でコーディングを行うのがよいとされています。
数年前に CoffeeScript と呼ばれる同様の言語が一時的にブームになりましたが、現在は TypeScript が主流です。 TypeScript には下記のような特徴があり、しばらくは JavaScript alternative として主流であり続けるでしょう。
Microsoft により強力にサポートされており、Visual Studio Code が最新の TypeScript バージョンに迅速に対応します。 静的な型付けにより、実行前（トランスパイル時）にコーディングのミスを発見しやすくなります。型の推論がしやすくなるため、IDE（VS Code など）のプロパティ名の自動補完が効くようになります。これがほんとに便利で、特にサードパーティ製のライブラリを使っているときにありがたみが分かります。 JavaScript (ECMAScript) の新しい仕様を使ってコーディングできます。TypeScript が新しい構文で書かれたコードを過去バージョンの JavaScript コードに変換してくれるため、各ブラウザベンダーが新しい仕様に対応するのを待つ必要がありません。 JavaScript のコードは有効な TypeScript のコードとして動作します（構文に互換性があります。専門用語では JavaScript の「スーパーセット」であると言う）。そのため、既存の JavaScript プロジェクトに TypeScript を導入しようとするとき、既存の JavaScript コードを修正する必要がありません。また、これまでに身に着けた JavaScript のノウハウをそのまま活かし続けることができます。</description></item><item><title>MongoDB の特徴</title><link>https://maku.blog/p/xzc5z98/</link><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xzc5z98/</guid><description>MongoDB はオープンソースの NoSQL データベースで、MongoDB Inc.（旧 10gen）によって開発とサポートが行われています。
https://www.mongodb.com/ MongoDB は次のような特徴を持っています。
ドキュメント指向型のデータベースで、BSON 形式 (Binary JSON) でオブジェクトを格納する。 スキーマ定義が必要なく、データ構造が柔軟。 マスタ・スレーブ型のアーキテクチャを取り、書き込みはマスタノードに対してのみ、読み出しは複製されたスレーブノードからのみ行われる。非同期に複製が行われ、一時的に複数のデータバージョンが混在する可能性があるため、完璧な整合性が求められる用途には向かない。 バージョン 1.6 以降はレプリカ・セットという方式を採用し、プライマリ＆セカンダリの役割に基づいて複製制御が行われる。 MapReduce を使ったバッチ処理を利用できる。 セカンダリ・インデックスという機能により、複数の索引を使ってデータを検索できる。 RDB と比較して大量のデータを扱える。Mongo という名前は、英語の humongous（巨大な）から来ている。 JavaScript コードをストアド・プロシージャとして使用できる。</description></item><item><title>PlantUML の基本（インストール〜画像ファイルへの保存）</title><link>https://maku.blog/p/opxhnho/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/opxhnho/</guid><description>Graphviz のインストール PlantUML は図の生成のために内部で Graphviz の dot コマンドを使用するので、先に Graphviz をインストールしましょう。
Graphviz - Graph Visualization Software ここでは、上記のサイトから ZIP ファイル graphviz-2.38.zip をダウンロードし、展開してできた release ディレクトリ内のファイル群を C:\app\graphviz-2.38 というディレクトリ内に配置するとします。 Graphviz に含まれる dot コマンドのパスを環境変数 GRAPHVIZ_DOT に設定すれば Graphviz のインストールは完了です（この環境変数を PlantUML が参照します）。
環境変数 GRAPHVIZ_DOT の設定 GRAPHVIZ_DOT=C:\app\graphviz-2.38\bin\dot.exe PlantUML のインストール 下記から plantuml.jar をダウンロードして、適当なディレクトリに配置します。
PlantUML - plantuml.jar のダウンロード ここでは、C:\app\plantuml\plantuml.jar というパスで配置することにします。 コマンドプロンプトから、下記のように実行して、特にエラーが発生しなければ OK です。
実行テスト C:\&amp;gt; java -jar C:\app\plantuml\plantuml.jar -testdot The environment variable GRAPHVIZ_DOT has been set to C:\app\graphviz-2.38\bin\dot.exe Dot executable is C:\app\graphviz-2.</description></item><item><title>mongo シェルの基本的な使い方</title><link>https://maku.blog/p/pwx5kf7/</link><pubDate>Mon, 13 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pwx5kf7/</guid><description>MongoDB サーバーへの接続 mongo シェルで MongoDB サーバーへ接続するには次の用に実行します。 先に MongoDB サーバーを起動 しておく必要があります）。
$ mongo # 単純に接続する場合 $ mongo mydb # 使用するデータベース名を指定する場合 ポート番号（デフォルトは 27017）や接続先の IP アドレスを指定することもできます。 下記はすべて正しい接続方法です。
$ mongo --port 40001 $ mongo --port 40001 mydb $ mongo localhost:40001 $ mongo localhost:40001/mydb $ mongo 192.168.0.100 $ mongo 192.168.0.100/mydb $ mongo 192.168.0.100:40001/mydb ヘルプの表示 (help) mongo シェルを起動したあとに、help コマンドを実行するとヘルプを表示することができます。
&amp;gt; help db.help() help on db methods db.mycoll.help() help on collection methods sh.help() sharding helpers rs.help() replica set helpers help admin administrative help help connect connecting to a db help help keys key shortcuts help misc misc things to know help mr mapreduce show dbs show database names show collections show collections in current database show users show users in current database show profile show most recent system.</description></item><item><title>MongoDB サーバー (mongod) を起動する</title><link>https://maku.blog/p/3ucs8n3/</link><pubDate>Mon, 13 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3ucs8n3/</guid><description>MongoDB クライアント（mongo コマンドや Web アプリケーション）から MongoDB のデータベースにアクセスするには、あらかじめ MongoDB サーバー（mongod）を起動しておく必要があります。
MongoDB サーバーを起動する (mongod) MongoDB サーバーは、単純にコマンドラインから mongod と実行するだけで起動できます（Windows のサービスとして起動 しておくことも可能です）。 mongod コマンドを実行するときに、--dbpath オプションを使ってデータの格納先ディレクトリを指定することができます（デフォルトは /data/db）。 下記の例では、mydata ディレクトリをデータ格納先に指定しています。
MongoDB サーバーの起動 $ mkdir mydata $ mongod --dbpath mydata ログファイル名を指定する (&amp;ndash;logpath, &amp;ndash;logappped) MongoDB サーバーのログはデフォルトで標準出力に出力されますが、--logpath オプションを使って、出力先のログファイル名を指定することもできます。 さらに、--logappend オプションを指定すると、これまでのログに追記される形で書き込まれます（このオプションを付けないと、ログファイルが上書きされてしまいます）。
ログを log.txt に保存する $ mongod --dbpath mydata --logpath log.txt --logappend --dbpath にはディレクトリ名を指定しますが、--logpath にはファイル名を指定することに注意してください。
ポート番号を指定する (&amp;ndash;port) mongod が使用するデフォルトのポート番号は 27017 ですが、--port オプションを使用して、任意のポート番号で起動することができます。 ポート番号を変更しておけば、1 台のホスト上で複数の mongod を立ち上げることができます。
ポート番号 40001 で起動する $ mongod --dbpath mydata --port 40001 サーバー側のポート番号を変更した場合は、mongo クライアントを起動するときにも mongo localhost:40001/dbname や --port 40001 のようにポート番号の指定が必要になることに注意してください。</description></item><item><title>SSH キーの管理: SSH キーを作成する (ssh-keygen)</title><link>https://maku.blog/p/ftducs9/</link><pubDate>Wed, 13 Aug 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ftducs9/</guid><description>SSH (Secure Shell) によるマシン間接続を有効にするには、接続元のマシンで SSH のキーペア（秘密鍵＋公開鍵）を作成し、接続先のマシンに公開鍵を登録する必要があります。 ここでは OpenSSH の ssh-keygen コマンドを使用した SSH キーの作成方法を紹介します。
SSH 鍵の作成 ssh-keygen コマンドをオプションなしで実行すると、SSH キー（秘密鍵＋公開鍵）を作成できます（SSH プロトコル ver.2 用）。 デフォルトでは暗号アルゴリズムとして RSA を使用するキーが生成されますが、-t オプションで暗号アルゴリズムを指定することができます。
SSH キーペアの生成 $ ssh-keygen -t ed25519 # Ed25519 鍵を作成する場合 -t オプション アルゴリズム 説明 rsa RSA 鍵 4096 bits の長い鍵長を選べば強度は出るが遅くなる ecdsa ECDSA 鍵 楕円曲線暗号。少ない鍵長で強度あり。ED25519 より普及している ed25519 Ed25519 鍵 楕円曲線暗号。少ない鍵長で強度あり。ECDSA より高速 dsa DSA 鍵 （非推奨）SSH2 の環境で使えるが、1024 bits しか選べないことが多い rsa1 RSA1 鍵 （非推奨）SSH1 のレガシー環境用。強度が弱いので使わない方がよい 実際に ssh-keygen コマンドを実行すると、パスワード (passphrase) の入力を求められるので、秘密鍵を使用する際のパスワードを設定しておきます。 このパスワードは、ssh コマンドでリモートホストに接続する際に入力することになります。 パスワード入力時に、何も入力せずに Enter を入力すれば、パスワードなしの SSH キーを生成できますが、通常はパスワードを設定してください。</description></item><item><title>１時間で分かる GoF デザインパターン</title><link>https://maku.blog/p/7gmjvza/</link><pubDate>Tue, 13 May 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7gmjvza/</guid><description>オブジェクト指向における再利用のためのデザインパターン エリック ガンマ, ラルフ ジョンソン, リチャード ヘルム, ジョン ブリシディース ソフトバンククリエイティブ 増補改訂版Java言語で学ぶデザインパターン入門 結城 浩 ソフトバンククリエイティブ デザインパターンの輪講をしたときのメモ。
生成に関するパターン (Creational Patterns) (1) Abstract Factory パターン 同種の複数のオブジェクト生成を concrete factory クラスとして種類ごとにまとめ、実際の生成は abstract factory クラスの抽象化されたインタフェース経由で行う。一貫した種類のインスタンスを作ることができる。
実装イメージ TvFactory tvFactory = new SonyTvFactory(); // Sony 製の TV を作るための TvFactory ... tvFactory.CreatePanel(); // SonyPanel を生成 tvFactory.CreateTuner(); // SonyTuner を生成 ... どのような手順で factory method を呼び出すかを定義すると、それは Builder パターンになる。
(2) Builder パターン オブジェクトの生成手順を共通化して使いまわし、異なるオブジェクトを作成。
実装イメージ Product* Director::CreateProduct(Builder *builder) { builder-&amp;gt;CreateStep1(); builder-&amp;gt;CreateStep2(); builder-&amp;gt;CreateStep3(); return builder-&amp;gt;GetProduct(); } 上記のメソッドに異なる Builder オブジェクトを渡せば、異なる Product が生成される。ただし、作成手順は共通化されている。</description></item><item><title>Node.js と Deno のコーディング方法の違いまとめ</title><link>https://maku.blog/p/zbaga2z/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zbaga2z/</guid><description>Deno でのコーディングは、Node.js とほぼ同様の書き方で行えますが、いくつか押さえておきたいポイントがあるのでまとめておきます。
Web Platform APIs Web ブラウザーで使える JavaScript の標準 API、例えば fetch API や、それに付随する Request や Response インタフェースをデフォルトで使用することができます。 これは、Chrome や Firefox などのブラウザ上で動作する JavaScript で使える API と同様の API を使えるということです。もちろん、Deno の実行環境はブラウザではないので、セキュリティモデルなどに微妙に違いがありますが、インタフェースが統一されているので学習コストが低いです。 Web Platform API の一覧は、こちらを参照してください。
Deno APIs / Built-in APIs JavaScript 標準ではない、組み込みの API (Deno API) は、Deno という namespace 以下のメソッド／プロパティとして提供されています。Deno が提供している API ということが一目でわかります。下記は、コマンドライン引数を参照するときの例です。 Deno.argv[0] // Deno の場合 process.argv[0] // Node の場合 Deno API 呼び出し時に発生するエラーは、Deno.errors namespace に定義されています。 Deno API には、まだ安定版 (stable) になっていないものがあり、それらを使う場合は、deno run 実行時に --unstable オプションを指定します。 Deno namespace の API の一覧は、こちらを参照してください。</description></item><item><title>Next.js から AWS DynamoDB にアクセスする</title><link>https://maku.blog/p/xp8o5k2/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xp8o5k2/</guid><description>何をするか？ Next.js アプリの API routes (pages/*.ts) や、getServerSideProps などのサーバーサイドで実行される関数では、通常の Node.js モジュールを使うことができるため、AWS の DynamoDB からデータを取得する、といったことも自由に行えます。 ここでは、Next.js の API routes 機能を使って、DynamoDB から情報を取得する Web API を作ってみます。 具体的には次のようなことをします。
テスト用の DynamoDB テーブル (Books) を作成する Books テーブルを参照するためのアクセスキー（IAM ユーザー）を作成する Next.js の API routes の実装 (pages/api/books.ts) を行う AWS SDK を使って DynamoDB から情報を取得する /api/books/001 のような URL にアクセスすると JSON データを返す アクセスキーは環境変数で設定する ☝️ アクセスキーを使った AWS リソースのアクセスについて AWS のアクセスキーは、IAM ユーザーに設定されるものであり、このアクセスキーが漏洩すると、そのユーザーの権限で何でもできる ということになります。 そのため、アクセスキーを使用するときは、IAM ユーザーの権限を適切に絞ることが大切で、そもそも本当に必要なケースでのみアクセスキーを使うようにすべきです。 アクセスキーが必要になるのは、AWS の外から AWS リソースに直接アクセスするケースです。 例えば、AWS CLI のコマンドで AWS の制御を行う場合や、今回の例のように AWS 外のサーバーから AWS へアクセスするようなケースです。</description></item><item><title>Amazon Cognito (2) サインイン後に AWS リソースへのアクセス権限を与える (Cognito Identity Pool)</title><link>https://maku.blog/p/3mx8hr2/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3mx8hr2/</guid><description>何をやるか？ 参考: Amazon Cognito (1) サインイン可能な Web サイトを作る (with React) 上記記事では、Cognito のユーザープール機能を使って、Web サイトにサインイン（サインアップ）機能を付けるところまでを説明しています。 ここでは、さらに Cognito の ID プール機能を使い、認証後のユーザーに AWS リソースへのアクセス権限を割り当てる方法を説明します。
Amazon Cognito サービスは、大きくわけて下記の 2 つの機能を提供しています。
User Pool &amp;hellip; 認証 (Authentication) Identity Pool &amp;hellip; 認証後のユーザーに対する 認可 (Authorization) 「認証」の方は、Cognito の User Pool を使う方法以外にも、Amazon、Facebook、Google など、様々な認証サービス（これらを 認証プロバイダー (IdP) と呼びます）を使用することができますが、ここでは Cognito の User Pool でユーザー認証することを前提とします。
ここから先の説明は、「認可」に関しての説明になります。 Cognito Identity Pool は、何らかの認証プロバイダーによる認証済みユーザーに対して、IAM ロールを割り当てることによって、任意の AWS リソースへのアクセスを許可します。 また、認証していないユーザー（いわゆるゲストユーザー）に対して、リードオンリーな IAM ロールを割り当てたり、User Pool の方でユーザーをグループに登録しておいて、そのグループの IAM ロールをアクセス権限として割り当てるといったことも可能です。
ID プール（フェデレーティッドアイデンティティ） Cognito の ID プールを使うと、各種認証プロバイダーサービス（Cognito の場合は「ユーザープール」）でサインインしたユーザーに対して、AWS リソース（API Gateway や DynamoDB など）へのアクセス権限を割り当てることができます。 ざっくり言うと、ID プールは、ユーザーに対して IAM ロールを割り当てる仕組み です。</description></item><item><title>Next.js でコンポーネント単位の CSS を作成する (CSS Modules)</title><link>https://maku.blog/p/seq2cmw/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/seq2cmw/</guid><description>CSS Modules とは CSS Modules は、コンポーネント（ファイル）単位で CSS ファイルを分けて管理する仕組みです（これ自体は Next.js の仕組みではありません）。 CSS の名前空間がコンポーネントごとに分離されるため、シンプルな CSS クラス名を付けても名前がコンフリクトする心配がありません。
Next.js は標準で CSS Modules の仕組みをサポートしており、CSS ファイルの拡張子を .module.css にするだけで、各コンポーネントの実装ファイルから簡単にインポートすることができます。
Next.js で CSS Modules 機能を使う Next.js で特定のコンポーネント用に CSS ファイルを用意するときは、そのコンポーネントと同じディレクトリに .module.css という拡張子を持つファイルを作成します。 この拡張子は、Next.js で CSS Modules の仕組みを使うときのルールです。
ここでは、警告メッセージを表示する Alert コンポーネント用の Alert.module.css を作成してみます。 といっても、普通に CSS ファイルを記述するだけです。 グローバルに適用する CSS ファイルと異なるのは、Alert コンポーネント用のスタイル定義しか含まれていないことです。
components/Alert.module.css .box { margin: 1em; padding: 0.5em; background: red; color: white; font-weight: bolder; border-radius: 0.5em; } この CSS ファイルを Alert コンポーネントから使用するには、次のようにインポートします。</description></item><item><title>Next.js のダイナミックルーティング機能を利用する (getStaticPaths, getStaticProps, getServerSideProps)</title><link>https://maku.blog/p/rdq3ep2/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq3ep2/</guid><description>ダイナミックルーティングとは Next.js では、pages/books/[id].tsx のようなファイル名でページを作成すると、1 つのファイルで、
/books/001 /books/002 /books/003 のようなパス (URL) によるアクセスをハンドルできます。 これを ダイナミックルーティング (Dynamic Routes) 機能と呼びます。
Next.js のページコンポーネント (/pages/xxx.tsx) は、そのページのエントリポイント（ルートコンポーネント）となるため、通常の React コンポーネントとは違って、上位のコンポーネントから props 情報を渡すことができません。 そこで Next.js では、ページコンポーネントの実装ファイル内で getStaticProps という関数を定義することで、ページコンポーネントに渡す props 情報を生成できるようにしています。 getStaticProps 内では、上記のような URL パラメータ情報（/books/[id] の id の部分の値）を取り出して、それを元に props 情報を生成できます。 この仕組みによって、Next.js のページコンポーネントは、1 つの .tsx ファイルで、複数のページ (.html) を生成できるようになっています。
ダイナミックルーティングの実装（SSG の場合） 静的ジェネレーション (SSG: Static Generation)、つまり Web サイトのビルド時にすべての HTML ファイルを生成してしまうには、あらかじめどのようなパラメーター（上記の例では id）でのアクセスが行われるかを把握した上で、各ページの内容を生成する必要があります。 これを実現するには、ページコンポーネントの実装ファイル (pages/*.tsx) で、次のような async 関数を実装して export します。
getStaticPaths 関数 URL のパラメーター部分（上記の例では id）で指定可能な値を返すように実装します。言い換えると、プリビルドすべきページの一覧情報を Next.</description></item><item><title>Next.js で全ページ共通のレイアウトを定義する（Layout コンポーネント）</title><link>https://maku.blog/p/dxamw8i/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dxamw8i/</guid><description>Next.js で Web サイトに見た目の統一感を持たせるには、Layout コンポーネントを作成して、全てのページのベースレイアウトとして使用するようにします。 Next.js の仕組みというより、React コンポーネントを作成するときの慣例のようなもので、コンポーネントに Layout という名前を付けるのも多くの人がその名前を使っているだけです。
Layout コンポーネントを定義する Layout コンポーネントを定義するために、次のようなファイルをプロジェクト内に作成します。 {children} の部分には、Layout 要素以下に配置した子要素が展開されることになります。
components/Layout.tsx import { ReactNode } from &amp;#39;react&amp;#39; type Props = { children: ReactNode; } export function Layout({ children, ...props }: Props) { return &amp;lt;div {...props}&amp;gt;{children}&amp;lt;/div&amp;gt; } この Layout コンポーネントを使用するには、各ページのコンポーネント実装において、ルート要素として配置します。
pages/about.tsx import Head from &amp;#39;next/head&amp;#39; import Link from &amp;#39;next/link&amp;#39; import { Layout } from &amp;#39;../components/Layout&amp;#39; export default () =&amp;gt; ( &amp;lt;Layout&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;About me&amp;lt;/title&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;h1&amp;gt;About me&amp;lt;/h1&amp;gt; &amp;lt;Link href=&amp;#34;/&amp;#34;&amp;gt; &amp;lt;a&amp;gt;Back to home&amp;lt;/a&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;/Layout&amp;gt; ) Layout コンポーネントに CSS を適用する styled-jsx で直接スタイルを埋め込む方法 styled-jsx の仕組み を使って、コンポーネントの定義内に直接 CSS を埋め込んでしまう方法です。</description></item><item><title>AWS CLI: Windows で HOME 環境変数を設定したときに credentials が見つからなくなる場合の対処</title><link>https://maku.blog/p/2td9ouj/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2td9ouj/</guid><description>AWS CLI や AWS SDK が参照する共有認証ファイル（credentials および config）は、デフォルトでは下記のようなディレクトリになっています。
Linux の場合: ~/.aws/credentials Windows の場合: ~/%USERPROFILE%/.aws/credentials ところが、Windows を使用している場合に、環境変数 %HOME% を設定していると、CLI や SDK が %HOME%/.aws/credentials を見に行ったりして、credentials が見つからない系のエラーが出ることがあります。 一貫して %USERPROFILE% の方を見に行ってくれれればよいのですが、このあたりの振る舞いは結構ルーズなようです。
そこで、Windows のジャンクション機能 で、両方の .aws ディレクトリが同じディレクトリを指すようにしてみました。 ジャンクション生成のコマンドは、mklink /j &amp;lt;fromDir&amp;gt; &amp;lt;toDir&amp;gt; です。
ジャンクションで 2 つの .aws を同一にする C:\&amp;gt; mklink /j %HOME%\.aws %USERPROFILE%\.aws C:\home\.aws &amp;lt;&amp;lt;===&amp;gt;&amp;gt; C:\Users\maku\.aws のジャンクションが作成されました これで、%HOME%\.aws ディレクトリを参照したときの実体として、%USERPROFILE%\.aws ディレクトリが使われるようになります。 今のところ快適に動作しています。
ちなみに、ジャンクションを削除したいときは、ジャンクション元の %HOME%\.aws ディレクトリを削除するだけです。 実体の方の %USERPROFILET%\.aws は削除されないので安全です。</description></item><item><title>Node.js で Amazon S3 を操作する (AWS SDK)</title><link>https://maku.blog/p/m8kv8it/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m8kv8it/</guid><description>ここでは、Node.js 用の AWS SDK を使って Amazon S3 を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
S3 用の Node.js SDK をインストールする AWS SDK version 3 の S3 用パッケージをインストールするには次のようにします。
### npm の場合 $ npm install @aws-sdk/client-s3 ### yarn の場合 $ yarn add @aws-sdk/client-s3 これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。
main.ts import { S3Client, ListBucketsCommand } from &amp;#39;@aws-sdk/client-s3&amp;#39;; S3Client インスタンスの生成 AWS SDK で S3 の操作を行うには、S3Client オブジェクトを使って各種コマンドを送ります。
new S3Client(configuration: S3ClientConfig): S3Client S3Client コンストラクタには S3ClientConfig オブジェクトを渡すようになっており、接続情報などを指定できます。 空オブジェクト ({}) を渡すと、現在の環境の default プロファイルの設定が使用されます（~/.aws/config と ~/.aws/credentials に設定されたもの）。</description></item><item><title>VSCode の textlint プラグインで文章を校正する (vscode-textlint)</title><link>https://maku.blog/p/d3fs5gs/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d3fs5gs/</guid><description>事前準備（textlint のインストール） vscode-textlint は、Visual Studio Code でテキスト校正ツールの textlint を実行するためのプラグインです。 プレーンテキスト (.txt) や、Markdown ファイル (.md) の校正を VSCode 上で実行できるようになります。 textlint の本体の方は、Node.js の npm コマンドを使ってあらかじめインストールしておく必要があります。
参考: textlint のインストールと基本的な使い方 こんな感じでインストールできます。
textlint 本体のインストール $ cd myproject # テキストファイルのあるディレクトリへ移動 $ npm init -y # package.json がない場合は作成 $ npm install -D textlint # textlint のインストール もし、既存のプロジェクトで、package.json や .textlintrc などがすでに存在しているのであれば、次のように実行すれば一発で textlint の実行環境が整います。
package.json に従って環境構築する場合 $ npm install vscode-textlint プラグインをインストールする vscode-textlint プラグインは、VS Code の Extensions タブから、textlint で検索してインストールすることができます。
vscode-textlint プラグインによる校正を実行する vscode-textlint プラグインは、VS Code で開いたディレクトリ内に設定ファイル .</description></item><item><title>TypeScript のコーディング規約（ルール／ガイドライン）</title><link>https://maku.blog/p/avssq37/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/avssq37/</guid><description>有名な JavaScript/TypeScript スタイル TypeScript のコーディングスタイルは下記のサイトが参考になります。
スタイルガイド（コーディング規約） - TypeScript Deep Dive 日本語版 TypeScript Deep Dive のスタイルガイドは、重要なポイントが簡潔にまとまっていてわかりやすいです。 standard/standard: JavaScript Standard Style セミコロンの省略を推奨していますが、2021 年時点ではまだセミコロン有り派の方が多いようです。モダンなプログラミング言語では行末にセミコロンを付けないものが多いので、セミコロン省略派が増えてきているというのも何となく頷けます。 関数定義の際に、カッコの前にスペースを強制するところがちょっと気持ち悪いです。 Node.js、npm、GitHub、Electron など有名どころが採用しています。 ドキュメントサイト airbnb/javascript: JavaScript Style Guide Airbnb は JS スタイルを細かく定義しています。ただ、長大すぎるので、重要なポイントをかいつまんで読むのには向いてません。ESLint などのツールを使ってスタイル強制する 場合にもよく使われますが、TypeScript 対応が不完全で、モジュールインポート時の拡張子省略がエラーになったりします（2021-05 時点）。 Coding guidelines · microsoft/TypeScript Wiki TypeScript 自体のコントリビューター用のコーディングガイドラインです。ユーザーレベルの開発プロジェクトに強制するものではないと注記がありますが、多くのルールはそのまま採用できると思います。インデントサイズは 4 とされていますが、多くの TypeScript プロジェクトではインデントサイズは 2 が採用されているので、ここだけ例外的です。 google/styleguide: Google Style Guides JavaScript/TypeScript 以外にもいろいろな言語の Google スタイルが説明されています。 JavaScript/TypeScript の世界では、上記の JavaScript Standard か Airbnb のスタイルの方が人気があるようです。 ESLint 用の設定ファイルはこちら まとめると、多くのスタイルガイドでは次のようなルールが採用されています。
インデントは 2 文字（4 文字を採用しているのはごく一部のプロジェクトのみ） ドキュメンテーションコメントには JSDoc の記法を使う 命名規則 型名（クラス名、列挙型、エイリアスなど）は PascalCase 変数名や関数名は camelCase プライベートプロパティ名を _ で始めない 文字列リテラル は 'シングルクォーテーション' で囲む シングルクォーテーションを含む文字列はダブルクォーテーションで囲んで OK 比較には == ではなく === を使用する。ただし、下記は例外。 obj == undefined &amp;hellip; null あるいは undefined であることのチェック obj !</description></item><item><title>TypeScriptの型: 変数の型指定（タイプアノテーション）の基本</title><link>https://maku.blog/p/ugyw5ee/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ugyw5ee/</guid><description>TypeScript の特徴は、変数の型を明示的に指定できることです。 この型指定のことを タイプアノテーション (Type annotation) と呼びます。
単純な変数のタイプアノテーション 下記は、文字列、数値、真偽値、配列のタイプアノテーションの例です。
let user: string = &amp;#39;まく&amp;#39;; let age: number = 14; let isActive: boolean = true; let titles: string[] = [&amp;#39;名前1&amp;#39;, &amp;#39;名前2&amp;#39;, &amp;#39;名前3&amp;#39;]; 指定した型と異なる型の値を代入しようとするとエラーになります。
let age: number = 14; age = &amp;#39;100歳&amp;#39;; エラーメッセージ Cannot assign to &amp;#39;age&amp;#39; because it is a constant. 配列や辞書、クラスなどの使い方は下記のページを参考にしてください。
参考リンク 配列を定義する (Array) 辞書型を定義する (Dictionary) クラス定義の基本 (class) 関数のタイプアノテーション 関数の型もアノテーションで示すことができます。
// 文字列を受け取り、何も返さない関数 let logger: (name: string) =&amp;gt; void; // 2つの数値を受け取り、真偽値を返す関数 let equal: (a: number, b: number) =&amp;gt; boolean; これらの変数には、パラメータと戻り値の型が等しく定義された関数のみ代入することができます。</description></item><item><title>PlantUML でクラス図を作成する</title><link>https://maku.blog/p/tn6y85z/</link><pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tn6y85z/</guid><description>クラスの箱を描く 基本 クラスの箱を描くには、class キーワードを使用します。 他にも、interface でインタフェース、abstract で抽象クラス、enum で列挙型を定義することができます。
@startuml class クラス interface インタフェース abstract 抽象クラス enum 列挙型 @enduml クラス名にスペースや記号を含んでいる場合 クラス名やインタフェース名にスペースや記号を含めたい場合は、その文字列全体をダブルクォート &amp;quot;&amp;quot; で囲みます。 さらに、as で別名を付けておくと、あとから参照しやすくなります。
@startuml class &amp;#34;This is a class A&amp;#34; as A class &amp;#34;This is a class B&amp;#34; as B A -&amp;gt; B @enduml ステレオタイプ クラス名の後ろに &amp;lt;&amp;lt;ステレオタイプ&amp;gt;&amp;gt; と記述することで、クラス名の上部に任意のステレオタイプを表示することができます。 独自のステレオタイプを表示することができますし、複数のステレオタイプを表示することもできます。
@startuml interface インタフェース &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; abstract 抽象クラス &amp;lt;&amp;lt;abstract&amp;gt;&amp;gt; class ほげほげ &amp;lt;&amp;lt;独自ステレオタイプ&amp;gt;&amp;gt; class へむへむ &amp;lt;&amp;lt;Serializable&amp;gt;&amp;gt; &amp;lt;&amp;lt;Model&amp;gt;&amp;gt; @enduml クラス名の横の記号を非表示にする クラス名の左側に表示される C の記号などを非表示するには、hide circle コマンドを使用します。 下記のようにすると、クラスやインタフェースの記号がすべて非表示になります。 インタフェースに &amp;lt;&amp;lt;inteface&amp;gt;&amp;gt; というステレオタイプを表示するのであれば、記号は冗長なので消しておいた方がよいかもしれません。</description></item><item><title>mongo シェルで JavaScript ファイル（スクリプト）を実行する</title><link>https://maku.blog/p/2thipwb/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2thipwb/</guid><description>例えば、input.js というスクリプトを mongo シェルで実行するには以下のようにします。 ここでは、mydb という名前のデータベースの books コレクションに、テスト用のドキュメントを追加しています。
$ mongo mydb input.js input.js db.books.insert({title: &amp;#39;Title 1&amp;#39;}); db.books.insert({title: &amp;#39;Title 2&amp;#39;}); db.books.insert({title: &amp;#39;Title 3&amp;#39;}); ドキュメントには書いてありませんが、標準入力から読み込ませることもできるようです。 この方法を使うと、mongo コマンドのオプションのフォーマット的に、データベース名を省略してスクリプトファイル名を指定できるようになるので、スクリプトの中でデータベースを切り替えることができます。
$ mongo &amp;lt; input2.js $ mongo --port 40001 &amp;lt; input2.js $ mongo localhost:40001 &amp;lt; input2.js input2.js use testdb; db.books.insert({title: &amp;#39;Title 1&amp;#39;, tags: [&amp;#39;AAA&amp;#39;, &amp;#39;BBB&amp;#39;]}); db.books.insert({title: &amp;#39;Title 2&amp;#39;, tags: [&amp;#39;BBB&amp;#39;, &amp;#39;CCC&amp;#39;]}); db.books.insert({title: &amp;#39;Title 3&amp;#39;, tags: [&amp;#39;CCC&amp;#39;, &amp;#39;AAA&amp;#39;]});</description></item><item><title>MongoDB サーバー (mongod) を Windows サービスとして登録する</title><link>https://maku.blog/p/tm4jzet/</link><pubDate>Fri, 17 Jan 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tm4jzet/</guid><description>Windows サービスとして MongoDB サービスを登録する MongoDB サーバー (mongod) を Windows サービスとして登録しておくと、バックグラウンドで MongoDB サーバーが動作するようになるため、いちいちコマンドラインで mongod を起動する必要がなくなります。
MongoDB サーバーを Windows サービスとして登録するには、コマンドプロンプトを管理者権限で起動し、次のように入力します。
Windows サービスとして MongoDB サービスを登録 C:\&amp;gt; mongod --install --dbpath &amp;lt;DBディレクトリ&amp;gt; --logpath &amp;lt;ログファイル名&amp;gt; コンソール上でログを確認することができなくなってしまうので、ログがファイルに保存されるように、ログファイル名を指定しておく必要があります。
下記は実行例です。 ここでは、データベースディレクトリとして D:\mongo_data、ログファイル名 D:\mongo_log\log.txt を指定しています。 ディレクトリはあらかじめ作成しておく必要があります。
C:\&amp;gt; mkdir D:\mongo_data C:\&amp;gt; mkdir D:\mongo_log C:\&amp;gt; mongod --install --dbpath D:\mongo_data --logpath D:\mongo_log\log.txt Fri Jan 17 12:11:49.699 Trying to install Windows service &amp;#39;MongoDB&amp;#39; Fri Jan 17 12:11:49.711 Service &amp;#39;MongoDB&amp;#39; (Mongo DB) installed with command line &amp;#39;C:\app\mongodb\mongod.</description></item><item><title>MongoDB と RDB の用語比較</title><link>https://maku.blog/p/gbs79ua/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gbs79ua/</guid><description>MongoDB で使用する Database や Collection などの用語は、RDB の用語と以下のような関係にあります。
MongoDB の用語 RDB の用語 Database Database Collection（コレクション） Table（テーブル） Document（ドキュメント） Record / Row（行） Field（フィールド） Column（列） ある Database の Collection に Document を追加するときは、mongo クライアントでは以下のように実行します。
&amp;gt; use &amp;lt;Database名&amp;gt; &amp;gt; db.&amp;lt;Collection名&amp;gt;.insert(&amp;lt;Document の Field セット&amp;gt;)</description></item><item><title>Amazon Cognito: Amplify SDK による認証まわりの UI 表示あれこれ</title><link>https://maku.blog/p/24p8jjx/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/24p8jjx/</guid><description>認証済みユーザーが admin グループに属しているか調べて UI を切り替える Cognito ユーザープールの「グループ」機能を使うと、既存のユーザーをグループ単位でまとめて、特別な IAM ロールを割り当てたりすることができます。 例えば、admin グループを作っておいて、そのグループに所属するユーザーに、DynamoDB の書き込み権限 (IAM role) を与える、といったことができます。
React アプリのレイヤでは、このような IAM ロールの権限うんぬんの前に、カレントユーザーがどのようなグループに所属しているかに応じて UI の表示分けをしたいことがあります。 例えば、admin グループのユーザーが Web ページを表示しているときは、管理者向けのメニュー表示をする、といったケースです。
幸い、aws-amplify モジュールの Auth オブジェクトが提供する認証情報を参照することで、認証済みのユーザーがどの Cognito グループに属しているかを調べることができます。 具体的には、Auth.currentAuthenticatedUser() などが返すユーザー情報のアクセストークンのペイロードに cognito:groups というプロパティがあり、そこに Cognito グループ名のリストが格納されています。
参考: Using the Access Token - Amazon Cognito 次のようなカスタムフック useAuthState を定義しておくと、戻り値の isAdmin プロパティを見るだけで、現在のユーザーが admin グループに属しているかを確認できます。
src/hooks/useAuthState.tsx import { useEffect, useState } from &amp;#39;react&amp;#39; import { Auth } from &amp;#39;aws-amplify&amp;#39; import { AuthState, CognitoUserInterface, onAuthUIStateChange, } from &amp;#39;@aws-amplify/ui-components&amp;#39; // ユーザーがこのグループ名の Cognito グループに所属しているときに、 // useAuthState フックが返す isAdmin プロパティを true にします。 const ADMIN_GROUP_NAME = &amp;#39;admin&amp;#39; /** useAuthState フックの戻り値の型 */ export type UseAuthStateOutput = { isSignedIn: boolean isAdmin: boolean user: CognitoUserInterface | undefined } /** 現在の認証状態を取得するためのフック関数です。 */ export const useAuthState = (): UseAuthStateOutput =&amp;gt; { // Cognito によるサインイン状態やユーザー情報を保持するステート const [authState, setAuthState] = useState&amp;lt;AuthState | undefined&amp;gt;() const [user, setUser] = useState&amp;lt;CognitoUserInterface | undefined&amp;gt;() useEffect(() =&amp;gt; { // 画面遷移時に onAuthUIStateChange が呼ばれないことへの対応 // https://github.</description></item><item><title>Next.js で Sass (scss/sass) を有効にする</title><link>https://maku.blog/p/2n2doyb/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2n2doyb/</guid><description>Next.js は Sass を使ったスタイルシート記述 (.scss / .sass ファイル）をサポートしています。 ほぼゼロコンフィグ（設定なし）で使用できますが、NPM の sass モジュールだけはマニュアルでインストールする必要があります。
sass のインストール ### yarn の場合 $ yarn add sass --dev ### npm の場合 $ npm install sass --save-dev 今まで .css 拡張子で作成していたファイルを、.scss に変更すれば、SCSS フォーマットでスタイル記述できます。
置換前: styles/global.css 置換後: styles/global.scss あとは、.css ファイルをインポートしている部分を、.scss に置換すれば導入完了です。
pages/_app.tsx import type { AppProps } from &amp;#39;next/app&amp;#39; import &amp;#39;../styles/global.scss&amp;#39; export default function MyApp({ Component, pageProps }: AppProps) { return &amp;lt;Component {...pageProps} /&amp;gt; } もちろん、CSS Modules の仕組み を使っている場合にも Sass を使うことができます。 その場合は、.</description></item><item><title>TypeScriptの型: 値の型を typeof で調べる</title><link>https://maku.blog/p/ods6iv8/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ods6iv8/</guid><description>次のサンプルコードでは、それぞれの変数値の型情報を、JavaScript の typeof で調べています（ついでに、Object.prototype.toString.call でもう少し詳しい情報も表示）。
// ヘルパ関数 function printType(x: any) { console.log(`${typeof(x)} ${Object.prototype.toString.call(x)}`); } let booleanValue: boolean = true; printType(booleanValue); //=&amp;gt; boolean [object Boolean] let numberValue: number = 100; printType(numberValue); //=&amp;gt; number [object Number] let stringValue: string = &amp;#39;Hello&amp;#39;; printType(stringValue); //=&amp;gt; string [object String] function func(): number { return 100; } printType(func); //=&amp;gt; function [object Function] let undefinedValue: undefined = undefined; printType(undefinedValue); //=&amp;gt; undefined [object Undefined] let tupleValue: [string, number] = [&amp;#39;Hello&amp;#39;, 100]; printType(tupleValue); //=&amp;gt; object [object Array] let arrayValue: number[] = [1, 2, 3]; printType(arrayValue); //=&amp;gt; object [object Array] let nullValue: null = null; printType(nullValue); //=&amp;gt; object [object Null] let general: any = { name: &amp;#39;Mofu&amp;#39; }; printType(general); //=&amp;gt; object [object Object] let sym: symbol = Symbol(&amp;#39;key&amp;#39;); // ES2015 printType(sym); //=&amp;gt; symbol [object Symbol] let x: bigint = 1n; // ES2020 printType(x); //=&amp;gt; bigint [object BigInt] enum Color { Red, Green, Yellow }; // これは数値と同じ扱い printType(Color.</description></item><item><title>PlantUML でシーケンス図を作成する</title><link>https://maku.blog/p/n8p7qmw/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n8p7qmw/</guid><description>シーケンス図は相互作用図 (interaction diagram) の代表的なダイアグラムです。 シーケンス図は、特定のユースケースに関するオブジェクトの典型例と、オブジェクト間のメッセージを示します。
要素の並び順の制御 (participant) 必須の定義ではないですが、participant であらかじめ要素を列挙しておくと、その後のメッセージ定義の順序に関係なく、participant に並べた順に左から要素が配置されます。
@startuml participant Class1 participant Class2 participant Class3 Class3 -&amp;gt; Class1 Class2 -&amp;gt; Class3 Class1 -&amp;gt; Class2 @enduml participant の代わりに actor というキーワードを使用すると、アクターのシンボルを表示することができます。
@startuml actor Class1 participant Class2 participant Class3 Class3 -&amp;gt; Class1 Class2 -&amp;gt; Class3 Class1 -&amp;gt; Class2 @enduml 同期メッセージと非同期メッセージ、リターン オブジェクト間のメッセージは、下記のように描き分けることができます。
-&amp;gt;: 同期メッセージ --&amp;gt;: 戻り値（リターン） -&amp;raquo;`: 非同期メッセージ 同期メッセージには戻り値（リターン）(--&amp;gt;) がありますが、UML の仕様としては省略することができます。
@startuml A -&amp;gt; B : 同期メッセージ A &amp;lt;-- B : リターン A -&amp;gt;&amp;gt; C : 非同期メッセージ @enduml ライフラインの活性区間 (activation) と終了 ライフラインの上に描かれる長方形は「活性区間 (activation)」で、その区間の間はオブジェクトがアクティブな状態になっていることを表します。 活性区間は、activate と deactivate で示します。</description></item><item><title>MongoDB (mongo, mongod) をインストールする</title><link>https://maku.blog/p/jyn7v9y/</link><pubDate>Sat, 28 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jyn7v9y/</guid><description>各種 OS 用のパッケージでインストールする MongoDB のクライアント (mongo) やサーバー (mongod)、その他の各種コマンド（mongoexport や mongostat など） は、下記のサイトから各種 OS 用のバイナリをダウンロードしてインストールすることができます。
MongoDB Community Download | MongoDB Windows 用のインストーラを使うと、簡単に mongod を Windows サービスとして登録したりすることができます（手動でサービス登録することもできます）。 インストールして、bin ディレクトリへのパスが通ったら、mongo コマンドを実行できるか確認しておきましょう。
mongo コマンドを実行できるか確認 $ mongo --version MongoDB shell version v4.0.9 git version: fc525e2d9b0e4bceff5c2201457e564362909765 allocator: tcmalloc modules: none build environment: distmod: 2008plus-ssl distarch: x86_64 target_arch: x86_64 macOS なら Homebrew でのインストールが楽 macOS の場合、Homebrew を使うと簡単に MongoDB のコマンド群（mongo や mongod）をインストールできます。
mongodb-community パッケージのインストール $ brew tap mongodb/brew # MongoDB 用のリポジトリ情報を追加 $ brew install mongodb-community # MongoDB 関連コマンドをインストール $ brew upgrade mongodb-community # （バージョンアップしたいとき） これで、/usr/local/bin に以下のようなコマンド群がインストールされます（正確にはこれらはシンボリックリンクであり、実体は /usr/local/Cellar/mongodb-* 以下にインストールされています）。</description></item><item><title>Next.js でコンポーネント内に直接 CSS を記述する (styled-jsx)</title><link>https://maku.blog/p/pbp2dpy/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbp2dpy/</guid><description>Next.js は CSS-in-JS ライブラリの一種である styled-jsx をデフォルトでサポートしています（styled-jsx も Next.js と同様に Vercel がメンテナンスしています）。 React コンポーネントの定義の中に、次のように CSS を直接記述することができます。
&amp;lt;style jsx&amp;gt;{` ... `}&amp;lt;/style&amp;gt; 下記は実際に styled-jsx を使って p 要素をスタイル設定した例です。
pages/sample.tsx export default () =&amp;gt; &amp;lt;&amp;gt; &amp;lt;p&amp;gt;only this paragraph will get the style&amp;lt;/p&amp;gt; &amp;lt;style jsx&amp;gt;{` p { color: red; } `}&amp;lt;/style&amp;gt; &amp;lt;/&amp;gt; ここで設定したスタイルのスコープは、この React コンポーネントに閉じたものになるため、他の React コンポーネントに影響を与えてしまう心配がありません。 そのため、シンプルなタグ名やクラス名でスタイル設定を行うことができます。
Next.js は、外部ファイルとして作成した .css や scss ファイルを読み込む CSS Modules の機能 もデフォルトでサポートしています（その場合は *.module.css というファイル名にするというルールがあります）。</description></item><item><title>PlantUML でオブジェクト図を作成する</title><link>https://maku.blog/p/t7cfj92/</link><pubDate>Mon, 15 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t7cfj92/</guid><description>オブジェクト図はクラス図と同様の文法で記述することができます。 下記のページも参考にしてください。
PlantUML でクラス図を作成する オブジェクト図の基本 オブジェクト図 (object diagram) は、システム内のオブジェクト群のある時点のスナップショットを表現します。 具体的なオブジェクト同士の関係を表現することができるため、複雑な依存関係を持つオブジェクト
インスタンス名は下線付きで「インスタンス名：クラス名」という形式で記述します。 インスタンス名とクラス名はどちらか一方を省略して記述することもできますが、クラス名だけを記述する場合は、「：クラス名」のようにコロン部分だけは残して記述します。
オブジェクト図は、メッセージなしのコミュニケーション図と考えることもできます。 ─『UMLモデリングのエッセンス第3版』マーチン・ファウラー
PlantUML で登場させるオブジェクト群は、object キーワードを使って定義します。 as を使って別名を付けておくことができます。
@startuml object object1 object &amp;#34;My second object&amp;#34; as o2 @enduml 関連の線を引く オブジェクト同士の依存関係を示すには、-- でオブジェクト名（あるいは別名）を繋ぎます。 代わりに .. を使用すると、破線 (dashed line) で繋ぐことができます。
@startuml object object1 object &amp;#34;Second object&amp;#34; as o2 object &amp;#34;Third object&amp;#34; as o3 object &amp;#34;Fourth object&amp;#34; as o4 object1 -- o2 object1 -- o3 object1 -- o4 o2 .. o3 o3 .. o4 @enduml ハイフンやドットの数を 1 つに減らすことで、オブジェクトを横方向に配置することができます。</description></item><item><title>TypeScriptの型: 辞書型を定義する (Dictionary)</title><link>https://maku.blog/p/x3ocp9a/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3ocp9a/</guid><description>辞書オブジェクトを作成する JavaScript の配列は、もともと「キー＆値」を扱う連想配列として使用することができますが、TypeScript のタイプアノテーションを使うと、キーの型と値の型 を明示した辞書 (Dictionary) オブジェクトを作成することができます。
次の例では、文字列のキーと、数値の値を持つ辞書オブジェクトを作成しています。
// 辞書オブジェクトを作成する const userAges: { [name: string]: number } = {}; // 辞書オブジェクトを使用する userAges[&amp;#39;maku&amp;#39;] = 14; userAges[&amp;#39;hemu&amp;#39;] = 6; console.log(userAges[&amp;#39;maku&amp;#39;]); //=&amp;gt; 14 console.log(userAges[&amp;#39;hemu&amp;#39;]); //=&amp;gt; 6 間違った型のキーや値を格納しようとするとエラーになります。
userAges[14] = &amp;#39;maku&amp;#39;; // Error!! 辞書型のインタフェースを定義する 単純な辞書 上記の例では、辞書オブジェクトを生成するときに同時にその型を指定していましたが、あらかじめ辞書型を表すインタフェースだけを定義しておくこともできます。 次の UserAges インタフェースは、文字列型のキーと数値型の値を持つ、よくある辞書の定義例です。
// 辞書オブジェクトを作成する interface UserAges { [name: string]: number; } // 使用例 const userAges: UserAges = {}; userAges[&amp;#39;maku&amp;#39;] = 14; console.log(userAges[&amp;#39;maku&amp;#39;]); //=&amp;gt; 14 任意のオブジェクトを値にする辞書 次の UserDictionary インタフェースは、文字列型のキーと User 型の値を持つ辞書型を表しています。</description></item><item><title>TypeScriptの型: 配列を定義する (Array)</title><link>https://maku.blog/p/ttwoetd/</link><pubDate>Wed, 22 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ttwoetd/</guid><description>TypeScript で配列を定義するには、次のいずれかの方法を使います。
文字列配列を作成する const strArr: string[] = []; const strArr: Array&amp;lt;string&amp;gt; = []; ここでは初期値として空の配列 [] を代入しています。
const で変数を作成していますが、JavaScript の const は変数自体への代入を制限するだけなので、配列の内容を変更することは可能です。
const nums: number[] = []; nums.push(100); nums.push(200); nums.push(300); for (const x of nums) { console.log(x); } 実行結果 100 200 300 参考リンク TypeScript: タプルを定義する (Tuple types)</description></item><item><title>TypeScriptの型: タプルを定義する (Tuple types)</title><link>https://maku.blog/p/6uzqf4q/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6uzqf4q/</guid><description>タプルの基本 TypeScript のタプル型は、複数の値を保持することのできる型です。 [] 記号を使うところも配列によく似ていますが、それぞれの位置の要素の型を明示しておくことができます。
文字列と数値のタプルを定義する例 let vote: [string, number] vote = [&amp;#39;red&amp;#39;, 100]; // OK vote = [&amp;#39;green&amp;#39;, 200]; // OK vote = [&amp;#39;yellow&amp;#39;, 300]; // OK vote = [&amp;#39;AAA&amp;#39;, &amp;#39;BBB&amp;#39;]; // Error 上記の例では、2 つの値を保持するタプル型変数を定義していますが、3 つ以上の値を保持するタプルを定義することもできます。 配列と同様、タプルの各要素にはインデックスでアクセスできます。
let data: [string, number, number] data = [&amp;#39;maku&amp;#39;, 100, 5]; // インデックスで各要素を参照 console.log(data[0]); //=&amp;gt; maku console.log(data[1]); //=&amp;gt; 100 console.log(data[2]); //=&amp;gt; 5 // ループで各要素を取り出す for (const x of data) { console.log(x); } タプルによる多値関数 タプルを関数の戻り値として使用すると、複数の値を返す「多値関数」として扱うことができます。</description></item><item><title>TypeScriptの型: 関数を定義する (function)</title><link>https://maku.blog/p/tiwamzb/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tiwamzb/</guid><description>TypeScript の関数定義は JavaScript とほぼ同じですが、各パラメータと戻り値に型アノテーション付けることができます。
簡単な関数 次の indent 関数は、指定したレベルのインデント文字列（レベル数x2 の半角スペース）を返します。 TypeScript の型アノテーションで、number 型のパラメータと、string 型の戻り値を持つことを示しています。
function indent(level: number): string { return &amp;#39; &amp;#39;.repeat(level); } console.log(indent(0) + &amp;#39;AAA&amp;#39;); //=&amp;gt; &amp;#39;AAA&amp;#39; console.log(indent(1) + &amp;#39;BBB&amp;#39;); //=&amp;gt; &amp;#39; BBB&amp;#39; console.log(indent(2) + &amp;#39;CCC&amp;#39;); //=&amp;gt; &amp;#39; CCC&amp;#39; 関数オブジェクト 名前なしの関数オブジェクトやアロー関数を使用するときも同様に、パラメータや戻り値の型をアノテートできます。
const add = function(a: number, b: number) { return a + b; }; const sub = (a: number, b: number) =&amp;gt; { return a - b; }; console.log(add(1, 2)); //=&amp;gt; 3 console.</description></item><item><title>TypeScriptの型: インタフェースを定義する (interface)</title><link>https://maku.blog/p/5q5gs4f/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q5gs4f/</guid><description>プロパティを定義する 次の例では、2 つのプロパティ x、y を持つインタフェース Point を定義しています。
// Point インタフェースの定義 interface Point { x: number; y: number; } このインタフェースを使って、次のようにオブジェクトを生成することができます。 オブジェクトを生成するときには、インタフェースで定義されているすべてのプロパティに値を設定してやる必要があります。
// Point 型のオブジェクトを生成 const p: Point = { x: 10, y: 20 }; // 内容を出力してみる console.log(`x=${p.x}, y=${p.y}`); //=&amp;gt; x=10, y=20 Java などと異なり、TypeScript ではインタフェース定義さえあれば、上記のようにその型のオブジェクトを生成することができます（Java では厳密にはクラス定義がないとオブジェクトを生成できません）。 そのため、TypeScript では、interface キーワードを使ったインタフェース定義の頻度が高くなります。
TypeScript のインタフェースは、拡張に対してオープンであり、次のように後付けでプロパティを追加することができます。
interface Point { x: number; y: number; } // Point インタフェースにプロパティを追加 interface Point { z: number; } const p: Point = { x: 1, y: 2, z: 3 }; メソッドを定義する インタフェースでは、オブジェクトが持つべきメソッドを定義することができます。 次の Product インタフェースは、2 つのプロパティ name、price の他に、1 つのメソッド calcTotal() を持つ型を示しています。</description></item><item><title>TypeScriptの型: インタフェースのプロパティをオプショナルにする</title><link>https://maku.blog/p/rpfr5fr/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rpfr5fr/</guid><description>オプショナルプロパティの定義 TypeScript でインタフェースを定義するとき、プロパティ名の末尾に ? を付けると、そのプロパティをオプショナルプロパティとすることができます（関数のオプショナルパラメータと同様です）。
例えば、次の User インタフェースの age プロパティはオプショナルになっているため、User オブジェクトを生成するときに age プロパティの値を省略することができます。
interface User { name: string; age?: number; // age プロパティはオプショナル } const u1: User = { name: &amp;#39;Maku&amp;#39;, age: 5 }; // OK const u2: User = { name: &amp;#39;Maku&amp;#39; }; // OK console.log(u1.age); //=&amp;gt; 5 console.log(u2.age); //=&amp;gt; undefined インタフェースを定義せずに、変数の定義時に型情報を指定する場合も同様です。
let user: { name: string, age?: number }; user = { name: &amp;#39;Maku&amp;#39;, age: 5 }; // OK user = { name: &amp;#39;Maku&amp;#39; }; // OK user = { age: 5 }; // Error オプショナルなプロパティを定義する代わりに、特定の値（例えば -1）を、値がないことを示すために使用するという方法もありますが、プロパティ自体格納せずに undefined としておく方が分かりやすいでしょう。</description></item><item><title>TypeScriptの型: インタフェースのプロパティを読み取り専用にする (readonly)</title><link>https://maku.blog/p/p8ir2ai/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p8ir2ai/</guid><description>インタフェースのプロパティの前に、 readonly キーワードを付けると、そのプロパティは読み取り専用になり、オブジェクト生成時に格納した値を変更できなくなります。
次の Book インタフェースは 3 つのプロパティを持ちますが、そのうち id プロパティだけがリードオンリーとして定義されています。
interface Book { readonly id: string; // id プロパティはリードオンリー title: string; price: number; } 次の例では Book オブジェクトを作成した後で各プロパティの値を変更しようとしていますが、id プロパティを変更しようとしている部分でトランスパイルエラーになります。
const book: Book = { id: &amp;#39;001&amp;#39;, title: &amp;#39;TypeScript is Awesome&amp;#39;, price: 2300 }; book.id = &amp;#39;002&amp;#39;; // Error: リードオンリープロパティ book.title = &amp;#39;TypeScript is Horrible&amp;#39;; book.price = 800;</description></item><item><title>TypeScriptの型: インタフェースを結合する (交差型: Intersection types)</title><link>https://maku.blog/p/b4i46ah/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b4i46ah/</guid><description>2 つのインタフェースを &amp;amp; で結ぶと、両方のインタフェースを備えていることを示す新しい型 (交差型: Intersection type) を定義することができます。
interface Foo { foo(): void; } interface Bar { bar(): void; } // インタフェースの結合 type FooAndBar = Foo &amp;amp; Bar; 上記のように定義された FooAndBar インタフェースを実装するクラスは、Foo インタフェースと Bar インタフェースの両方を実装しなければいけません。
class Hoge implements FooAndBar { foo(): void { console.log(&amp;#39;foo!!&amp;#39;); } bar(): void { console.log(&amp;#39;bar!!&amp;#39;); } } const h = new Hoge(); h.foo(); h.bar(); ☝️ 共用体は OR、交差型は AND どちらかの型になることができること示す共用体 (union) が | （OR記号）で定義されるのに対し、両方の性質を持つ交差型 (intersection type) は &amp;amp;（AND記号）を使って定義されます。 意味が直感的に分かりやすいですね。</description></item><item><title>Deno Deploy で Deno のサーバープログラムを公開する</title><link>https://maku.blog/p/phz7fo3/</link><pubDate>Sat, 24 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/phz7fo3/</guid><description>Deno Deploy とは？ Deno Deploy を使うと、Deno で作成したサーバープログラムを簡単に公開することができます。 Deno Deploy はエッジサーバーで動作する Deno 実行環境を提供しており、ゼロコンフィグでデプロイすることができます。
TypeScript コードで記述したプログラムがそのまま動きます（Deno なので） CLI ツール (deployctl) や GitHub 統合、GitHub Actions で簡単にデプロイできます デプロイは数秒で終わります（GitHub 連携による Deno Deploy へのデプロイは、Vercel や Cloudflare へのデプロイより 10 倍以上速い） サーバー上で公開されている .ts ファイルを直接デプロイすることができます プレビューサイト用の URL が自動生成されます（もちろん SSL 対応） 1 日に 10 万回までの呼び出しであれば無料で利用できます（それ以上は$10/月からの有料プラン） deployctl のインストール ローカルにある .ts ファイルを Deno Deploy へデプロイするには、CLI コマンドの deployctl を使用します。 このコマンドは、deno コマンドでインストールできます。
deployctl のインストール $ deno install \ --allow-read --allow-write --allow-env --allow-net --allow-run \ --no-check -r -f https://deno.</description></item><item><title>Amazon Cognito をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/yzjj4c7/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yzjj4c7/</guid><description>AWS CLI による Cognito 操作用のコマンドには、cognito-idp と cognito-identity があります。
aws cognito-idp &amp;hellip; Cognito User Pools の操作（ユーザープール／ID プロバイダー） ユーザープール自体の作成や、ユーザーの追加・削除などを行えます。ユーザープールでの認証に成功すると、ユーザー情報を参照するためのトークンが発行されます。一般的にいうところの ID プロバイダー (IdP) です。 aws cognito-identity &amp;hellip; Cognito Federated Identities の操作（フェデレーテッドアイデンティティー／ID プール） 何らかの ID プロバイダー (IdP) で認証されたユーザーに対して、AWS サービスにアクセスするための一時的なアクセストークンを発行します。ID プロバイダーは上記の Cognito ユーザープールでもよいし、Google や Facebook などのサードパーティ ID プロバイダーでもかまいません。 ユーザープールの操作 (cognito-idp) aws cognito-idp のサブコマンドには、admin- プレフィックスが付くものと付かないバージョンがあったりしますが、プレフィックスがない方は、ユーザー認証後に取得できるトークンの指定 (--access-token) が必要です。
ユーザープールを作成する (cognito-idp create-user-pool) $ aws cognito-idp create-user-pool --pool-name &amp;#34;Test user pool&amp;#34; ユーザープールの作成に成功すると、初期設定の内容（パスワードのルールなど）が出力されます。
ユーザープールを削除する (cognito-idp delete-user-pool) $ aws cognito-idp delete-user-pool --user-pool-id ap-northeast-1_5O6lfqrqN --user-pool-id オプションには、ユーザープール名ではなく、ユーザープール ID を指定することに注意してください。 ユーザープール ID は、cognito-idp list-user-pools コマンドで確認できます。</description></item><item><title>VS Code の設定ファイルの場所 (settings.json)</title><link>https://maku.blog/p/tfq2cnw/</link><pubDate>Sun, 11 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tfq2cnw/</guid><description>ユーザー設定とワークスペース設定 VS Code の設定画面は Ctrl(Cmd) + , で起動できますが、ここで行った設定は、settings.json というユーザー設定ファイル（あるいはワークスペース設定ファイル）に保存されます。 このファイルの内容と設定画面の内容は連動しているので、設定はどちらで行ってもいいのですが、慣れてくると setttings.json を直接編集した方がすばやく設定を行えます。
ユーザー設定ファイル VS Code のユーザー設定ファイル (settings.json) は、OS ごとに下記のディレクトリに保存され、全ての VS Code インスタンス（ワークスペース）に共通の設定として使用されます。
OS ユーザー設定ファイルのパス Windows %APPDATA%\Code\User\settings.json macOS $HOME/Library/Application Support/Code/User/settings.json Linux $HOME/.config/Code/User/settings.json ワークスペース設定ファイル ワークスペースごとの設定は、プロジェクトのルートディレクトリの .vscode ディレクトリに保存されます。
&amp;lt;プロジェクトルート&amp;gt;/.vscode/settings.json ワークスペース設定は、前述のユーザー設定よりも優先されます（同じ設定項目の値が上書きされます）。 .vscode ディレクトリを Git にコミットしておけば、チーム内で VS Code の設定を共有できます。 .vscode ディレクトリには、プロジェクトのタスク設定ファイル (tasks.json) なども格納されます。
設定ファイルのサンプル settings.json ファイルの拡張子は .json ですが、JavaScript 形式のコメントを記述できるようになっています (JSON with Comments)。
settings.json の例 // Place your settings in this file to overwrite the default settings { &amp;#34;breadcrumbs.</description></item><item><title>Azure Functions で簡単な関数を作ってみる</title><link>https://maku.blog/p/vgt5g7f/</link><pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgt5g7f/</guid><description>Azure Functions を使うと、Web API 的なものを、サーバーの存在を意識せずに作成することができます。 ここでは、最初のステップとして、HTTP リクエストで送ったメッセージをオウム返しするだけの簡単な関数を作ってみます。
Functions アプリを新規作成する 新しい Functions アプリを作成するには、Azure ポータルのリソースの作成画面 から、Functions App（関数アプリ） を選択します。 Azure のアカウントがない場合は先に作成する必要があります。
画面に従って入力していけば作成できますが、いくつかポイントがあるので説明しておきます。
基本タブ 関数アプリ名 &amp;hellip; 任意のアプリ名を付けることができますが、&amp;lt;アプリ名&amp;gt;.azurewebsites.net というアドレスが割り当てられるので、世界で一意な名前を指定する必要があります。 ランタイムスタック &amp;hellip; 関数の実装に使用する言語を選択します。JavaScript で記述するなら Node.js、C# で実装するなら .NET Core を選択しておきます。 ホスティングタブ プランの種類 &amp;hellip; 今回のテストのように、ときどき実行するだけなら 消費量（サーバーレス） を選択しておきます。App Service プラン は常時起動型の VM でホスティングするもので、ほとんど関数呼び出ししなくても月額数千円はかかってしまうので、最初は避けておくのが無難です。ただし、すでに他の Web サーバに App Service リソースを使用しているのであれば、そちらに相乗りしてホスティングすることが可能です。 最後に 作成 ボタンを押せば、数分で Functions のリソース作成が完了します。
Functions アプリに関数を追加する Functions リソースに新しい関数を追加するには、関数 → 追加 と選択します。 ここでは HTTP リクエストにより関数を実行するので、HTTP trigger を選択します。
関数名はデフォルトのままで HttpTrigger1、Authorization level はキーなしでリクエストできるように Anonymous を選択しておきます。</description></item><item><title>React + TypeScript の環境を整える (1) 自力で webpack 設定する方法</title><link>https://maku.blog/p/m4dmt3a/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4dmt3a/</guid><description>React とは Web サイトを作成するときに React を採用すると、HTML をフラットな形でゴリゴリ記述していくのではなく、独自コンポーネント（例: &amp;lt;MyButton&amp;gt; コンポーネント）を定義してまとまりのある単位でサイトを構築していくことができます。 Web Components という同様な技術の標準化が進んでいますが、しばらくは React のようなコンポーネントライブラリが使われるでしょう。
React – ユーザインターフェース構築のための JavaScript ライブラリ ここでは React を使った Web サイト開発用に、下記のようなツールを組み合わた環境を構築します。
React &amp;hellip; コンポーネントベースで Web サイト構築するためのライブラリ TypeScript &amp;hellip; JavaScript を型付けできるようにした言語 webpack &amp;hellip; Web サイトのリソースをバンドルするためのツール この環境構築方法を理解すれば、React を利用した Web サイトをどんどん作ることができます。 ちなみに、上記のすべてのツールは Node.js 上で動作するため、Node.js がインストールされていない場合は先にインストールしてください。
TypeScript、React、webpack のインストール チュートリアルなどでは、create-react-app を使って React アプリの雛形を生成する方法がよく載っていますが、よくわからないモジュールが勝手にインストールされるのは気持ち悪いので、ここでは自力で各モジュールをインストールしてきます。
☝️ create-react-app は使わない方がいい TypeScript ベースの React アプリの雛形を生成するには、create-react-app myapp --template typescript のように実行します。 このコマンドによって作成された雛形をリファレンスにするのがよいかなと思ったのですが、少なくともバージョン 3.4.1 時点で生成される雛形はかなり怪しいです。 例えば、TypeScript の処理系や型定義ファイルが devDependencies ではなく、dependencies でインストールされるようになっていたりします。 最終的に Web サーバーにデプロイするファイル群は webpack で生成（バンドル）することを想定しているので、npm (or yarn) でインストールするモジュールは、 すべて devDependencies（開発用モジュール）としてインストール していきます（Web サーバー側で npm install を実行することはないということです）。</description></item><item><title>VS Code を code コマンドで起動できるようにする</title><link>https://maku.blog/p/f5iv9kx/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/f5iv9kx/</guid><description>Windows のコマンドプロンプトや、macOS のターミナルから Visual Studio Code を開くには、code コマンドを使用します。
$ code . # ディレクトリを開く（通常はこれを使う） $ code sample.txt # ファイルを開く code コマンドが見つからない (command not found) と言われる場合は、VS Code から次のように実行することで実行できるようになります。
Cmd + Shift + P (Ctrl + Shift + P) でコマンドパレットを開く shell と入力し、Shell Command: install 'code' command in PATH を選択する macOS の場合は、下記のコマンドへのシンボリックリンクとして、/usr/local/bin/code というファイルが作成されるようです。
/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code</description></item><item><title>TypeScriptの型: クラス定義の基本 (class)</title><link>https://maku.blog/p/qhxet9n/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qhxet9n/</guid><description>TypeScript のクラスは、Java や Kotlin に似た文法で定義します。 インタフェースの定義に似ていますが、コンストラクタやメソッドを持つことができるという大きな違いがあります。
簡単なクラス 次の Greeter クラスは、1 つのプロパティ、1 つのコンストラクタ、1 つのメソッドを持っています。
class Greeter { // プロパティの定義（デフォルトで public） private name: string; // コンストラクタの定義 constructor(name: string) { this.name = name; } // メソッドの定義（デフォルトで public） greet() { console.log(`Hello, ${this.name}`); } } コンストラクタやメソッドの前に function というキーワードは必要ないことに注意してください。 プロパティやメソッドの可視性は デフォルトで public になるため、外部からアクセスできないようにするには、明示的に private と指定する必要があります。
クラスのインスタンスを生成するには、次のように new キーワードを使用します。
const greeter = new Greeter(&amp;#39;Maku&amp;#39;); greeter.greet(); //=&amp;gt; &amp;#39;Hello, Maku&amp;#39; プロパティ定義の省略 コンストラクタ (constructor()) のパラメータ名の前に、private や public といった可視性を指定すると、プロパティ定義とその値を設定するコードを省略することができます。
次のようなコードは、
class Book { private name: string; constructor(name: string) { this.</description></item><item><title>逆引き Azure CLI: Azure CLI（az コマンド）をインストールする</title><link>https://maku.blog/p/dwsog4p/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dwsog4p/</guid><description>Azure CLI をインストールすると、az コマンドを使用して、Azure の様々な機能を呼び出すことができるようになります。 Azure ポータル 上で実行できることは、ほとんど az コマンドでも実行できるようになっています。
Azure CLI は下記のサイトに従ってインストールします（インストーラを実行するだけです）。
Azure コマンドラインインターフェイス (CLI) 実際には、Azure ポータル上で実行してしまった方が手軽なことが多いのですが、スクリプトなどで処理を自動化したい場合は Azure CLI を使うことになります。</description></item><item><title>VS Code で Markdown ファイルのプレビューを表示する</title><link>https://maku.blog/p/ornz2yx/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ornz2yx/</guid><description>図: VSCode の Markdown プレビュー表示 Visual Studio Code で Markdown ファイルのプレビュー表示を行うには、F1 キー（あるいは Ctrl + Shift + P) でコマンドパレットを開き、Markdown メニューから Open Preview を選択します。
次のように、新しいタブで開くか、左右に分割して表示するかを選択できます。
プレビューを新しいタブで表示: Markdown: Open Preview プレビューを左右分割して表示: Markdown: Open Preview to the Side Markdown ファイルを編集中に右上に表示される「プレビューボタン」を押すことでも、プレビューを表示することができます（こっちのが早いかも）。
図: VSCode の分割プレビューボタン 1 文字入力するごとにリアルタイムにプレビュー更新してくれるので気持ちよく作業できます。 フロントマターを解析してプレビュー表示してくれないなどの欠点はありますが、きっと近いうちに拡張されて表示できるようになると思います。</description></item><item><title>よいチャットボットとは？ボットを作成するときのベストプラクティス</title><link>https://maku.blog/p/o2nq2qa/</link><pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2nq2qa/</guid><description>とある事情によりチャットボットを作ろうという話になっています。 まずは、チャットボットってどんなことに気を付けて作ればよいかを調べたので、ポイントになりそうなことをまとめておきます。
下記の Microsoft が提供している Bot Framework のドキュメントがとても参考になりました。
参考: Principles of bot design - Bot Service | Microsoft Docs
チャットボットの知識は、今流行りのスマートスピーカー（Amazon Alexa や Google Home）などのスキルを作成する際にも応用がききそうです。 音声入力による会話は、チャットの特殊形態（キーボードやモニタがないときの手段）と考えることができるので、チャットボットの基本原則を押さえておくことはきっと参考になります。
チャットボットが目指すべきこと こだわるべき事 少ないステップで簡単に問題を解決できること 他の手段よりもチャットボットを使ったほうが速く、簡単で、よりよい結果を得られること ユーザが**使いたい環境（クライアント）**で動作すること ユーザがボットの存在に気付けること。それを使って何をすればよいのか気付けること 何より大切なのはユーザーエクスペリエンスです。 めっちゃ賢い AI を使っているかどうかではなく、ユーザがやりたいことを素早く、簡単に行えるかが重要です。
こだわらなくてよい事 機械学習は必須ではない。めっちゃ賢いボットは必須ではない。 完璧に自然言語を理解して会話できる必要はない。 ボイス対応により必ず UX が改善されるわけではない。ボイスを嫌うユーザはいるし、ノイズの多い環境では使えない。 大切なのは技術力とかクールさとかではなく、ユーザのやりたいことができることです。
最初の挨拶は「自然言語」か「メニュー選択」か？ どんな話しかけにも反応できるボットは存在しません（少なくとも現在は）。 ユーザは、ボットが何をできるのか知らないので、できることの選択肢を表示してあげるとよいです。
選択肢が少なければボタンを並べて、それを押すだけで会話を進められるようにすると、ユーザの入力の手間を大幅に削減することができます。 できることがたくさんあるのであれば、選択肢として「ヘルプ」ボタンを配置して、より詳しい使い方を提示してあげましょう。
図: 最初のメッセージの例 一般的に、自由回答形式の質問 (open-ended question) はユーザーの返答を予測できないので、選択回答形式の質問 (closed-ended question) を使用した方がボットの設計者にとっても望ましいといえます。 見栄を張ってどんな会話でもできる賢いボットを作ろうとするのではなく、できることを明確に示して上げたほうがユーザにとっても使いやすいボットができるでしょう。
プライバシーポリシーの表示 ユーザが「個人情報保護に関する方針と利用規約」(Privacy policy and terms of use) にアクセスできるようにしておくのが望ましいです。 特に、チャットボットサービスを介して個人情報を収集するのであれば、このような表示は必須になります。
会話 (Dialog) のスタック構造という罠 チャットボットのフレームワーク内部では、会話の流れは Dialog（会話）といった単位で管理されます。 一般的に、ユーザとの会話は、GUI アプリケーションのウィンドウと同様に、Dialog（会話）のスタック構造で管理されます。 つまり、ウィンドウを開いたり閉じたりするのと同様に、次の会話内容へ進んだり、前の会話内容へ戻ったりします。</description></item><item><title>.proto の文法: メッセージ型 (message)</title><link>https://maku.blog/p/7h3hu8k/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7h3hu8k/</guid><description>メッセージ型とは Protocol Buffers の メッセージ型 は、基本的なデータ構造を表すもので、.proto ファイルの中で message キーワードを使って定義します。 メッセージ型は、プログラミング言語でいうところの構造体に相当するものです。
message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } Go 言語のコードに変換した場合の例 変換コマンド $ protoc --go_out=. --go_opt=Msample.proto=message sample.proto sample.pb.go（抜粋） type SearchRequest struct { // ... Query string `protobuf:&amp;#34;bytes,1,opt,name=query,proto3&amp;#34; json:&amp;#34;query,omitempty&amp;#34;` PageNumber int32 `protobuf:&amp;#34;varint,2,opt,name=page_number,json=pageNumber,proto3&amp;#34; json:&amp;#34;page_number,omitempty&amp;#34;` ResultPerPage int32 `protobuf:&amp;#34;varint,3,opt,name=result_per_page,json=resultPerPage,proto3&amp;#34; json:&amp;#34;result_per_page,omitempty&amp;#34;` } 自動生成されたコードの型情報には、.proto で明示的に定義したフィールド以外の情報も含まれています。 それらの情報は、各種 protobuf ライブラリが内部的に使用します。
上記の SearchRequest というメッセージ型は 3 つのフィールド（文字列 1 つと数値 2 つ）を持っています。 ここでは、protobuf が標準で用意している スカラー型 の string と int32 を使っていますが、他のメッセージ型や列挙型、マップ型などのフィールドとして定義することもできます。 このあたりは、一般的なプログラミング言語と同様です。 各フィールドの末尾には、フィールドを一意に特定する整数である フィールド番号 を割り当てる必要があります。</description></item><item><title>Next.js で HelloWorld（プロジェクト作成からサーバー起動まで）</title><link>https://maku.blog/p/ubmu3bj/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ubmu3bj/</guid><description>Next.js とは Next.js は、React.js アプリ開発に必要なアレコレを詰め込んだパッケージです。 React.js を素の状態で導入すると、他にもいろいろなツールやライブラリを組み合わせていくことになるのですが、Next.js を使うとモダンな Web アプリ開発に必要なものが一気に揃えられます。
React.js は基本的に SPA（シングルページアプリ）を想定していますが、Next.js では複数ページによる構成や、サーバーサイドレンダリングなどをサポートしています。 これは、Next.js が単なる React.js 用のコンポーネントライブラリでないことを示しています。
Next.js には次のような特徴があります。
ゼロコンフィグ: 何も設定しなくても、最初から開発サーバーの立ち上げ、プロダクト用ビルドを行えるようになっています。これらは、最適なパフォーマンスが出るようメンテナンスが続けられています。カスタマイズしたいときも、複雑怪奇な webpack.config.js を作成する必要はなく、next.config.js による最小限の設定で済みます。できれば何も設定しないのが理想です。 SSR/SSG によるプリレンダリング: React.js はクライアントサイドで JavaScript を実行する CSR (Client Side Rendering) で動作しますが、Next.js は SSR (Server Side Rendering) や SSG (Static Site Generation) をサポートしています。これは、一般的な Node.js の API を利用してページを構築できることを意味します。開発元の Vercel は、パフォーマンスの面から SSG を推奨しています。 TypeScript をサポート: いまどきの Web アプリ開発では TypeScript はほぼ必須なので、標準サポートはうれしいです。空の tsconfig.js を置くだけで、TypeScript 対応は完了です（設定は自動で行われます）。 ファイルベースのルーティング: pages ディレクトリ以下の構成をそのままルーティング用のリンク名として使うことができます。例えば、pages/xxx/yyy.js は、/xxx/yyy というリンク名にマッピングされます。React Router によるルーティング設定が面倒だと感じている人にとってはうれしいかもしれません。 部分的な高速リロード (Fast Refresh): Next.</description></item><item><title>AWS CloudFormation をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkxamw9/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkxamw9/</guid><description>テンプレートファイルが正しく記述できているか確認する (cloudformation validate-template) YAML や JSON 形式で作成した CloudFormation 用のテンプレートファイルが、正しく記述できているかを調べることができます。
正しく記述できている場合 $ aws cloudformation validate-template --template-body file://template.json Description: Sample template Parameters: [] 不正なフォーマットの場合 An error occurred (ValidationError) when calling the ValidateTemplate operation: Template format error: JSON not well-formed. (line 5, column 2) 不正なプロパティがある場合 An error occurred (ValidationError) when calling the ValidateTemplate operation: Invalid template property or properties [ABC] スタックを作成する (cloudformation create-stack) ローカルの YAML テンプレートから生成 $ aws cloudformation create-stack --stack-name mystack \ --template-body file://template.</description></item><item><title>Amazon EC2 で Hello World (1) キーペアの作成</title><link>https://maku.blog/p/pcp3doy/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pcp3doy/</guid><description>EC2 を使う前に SSH キーペアを作成しておく 立ち上げた EC2 インスタンスは SSH で接続して操作するため、まずはキーペア（公開鍵＋秘密鍵）を作成して、その公開鍵を EC2 に登録しておく必要があります。 一度公開鍵を登録すると、EC2 インスタンスを作成するときに、割り当てる公開鍵をプルダウンから選択できるようになります。
EC2 コンソールからキーペアを作成する SSH 接続用のキーペアは、ローカルで作成して EC2 に登録することもできますし、EC2 コンソール上で新規作成することもできます。 EC2 上で作成すると、公開鍵が自動的に EC2 に登録された状態になるのでちょっとだけ楽です。 ここでは、次のように EC2 上でキーペアを作成します。
EC2 マネージメントコンソール を開く サイドバーから キーペア を選択し、キーペアを作成 をクリック キーペアの作成画面で名前とファイル形式を入力し、キーペアを作成 をクリック 名前: ec2key など自由に入力 ファイル形式:（使用する SSH クライアントに合わせて選択） pem 形式 &amp;hellip; OpenSSH を使う場合（主に Linux/macOS） ppk 形式 &amp;hellip; PuTTY を使う場合（主に Windows） すると、自動的に ec2key.pem（秘密鍵）のダウンロードが始まるので、~/.ssh ディレクトリなどに確実に保存します。 この キーファイルを再度ダウンロードすることはできないので注意してください。
EC2 コンソール上に次のように表示されていれば、今後 EC2 インスタンスを生成するときにこのキーを選択できます。
秘密鍵ファイルのパーミッションを設定する ローカル PC に保存した秘密鍵ファイル (.pem) には、自分だけを読み取り可能にするよう、適切なパーミッションを設定しておく必要があります。 これをやっておかないと、ssh コマンドを実行するときに、WARNING: UNPROTECTED PRIVATE KEY FILE!</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.3 の場合）</title><link>https://maku.blog/p/5mv5dkt/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5mv5dkt/</guid><description>ここでは、Node.js 用の AWS SDK ver.3 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
DynamoDB 用の Node.js SDK (ver.3) をインストールする まずは、AWS SDK version 3 の DynamoDB 用パッケージをインストールします。 DynamoDB を操作するときに主に次のようなクライアントクラスを使用するのですが、後者の DynamoDBDocumentClient の方は、前者の DynamoDBClient インスタンスをラップして扱いやすくするためのクラスなので、必要に応じてインストールしてください（主にテーブル内のアイテムを扱うときに便利です）。
DynamoDBClient DynamoDB を扱うための基本クラス（DB クライアントと呼ばれる） @aws-sdk/client-dynamodb パッケージが必要 DynamoDBDocumentClient 上記を扱いやすくするためのクラス（Document クライアントと呼ばれる） @aws-sdk/lib-dynamodb パッケージが必要 @aws-sdk/util-dynamodb パッケージも必要っぽい ### yarn の場合 $ yarn add @aws-sdk/client-dynamodb $ yarn add @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント ### npm の場合 $ npm install @aws-sdk/client-dynamodb $ npm install @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。</description></item><item><title>AWS の初期設定: 管理者用の IAM ユーザーを作成する</title><link>https://maku.blog/p/xbipv39/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xbipv39/</guid><description>何をするか？ AWS のベストプラクティスでは、管理者であっても普段の作業では AWS アカウントのルートユーザーを直接使うべきではないとされています。
参考: AWS アカウント、IAM ユーザー、グループ、ポリシーの違い そこで、まずは管理者の普段の作業用に IAM ユーザーを作成します。 この作成作業は、AWS アカウントのルートユーザーで行う必要があります（初期状態ではユーザー作成の権限がルートユーザーにしかないため）。
ここでは、下記のような名前の IAM ユーザーとグループを作成することにします。
IAM ユーザー: admin IAM グループ: Admins &amp;hellip; （AdministratorAccess ポリシーを割り当てます） 管理者用 IAM ユーザーの作成 AWS IAM コンソール にサインインし、次のような感じで IAM ユーザーを作成します。
アクセス管理 → ユーザー → ユーザーを追加 を選択し、次のように入力 ユーザー名: admin アクセスの種類: CLI などで操作するなら プログラムによるアクセス にチェック ユーザーをグループに追加 → グループの作成 を選択し、次のように入力 グループ名: Admins ポリシー: AdministratorAccess を選択 アクセスキーや、シークレットアクセスキーを作成したのであれば、このタイミングで表示されるので、なくさないよう厳重に保存します（後から確認することはできません）。
これで、管理者用の普段の作業も、ルートユーザーではなく、admin という IAM ユーザーで行えるようになります。
（応用）開発者用の IAM ユーザーの作成 上記では管理者用の IAM ユーザーを作成しましたが、それ以外の IAM ユーザー（開発者用など）も同様に作成することができます。 AWS は開発者用の IAM ポリシーをいくつか定義しています。 AdministratorAccess ポリシーとの大きな違いは、IAM 関連の操作（つまりユーザー管理）をするための権限を持っていないことです。</description></item><item><title>GitHub OAuth トークンを取得する (1) 処理の流れを理解する</title><link>https://maku.blog/p/ubkt3ai/</link><pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ubkt3ai/</guid><description>GitHub の OAuth トークンとは GitHub API を使って GitHub 上の情報（リポジトリ情報やユーザー情報）を取得するには、GitHub によって発行されるアクセストークンが必要です。 GitHub API ver.3 (REST API) ではアクセストークンを必要としない API もありましたが、GitHub API ver.4 (GraphQL API) では必ずアクセストークンが必要です。
アクセストークンにはいくつか種類があり、GitHub の Web サイト上で作成する パーソナルアクセストークン や、Web アプリの OAuth プロセスで取得する OAuth アクセストークン などがあります。 アクセストークンの取得方法は異なりますが、いずれも取得した後は同じように使用できます。
パーソナルアクセストークン : ユーザーが GitHub サイト上で作成 OAuth アクセストークン : Web アプリ内の OAuth プロセスで取得 通常、Web アプリから GitHub API を使用する場合は、後者の OAuth を使用してアクセストークンの取得を自動化します。 ここでは、GitHub の OAuth アクセストークン取得の流れを、実装コードを示しながら説明していきます。
GitHub の OAuth の流れ (Web application flow) Web アプリから OAuth トークンを取得するまでの流れはざっと次のような感じになります。</description></item><item><title>React + TypeScript の環境を整える (2) Parcel を使う方法</title><link>https://maku.blog/p/r7fov4b/</link><pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r7fov4b/</guid><description>Parcel とは Parcel は、ゼロ設定 をウリとした Web アプリバンドラーです。 React + TypeScript + SCSS + CSS Modules といった環境を自力でセットアップしようとすると なかなか大変な設定が必要 なのですが、Parcel を使うと、開発環境がサクサクッと完成します。
React プロジェクトを作成するときは、create-react-app を使って雛形を生成する方法もありますが、余計なファイルがたくさん作られたりして、あまり分かりやすいとは言えません。 そんなときは Parcel を使ってみると、そのシンプルさに驚くと思います。
Parcel を使うと、次のような機能がほとんど設定なしでいきなり使えます。 コマンドラインオプションの一覧 を見ると、どのような機能があるかをざっと把握することができます。
開発用の Web サーバー機能（HMR: Hot Module Replacement 対応） TypeScript の自動変換（HTML ファイルから直接ロードする記述が可能） PostCSS による CSS 生成（SCSS、ベンダープレフィックス） CSS ファイルのインポート (CSS Modules) JSON ファイルのインポート PNG ファイルのインポート Pug (Jade) による HTML 生成 リリース用の minify また、Parcel は Node モジュールの自動インストール機能を備えており、parcel コマンドで開発用 Web サーバーを起動すると、自動的に依存モジュールをインストールしてくれます。 例えば、HTML ファイルから TypeScript ファイルを読み込んでいると、typescript モジュールが自動的にインストールされます。</description></item><item><title>Electron で Hello World (1) 最小構成で作る</title><link>https://maku.blog/p/ter4eq2/</link><pubDate>Mon, 08 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ter4eq2/</guid><description>Electron とは Electron | Build cross-platform desktop apps with JavaScript, HTML, and CSS.
Electron は GitHub が開発した、デスクトップアプリを開発するためのプラットフォームで、2020 年現在も活発な開発が続けられています。 Node.js や HTML5 技術を利用しており、 様々な OS (Windows, macOS, Linux) で動作するデスクトップアプリ を作成することができます。
フロントエンド（UI 表示部分）に Chromium (HTML/CSS) を使用し、バックエンド（OSとの連携部分）に Node.js を使用するという構成になっています。 Electron で作成されている有名なアプリケーションに Visual Studio Code や Slack などがあります。 これらのアプリケーションの完成度を見れば、大規模なアプリケーション開発にも使用できるプラットフォームだということが分かります。
Node.js さえ入っていれば、簡単にデスクトップアプリの開発を始められる ので、下記の Hello World だけでも試してみてください。
Electron で Hello World アプリを作成する package.json の作成 Electron アプリは Node.js アプリとして作成するので、プロジェクトのルートディレクトリに package.json を作成します。 npm init コマンドなどでベースとなる package.json ファイルをサクッと生成し、
$ npm init -y 次のような内容を含むように修正します。</description></item><item><title>Azure Pipelines の使い方 (Hello World)</title><link>https://maku.blog/p/vxoctbs/</link><pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vxoctbs/</guid><description>ここでは、Azure Pipelines の Hello World として、任意の GitHub リポジトリへ git push したときのビルド処理を自動化してみます。 ビルド処理は、Hello World らしく、echo Hello, world! を実行するだけにしておきます。
DevOps organization を作成する Azure Pipelines は、Azure DevOps の中の 1 サービスであり、まず最初に Azure DevOps の organization（組織）を作成する必要があります。 Azure アカウント上でまだ DevOps organization を作成していない場合は、下記 URL にアクセスすることで作成することができます。
https://dev.azure.com/ DevOps organization の構成は次のようになっており、organization 以下に複数のプロジェクトを作成することができます。 各プロジェクトには、複数の Repos（Gitリポジトリ）や Pipelines (CI/CDの仕組み) を設定することができます。
+ Azure DevOps organization + Project - Repos (Gitリポジトリ） - Pipelines (CI/CDの仕組み) - Boards（かんばん、バックログ管理など） - ... + Project - Repos - Pipelines - Boards - .</description></item><item><title>逆引き Azure CLI: Azure にログインする (az login)</title><link>https://maku.blog/p/ejar7k8/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ejar7k8/</guid><description>az login コマンドを使って Azure にログインすると、Azure アカウントに紐づいた情報（サブスクリプション情報など）を取得できるようになります。
パラメータなしで実行してブラウザ上で認証することもできるし、コマンドラインからユーザ名とパスワードを指定することもできます。
ブラウザを起動して認証 $ az login ユーザー名をパラメータで指定 $ az login -u yourname@example.com Password: ******** ユーザー名とパスワードをパラメータで指定 $ az login -u yourname@example.com -p yourpass ログインが成功すると、az account show コマンドで、使用しているサブスクリプションの情報を確認できるようになります。
$ az account show { &amp;#34;environmentName&amp;#34;: &amp;#34;AzureCloud&amp;#34;, &amp;#34;homeTenantId&amp;#34;: &amp;#34;b431a0d2-3656-ed42-9497-c0dfd20ae040&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;343f3fd9-1f19-1d49-7b92-5f365bbc6fd6&amp;#34;, &amp;#34;isDefault&amp;#34;: true, &amp;#34;managedByTenants&amp;#34;: [], &amp;#34;name&amp;#34;: &amp;#34;従量課金&amp;#34;, &amp;#34;state&amp;#34;: &amp;#34;Enabled&amp;#34;, &amp;#34;tenantId&amp;#34;: &amp;#34;b431a0d2-3656-ed42-9497-c0dfd20ae040&amp;#34;, &amp;#34;user&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;yourname@example.com&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;user&amp;#34; } }</description></item><item><title>Unityメモ: Unity の動画を撮る (Unity Recorder)</title><link>https://maku.blog/p/j8mzbnx/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j8mzbnx/</guid><description>Unity Recorder を使用すると、Unity のゲーム画面を簡単に動画ファイル（mp4 など）にして保存することができます。
Unity Recorder のインストール Unity Recorder は Package Manager からインストールします（Unity 2018 より以前は Asset Store で配布されていましたが、Unity 2019 以降は Package Manager からインストールしたものしか動作しません）。 Package Manager は Unity のメニューから下記のように辿ると起動できます。
Window → Package Manager Unity Recorder は、Preview Package として配布されているので、まず、Package Manager の Advanced というプルダウンメニューから Show preview packages を選択してください。
図: Preview Package を表示する すると、リストに Unity Recorder が表示されるので、選択して Install ボタンを押せばインストールできます。
図: Unity Recorder のインストール Unity Recorder で動画を作成する まず Unity Recorder の設定を行い、mp4 で録画するための設定を行います。 メニューから次のように辿り、Recorder ウィンドウを開きます。</description></item><item><title>TypeScriptの型: クラスに static プロパティを定義する</title><link>https://maku.blog/p/2snuk25/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2snuk25/</guid><description>TypeScript のクラス内に、static（静的）なプロパティを定義するには、その名の通り static キーワードを付けるだけで済みます。
下記の例では、MyClass クラスの中に DEBUG という static プロパティを定義しています。 このプロパティを参照するときは、クラス名を前に付けて、MyClass.DEBUG と記述します。
class MyClass { static DEBUG: boolean = true; hello() { if (MyClass.DEBUG) { console.log(&amp;#39;hello!&amp;#39;); } } } const obj = new MyClass(); obj.hello(); static プロパティに、さらに readonly キーワードを付加することで、読み取り専用にすることができます（TypeScript 2.0 移行）。
static readonly DEBUG: boolean = true; 参考リンク TypeScript: クラス定数を定義する (static readonly)</description></item><item><title>Azure Table Strage を使ってみる (1) テーブルの作成</title><link>https://maku.blog/p/xyzwod2/</link><pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xyzwod2/</guid><description>ストレージアカウントを作成する Table Storage や BLOB Storage などの個々のストレージ系サービスは、ストレージアカウントに紐づく形で管理されます。 まずは、ストレージアカウントを作成しておく必要があります。
Azure のストレージアカウントを作成する Table Storage にテーブルを作ってみる テーブルの作成 上記で作成したストレージアカウントを選択し、Table Service → テーブル を選択し、作成 ボタンを押すと、Table Service 上に新しいテーブルを作成することができます。
ここでは、書籍を管理するための、books テーブルを作成してみました。
エンティティの追加 テーブルができたら、そこに適当にデータを追加していきます。 Table Strorage では、テーブル内の個々のデータのことを「エンティティ」と呼びます（RDB でいうレコードです）。
ストレージアカウントのメニューにある、「Storage Explorer」を使ってエンティティを追加できます。
「エンティティの追加」ダイアログが表示されるので、ここでエンティティの情報を入力していきます。 デフォルトでは、PartitionKey と RowKey というプロパティ（RDB でいうフィールド）が定義されていますが、本の情報を入力するために、タイトル (Title) と著者 (Author) のプロパティを追加しておきます。 プロパティ名は、C# の慣例に従って、単語の先頭を大文字で始める CamelCase で定義 しておくのがよいようです（C# から使うとは限らないのですが^^;）。
最初のデータとして次のように入力してます。
PartitionKey : book RowKey : 1 Title : まくの秘密 Author : まく PartitionKey と RowKey は、Table Storage がデフォルトで用意する文字列型プロパティで、これらを組み合わせたものがテーブル内でデータを一意に特定する情報になります（RDB のプライマリキーのようなもの）。 詳しくは後述しますが、ここでは単純に book というパーティション名を付けています。</description></item><item><title>TypeScriptの環境: tsconfig.json の基本</title><link>https://maku.blog/p/27m3brm/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/27m3brm/</guid><description>tsconfig.json があれば TypeScript プロジェクト tsconfig.json は TypeScript の設定ファイルであり、このファイルが置かれたディレクトリが TypeScript プロジェクトのルートディレクトリだとみなされます。 tsconfig.json の記述内容は空っぽ（{} の2文字）でも正しい設定ファイルであり、その場合は、すべてデフォルトの設定値で動作することになります。
TypeScript のトランスパイラである tsc コマンドを実行すると、カレントディレクトリにある tsconfig.json が読み込まれてトランスパイラの動作設定が行われます。 tsconfig.json が見つからない場合は、親ディレクトリを上りながらファイルを探します。 つまり、tsc コマンドは TypeScript のプロジェクト内であれば、どのディレクトリからでも実行できます。
変換対象とするファイルを指定する (files/include/exclude) 最も大切な設定は、TypeScript のトランスパイラがどのファイルを変換対象とみなすかの設定です。 入力ファイルの指定は、設定ファイルの最上位プロパティとして指定する files、include、exclude プロパティを使って行います。
ファイル名を 1 つずつ指定する (files) tsconfig.json { &amp;#34;files&amp;#34;: [ &amp;#34;index.ts&amp;#34;, &amp;#34;module1.ts&amp;#34;, &amp;#34;module2.ts&amp;#34; ] } files プロパティを使って、変換対象の TypeScript ファイルを 1 ファイルずつ指定することができます。
ファイル名のパターン（グロブ）で指定する (include) tsconfig.json { &amp;#34;includes&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;exclude&amp;#34;: [ &amp;#34;node_modules&amp;#34;, &amp;#34;**/*.spec.ts&amp;#34; ] } include プロパティを使用すると、ファイルグロブを使って変換対象とするファイルを指定できます。 ファイルグロブは、下記のようなワイルドカードを使ってファイル名をパターン指定する仕組みです。
** は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータも含みます） * は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータは含みません） ?</description></item><item><title>Azure Cosmos DB にアカウントを作って MongoDB API でアクセスする</title><link>https://maku.blog/p/cd9bg3x/</link><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cd9bg3x/</guid><description>Azure Cosmos DB と MongoDB API Azure Cosmos DB は、Microsoft の Azure 上に配置できるスケーラブルなデータベースで、SQL や MongoDB API など様々なインタフェースでアクセスできるようになっています。
MongoDB を使った既存のアプリケーションがある場合、接続先を Azure Cosmos DB アカウントのアドレスに変更するだけで、簡単にクラウド上のデータを扱えるようになります。 ローカルの MongoDB サーバ (mongod) に接続する代わりに、Azure Cosmos DB に接続するということです。
ここでは、MongoDB API（MongoDB シェル）による Azure Cosmos DB へのアクセスを試してみます。 まずは、Azure 上に Cosmos DB のリソースを作成します。
Azure Cosmos DB アカウントを作成する Azure ポータルへログインし、Azure Cosmos DB のページを開き、Azure Cosmos DB アカウントの作成 をクリックします。
次の画面では、アカウント名 や API の種類を設定します。
アカウント名 に入力した値は、下記のように接続 URI の一部として使われます。 よって、このアカウント名は世界中で一意である必要があります。
mongodb://＜アカウント名＞:＜キー＞@＜アカウント名＞.documents.azure.com:10255/?ssl=true&amp;amp;replicaSet=globaldb API の種類には、MongoDB API を指定してください。 各項目の入力が終わったら、確認と作成 を押して数分待つと、Azure Cosmos DB アカウントの作成が完了します。</description></item><item><title>Ansible とは？ Ansible をインストールする</title><link>https://maku.blog/p/m7ju6fq/</link><pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7ju6fq/</guid><description>Ansible とは？ Ansible は、2012 年に Michael DeHaan 氏によって公開されたコンフィギュレーションツールです。 Ansible を実行するホスト自身の構成を行うこともできるし、複数のホストに対して一括して設定することもできます。 Chef や Puppet に比べて、導入や設定が容易という特徴があります。
類似ツールの比較 ツール名 公開日 作者 作成言語 構成管理ファイル Ansible 2012 年 Michael DeHaan 氏 Python 製 Playbook Chef 2009 年 Adam Jacob 氏 Ruby + Erlang 製 クックブック Puppet 2005 年 Luke Kanies 氏 Ruby 製 マニフェスト Ansible の特徴 ツール自体は Python で記述されています。 コントロールされる側のホスト（マネージドノード）には、Python と SSH さえ入っていればよく、導入が非常に容易です。コントロールする側のホスト（コントロールノード）から、SSH で Python スクリプトを流し込んで実行するという手法です。 複数のホストをプッシュ型でコントロールするので、大量のホスト（数千）の制御も問題なく行えます（複数のホストで並列にコンフィギュレーションが実行される）。ansible-pull というツールを導入すれば、プル型で動作させることも可能です（リモートホストがプロキシ環境内にある場合など）。 設定・構成情報は YAML 形式のテキストファイル (Playbook) で記述します。 Playbook で定義する各種処理（タスク）はモジュールによって提供されており、モジュール自身は様々な言語で実装することが可能 です（200 を超える組み込みモジュールは Python で記述されています）。 実行後の状態に関して冪等性（べきとうせい）が保証されており、何度実行しても同じ状態になるようになっています。Playbook には、「期待する状態」を「宣言的」に記載します。処理手順ではなく、目指すべき姿を定義するということです。 どのような環境でも実行可能な汎用的な Playbook を記述するというよりは、自分たちの組織用にカスタマイズされた Playbook を作成するという用途に向いています。たとえば、apt と yum のどっちのパッケージ管理ツールが使えるのかなどは意識して記述する必要があります。 Ansible の要件 VPS などのリモートサーバーを Ansible で制御できるようにするには、少なくとも対象のサーバー（マネージドノード）に SSH 接続できるようになっていて、Python がインストールされている必要があります。 これは、Ansible が SSH で Python スクリプトを流し込んで、ターゲット上で実行するという仕組みになっているからです。</description></item><item><title>Jadeメモ: jade コマンドをインストールする</title><link>https://maku.blog/p/cfnkkhk/</link><pubDate>Sat, 28 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cfnkkhk/</guid><description>Jade は Node.js 製のテンプレートエンジンです。 HTML ファイルを直接記述するよりも簡潔なフォーマットで Web ページを作成することができます。
jade コマンドは Node Package Manager (npm) を使ってインストールすることができます。 下記のようにグローバルインストールすれば、どのディレクトリからでも jade コマンドを実行できるようになります。
Jade のインストール $ sudo npm install jade --global 参考サイト http://jade-lang.com/ http://jade-lang.com/reference/</description></item><item><title>gnuplot: gnuplot の基本設定</title><link>https://maku.blog/p/je8stcd/</link><pubDate>Wed, 28 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku.blog/p/je8stcd/</guid><description>初期化ファイル (~/.gnuplot or gnuplot.ini) 初期化ファイルは gnuplot を起動した時に、自動的に読み込まれるファイルです。 Unix の場合は ~/.gnuplot、Windows の場合は gnuplot.ini が読み込まれます。 gnuplot.ini は次に説明する「作業フォルダ」内に置きます。 例えば、作業フォルダを D:\home\gnuplot とした場合は、よく使う関数を D:\home\gnuplot\lib\func.gp などに書いておいて、gnuplot.ini で次のように起動時に読み込むようにしておくと便利です。
gnuplot.ini load &amp;#39;lib/func.gp&amp;#39; gnuplot のホームディレクトリの設定 gnuplot を起動した時にカレントとなるディレクトリを指定しておくと便利です。 デフォルトでは、gnuplot の実行ファイルのあるディレクトリがカレントディレクトリになっているので、出力したファイルがそのディレクトリにできてしまいます。 起動時のカレントディレクトリを変更するには次のようにします。
gnuplot.ini (~/.gnuplot) cd &amp;#39;D:\home\gnuplot&amp;#39; 初期化ファイルの中で、ディレクトリを移動しているだけです。
あるいは、Windows では wgnuplot.exe のショートカットを作成して、そのプロパティの作業フォルダで指定する方法もあります。
wgnuplot.exe のショートカット右クリック → プロパティ ショートカット タブの 作業フォルダ に D:\home\gnuplot などを設定 上のように設定してショートカットをダブルクリックすると、好きなディレクトリで作業を始められます。 この方法を使うと、ショートカットごとに作業ディレクトリを変更することができます。</description></item><item><title>.proto の文法: フィールド番号について</title><link>https://maku.blog/p/w7xkvnb/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7xkvnb/</guid><description>フィールド番号の基本 Protocol Buffers の .proto ファイルの型定義では、各フィールドの末尾に フィールド番号 を割り当てておく必要があります。
フィールド番号の割り当て例 message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } = 記号が使われていますが、そのフィールドに値を代入しているわけではないので注意してください。 Protocol Buffers は、メッセージ送信用にデータをシリアライズ（バイナリ化）するとき、フィールド名の代わりにこのフィールド番号を使用します。 これにより、Protocol Buffers は効率的なデータ転送を実現しています。
フィールド番号は 1 以上の整数（最大値は 229-1 = 536,870,911）で、メッセージの定義内（同じ階層）で一意になっている必要があります。 必ずしも 1、2、3 のように連番で割り当てる必要はなく、ほぼ任意の数値を割り当てることができますが、19000 ～ 19999 の値は使えません。 これらは、Protocol Buffers ライブラリが内部実装用に予約している値です。 これらの不正な値を使用していると、protoc コマンドなどでコンパイルしようとしたときにエラーになります。
データをシリアライズするとき、フィールド番号 1～15 の数値は、わずか 1 バイトのデータに変換されるため、頻繁に使用するフィールドには 1～15 のフィールド番号を割り当てておくと効率的な通信を行えます。 とはいえ、フィールド番号が 16～2047 であっても、2 バイトのデータで表現できるので、シビアな通信速度が求められている環境でなければそれほど気にする必要はないでしょう。
reserved と deprecated reserved 一度割り当てたフィールド番号は、将来にわたって変更してはいけません。 なぜなら、過去のバージョンの .proto を使って実装されたアプリケーションは、古い .proto で割り当てられたフィールド番号で通信しようとするためです。 同じフィールド番号で異なるデータが送られてきたら、アプリケーションはうまく動作しなくなってしまいます。 .</description></item><item><title>Ansible で Hello World</title><link>https://maku.blog/p/uhu7hs4/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uhu7hs4/</guid><description>インベントリーファイルを作る Ansible で制御したいホストは、インベントリーファイル (inventory file) に列挙しておく必要があります。 これは、想定外のホストを操作してしまうのを防ぐための安全策です。 デフォルトでは、インベントーリファイルとして /etc/ansible/hosts というファイルが読み込まれます。 コマンドラインオプション (-i) などで、読み込むファイルを指定する こともできます。
/etc/ansible/hosts（記述例） localhost 192.168.1.20 host.example.com インベントリーファイル内では、上記のように「ホスト名」や「IP アドレス」で制御対象のホスト (managed node) を列挙します。 ここでは、3 つのホストを Ansible のコマンド（ansible や ansible-playbook）で制御できるようにしています。 localhost 以外のホストは、SSH で接続できる状態になっている必要があります。
ansible コマンドで ping モジュールを実行してみる インベントリーファイルを用意したら、まずは制御対象のホストに ping を実行してみます。 ping は Ansible の組み込みモジュールとして提供されており、ターゲットホストへの接続確認のために使われます。 いわゆる Linux の ping コマンド (ICMP ping) ではないことに注意してください。
ローカルホストを制御する まずは、localhost に対して（自分自身を制御対象として）、ping を実行してみます。 制御対象とするホスト名は、ansible コマンドの第 1 パラメータで指定します。 次のように SUCCESS 表示が出れば成功です。
例: localhost に対して ping を実行 $ ansible localhost -c local -m ping localhost | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: false, &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34; } Ansible はデフォルトで SSH 接続しようとするので、ローカルホストを制御対象とするときは -c local オプションを指定します。 -m ping オプションは、ping モジュールを使用してタスクを実行することを示しています。</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.2 の場合）</title><link>https://maku.blog/p/8t7iu6g/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8t7iu6g/</guid><description>ここでは、Node.js 用の AWS SDK ver.2 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
SDK ver.3 を使う方法はこちらの記事 を参照してください。 基本的には ver.3 の使用が推奨されていますが、AWS の Lambda 実行環境は現時点（2021年5月）でも ver.2 がインストールされていたりするので、ver.2 の需要はまだあると思います。
Dynamo DB 用の SDK (ver.2) をインストールする AWS SDK version 2 で DynamoDB を扱うには、次のように AWS SDK パッケージ全体をインストールする必要があります（version 3 では DynamoDB サービスなどのパッケージを個別にインストールできます）。
$ npm install aws-sdk --save これで、TypeScript コードから次のように SDK モジュールをインポートできるようになります。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; AWS.DynamoDB だけ参照したければ、次のようにインポートできます。
import { DynamoDB } from &amp;#39;aws-sdk&amp;#39;; DynamoDB インスタンスの生成 基本 DynamoDB の API を呼び出すには、まずは AWS.</description></item><item><title>Next.js のプロジェクトを TypeScript 化する</title><link>https://maku.blog/p/ny9fmty/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ny9fmty/</guid><description>何をするか？ create-next-app コマンドで Next.js プロジェクトを生成するときに --typescript (--ts) オプションをつけて実行すると、TypeScript 対応したプロジェクトを生成することができます。
$ npx create-next-app myapp --typescript # ただ、こっちのテンプレートを使う方法の方が若干洗練されてる気はする $ npx create-next-app myapp --example with-typescript また、Next.js は既存の JavaScript プロジェクトを TypeScript 化する機能も備えています。 ここから先は、その方法を説明します。
参考リンク Next.js で HelloWorld TypeScript 環境の導入 Next.js は、プロジェクトのルートに tsconfig.json ファイルがあると、自動的に TypeScript モードで動作するようになります。 次のようにして、空の tsconfig.json ファイルを作成し、TypeScript 用のパッケージをインストールします。
$ touch tsconfig.json $ npm install typescript @types/node @types/react --save-dev なんと、これだけで Next.js プロジェクトへの TypeScript 導入は完了です。 お手軽〜
自動生成される設定ファイルを見ておく 上記のステップで、TypeScript の設定ファイル (tsconfig.json) に何も記述していないことに気づいたかもしれません。 実は、Next.js のビルド（next dev や next build）を実行すると、自動的に設定ファイルの内容を更新してくれるようになっています。</description></item><item><title>Amazon EC2 で Hello World (2) EC2 インスタンスの起動と接続</title><link>https://maku.blog/p/whu7hr3/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whu7hr3/</guid><description>EC2 インスタンスの起動 EC2 インスタンスに接続するための キーペアを作成 したら、実際に EC2 インスタンスを起動してみます。 ここでは、マシンイメージ (AMI) として EC2 用に最適化された Amazon Linux 2 を選択することにします。
EC2 マネージメントコンソール を開く サイドバーの インスタンス を選択し、インスタンスを起動 ボタンを押す Amazon マシンイメージ (AMI) の選択画面で、Amazon Linux 2 を選択 インスタンスタイプの選択画面で、一番安い t2.nano や、一年間の無料枠がある t2.micro を選択（料金の参考: EC2Instances.info） 確認と作成 ボタンを押す 使用するキーペアを選択する画面が表示されるので、あらかじめ設定しておいた キーペアを選択して、インスタンスの作成 ボタンを押す 図: キーペアの選択 あとは数分待てば、EC2 インスタンスが起動します。
EC2 インスタンスへの SSH 接続 EC2 インスタンスが無事起動したら、SSH で接続してみます。 接続用のユーザー名やアドレスは、次のようにして確認することができます。
EC2 マネージメントコンソール を開く サイドバーの インスタンス を選択し、対象の EC2 インスタンスを選択 接続 ボタンを押す すると、次のような感じで接続先のユーザー名（ec2-user）や DNS アドレス（ec2-XXXXX) を確認することができます。
図: EC2 インスタンスの接続情報 あとは、この情報を使って ssh コマンドで接続するだけです。 EC2 Instance Connect タブで 接続 ボタンを押すと、ブラウザ上で動作する端末画面から接続することもできます。</description></item><item><title>GitHub OAuth トークンを取得する (2) Azure Functions 経由で取得する</title><link>https://maku.blog/p/ar2bjs2/</link><pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ar2bjs2/</guid><description>何をするか？ ここでは、静的な Web サイト（の JavaScript) から、GitHub の OAuth トークンを取得できるようにしてみます。 この処理を実装すると、GitHub と連携した Web アプリを、GitHub Pages や Azure Static Web Apps などの、静的サイト用のホスティングサービス上で公開できるようになります。 汎用的な Web サーバー（VPSなど）でホスティングする場合と比べ、非常に安価に運用することができます。
前提知識として、下記の GitHub の OAuth トークン取得の流れを理解しているものとします。
参考: GitHub OAuth トークンを取得する (1) 処理の流れを理解する 静的な Web サイトから GitHub のアクセストークンを取得するときにネックになるのが、クロスオリジン通信 (CORS) の制約です。 また、GitHub のアクセストークンリクエストには、クライアントシークレット情報が必須であり（2020年、2021年現在）、これをクライアントサイドの JavaScript にハードコードするわけにはいきません。 よって、ブラウザ上で実行される JavaScript からは、実質アクセストークンの取得ができないので、何らかのバックエンドサーバーを介す形でアクセストークンを取得する必要があります。
バックエンドサーバーはどのようなものでも構わないのですが、ここではサーバーレス環境である Azure Functions を使ってアクセストークンの取得機能を実装します。
Azure Functions に関数を追加する Azure Functions に HTTP トリガーで起動する関数を追加し、GitHub の OAuth トークンを取得する処理を実装します。 まずは下記の記事を参考にして、Functions アプリ（プロジェクト）を作成してください。
参考: Azure Functions で簡単な関数を作ってみる 作成する関数の仕様は次のとおりとします。</description></item><item><title>Electron で Hello World (2) TypeScript で開発できるようにする</title><link>https://maku.blog/p/78whxix/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/78whxix/</guid><description>概要 前回の記事（Electron で Hello World (1) 最小構成で作る）では、プレーンな JavaScript を使用して簡単な Electron アプリを作成しましたが、本格的な開発を始めるときは TypeScript の環境を導入しておいた方がよいでしょう。
ここでは、上記のプレーンな JavaScript による Hello World ができているとして、TypeScript の環境を追加でセットアップします。 次のように、src ディレクトリ内に .ts ファイルを作成し、トランスパイルされた .js ファイルを build ディレクトリに出力するように設定することにします。
myapp/ +-- build/ # トランスパイル後の .js ファイルを格納 +-- src/ # .ts ファイルを格納 +-- public/ # そのままパッケージングするもの | +-- index.html +-- package.json # Node.js 用設定ファイル +-- tsconfig.json # TypeScript 用設定ファイル ビルド設定 TypeScript をインストールします。
$ npm install typescript --save-dev Node.js ライブラリ用の型宣言ファイル (node.d.ts) をインストールします。
$ npm install @types/node --save-dev ☝️ ワンポイント Electron の型定義については、Electron パッケージにデフォルトで含まれているので、型定義ファイルを別途インストールする必要はありません。 TypeScript の設定ファイル (tsconfig.</description></item><item><title>Azure Pipelines で Hugo サイトのビルド＆デプロイ</title><link>https://maku.blog/p/kevcr7m/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kevcr7m/</guid><description>前提知識 Azure Pipelines の基本的な使い方は下記ページを参考にしてください。
Azure Pipelines の使い方 (Hello World) hugo deploy コマンドによる Hugo サイトのデプロイについては下記ページを参考にしてください。
hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする | まくまくHugo/Goノート 事前準備 ここでは、Azure Pipelines の設定の説明をしますので、下記の作成・準備は終わっているものとします。
Hugo コンテンツ用の Git リポジトリ Azure Repos や GitHub の Git リポジトリに、Hugo サイトのコンテンツをコミットしてください。 hugo deploy コマンドのための設定 Hugo の設定ファイル config.toml に、deployment.targets などの設定をしてください。 Azure Pipelines の作成 Azure DevOps のプロジェクト内に、上記の Git リポジトリと連携する Pipelines を作成してください。 Hugo 自動ビルド＆デプロイのための Azure Pipelines 設定 azure-pipelines.yml trigger: - master variables: hugo_version: &amp;#39;0.68.3&amp;#39; pool: vmImage: &amp;#39;ubuntu-latest&amp;#39; steps: - script: wget -O hugo.</description></item><item><title>逆引き Azure CLI: プロキシ環境下で Azure CLI (az) を使用する</title><link>https://maku.blog/p/7g9seub/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7g9seub/</guid><description>会社などのプロキシ環境下において az コマンドを実行する場合は、環境変数 https_proxy を設定しておきます。
Windows の場合 C:\&amp;gt; set https_proxy=http://proxy.example.com:8080 Linux/Mac の場合 $ export https_proxy=http://proxy.example.com:8080</description></item><item><title>TypeScriptの型: クラス定数を定義する (static readonly)</title><link>https://maku.blog/p/nky6cbb/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nky6cbb/</guid><description>static readonly プロパティを定義する TypeScript 2.0 移行では、クラス内の static プロパティに readonly キーワードを付けて読み取り専用であることを示すことができます。
class SiteInfo { // クラス定数の定義 static readonly FAQ_URL = &amp;#39;https://example.com/faq/&amp;#39;; } クラス定数を別ファイルから参照する このようなクラスをモジュールとして公開 (export) すれば、アプリ全体でそのクラス定数を共有できます。
（export側）siteInfo.ts export class SiteInfo { static readonly FAQ_URL = &amp;#39;https://example.com/faq/&amp;#39;; } （import側）index.ts import { SiteInfo } from &amp;#39;siteInfo&amp;#39;; console.log(SiteInfo.FAQ_URL); 配列をクラス定数にする (ReadonlyArray) readonly キーワードは、その変数への代入を禁止するだけなので、オブジェクト自体のセット系メソッドは呼び出せてしまいます。 配列に関しても各要素の値が変更できてしまうのは同様ですが、TypeScript にはそれを禁止するための ReadonlyArray&amp;lt;T&amp;gt; というジェネリッククラスが用意されています。
クラス定数として読み取り専用配列を定義 class Coordinates { static readonly ORIGIN: ReadonlyArray&amp;lt;number&amp;gt; = [0, 0]; } Coordinates.ORIGIN = [1, 1]; // Error (readonly により防止) Coordinates.</description></item><item><title>Azure Table Strage を使ってみる (2) 接続情報（キー）を確認する</title><link>https://maku.blog/p/dofzeua/</link><pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dofzeua/</guid><description>Table Storage サービスの ストレージアカウントを作成 すると、各種プログラムから Table Storage にアクセスするための接続情報（キー）を取得することができます。
Table Storage の接続情報は、Azure ポータル からストレージアカウントのリソースを開き、設定 → アクセスキー と辿ると確認することができます。
Python や Node.js などのプログラムから Azure Storage に接続するには、上の図の中の、
ストレージアカウント名 と キー のペア 接続文字列 のいずれかの情報が必要です。</description></item><item><title>TypeScriptの環境: Visual Studio Code で TypeScript の開発環境を構築する</title><link>https://maku.blog/p/ak7u3h3/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ak7u3h3/</guid><description>はじめに TypeScript は Microsoft が開発している言語で、同じく Microsoft が開発している IDE である Visual Studio Code（以下 VS Code）が TypeScript コードの編集に適しています。
VS Code による TypeScript の開発環境を構築するには、下記をインストールする必要があります。
Visual Studio Code Node.js（npm コマンド） TypeScript（tsc コマンド) 開発環境をインストールする Visual Studio Code のインストール VS Code は下記からインストーラーをダウンロードしてインストールできます。
Download Visual Studio Code TypeScript のソースコード (.ts) ファイルは、単純なテキストエディタでも編集できますが、この VS Code を使って編集すると、プロパティ名の自動補完などができて効率的に開発を行えます。
コマンドラインから code と入力して、VS Code を起動できるようになれば OK です。 VS Code をインストールしたのに code コマンドが認識されない場合は、こちらの記事 を参考にしてパスを通してください。
Node.js のインストール TypeScript のトランスパイラである tsc コマンドは、Node.js のパッケージとして提供されているため、先に Node.js をインストールしておく必要があります。 Node.js は下記からインストーラーをダウンロードしてインストールできます。</description></item><item><title>Jadeメモ: jade コマンドの使い方</title><link>https://maku.blog/p/onvso3a/</link><pubDate>Mon, 30 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/onvso3a/</guid><description>jade コマンドで HTML を生成する コマンドラインから jade コマンドを実行するには下記のようにします。 いずれの場合も index.jade ファイルの内容から HTML を生成します。
$ jade index.jade # index.html を作成 $ jade &amp;lt; index.jade # 標準出力へ HTML を出力 $ jade --pretty &amp;lt; index.jade # 改行を追加して見やすく出力 テスト 実際に index.jade というファイルから、HTML を生成してみます。
index.jade doctype html html body h1 Hello World jade コマンドの実行 $ jade &amp;lt; index.jade &amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;</description></item><item><title>gnuplot: 2次元プロットの基本</title><link>https://maku.blog/p/ffyw55u/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ffyw55u/</guid><description>関数をプロットする Syntax plot &amp;lt;expression&amp;gt; [with &amp;lt;line_style&amp;gt;] line_style 一覧 lines &amp;ndash; 線だけ (関数をプロットする時のデフォルト) points &amp;ndash; 記号だけ (ファイルのデータをプロット時のデフォルト) linespoints &amp;ndash; 線と点 例: y = 0.5x &amp;#43; 1 plot 0.5*x + 1 複数の関数をプロットする Syntax plot &amp;lt;expression&amp;gt; [, &amp;lt;expression&amp;gt;...] 複数のグラフを重ねたい場合は、 plot の後ろにカンマ (,) で区切って関数を並べます。 一行が長くなってしまう場合は \ の次に改行すれば複数行に渡ってコマンドを書くことができます。
最後に実行した plot を再び実行する Syntax replot [&amp;lt;expression&amp;gt;] replot と入力すると、最後にプロットしたグラフを再表示します。 replot の引数に別の関数を指定すれと、 最後に実行した plot の出力に重ねてグラフを表示することができます。 連続して replot を実行すればどんどんグラフが重なっていきます。 replot は主に環境設定を変更した際に使用します。
例: sin(x) と cos(x) と tan(x) を重ねたグラフを描画 plot sin(x) replot cos(x) replot tan(x) 次のようにしても同じ</description></item><item><title>.proto の文法: スカラー型の一覧</title><link>https://maku.blog/p/bi5jyer/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bi5jyer/</guid><description>Protocol Buffers の .proto ファイルの中で使用可能なスカラー型と、各言語の型の対応表です。 スカラー型は、メッセージ型 の各フィールドの型として使用できます。
protobuf C++ Java/Kotlin Go Dart double double double float64 double float float float float32 double int32 int32 int int32 int int64 int64 long int64 Int64 uint32 uint32 int uint32 int uint64 uint64 long uint64 Int64 sint32 int32 int int32 int sint64 int64 long int64 Int64 fixed32 uint32 int uint32 int fixed64 uint64 long uint64 Int64 sfixed32 int32 int int32 int sfixed64 int64 long int64 Int64 bool bool boolean bool bool string string String string String bytes string ByteString []byte List 次のような repeated フィールドは、配列やリスト（Golang ではスライス）に相当するコードに置き換えられます。</description></item><item><title>Ansible で VPS を設定するための準備</title><link>https://maku.blog/p/2yahqx6/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2yahqx6/</guid><description>何をするか？ ConoHa VPS などの VPS を借りてサーバーをセットアップしようとすると、多くの手順が必要になります。 そんなとき、最初から Ansible で環境構築するようにしておけば、セットアップ手順を Ansible Playbook でドキュメント化することができ、サーバーの再構築が容易になります。
ここでは、初期状態の VPS サーバー（root 接続のみ可能な状態）に、ansible というユーザーを追加し、Ansible で VPS を制御するための環境を整えます。
前提条件 コントロールノード側（手元の PC）には、あらかじめ Ansible の実行環境がインストールされているものとします（参考: Ansible をインストールする）。 マネージドノード側（VPS サーバー）にはパスワードで SSH 接続することが可能で、Python3 の実行環境がインストールされているものとします。最新の Ubuntu であれば、これらのソフトウェアは最初から使えるはずです。 多くの場合、VPS を使い始めた直後は、root ユーザーで直接 SSH 接続できるようになっていると思います。 今回の手順で、Ansible による接続ができるようになった後は、SSH デーモンの設定を変更して、root ユーザーでの直接接続を禁止するようにしておくと安全です。 もちろん、この設定には Ansible を使うことができます。
セットアップの流れ ここでは、VPS に ansible というユーザーを作成し、Ansible で制御できるようにセットアップします。
VPS に ansible ユーザーを作成する ansible ユーザーを sudoers に登録する VPS に ansible ユーザーで SSH 接続できるようにする （おまけ）Ansible で SSH デーモンの設定を変更しておく root ユーザーで直接 SSH 接続すれば専用のユーザーを作成する必要はないのですが、それは sshd の運用上望ましくない ので却下とします。</description></item><item><title>Next.js アプリのソースコードを GitHub で管理する</title><link>https://maku.blog/p/xjw8it5/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjw8it5/</guid><description>Next.js のプロジェクトは、create-next-app コマンドで作成済みであるとします。
参考: Next.js で HelloWorld create-next-app コマンドで Next.js アプリを新規作成すると、アプリのトップディレクトリに、Git リポジトリ (.git/) が自動的に生成されます。 git log コマンドを実行すると、初回のコミットがすでに生成されていることがわかります。
$ git log commit 4607ecdd2f3f9f3d0d4c86442463c3b86856e88a (HEAD -&amp;gt; main) Author: maku &amp;lt;maku@example.com&amp;gt; Date: Sun Apr 18 23:28:22 2021 +0900 Initial commit from Create Next App この Next.js アプリを GitHub で管理したいときは、以下の手順で GitHub リポジトリと結びつけます。
GitHub 上に 新規リポジトリを追加 します リポジトリ名は create-next-app で指定したアプリ名と合わせましょう。 Initialize this repository with: の項目では、README.txt の作成にはチェックを入れないでください。リポジトリファイル (.git) はすでに create-next-app によって生成されているので、GitHub 側のリポジトリは空の状態で作成する必要があります。 既存の Next.js アプリを上記の GitHub リポジトリに結びつけます $ cd myapp $ git remote add origin https://github.</description></item><item><title>Electron で Hello World (3) React を使えるようにする</title><link>https://maku.blog/p/6pybmv6/</link><pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6pybmv6/</guid><description>概要 ここでは、Electron アプリの開発に React を導入する手順を示します。 React を導入すると、HTML をフラットな形でゴリゴリ記述していくのではなく、独自コンポーネント（例: &amp;lt;MyButton&amp;gt; コンポーネント）を定義して、まとまりのある単位でコンテンツを構築していくことができます。
下記の手順により、Electron + TypeScript による開発環境が構築できていることを前提とします。
Electron で Hello World (1) 最小構成で作る Electron で Hello World (2) TypeScript で開発できるようにする この記事の手順が完了すると、Electron + TypeScript + React による開発環境が整います。 一応 webpack などのバンドルツールを使わなくても開発を始められるので、Electron と React の開発環境としての相性はよさそうです。
React のセットアップ React モジュールのインストール React モジュールおよび、TypeScript 用の型定義ファイルをインストールします。
$ npm install --save react react-dom $ npm install --save-dev @types/react @types/react-dom package.json の内容は次のような感じになります。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;build/main.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;tsc &amp;amp;&amp;amp; electron .</description></item><item><title>Azure Table Strage を使ってみる (3) Python からテーブル操作してみる</title><link>https://maku.blog/p/o8ufwct/</link><pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o8ufwct/</guid><description>azure-cosmosdb-table パッケージのインストール Python から Azure Table Storage を操作するには、azure-cosmosdb-table というライブラリを使用します。
azure-cosmosdb-table のインストール $ pip install azure-cosmosdb-table ☝️ ワンポイント Cosmos DB をまったく使わない場合でも cosmosdb と名前のついたライブラリを使わせようとするのは、 Microsoft の策略 Cosmos DB に力を入れているという意思表示でしょう。 正直なところ Cosmos DB はお金がかかりすぎて個人の趣味レベルでは使えないのですが。。。
（追記: 2021年）CosmosDB に無料枠ができて少しずつ個人利用もできそうな感じになってきました。
TableService オブジェクトの生成 Azure Storage にアクセスするには、接続情報（ストレージアカウント名とキー）が必要になるので、Azure ポータル で確認しておいてください。
参考: Azure Storage の接続情報（キー）を確認する Table Storage にアクセスしてごにょごにょするには、TableService クラス のメソッドを使用します。 TableService のコンストラクタには、ストレージアカウント名とキーを渡します。
from azure.cosmosdb.table.tableservice import TableService STORAGE_NAME = &amp;#39;maku77storage&amp;#39; STORAGE_KEY = &amp;#39;XlgKN4Hv...(省略)...F55o3N9g==&amp;#39; table_service = TableService(account_name=STORAGE_NAME, account_key=STORAGE_KEY) ☝️ URL の指定は必要ない？ 接続先アドレス (URL) の構築は TableService クラスがよろしくやってくれるので、実装コードがとてもスッキリします。 ストレージアカウント名は Azure 内（世界中）で一意になっているので、ストレージアカウント名さえ指定すれば、Web API の URL も自動的に決まるということですね。 ストレージアカウントのキーを環境変数から取得する ストレージアカウントにアクセスするためのキー情報をスクリプト内にハードコーディングするのは望ましくないので、環境変数などから取得するようにしておくとよいでしょう。</description></item><item><title>gnuplot: 棒グラフのプロット (with boxes)</title><link>https://maku.blog/p/67swums/</link><pubDate>Sun, 18 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/67swums/</guid><description>棒グラフをプロット 棒グラフをプロットしたい時は、ラインスタイルに boxes を指定します。 範囲とボックスの幅を指定しない場合は、隣のボックスとくっつくように表示されます。
例: 棒グラフのプロット plot &amp;#39;test.dat&amp;#39; with boxes test.dat 1 10 2 30 3 25 4 40 5 20 範囲を指定しないと、上のように見にくいグラフになってしまうので、棒グラフを表示する場合は範囲指定を行うか、マージンなどを設定するとよいです。
例: 範囲を指定してプロット plot [0:6] [0:50] &amp;#39;test.dat&amp;#39; with boxes 例: マージンを設定してプロット set yrange [0:] set offset 1, 1, 1, 0 # left, right, top, bottom の順 (後ろの方は省略できる) plot &amp;#39;test.dat&amp;#39; with boxes ボックスの幅を指定する Syntax set boxwidth &amp;lt;width&amp;gt; # ボックスの幅を指定 set boxwidth # ボックスの幅を自動調整に戻す 例: ボックスの幅を 0.7 にする set boxwidth 0.</description></item><item><title>Next.js アプリを GitHub Actions でビルドして GitHub Pages で公開する</title><link>https://maku.blog/p/au8ju6g/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/au8ju6g/</guid><description>何をするか？ ここでは、Next.js アプリを次のような構成でホスティング（Web サイトとして公開）できるようにします。
create-next-app で作成した Next.js アプリのコードを GitHub で管理する main ブランチにプッシュ（マージ）したら GitHub Actions で下記を実行 Next.js アプリをビルド (npm run build, npm run export) GitHub Pages にデプロイ つまり、この設定が終わると、GitHub に Next.js アプリのコードをプッシュするだけで、自動的にビルドされて、Web サイトに反映されるようになります。
GitHub リポジトリの準備 空の GitHub リポジトリを作成し、そこに create-next-app で作成した Next.js アプリをプッシュします。 リポジトリ名は、最終的な Web サイトのアドレスをどうしたいかで、次のように作り分けます。
ユーザーサイト（あるいは Organization サイト） 公開 URL: https://&amp;lt;username&amp;gt;.github.io/ 作成するリポジトリ名: &amp;lt;username&amp;gt;.github.io プロジェクトサイト 公開 URL: https://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository&amp;gt;/ 作成するリポジトリ名: &amp;lt;repository&amp;gt; ここでは、プロジェクトサイトとして myapp というリポジトリを作成した場合の例で説明していきます。
$ npx create-next-app myapp $ cd myapp $ git remote add origin https://github.</description></item><item><title>Azure Table Strage を使ってみる (4) Node.js からテーブル操作してみる</title><link>https://maku.blog/p/ccoonon/</link><pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ccoonon/</guid><description>azure-storage パッケージのインストール Node.js から Azure Table Storage を操作するには、azure-storage というライブラリを使用します。 npm コマンドで簡単にインストールすることができます。
azure-storage のインストール $ npm install --save azure-storage 参考: npm によるパッケージのインストール | Node.js ノート TableService オブジェクトの生成 Azure Storage にアクセスするには、接続情報（ストレージアカウント名とキー）が必要になるので、Azure ポータル で確認しておいてください。
参考: Azure Storage の接続情報（キー）を確認する 接続情報としてデフォルトの環境変数を使用する Node.js から Table Storage を扱うには、azure-storage モジュールが提供する TableService クラス を使用します。 TableService のインスタンスは下記のように生成することができます。
const azure = require(&amp;#39;azure-storage&amp;#39;); const tableService = new azure.TableService(); 上記のように、TableService のコンストラクのパラメータを何も指定しないと、接続のために下記のような環境変数が参照されます。
AZURE_STORAGE_ACCOUNT &amp;hellip; Azure Storage の「ストレージアカウント名」 AZURE_STORAGE_ACCESS_KEY &amp;hellip; Azure Storage の「キー」 AZURE_STORAGE_CONNECTION_STRING &amp;hellip; Azure Storage の「接続文字列」 1 と 2 を両方とも設定するか、3 を設定しておけば Azure Storage にアクセスできるようになります。</description></item><item><title>gnuplot: 三次元プロットの基本</title><link>https://maku.blog/p/awbbari/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/awbbari/</guid><description>三次元グラフの表示 Syntax splot &amp;lt;expression&amp;gt; 例: z = x2 &amp;#43; 10y splot x**2 + 10*y メッシュの細かさを指定する Syntax set isosample &amp;lt;x_rate&amp;gt;, &amp;lt;y_rate&amp;gt; デフォルトの細かさは 10, 10 です。
例: メッシュの細かさを 20, 20 にする set isosample 20, 20 等高線を表示する Syntax set contour 例: z = -x2-y2 の等高線を表示 set contour splot -x**2 - y**2</description></item><item><title>gnuplot: 実行したコマンドのファイルへの保存・読み込み</title><link>https://maku.blog/p/ncyuy3e/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ncyuy3e/</guid><description>実行したコマンドをファイルへ保存 Syntax save &amp;#39;&amp;lt;filename&amp;gt;&amp;#39; 今まで実行したコマンドをファイルに保存したい場合は、save を使います。 ファイルの拡張子には .plt をつけることが多いみたいです。 上書きのチェックはしてくれないので注意してください。
例: sample.plt にコマンドを保存 save &amp;#39;sample.plt&amp;#39; ファイルからコマンドを読み込み Syntax load &amp;#39;&amp;lt;filename&amp;gt;&amp;#39; 逆に保存したファイルを読み込んで実行するには、load を使います。
例: sample.plt を実行 load &amp;#39;sample.plt&amp;#39;</description></item><item><title>gnuplot: 画像ファイルへの保存</title><link>https://maku.blog/p/ojm4was/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ojm4was/</guid><description>GIF で出力 Syntax set terminal gif [transparent] [interlace] [font_size] [size x, y] [bg_color] [border_color] [axes_color] [line1_color line2_color ...] set terminal gif のオプション optionvalueDefaultdescription transparenttransparent | なしなし背景を透過するか interlaceinterlace | なしなしインターレースにするか font_sizesmallsmall6x12 medium7x13 (Bold) large8x16 sizesize &amp;lt;x&amp;gt;, &amp;lt;y&amp;gt;640, 480画像の幅と高さ bg_color&amp;lt;xRRGGBB&amp;gt;xFFFFFF (白)背景色 border_color&amp;lt;xRRGGBB&amp;gt;x000000 (黒)枠の色 axes_color&amp;lt;xRRGGBB&amp;gt;xCCCCCC (灰)軸の色 lineX_color&amp;lt;xRRGGBB&amp;gt;xFF0000 (赤)x00FF00 (緑)x0000FF (青)線の色を順に指定 例: test.gif に出力する設定 set terminal gif size 400, 300 set output &amp;#39;test.gif&amp;#39; 例: test.gif に出力する設定（白色を透過） set terminal gif size 400, 300 transparent xffffff set output &amp;#39;test.</description></item><item><title>Ansible 関連用語</title><link>https://maku.blog/p/a9twaog/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a9twaog/</guid><description>モジュール Ansible で使う機能の単位。例えば、ansible.builtin.systemd など。 プレイブック中の各プレイで指定するタスクリストは、モジュールを指定して定義していきます。 インベントリ コントロール対象とするマネージドノードの一覧ファイル。 INI 形式、あるいは YAML 形式で記述します。 シンプルに記述したければ INI 形式、階層構造を明確にしたければ YAML 形式を使います。 ホスト変数 インベントリで定義したホストに対して設定する変数。 インベントリファイルから分離して、host_vars ディレクトリ内の YAML ファイルに記述することもできます。 グループ変数 インベントリで定義したグループに対して設定する変数。 インベントリファイルから分離して、group_vars ディレクトリ内の YAML ファイルに記述することもできます。 インベントリプラグイン (inventory plugins) Ansible 本体にインベントリの機能を提供しているプラグイン。 INI ファイル用の ansible.builtin.ini や、YAML ファイル用の ansible.builtin.yaml などがあります。 他にも動的にインベントリを生成するものもあります。 参考: Index of all Inventory Plugins — Ansible Documentation プレイブック (playbook) マネージドノードに対する処理内容を YAML 形式で定義したもの。 プレイブックは、複数のプレイ (Play) で構成されており、プレイは複数のタスクで構成されています (Playbook ◇─ Play ◇─ Task)。 プラグイン Ansible 本体に対して機能を追加する仕組み。 参考: Indexes of all modules and plugins — Ansible Documentation ホスト / Host Ansible のコントロール対象となるリモートマシン。 ansible.</description></item><item><title>TypeScript で AWS SDK を使う開発環境を整える</title><link>https://maku.blog/p/taiqx6d/</link><pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/taiqx6d/</guid><description>TypeScript のプロジェクトを作成する 何をできるようにするか？ ここでは、Node.js はインストール済みであるという前提で、次のようなことを行える TypeScript 環境を整えます。
npm run build で src ディレクトリ以下の .ts ファイルをコンパイルする
（.js ファイルが build ディレクトリ以下に出力される） npm start でコンパイルされた build/main.js を起動する 下記のセットアップ手順の 詳しい意味はこちらを参照 していただくとして、ここでは一気にセットアップを終わらせてしまいます。
セットアップ # アプリ用のディレクトリを作成 $ mkdir myapp $ cd myapp # Node.js アプリの設定ファイル (package.json) を生成 $ npm init -y # TypeScript および Node 型情報をインストール $ npm install typescript -D $ npm install @types/node -D # TypeScript の設定ファイル (tsconfig.json) を生成 $ npx tsc --init package.json を次のような感じで修正します。 主に scripts の定義です。</description></item><item><title>Next.js アプリを Vercel で公開する</title><link>https://maku.blog/p/j6ht5fq/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6ht5fq/</guid><description>Vercel とは？ Vercel は Next.js を開発している企業であり、同名の Vercel というサービスを提供しています。
Vercel - Develop. Preview. Ship. For the best frontend teams Vercel サービスは Next.js アプリのホスティングに特化しており、GitHub などのリポジトリと連携させることにより、ビルドから Next.js サーバーによるホスティングまでを簡単に自動化することができます（実際には、Vercel サービスは、Next.js 以外で作成した Web サイト、例えば、Hugo で作成したブログなどのホスティングにも対応しています）。
Next.js アプリで SSR (Server-side Rendering) や API ルートなどの機能を使用している場合は、Next.js サーバー上で Web サイトをホスティングする必要があるのですが、現状そのような環境をサーバーレスなサービスとして提供しているのは Vercel のみです（一応 Serverless Next.js という AWS Lambda で動かすものもあったりしますが）。
Next.js の開発サーバー (next dev) で何らかのアプリをローカルで動かせているのであれば、Vercel を使って、ほぼそのままの形でネット上に公開することができます。 小規模な Web サイトであれば無料で動かせますし、とっても簡単なので、一度試してみるとよいです。
Vercel で Next.js アプリを公開する ここでは、GitHub にプッシュした Next.js アプリを Vercel を使って公開してみます。 まずは、下記を参考にして、GitHub に何らかの Next.</description></item><item><title>Vercel のウェブサイトに独自ドメインを割り当てる</title><link>https://maku.blog/p/9vakw8i/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9vakw8i/</guid><description>Vercel で公開している Web サイトに、お名前.com で取得した独自ドメインを割り当てる方法を説明します。 Vercel 上での Next.js アプリ公開までの手順は、下記の記事を参考にしてください。
参考: Next.js アプリを Vercel で公開する ここでは、独自ドメインを「お名前.com」で取得済みだと仮定しますが、別のレジストラで取得している場合もほぼ同様に設定できるはずです。 大きく分けて、次の 2 種類の設定方法があります。
Vercel の DNS サーバーを使う方法 Vercel 以外の DNS サーバーを使う方法 独自ドメインの「レジストラ」と「DNS サーバー」の関係については、下記の記事で簡単にまとめていますので参考にしてください。 後述の設定で何をしているのかが分かりやすくなると思います。
参考リンク ドメイン管理と DNS 管理の違いを理解する Vercel の DNS サーバーを使う方法 お名前.com などのレジストラで独自ドメインを取得すると、そのドメインをどの DNS サーバーで運用するかという設定を行えるはずです。 次のように Vercel 側の DNS サーバー設定を行うと、お名前.com 側に設定すべき DNS サーバー名を確認できます。
(1) Vercel のサイト から対象アプリのページを開き、Settings → Domains と選択し、取得済みの独自ドメイン名を入力して Add ボタンを押してください。ここでは、例として example.com というドメインを管理するとします（ドメイン自体は「お名前.com」で取得したものです）。
図: Vercel に独自ドメインを設定する (2) example.com に加えて www.example.com もエイリアスとして設定するかというダイアログが出ますが、example.com だけでよければ、Add example.com を選択すれば　OK です。</description></item><item><title>React コンポーネント実装の基本（関数コンポーネントとクラスコンポーネント）</title><link>https://maku.blog/p/vfr3cnw/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vfr3cnw/</guid><description>React で独自コンポーネントを作成する方法として、大きく次の 2 種類の方法があります。
関数コンポーネント (Function Components) クラスコンポーネント (Class Components) 昔は、ステートを持つコンポーネントは「クラスコンポーネント」で作成し、ステートを持たないものは「関数コンポーネント」として作成するという使い分けがありました。 現在は、関数コンポーネントでも Hook の仕組みでステートを管理することができるようになったため、関数コンポーネントの使用が推奨されています。
関数コンポーネント 関数コンポーネントの基本 下記は、固定のテキストを表示するシンプルな関数コンポーネントの定義例です。 TypeScript (@types/react) では、関数コンポーネントの型は React.FunctionComponent インタフェースとして定義されています。 エイリアスとして React.FC が定義されているので、こちらを使えばより短く記述できます。
components/Hello.tsx import * as React from &amp;#39;react&amp;#39;; // Hello コンポーネントの定義 export const Hello: React.FC = () =&amp;gt; { return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; }; HTML ファイルから読み込む JS ファイルでは、ReactDOM.render() で上記の Hello コンポーネントを描画します。 次のコードを実行すると、&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt; 要素の内容が、Hello コンポーネントの内容に置き換えられます。
index.tsx（使用例） import * as React from &amp;#39;react&amp;#39;; import * as ReactDOM from &amp;#39;react-dom&amp;#39;; import { Hello } from &amp;#39;.</description></item><item><title>Azure: Cosmos DB の SQL API をプロキシ経由で使用する</title><link>https://maku.blog/p/t8rfkjn/</link><pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t8rfkjn/</guid><description>参照するサンプルコード Azure の Cosmos DB を SQL API で操作するための最初の手順は下記のドキュメントに記載されています。
クイック スタート:Azure Cosmos DB SQL API アカウントを使用して Node.js アプリを構築する ここに Node.js 用のサンプルコードがあり、@azure/cosmos パッケージが提供する CosmosClient クラスを使用したコードになっています（昔のサンプルコードでは documentdb というライブラリを使用していたりしますが、今は Microsoft が提供する @azure/cosmos を使用すると完結なコードを記述できます）。
const CosmosClient = require(&amp;#39;@azure/cosmos&amp;#39;).CosmosClient; 基本的には、config.js ファイルに記述されたエンドポイントとキーを下記のような感じで設定すれば実行できるようになるのですが、
config.js var config = {}; config.endpoint = &amp;#39;https://your-cosmosdb.documents.azure.com:443/&amp;#39;; config.key = &amp;#39;9Hp4WSwgvggexAuGy4dKdl...snipped...lV9Nm44Pg8WVkH==&amp;#39;; 会社などのプロキシ環境内からだとうまく接続できず、次のような感じのエラーが発生すると思います。
$ node app.js Completed with error {&amp;#34;message&amp;#34;:&amp;#34;request to https://your-cosmosdb.documents.azure.com:443/dbs/FamilyDatabase failed, reason: connect ETIMEDOUT 123.34.56.78:443&amp;#34;,&amp;#34;type&amp;#34;:&amp;#34;system&amp;#34;,&amp;#34;errno&amp;#34;:&amp;#34;ETIMEDOUT&amp;#34;, &amp;#34;code&amp;#34;:&amp;#34;ETIMEDOUT&amp;#34;,&amp;#34;headers&amp;#34;:{&amp;#34;x-ms-throttle-retry-count&amp;#34;:0,&amp;#34;x-ms-throttle-retry-wait-time-ms&amp;#34;:0}} HTTPS_PROXY 環境変数を設定しても同様で効果がありません。
プロキシ経由で CosmosClient を使用する CosmosClient クラスでの Cosmos DB へのアクセスをプロキシ経由で行うには、コンストラクタのパラメータとして渡せる CosmosClientOptions の agent プロパティを設定します。 ここでは、エージェントとして proxy-agent モジュールを使用します。</description></item><item><title>Apollo Client で GitHub GraphQL API を使う (Node &amp; React)</title><link>https://maku.blog/p/qcp2cnx/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2cnx/</guid><description>Apollo Client とは Apollo パッケージは、GraphQL を使ったクライアントアプリやサーバーを作成するためのライブラリ群です。 クライアントアプリを作るためのライブラリは、Apollo Client として @apollo/client という NPM パッケージにまとめられています。
Web アプリのコンポーネントを作成するときは React がよく使われますが、Apollo は GraphQL を扱いやすくする React コンポーネント（ApolloProvider、Query、Mutation、Subscription）や React Hook 拡張（useQuery) などを提供しています。
ここでは、Apollo Client パッケージを使用して、
Node.js アプリ（コマンドラインアプリの JS）から GraphQL API の実行 React アプリ（Web サイトの JS）から GraphQL API の実行 を行ってみます。 呼び出す GraphQL API は何でもよいのですが、今回は GitHub GraphQL API を利用することにします。
Node パッケージのインストール Apollo Client Apollo Client 関連のパッケージとしては、@apollo/client と、それが使用する graphql をインストールします。
Apollo Client のインストール ### yarn の場合 $ yarn add @apollo/client graphql ### npm の場合 $ npm install @apollo/client graphql fetch ポリフィル Apollo クライアント内部の実装では、Web ブラウザの fetch API を利用しています。 React アプリから Apollo クライアントを利用する場合は問題ないのですが、コンソールで動作する Node.</description></item><item><title>VS Code のショートカットキーを使いこなす（ウィンドウ操作編）</title><link>https://maku.blog/p/as4cmu4/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/as4cmu4/</guid><description>ショートカットキーで Cmd になっているところは、Windows の場合は Ctrl に置き換えればほぼ動作します。 とりあえずは、サイドバーやターミナルパネルを On/Off する Cmd + B や Cmd + J から覚えて、画面を広く使えるようになりましょう。
アクティビティバー／サイドバーの操作 ショートカット 説明 Cmd + B サイドバー全体の表示／非表示 Cmd + Shift + E Explorer を開く Cmd + Shift + F(H) Search を開く（H なら置換モード） Ctrl + Shift + G Source Control を開く Cmd + Shift + D Debug を開く Cmd + Shift + X Extension を開く ターミナル／出力パネル 画面の下の方に表示されるターミナルなどのパネルを開くためのショートカットキーです。
ショートカット 説明 Cmd + J パネル全体の表示／非表示 Ctrl + ` Terminal パネルを開く Cmd + Shift + Y Debug Console パネルを開く Cmd + Shift + M Problem パネルを開く Cmd + Shift + U Output パネルを開く 外部コマンドを実行するときは、Terminal パネルを使用する代わりに、Cmd + Shift + C で OS 標準のターミナルを開くこともできます（Windows なら Ctrl + Shift + C でコマンドプロンプトが開きます）。</description></item><item><title>Azure Pipelines の Pull Request 時の起動トリガ設定</title><link>https://maku.blog/p/i6549xd/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i6549xd/</guid><description>ビルドしない azure-pipelines.yml trigger: none # will disable CI builds entirely Azure Pipelines によるビルドを起動しないようにします。
trigger プロパティを省略すると、デフォルトですべてのブランチへのプッシュ時にビルドが走るので、ビルドしないようにするには、上記のように明示的に none 指定が必要です。 この設定を行うと、pr プロパティの設定（後述）も無効になります（Pull Request 時もビルドは実行されない）。
master ブランチへのプッシュ or マージでビルド？ azure-pipelines.yml trigger: - master 次のように複数のブランチをビルド対象とすることもできます。
trigger: - master - release このように記述すると、指定したブランチへのプッシュ or マージ時にのみ Pipelines が起動しそうに見えますが、この指定だけだと、 あらゆる Pull Request の作成時に Pipelines が起動します。 master ブランチや release ブランチをターゲットとしない Pull Request でもビルドが走ります。 なぜなら、Pull Request トリガの設定がデフォルトで次のようになっているからです。
pr: branches: include: - &amp;#39;*&amp;#39; このため、一連のステップにデプロイ処理まで組み込んでいると、レビュー用に Pull Request を上げただけでデプロイまで実行されてしまうという振る舞いになります。
Pull Request 時にビルドしない azure-pipelines.yml trigger: - master pr: none # no PR triggers 上記のように設定しておくと、Pull Request を作成したときには Pipelines は起動しなくなります。 つまり、master ブランチへのプッシュ or マージ時のみビルドが実行されます。</description></item><item><title>Azure Pipelines のビルド結果を GitHub にバッジ表示する</title><link>https://maku.blog/p/teq2cmv/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/teq2cmv/</guid><description>ステータスバッジとは ステータスバッジというのは、GitHub プロジェクトのトップページ (README.md) でよく見かける上のようなアイコンのことです。 ステータスバッジを貼り付けておくことで、最新のソースコードが正しくビルドできていることを一目で確認することができますし、ちゃんと開発しているんだということをアピールすることにもなります。
Azure Pipelines のビルド結果を示すステータスバッジは、下記のように簡単に追加することができます。
Azure Pipelines のステータスバッジを表示する ステータスバッジは、画像ファイルの URL の形で提供されているので、GitHub の README.md などにその URL を貼り付けるだけで OK です。
ステータスバッジの画像 URL を確認するには、Azure Pipelines のページを開き、右上のメニューアイコン → Status badge と選択します。
画像の URL と一緒に、Markdown ファイルに記述する場合のコード (Sample markdown) も表示してくれるので、GitHub のページに貼り付ける場合はそちらを使えばよいでしょう。 右側のコピーアイコンを押してクリップボードにコピーし、GitHub の README.md ファイルに次のような感じで貼り付ければ OK です。
これで、GitHub プロジェクトのトップページアクセスしたときに、次のようにステータスバッジが表示されるはずです。
ステータスバッジの画像が表示されないとき Azure DevOps にサインインしていない状態で、ステータスバッジが表示されない場合は、Pipelines の設定を確認してみてください。
上記のように、Disable anonymous access to badge という項目を OFF にすれば表示されるようになると思います。</description></item><item><title>Azure Storage で静的 Web サイトをホスティングする</title><link>https://maku.blog/p/gkardu9/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gkardu9/</guid><description>（Azure Storage による静的な Web サイトのホスティング機能は 2018 年末にリリース されました）
ストレージアカウントを作成する（まだ作成していない場合） Azure 上に静的な Web サイトをホスティングするためのストレージを作成するには、ストレージアカウントが必要です。 まだ作成していない場合は、下記の手順に従ってストレージアカウントを作成してください。 静的な Web サイトをホスティングする場合は、アカウントの種類 (Account kind) の項目で StorageV2（汎用v2） というのを選んで作成しておく必要があります。
→ Azure のストレージアカウントを作成する
静的な Web サイトを有効にする ストレージアカウントを作成したら、コンテンツのアップロード先である Azure ストレージコンテナーと、Web サイトの URL を生成します。 といっても、ストレージアカウントがあれば、Azure ポータル から数秒で自動作成できます。
ストレージアカウントのページを開き、設定 → 静的な Web サイト を選択します。 静的な Web サイト のスイッチを 有効 に切り替えて 保存 ボタンを押します。 これで、Web サイトをホスティングするための Azure ストレージコンテナー（BLOB を入れるコンテナー）が作成されます。 コンテナー名は自動的に $web になるようです。
同時に、Web サイトの URL も自動的に生成されます。
これが Web ブラウザからサイトにアクセスするときのアドレスになります。 あとは、コンテナーに HTML ファイルをアップロードするだけです。
Web サイトのコンテンツをアップロードする 作成されたコンテナー ($web) にコンテンツをアップロードするには、Azure CLI などのコマンドラインツールを使用します。 Azure ポータルのサイト上で BLOB リソースの項目からポチポチやってアップロードすることもできますが、自動化のことを考えると、コマンドラインツールを使った方がよいでしょう。</description></item><item><title>逆引き Azure CLI: ストレージアカウントのキーを確認する (storage account keys list)</title><link>https://maku.blog/p/3wk5vnw/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3wk5vnw/</guid><description>Azure ストレージアカウントのキー（鍵）情報を取得するには、Azure にログイン した状態で、以下のように実行します。
$ az storage account keys list --account-name ストレージアカウント名 [ { &amp;#34;keyName&amp;#34;: &amp;#34;key1&amp;#34;, &amp;#34;permissions&amp;#34;: &amp;#34;Full&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;7s+V+j4CcwDNHyTvx7/UXlgKN4HvFoUuIhOuzH1YLaBWgVTWQadQB2vFjRPTAv2aoGP2mpyQcMm4C+R55o3N9g==&amp;#34; }, { &amp;#34;keyName&amp;#34;: &amp;#34;key2&amp;#34;, &amp;#34;permissions&amp;#34;: &amp;#34;Full&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;+uzKfRt3rCP7RkNBXG93lqEqD7MLvgFQmKxudWHjYbDMUeFH0VmdMhN8V/6ChCwVANi6jaDL4ZKopfwV5RjY9g==&amp;#34; } ] このストレージアカウントキーは、az storage コマンドを使って Azure ストレージ上のデータを操作するときに必要になります。
参考リンク BLOB ストレージにファイルをアップロードする (storage blob upload)</description></item><item><title>逆引き Azure CLI: ストレージアカウントの接続文字列を確認する (storage account show-connection-string)</title><link>https://maku.blog/p/hquhjki/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hquhjki/</guid><description>Azure CLI で Azure ストレージアカウントの接続文字列（アカウント名とキーがペアになったもの）を取得するには、az storage account show-connection-string コマンドを使用します。
このコマンドを実行する前に、az login で Azure にログイン しておく必要があります。
ストレージアカウントの接続文字列を取得 $ az storage account show-connection-string --name yourstorage { &amp;#34;connectionString&amp;#34;: &amp;#34;DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=yourstorage;AccountKey=7s+V+j4CcwDNHyTvxTAv2aoGP2mpyQcMm4C+R7/UXlgKN4HvFoUuIhOuzH1YLaBWgVTWQadQB2vFjRP55o3N9g==&amp;#34; } 参考リンク az storage account show-connection-string コマンド</description></item><item><title>TypeScriptの型: リテラル型を定義する (Literal types)</title><link>https://maku.blog/p/6iuo8aj/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6iuo8aj/</guid><description>TypeScript のリテラル型は enum 型（列挙型）の制約を緩めたようなものです。 enum 型は 整数値 で値を保持しますが、リテラル型は 任意の型 で格納可能な値を定義します。
例えば、次のように定義した Answer 型は、その値として yes あるいは no という文字列のみ格納できるようになります。
// Answer というリテラル型を定義する type Answer = `yes` | `no`; // Answer 型の変数には &amp;#39;yes&amp;#39; か &amp;#39;no&amp;#39; のみ格納可能 let answer: Answer answer = &amp;#39;yes&amp;#39;; // OK answer = &amp;#39;no&amp;#39;; // OK answer = &amp;#39;maybe&amp;#39;; // Error answer = 100; // Error 参考リンク TypeScript: 列挙型を定義する (enum) TypeScript: タイプエイリアスを定義する (type)</description></item><item><title>TypeScriptの型: タイプエイリアスを定義する (type)</title><link>https://maku.blog/p/5zoqtmi/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5zoqtmi/</guid><description>TypeScript の タイプエイリアス (Type alias) を使用すると、既存の型を組み合わせて新たな型を定義することができます。
下記の例では、string 型と number 型の 2 つの値を保持する Person という型を定義しています。 タイプエイリアスの定義では、代入 (=) の構文を使用すること注意してください。
type Person = { name: string; age: number; }; let p: Person = { name: &amp;#39;Maku&amp;#39;, age: 14 }; console.log(p.name); console.log(p.age); Person 型の変数を初期化するときは、上記のように各プロパティの値を漏れなく明示する必要があります。 次のように、プロパティの指定に過不足があるとコンパイルエラーが発生します。
間違った例 let p1: Person = { name: &amp;#39;Maku&amp;#39; }; // プロパティが不足 let p2: Person = { name: &amp;#39;Maku&amp;#39;, age: 14, xxx: 20 }; // 未知のプロパティ エラーメッセージ sample.ts:6:5 - error TS2741: Property &amp;#39;age&amp;#39; is missing in type &amp;#39;{ name: string; }&amp;#39; but required in type &amp;#39;Person&amp;#39;.</description></item><item><title>TypeScriptの型: 共用体を定義する (Union types)</title><link>https://maku.blog/p/cdazjwv/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cdazjwv/</guid><description>共用体 (union) の基本 変数の型をタイプアノテーションで指定するときに、複数の型を | (or) でつなげて指定すると、それらのいずれの型の値でも格納できる 共用体 (union) となります。
例: 文字列と数値を格納できる変数 let a: string | number; a = &amp;#39;Hello&amp;#39;; // OK a = 123; // OK a = true; // NG 例: 文字列あるいは数値のパラメータをとる関数 function foo(value: string | number) { // ... } 共用体のタイプエイリアスを定義する ある種類の共用体を繰り返し使用する場合、タイプエイリアスを定義しておくと、何度も同じ記述をしなくて済みます。
// interface Context {}; type ContextOrString = Context | string; 定義したタイプエイリアスは、通常の型と同様に使用することができます。
function onMessage(context: ContextOrString) { // ... }</description></item><item><title>TypeScriptの型: 列挙型を定義する (enum)</title><link>https://maku.blog/p/fdjk4hh/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fdjk4hh/</guid><description>列挙型 (enum) の基本 TypeScript で列挙型を定義するには、enum キーワードを使用します。
enum Fruits { Apple, //= 0 Banana, //= 1 Orange //= 2 } console.log(Fruits.Apple); //=&amp;gt; 0 console.log(Fruits[Fruits.Apple]); //=&amp;gt; Apple デフォルトでは、各要素の値として先頭から順番に 0、1、2 という連番の 整数値 が内部的に割り当てられます（C 言語や Java と同様です）。 この値は任意の数値に変更することができます。
次の例は、ビットフラグとして使用することを想定した enum の定義例です。 各値が 2 のべき乗の値になっていることに注意してください。
enum OpenModes { Read = 1, Write = 2, Append = 4 } const mode = OpenModes.Read | OpenModes.Write; if ((mode &amp;amp; OpenModes.Write) == OpenModes.Write) { console.log(&amp;#39;Write フラグが指定されています&amp;#39;); } enum 値をインライン展開する (Constant enumeration) enum 定義を行うときに const キーワードを付加すると、その enum 値を使用した場所に値がハードコードされる形で展開されます（JavaScript のコードに変換するときに、0 や 1 といった値をインライン展開する）。</description></item><item><title>React フック: useSWR でデータフェッチ</title><link>https://maku.blog/p/vm2ft83/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vm2ft83/</guid><description>SWR とは useSWR フック SWR (useSWR) は、Next.js を開発している人たち (Vercel) が開発したデータフェッチ用の React フックライブラリです。 React アプリでデータフェッチを真面目に実装しようとすると、大体最後にこのライブラリに行き着きますので、最初からこれを使いましょう（GraphQL の場合は Apollo Client がありますが）。
SWR - React Hooks library for data fetching React コンポーネント内から Web API などを呼び出してデータフェッチを行う場合、標準の仕組みだけで実現しようとすると、useEffect フックなどで fetch 関数を呼び出したりすることになります。
useEffect による不完全なデータフェッチ実装 function Page () { const [user, setUser] = useState(null) useEffect(() =&amp;gt; { fetch(&amp;#39;/api/user&amp;#39;) .then(res =&amp;gt; res.json()) .then(data =&amp;gt; setUser(data)) }, []) // ... } もちろん、それで実現は可能なのですが、「データ取得前の表示」「エラー処理/リトライ処理」「非同期処理のキャンセル処理」などをちゃんとやろうとすると非常に煩雑なコードになってきます（上記コードはそれらが全く考慮できていません）。 useSWR フックを使うと、クライアントサイド JavaScript からのデータフェッチ処理をとても綺麗に記述することができます。
useSWR の使用例 import { FC } from &amp;#39;react&amp;#39; import useSWR from &amp;#39;swr&amp;#39; const fetcher = (url: string) =&amp;gt; fetch(url).</description></item><item><title>AWS CloudFormation で Lambda 関数のリソースを生成する</title><link>https://maku.blog/p/w8s8kx9/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w8s8kx9/</guid><description>何をするか？ AWS CloudFormation を使うと Lambda 関数を含むインフラ（AWS リソース群）をまとめて生成することができますが、AWS CloudFormation の拡張である AWS SAM を使うと、もっと簡潔に Lambda 関数のリソースを生成することができます。
例えば、CloudFormation テンプレートの AWS::Lambda::Function リソースでは、Role プロパティが必須でしたが、SAM テンプレートの AWS::Serverless::Function リソースでは、Role プロパティはオプショナルになっています。 Role プロパティを省略すると、Lambda 関数に付けた論理 ID (Logical ID) をもとに、&amp;lt;論理ID&amp;gt;Role という名前のロールが自動生成されます。
ここでは、AWS SAM を使った Lambda 関数生成の基本として、次のようなパターンで CloudFormation スタックを生成してみます。
SAM テンプレートに関数コードを埋め込んでデプロイ S3 バケット上の関数の ZIP ファイルを使ってデプロイ SAM テンプレートに関数コードを埋め込んでデプロイ まずは、一番シンプルな例として、SAM テンプレート内に Lambda 関数の実装をハードコーディングしてしまい、それをデプロイ（CloudFormation スタックの生成）してみます。
下記が SAM テンプレートです。 SAM で Lambda 関数のリソースを定義するときは、リソースタイプとして AWS::Serverless::Function を指定します（CloudFormation では AWS::Lambda::Function です）。 ここでは関数の実装を InlineCode プロパティでハードコーディングし、単純な Hello World! メッセージをレスポンスとして返すようにしています。
template.yml AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Transform: AWS::Serverless-2016-10-31 Description: Simple Lambda Function Resources: HelloFunction: Type: AWS::Serverless::Function Properties: Runtime: python3.</description></item><item><title>逆引き Azure CLI: Azure ストレージの SAS トークンを生成する (storage container generate-sas)</title><link>https://maku.blog/p/n4yqdys/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n4yqdys/</guid><description>Azure ストレージの操作を行うとき、有効期限付きのアクセストークンである SAS トークン が必要になることがあります。 SAS トークンは、az storage container generate-sas コマンドで生成することができます。
実際は 1 行 $ az storage container generate-sas --name &amp;lt;BLOBコンテナー名&amp;gt; --expiry &amp;#34;2020-07-07T00:00:00Z&amp;#34; --permission acdlrw --connection-string &amp;lt;ストレージアカウントの接続文字列&amp;gt; ストレージアカウントの接続文字列さえあれば、特に Azure ログインしたりせずに生成できます。 接続文字列自体を Azure CLI で取得することもできます。
SAS トークン生成時に指定するオプションの詳細は下記のコマンドリファレンスを参照してください。
参考リンク az storage container generate-sas コマンド 実行に成功すると、次のような文字列が標準出力に出力されます。 これが SAS トークンです。
&amp;#34;se=2020-07-07T00%3A00%3A00Z&amp;amp;sp=racwdl&amp;amp;sv=2018-11-09&amp;amp;sr=c&amp;amp;sig=c7bapOBvLkHVlebBIEQFQc2bGd%2BjmfScqKCbkLUzzoo%3D&amp;#34; この SAS トークンは、AzCopy (azcopy) ツールなどで、BLOB ストレージにファイル転送したりするときに必要になります。
SAS トークンの生成には、有効期限を示す --expiry オプションの指定が必須になっています（なくてもトークンの生成には成功しますが、使用時に認証エラーになるようです。不親切）。 ここで指定する日時のフォーマットは、少しでも間違えると出力される SAS トークンの se パラメータが無効なものになってしまうので要注意です（こちらも生成時にはエラーになりません。不親切）。
生成される SAS トークンの最後には、このトークン自体の署名がついています。 これにより、SAS トークン内の有効期限 (se) などを部分的に改ざんしたりできないようになっています。</description></item><item><title>逆引き Azure CLI: BLOB ストレージにファイルをアップロードする (storage blob upload)</title><link>https://maku.blog/p/ptx36ue/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ptx36ue/</guid><description>Azure CLI を使ってストレージアカウント上に作成された、既存の BLOB コンテナにコンテンツをアップロードするには、az storage blob upload コマンドを使用します。 Azure ポータルのサイト上でポチポチやってアップロードすることもできますが、自動化のことを考えると、コマンドラインを使った方がよいでしょう。
書式 az storage blob upload --account-name &amp;lt;ストレージアカウント名&amp;gt; --account-key &amp;lt;キー&amp;gt; -c &amp;lt;コンテナ名&amp;gt; --file &amp;lt;ローカルファイル名&amp;gt; --name &amp;lt;アップロード後のファイル名&amp;gt; 実行例 $ az storage blob upload --account-name yourstorage --account-key vFjRP7s+V+j4CcwDNHyTvxT7/UXlgKN4HvFoUuIhOuzH1YLaBWgVTWQadQB2Av2aoGP2mpyQcMm4C+R55o3N9g== -c $web --file index.html --name index.html Finished[#############################################################] 100.0000% { &amp;#34;etag&amp;#34;: &amp;#34;\&amp;#34;0x8D7CA465578BC90\&amp;#34;&amp;#34;, &amp;#34;lastModified&amp;#34;: &amp;#34;2020-03-17T07:39:32+00:00&amp;#34; } アップロード時にストレージアカウントのキーを指定するので、あらかじめ az login で Azure にログインしておく必要はありません。
参考リンク 逆引き Azure CLI: ストレージアカウントのキーを確認する (storage account keys list)</description></item><item><title>TypeScriptでモジュールを作成する／インポートする (export, import)</title><link>https://maku.blog/p/fbu8k8j/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fbu8k8j/</guid><description>モジュールとは TypeScript で大きなプログラムを作成するときは、モジュールの仕組みを使って 複数のファイルに分割 していきます。 ファイルを分割することでコードを管理しやすくなるだけでなく、名前空間のコンテキストが分けられることになるので、 名前の衝突の問題も解決 することができます。
モジュールを作るのは簡単で、export キーワードを含む .ts ファイルを作ればそれがモジュールになります。 export キーワードでは、クラスやインタフェースをまるごと公開することもできるし、関数や変数の単位で公開することもできます。
export の使い方のポイントは、次のように、 クラスや変数を定義するときにプレフィックスとして付加する というところです。 基本的には、定義済みのオブジェクトを後から export するという使い方はしません。
export class &amp;hellip; export interface &amp;hellip; export const &amp;hellip; export let &amp;hellip; ここからは、具体的な export の使い方を見ていきます。
クラスやインタフェースの定義を export する 下記の lib/mylib.ts ファイルでは、MyInterface インタフェースと、MyClass クラスを公開しています。 それぞれの定義の前に export キーワードを付けるだけでよいので簡単ですね。
lib/mylib.ts export interface MyInterface { name: string; } export class MyClass implements MyInterface { constructor(public name: string) {} } 次の index.ts ファイルからは、上記のクラスモジュールを import して読み込んでいます。</description></item><item><title>Jadeの構文: タブとスペースを混ぜない</title><link>https://maku.blog/p/2sdyex5/</link><pubDate>Mon, 30 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2sdyex5/</guid><description>Jade では、インデントとしてスペースとタブのどちらでも使用できますが、テンプレートファイル (.jade) 内では、どちらか一方に統一する必要があります。 スペースとタブが混ざっていると、変換時に Invalid indentation のエラーが発生します。
エラーになる例 $ jade test.jade /usr/local/lib/node_modules/jade/lib/runtime.js:200 throw err; ^ Error: test.jade:4 2| div 3| b Maku &amp;gt; 4| b Moja 5| 6| Invalid indentation, you can use tabs or spaces but not both</description></item><item><title>gnuplot: グラフ内に矢印や直線を表示する</title><link>https://maku.blog/p/xfp42np/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xfp42np/</guid><description>矢印・直線を表示する Syntax set arrow &amp;lt;tag&amp;gt; from &amp;lt;sx&amp;gt; &amp;lt;sy&amp;gt; to &amp;lt;ex&amp;gt; &amp;lt;ey&amp;gt; [[no]head] # 2次元の場合 set arrow &amp;lt;tag&amp;gt; from &amp;lt;sx&amp;gt; &amp;lt;sy&amp;gt; &amp;lt;sz&amp;gt; to &amp;lt;ex&amp;gt; &amp;lt;ey&amp;gt; &amp;lt;ez&amp;gt; [[no]head] # 3次元の場合 nohead オプションを付けると、矢印でなく直線になります。 &amp;lt;tag&amp;gt; は他のコマンドで対象となる矢印を指定するために 1 以上の値を指定します。
※プロットの範囲の中に矢印が収まっていないと変な表示になることがあります。
例: 原点付近に十字を表示 set arrow 1 from 0, -3 to 0, 3 nohead set arrow 2 from -3, 0 to 3, 0 nohead 矢印を非表示にする Syntax set noarrow &amp;lt;tag&amp;gt; &amp;lt;tag&amp;gt; には、set arrow で設定した数値を指定します。</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数の設定いろいろ</title><link>https://maku.blog/p/pbo2dpy/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbo2dpy/</guid><description>タイムアウト時間 (Timeout) Lambda 関数のタイムアウト時間（最大実行可能時間）を設定するには、Timeout プロパティで秒単位の指定を行います。
例: タイムアウトを 15 秒にする AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Transform: AWS::Serverless-2016-10-31 Resources: MyLambda: Type: AWS::Serverless::Function Properties: Runtime: nodejs14.x CodeUri: function.zip Handler: index.handler Timeout: 15 すべての Lambda 関数の Timeout 値をまとめて設定したいときは、Globals セクションを使います。
AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Transform: AWS::Serverless-2016-10-31 Globals: Function: Runtime: nodejs14.x CodeUri: function.zip Timeout: 15 Resources: MyLambda1: Type: AWS::Serverless::Function Properties: Handler: index.handler1 MyLambda2: Type: AWS::Serverless::Function Properties: Handler: index.handler2 環境変数 (Environment) Lambda 関数の中から参照可能な環境変数を設定するには、Variables プロパティに、キーと値のペアを指定します。 すべての Lambda 関数に共通で設定する環境変数は、Globals セクションで定義します。
Globals: Function: Environment: Variables: STAGE: Production TABLE_NAME: global-table Resources: MyFunction: Type: AWS::Serverless::Function Properties: Environment: Variables: TABLE_NAME: resource-table NEW_VAR: hello トリガー設定 (Events) Lambda 関数を呼び出すためのトリガー（イベント）は、Events プロパティで定義できます。 Resouces プロパティと同様に、Events プロパティの一階層目にはイベントの論理 ID (Logical ID) を記述して、その下にそのイベントの設定を記述します。</description></item><item><title>TypeScriptのモジュールのインポートには import を使う</title><link>https://maku.blog/p/emdtiio/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/emdtiio/</guid><description>require ではなく import を使う TypeScript で型情報付きのモジュールをインポートするときは、ECMAScript 2015 の module 構文 で定義されている import を使うようにすると、VSCode などで型情報を使った補完がうまく効くようにになります。
これを使う // Good import * as mod from &amp;#39;mod&amp;#39;; 下記のように、Node.js で一般的に使用されていた CommonJS 形式の require を使ってもインポートできますが、any 型の変数を定義していることになるため、型情報を用いた補完が効きません。
これは使わない // NG const mod = require(&amp;#39;mod&amp;#39;); TypeScript でモジュールをインポートするときには、できるだけ import を使う ようにしましょう。
インポートの例（関数ベースのモジュール） Node.js のコアモジュール（os や path など）は、もともと TypeScript 用に作成されたものではありませんが、TypeScript 用の型情報が @types/node モジュールとして提供されています。
Node.js コアモジュールの型情報をインストール $ npm install --save-dev @types/node これで、Node.js のコアモジュールを下記のように型情報付きでインポートできるようになります。 これは、複数の関数を export する TypeScript モジュールをインポートする方法のよい例です。
よい例: 型として認識される import * as path from &amp;#39;path&amp;#39;; // 全ての関数をインポート import { join } from &amp;#39;path&amp;#39;; // 個別の関数をインポート これで、VSCode などの IDE で次のように補完が聞くようになります。</description></item><item><title>Jadeの構文: クラス属性と ID 属性を設定する</title><link>https://maku.blog/p/n6cwnk7/</link><pubDate>Mon, 30 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n6cwnk7/</guid><description>Jade のテンプレートファイルでは、CSS セレクタと同じ表現で、HTML タグのクラス属性、ID 属性を指定することができます。
p.class1 AAA #=&amp;gt; &amp;lt;p class=&amp;#34;class1&amp;#34;&amp;gt;AAA&amp;lt;/p&amp;gt; span#id1 BBB #=&amp;gt; &amp;lt;span id=&amp;#34;id1&amp;#34;&amp;gt;BBB&amp;lt;/span&amp;gt; もちろんクラス属性値は、複数指定可能です。
p.class1.class2.class3 AAA #=&amp;gt; &amp;lt;p class=&amp;#34;class1 class2 class3&amp;#34;&amp;gt;AAA&amp;lt;/p&amp;gt; クラス属性、ID 属性を指定するときに、タグ名を省略すると、デフォルトで div タグとみなされます。
.class1 AAA #=&amp;gt; &amp;lt;div class=&amp;#34;class1&amp;#34;&amp;gt;AAA&amp;lt;/div&amp;gt; #id1 BBB #=&amp;gt; &amp;lt;div id=&amp;#34;id1&amp;#34;&amp;gt;BBB&amp;lt;/div&amp;gt; クラス属性と ID 属性は、どちらを先に指定しても構いません。
.class1#id1.class2 #=&amp;gt; &amp;lt;div id=&amp;#34;id1&amp;#34; class=&amp;#34;class1 class2&amp;#34;&amp;gt;AAA&amp;lt;/div&amp;gt;</description></item><item><title>gnuplot: グラフ内にコメントを表示する</title><link>https://maku.blog/p/adxysxf/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/adxysxf/</guid><description>コメントを表示する Syntax set label tag &amp;#39;text&amp;#39; at [coordinate] x, [coordinate] y [justification] tag にはコメントを識別するための 1 以上の整数を指定します。
オプショナルパラメータの coordinate には、どのような座標系でコメント位置を指定するかを設定できます。
first (default) &amp;ndash; x、y 軸の座標系 second &amp;ndash; x2、y2 軸の座標系 graph &amp;ndash; グラフの左下を (0, 0)、右上を (1, 1) とする座標系 screen &amp;ndash; 表示全体の左下 (0, 0)、右上を (1, 1) とする座標系 justification パラメータでは、指定した座標のどちら側にコメントを表示するかを設定できます。
left (default) &amp;ndash; 指定した座標の左側 right &amp;ndash; 指定した座標の右側 center &amp;ndash; 指定した座標の中央 例 set label 1 &amp;#34;Label 1&amp;#34; at 5, 4 set label 2 &amp;#34;Label 2&amp;#34; at 10, 7</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数から S3 にアクセスできるようにする</title><link>https://maku.blog/p/dzdq3ep/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dzdq3ep/</guid><description>CloudFormation (SAM) を利用して、Lambda 関数および S3 バケットを作成し、Lambda 関数から S3 バケットにアクセスできるようにポリシー設定するテンプレートの例です。 参考までに Lambda 関数の TypeScript コードも載せましたが、あくまで SAM テンプレートの記述例を示すことを目的としています。
SAM テンプレートの記述例 次の SAM テンプレートでは、AWS リソースとして S3 バケット (MyBucket) と Lambda 関数 (MyFunction) を定義しています。
template.yml AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Transform: AWS::Serverless-2016-10-31 Resources: # S3 バケットの定義 MyBucket: Type: AWS::S3::Bucket # Lambda 関数の定義 MyFunction: Type: AWS::Serverless::Function Properties: Runtime: nodejs14.x Handler: build/index.handler CodeUri: function.zip Policies: - S3CrudPolicy: BucketName: !Ref MyBucket Environment: Variables: BUCKET_NAME: !Ref MyBucket S3 バケットは単純にスタック内に新規作成するだけなので、何もプロパティ設定していません。 ポイントは、Lambda 関数側のポリシー設定（Policies プロパティ）です。</description></item><item><title>Jadeの構文: ブロック展開 (block expansion) によってネストを減らす</title><link>https://maku.blog/p/ef8i8dx/</link><pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ef8i8dx/</guid><description>Jade の ブロック展開 (block expansion) を使うと、改行とインデントによるネストを一行で表現できます。 例えば、
div.box div.prompt Hello というネストされた構文は、下記のように一行で記述することができます。
div.box: div.prompt Hello ただし、以下のように、上位の要素にテキストノードが存在する場合は、ブロック展開を使った記述は行えません。
div.box Hello div.prompt World 間違い div.box Hello: div.prompt World</description></item><item><title>gnuplot: アスキーアートでグラフを出力する (dumb 端末)</title><link>https://maku.blog/p/538wdr7/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/538wdr7/</guid><description>Syntax set term(inal) dumb [feed &amp;lt;x幅&amp;gt; &amp;lt;y幅&amp;gt;] set terminal で dumb 端末を指定すると、グラフをアスキーアートで出力できます。 テキストベースのメールやチャットでグラフを送る場合に便利です。
例: -10 log(x) gnuplot&amp;gt; set term dumb gnuplot&amp;gt; plot [0:] -10*log(x) 15 ++-----------+------------+-----------+------------+-----------++ + + + + -10*log(x) ****** + 10 ++* ++ | * | 5 ++ * ++ | *** | 0 ++ ** ++ | ** | -5 ++ ** ++ | ** | -10 ++ ***** ++ | ****** | -15 ++ ******* ++ | ********* | -20 ++ ************* ++ + + + + + ********** -25 ++-----------+------------+-----------+------------+-----------++ 0 2 4 6 8 10 グラフの形だけを示したい場合は、目盛りを消したほうが見た目がきれいになります。</description></item><item><title>Jadeの構文: テキストブロックでテキストノードを生成する</title><link>https://maku.blog/p/wwao94j/</link><pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wwao94j/</guid><description>Jade のテンプレートファイルでは、次のように要素名の後ろに続けてテキストを記述することで、要素内にテキストノードを作成 することができます。
p Hello World テキストの内容が長くなり、複数行に分けて記述したいときは、バー記法 (bar notation) やドット記法 (dot notation) を使用した「テキストブロック」 を作成します。
バー記法によるテキストブロックの例 p | long long long long long | long long long long long | long long long description. ドット記法によるテキストブロックの例 p. long long long long long long long long long long long long long description. ドットは、必ずタグ名の直後にスペースを入れずに記述 してください。 スペースを入れると、ドットがテキスト内容として認識されてしまいます。
出力 &amp;lt;p&amp;gt;long long long long long long long long long long long long long description.&amp;lt;/p&amp;gt; これらの記法は、ソースコードなど、改行やインデントが重要なテキストを pre 要素として出力する際に便利です。</description></item><item><title>gnuplot: サンプル数を上げて強引に塗りつぶす（積分領域の表示）</title><link>https://maku.blog/p/fyjpvb2/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fyjpvb2/</guid><description> 強引な塗りつぶし表示 set samples 1000 plot [-pi:pi] sin(x) with impulse （追記: 2013-05-02）最近の gnuplot だと、こんな強引なことしなくても、plot するときに with filledcurve の指定をするだけで、塗りつぶし表示ができるみたいです。 しかも、凡例の表示もそれっぽく代わってくれます。
参考 http://gnuplot.sourceforge.net/demo_cvs/fillcrvs.html http://gnuplot.sourceforge.net/demo_cvs/transparent.html</description></item><item><title>Jadeの構文: CSS や JavaScript を使用する</title><link>https://maku.blog/p/d8cx8a3/</link><pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d8cx8a3/</guid><description>Jade テンプレート内に、直接 CSS や JavaScript のコードを記述するときは、ドット記法によるテキストブロック内に記述します。
test.jade style. body { color: #111; background: #ccc; } script. var message = &amp;#39;Hello&amp;#39;; alert(message); 実行結果 $ jade --pretty &amp;lt; test.jade &amp;lt;style&amp;gt; body { color: #111; background: #ccc; } &amp;lt;/style&amp;gt; &amp;lt;script&amp;gt; var message = &amp;#39;Hello&amp;#39;; alert(message); &amp;lt;/script&amp;gt; link タグや script タグによって、外部の CSS や JavaScript コードをロードするには、以下のようにします。
test.jade doctype html html head meta(charset=&amp;#39;UTF-8&amp;#39;) link(rel=&amp;#39;stylesheet&amp;#39;, href=&amp;#39;main.css&amp;#39;) title Hello script(src=&amp;#39;jquery.js&amp;#39;) script(src=&amp;#39;main.js&amp;#39;) body p Hello 実行結果 $ jade --pretty &amp;lt; test.</description></item><item><title>gnuplot: 場合分けをして不連続関数を描画する</title><link>https://maku.blog/p/tbxfo2c/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tbxfo2c/</guid><description>次のようにすると、x の範囲によって値を不連続に変化させることができます。
f(x) = (x &amp;gt; 0) ? 1 : -1 set samples 10000 plot f(x) 上のように連続した関数じゃない場合は、サンプル数が少ないと x=0 の場所の縦線が斜めになってしまうようです。
（追記: 2013-05-03）plot するときに、plot f(x) with steps とすれば、少なくとも線が斜めになってしまうのは防げるようです。 ただ、samples の数は増やしておかないと、x=0 の位置より少しずれた場所で y の値が変化してしまうので、やっぱり set samples は必要です。</description></item><item><title>TypeScriptで名前空間を定義する (namespace)</title><link>https://maku.blog/p/a3eh9w2/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a3eh9w2/</guid><description>namespace ではなくモジュールの仕組みを使うべし TypeScript では、namespace キーワードを使って名前空間を定義することができますが、通常はより柔軟性の高い モジュールの仕組み を使うようにしてください（といっても .ts ファイルを分けるだけですが）。
namespace を使うと、同じファイル内で階層化された名前空間を作ることができますが、あくまでその階層構造はグローバルに共有されています。 一方、モジュールの仕組みを使うと、ファイル単位で名前空間のコンテキストを分けることができます。 大きなプロジェクトであっても、適切な単位でモジュール（ファイル）を分割している限り、名前の衝突は本質的には発生しません。
とはいえ、これは namespace の記事なので、ここからは namespace の使い方の説明をします。
namespace による名前空間の定義 namespace による名前空間の定義は簡単で、namespace Xxx { ... } というブロックで囲むだけです。 次の例では、First と Second という名前空間を作成し、それぞれに同じ名前の Person というクラスを定義しています。
namespace First { export class Person { greet() { console.log(&amp;#39;First.Person&amp;#39;); } } } namespace Second { export class Person { greet() { console.log(&amp;#39;Second.Person&amp;#39;); } } } const p1 = new First.Person(); const p2 = new Second.Person(); p1.greet(); //=&amp;gt; First.</description></item><item><title>チャットボット (1-1) Bot Builder SDK とは</title><link>https://maku.blog/p/tzaeb9x/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tzaeb9x/</guid><description>Microsoft の Azure は Chatbot サービスを作成する機能を提供しています。 Microsoft が提供している Bot Framework は、この Chatbot サービスを作成するとき、あるいは Chatbot を使用するクライアントを作成するときに使用するツール群（あるいは仕組み）やそれらを取り巻く環境の総称です。
Microsoft Bot Framework ボットのサーバを実装するためのライブラリは、Bot Builder SDK という名前で提供されています。 現状では、ボットは Node.js と .NET による開発が想定されているため、Bot Builder SDK も Node.js と .NET 用のものが提供されています（2019年3月現在、Python と Java 版が preview リリースされているようです）。
Bot Builder SDK (for Node.js) Bot Builder SDK (for .Net) Bot Builder サンプルコード集 Node.js と .NET のどちらを使って開発するかに迷ったら、非同期処理を前提にして設計されている Node.js 版を選択するのがよいでしょう。
Node.js の Bot Builder SDK は、NPM パッケージとして公開されているため、npm コマンドを使って簡単にインストールすることができます。
$ mkdir mybot $ cd mybot $ npm init -y $ npm install --save botbuilder@4.</description></item><item><title>チャットボット (1-2) Bot Builder SDK で Echo ボットを作成する</title><link>https://maku.blog/p/you6q5r/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/you6q5r/</guid><description>ここでは、Microsoft の Bot Builder SDK を使ったボット作成のファーストステップとして、チャットクライアントから入力されたテキストをそのままオウム返しするだけの Echo ボットを作成します。 言語としては JavaScript (Node.js) を使用することにします。
ここで作成するのはボットの本体（サービス側）で、クライアントとしては Microsoft が提供している Bot Framework Emulator を使用します。
Bot Builder SDK をインストールする Node.js 版の Bot Builder SDK（botbuilder パッケージ）は、npm コマンドを使ってインストールすることができます。 パッケージの依存関係を管理するための package.json ファイルも、npm init コマンドで作成しておきます。
$ mkdir mybot $ cd mybot $ npm init -y $ npm install --save botbuilder@4.x Bot Service のインタフェースは REST API として提供することが定められているのですが、Bot Builder SDK には REST API サーバを作成する機能は含まれていません。 そこで、REST API サーバを作成するための restify パッケージも一緒にインストールしておきます（express などでも実装できると思いますが、リファレンス実装では restify が使用されています）。</description></item><item><title>チャットボット (2-1) Azure でボットをホストするための Web App Bot リソースを作成する</title><link>https://maku.blog/p/tttou4o/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tttou4o/</guid><description>Web App Bot リソースを作成する 作成したボットプログラムは、Azure 上の Web App Bot リソース上で動作させることができます。 このリソースのことを特にボットサービスと呼んだりします。
Azure ポータル にログインし、下記のように辿ることで Web App Bot リソースの作成画面を表示できます。
＋リソースの作成 AI + Machine Learning Web App Bot 下記のような Web App Bot リソースの設定画面が表示されるので、1 つずつ入力していきます。
ボット名 任意のボット名称。後から自由に変更することができるので、自分のわかりやすい名前を付けておけば OK です。例: maku-bot サブスクリプション 月額の請求先となるサブスクリプションを選択します。最初の Azure トライアル期間であれば、Free Trial などを選択できるはずです。 リソースグループ この Web App Bot リソースを所属させるリソースグループを選択します。存在しない場合は 新規作成 のリンクをクリックして新しく作成します。 場所 リソースグループの場所を選択。ここでは、地理的に近い Japan East を選択してます。 価格レベル チャンネルに応じたメッセージ制限解除のためのプラン設定です。 スタンダードチャンネル（Skype、Cortana、Teams、Facebook、Slack などの一般的なクライアント）とのやりとりは無制限なので、通常は F0 の無料プランを選択しておけば OK です。 一方で、プレミアムチャンネル（ユーザ独自のチャンネルや、Web ページ埋め込みチャットボットなど）と多くのメッセージをやりとりする予定がある場合は、有料の S1 プランを選択する必要があります。 無料の F0 だと 1 か月に 10,000 メッセージまでの制限があります。 （参考: Standard channels と Premium channels について） アプリ名 ボットサービスのエンドポイント URL となる XXX.</description></item><item><title>チャットボット (2-2) Web App Bot で生成されたボットのコードを編集する</title><link>https://maku.blog/p/bpqkm2o/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bpqkm2o/</guid><description>チャットボットのソースコードをダウンロードする 下記のページの手順に従い、Azure ポータル上で Web App Bot のリソースを作成すると、自動的に Echo Bot のテンプレートコードが生成されているはずです（選択したテンプレートの種類によって変わりますが、ここでは Node.js 版の Echo Bot テンプレートを指定しているとします）。
Azure でボットをホストするための Web App Bot リソースを作成する ボットプログラムを作成する場合は、基本的にはこのテンプレートコードをベースにして修正を行っていくのがよいでしょう。 自動生成されたコードは、Azure ポータルから下記のように辿ると ZIP アーカイブでダウロードすることができます。
すべてのリソース を選択 対象の Web アプリボット リソースを選択（下記の例では maku-bot） ボット管理 の ビルド を選択 ボットのソースコードをダウンロードする のボタンをクリック 図: ボットコードをダウンロード bot ファイルの復号化・暗号化 botFileSecret とは ダウンロードした ZIP アーカイブの中には、ボットサーバの設定ファイルである .bot ファイルが含まれています。
このファイルは、ローカルでボットサーバを立ち上げたり、エミュレータからそのサーバに接続するときの設定ファイルとして使用するのですが、自動生成された .bot ファイルは、接続情報などの値が暗号化されています。 .bot ファイルの復号化、および暗号化に使用されているキーのことを botFileSecret と呼びます。
ボットサーバやエミュレータを正しく起動するためには、この botFileSecret を使って .bot ファイルをあらかじめ復号化しておくか、環境変数などでキーを設定しておく必要があります。
.bot ファイルを復号化した場合は、Azure 上の Web App Bot サービスにデプロイする前に、忘れずに暗号化しておく必要があります。
botFileSecret の取得 初期の暗号化に使用されている botFileSecret は、Azure ポータルから下記のように辿ることで参照することができます。</description></item><item><title>チャットボット (2-3) Azure の Web App Bot リソースにボットをデプロイする</title><link>https://maku.blog/p/gxm9shf/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gxm9shf/</guid><description>まず前提として、下記の手順により、Azure 上に Web App Bot リソースが作成済みであることとします。 ここに、ローカルで作成したボットをデプロイすることになります。
Azure でボットをホストするための Web App Bot リソースを作成する Web ブラウザでデプロイする方法（KUDU の Zip Deploy UI） プロジェクトのファイルを ZIP ファイルとしてアーカイブし、Zip Deploy UI という Web ページにドラッグ＆ドロップでデプロイする方法です。 この Web サイトには、下記のような URL でアクセスできます。 &amp;lt;app_name&amp;gt; の部分は、自分のボットアプリ名に置き換えてください。
https://&amp;lt;app_name&amp;gt;.scm.azurewebsites.net/ZipDeployUI 図: Web App Bot の Zip Deploy UI 左上に表示されるロゴからも分かるように、Azure の Web App サービスでは、Kudu というデプロイエンジンが使われているようですね。
この /wwwroot ディレクトリの内容が表示されている画面で、エクスプローラ領域に ZIP ファイルをドラッグ＆ドロップすると、ZIP ファイル内のファイルがまとめて /wwwroot にアップロードされます。
図: ZIP ファイルのドラッグ＆ドロップでデプロイ ボットプログラムのエントリポイントとなる bot.js ファイルを編集してから ZIP 化し、デプロイすることで、ボットの動作が変わることを確認できると思います。
ZIP アーカイブ作成時の注意 ZIP ファイルの中身が展開された状態でデプロイされるので、ZIP の展開後に余計なディレクトリ階層ができないように ZIP アーカイブを作成してください。 具体的には、プロジェクトのディレクトリを ZIP 化するのではなく、プロジェクトのディレクトリ内のファイル群を ZIP 化します。 コマンドラインから ZIP アーカイブを作成するには、プロジェクトのルートディレクトリから下記のようにします。</description></item><item><title>チャットボット: Azure ポータルで生成されるボットのテンプレートコードを解読＆リファクタしてみる</title><link>https://maku.blog/p/iob68qa/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iob68qa/</guid><description>Azure が生成するテンプレートコードを理解する 下記の手順に従って Azure ポータル上で Web App Bot リソースを作成すると、ボットプログラムのテンプレートとして index.js や bot.js などのコードが自動生成されます。
Azure でボットをホストするための Web App Bot リソースを作成する ボットサーバのエントリポイントとなる index.js には、設定情報の読み取りと Web サーバの立ち上げ処理が記述されており、bot.js の方にはボットの応答処理を記述するようになっています。
つまり、基本的にボットの作成者は bot.js の方にボットのコア部分を実装していけばよいのですが、LUIS や QnA Maker などのサービスと連携する場合は、それぞれの初期化処理が必要であり、結局のところ index.js 側の実装に関してもある程度理解しておく必要があります。
Azure ポータルで自動生成される index.js は決して理解しやすいものではないので（少なくとも記述時点では）、ここでは index.js の内容を理解する目的と、わかりやすくリファクタする目的を兼ねて、ボットのベースとなるコードを作成していきます。
最終的には Azure が生成するテンプレートコードと同様の振る舞いになることを想定しています（少なくとも、環境変数の名前などは合わせておいた方がよいです）。
全体の流れ ボットプログラムのエントリポイントとなる index.js では、大まかに下記のような処理を行います。
.env ファイルを読み込み、環境変数の情報とマージする 1 の情報を基に、.bot ファイルを読み込む 2 の情報を基に、ボットサーバーを立ち上げる Azure ポータルで生成されるテンプレートコードでは、上記の処理をすべて index.js の中で行っているのですが、ここでは設定の読み込み部分と、ボットサーバの立ち上げ部分を明確に分離してみます。
config.js: 環境変数や .env ファイルの情報を基に、.bot ファイルの設定を読み込む。 index.js: 上記の設定情報を基にボットサーバを立ち上げる。 という感じにします。
ステップ(1) 環境変数あるいは .env ファイルの読み込み (config.</description></item><item><title>チャットボット: MS Bot Framework の .bot ファイルで接続情報を管理する</title><link>https://maku.blog/p/8choj4w/</link><pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8choj4w/</guid><description>エミュレータのための .bot ファイル Bot Framework Emulator は、自分自身（チャットクライアント）が接続するボットサーバのアドレスを .bot ファイルから取得します。
.bot ファイルの中には、&amp;quot;type&amp;quot;: &amp;quot;endpoint&amp;quot; というエンドポイント定義が 1 つ以上記述されており、ここにはボットプログラムのアドレスが記述されています。 エミュレータの設定で、どのエンドポイント設定を使用するかを切り替えることで、実際に接続するボットを使い分けることができます。 典型的には、開発時にローカルホスト上で動作させたボットサーバに接続するための development と、実稼働用に Azure 上で動作させたボットサーバに接続するための production というエンドポイントを定義します。
図: エミュレータ上でのエンドポイント切り替え ボットプログラムのための .bot ファイル .bot ファイルは、ボットプログラムからも利用されます（こちらの方がメイン）。
.bot ファイルには、LUIS や QnA Maker のサービスを利用するためのエンドポイント情報（アドレスやエンドポイントキー）が定義されており、ボットプログラムはこれらの情報を使って各サービスの API を利用します。 こららの情報は、ボット自体がローカルホスト上で動作していても、Azure 上で動作していても同様に利用されます。
また、ここでもボット自体の endpoint エントリが参照され、各種チャンネル（チャットクライアント）がボットにアクセスするときの認証処理のために使用されます。 このあたりの処理は、Bot Builder SDK を使ってボット実装を行っていれば、Adapter クラスとして抽象化されるため、特に意識せずに実装することができます。
.bot ファイルに LUIS や QnA Maker の接続設定を記述する .bot ファイルは XML ファイルなので、フォーマットさえ理解すればテキストエディタなどで編集してしまうことはできますが、エンドポイントキー部分の復号化・暗号化が必要だったりして面倒です。 Bot Framework Emulator には、.bot ファイルの内容を GUI で編集する機能が付いているのでこの機能を使うのがよいでしょう。
LUIS/QnA Maker サービスへの接続情報を設定する .bot ファイルをダブルクリックしてエミュレータを起動したら、左上の SERVICES の ＋ ボタンを押すことで各サービスの接続設定を行うことができます。</description></item><item><title>チャットボット: LUIS や QnA Maker サービスへの接続情報を .bot ファイルから取得する</title><link>https://maku.blog/p/o2bqajv/</link><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2bqajv/</guid><description>参考: MS Bot Framework の .bot ファイルで接続情報を管理する ここで作るもの こちらの実装 では、最初のステップとしてボットサーバ自体 (Azure Web Apps) のエンドポイント情報を .bot ファイルから取得する実装を行いました (config.js)。 ここでは、さらに、LUIS サービスや QnA Maker サービスを利用することを想定し、これらの情報も .bot ファイルから取得できるように拡張します。
使用イメージとしては、下記のようにしてそれぞれの接続情報を簡単に読み込めるようにします。
const config = require(&amp;#39;./config.js&amp;#39;); const LUIS_APP_NAME = &amp;#39;maku-luis-sample&amp;#39;; const QNA_APP_NAME = &amp;#39;maku-qna-sample&amp;#39;; const botEndpoint = config.loadBotEndpoint(); // ボット自体への接続情報 const luisEndpoint = config.loadLuisEndpoint(LUIS_APP_NAME); // LUIS への接続情報 const qnaEndpoint = config.loadQnaEndpoint(QNA_APP_NAME); // QnA Maker への接続情報 単一のオブジェクトとしてまとめて取得するように実装することもできるのですが、分かりやすさのために、3 つの情報に分けて取得するようにしています。 LUIS や QnA Maker は、複数のアプリ（ナレッジベース）を同時に使用する可能性があるので、アプリ名を指定して接続情報を取得できるようにしています。
取得した情報は、次のように BotBuilder SDK が提供するクラスへの入力として使用することを想定しています。</description></item><item><title>チャットボット: 作成したチャットボットを LINE に接続する</title><link>https://maku.blog/p/asuzg7k/</link><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/asuzg7k/</guid><description>LINE に Messaging API チャネルを作成する 自作したチャットボットアプリを LINE から「友だち」として見えるようにするには、まず LINE 側に「プロバイダー」を作成し、そこに「Messaging API チャネル」を追加する必要があります。 この Messaging API チャネルは、LINE アプリから「友だち」として見える単位だと考えればよいでしょう。
LINE に開発者として登録する LINE のプロバイダー登録作業などは、下記の LINE Developer Console から行うことができます。 初めてアクセスする場合は、開発者としての登録を求められるので、LINE アカウントでログインして開発者情報を入力してください。
LINE Developer Console プロバイダーを新規作成する LINE に開発者登録できたら、新規プロバイダー作成 のボタンを押して、プロバイダーを作成します。
Messaging API チャネルを追加する プロバイダーの作成が終わったら、そこに Messaging API チャネル を追加します。
チャネルの作成時には、アプリアイコンやアプリ名を自由に登録することができます。 アプリ名は一度設定すると 7 日間は変更できないようなので慎重に決めましょう（アイコンは 1 時間経てば変更できます）。
下のように、プロバイダー上に Messaging API チャネルが追加されていれば OK です。
スマホの LINE に友達登録する Messaging API のチャネルを選択し、チャネル基本設定 タブを見ると、LINE アプリ用の QR コードが見つかります。
この QR コードを LINE アプリのカメラで読み取ることで、チャットボットを友達追加することができます。
ただ、まだボットアプリ本体（自分で作成したボット実装）には接続していないので、話しかけても何も返答してくれません。 下記のようなテンプレートメッセージだけが表示されます。</description></item><item><title>チャットボット: 作成したチャットボットを Slack に接続する</title><link>https://maku.blog/p/rtxqceq/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rtxqceq/</guid><description>Slack に Bot Framework で作成したボットを接続する 図: ボットとのダイレクトメッセージによる会話 Microsoft Azure 上に作成したボットアプリを Slack に接続するには、下記の Bot Service 公式ドキュメントで説明されている手順に従ってください。
（日本語）ボットを Slack に接続する - Bot Service ｜ Microsoft Docs （英語）Connect a bot to Slack - Bot Service ｜ Microsoft Docs 接続のおおまかな手順は下記のような感じです。
Slack アプリを作成する（何らかのワークスペースに所属させる形で作成する） Slack アプリにボット用のユーザーを登録する Azure ポータルから、Web アプリボットのチャンネルとして Slack を追加（Slack アプリ側の Client ID、Client Secret、Verification Token をコピペすれば OK） この作業が終わると、ボット（アプリ）が Slack のワークスペースに参加している状態になります。 その時点ではどのチャンネルにも参加していませんが、ダイレクトメッセージを使って一対一でボットと会話することができます。
特定のチャンネルで会話している最中に @ボット名 と話かけると、そのチャンネルにボットを招待することができます。 チャンネルにボットが参加すると、後はそのチャンネルに対してつぶやくだけでボットが反応するようになります。
わかりにくいところの補足 図入りで説明されているので、特に迷うことはないと思いますが、Microsoft の Bot チームのドキュメント通りにはうまくいかない部分があるので若干補足しておきます。
ボットハンドル 「ボットのイベントをサブスクライブ」するという項目で、下記のような Request URL でボットハンドル (YourBotHandle) を指定するところがあります。</description></item><item><title>チャットボット: Chatdown（.chat ファイル）を使ってボットの会話をデザインする</title><link>https://maku.blog/p/a6yzskr/</link><pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a6yzskr/</guid><description>Chatdown フォーマットとは Chatdown フォーマットは、会話の設計をテキストベースで行うことを意図したフォーマットです。 拡張子は .chat で、下記のような感じで会話例を記述していきます。
sample.chat user=Joe bot=LulaBot bot: Hi! user: yo! bot: [Typing][Delay=3000] Greetings! What would you like to do? * update - You can update your account * List - You can list your data * help - you can get help user: I need the bot framework logo. 上記のように、チャットボットがタイプ中であることや、応答までのディレイなどもデザインすることができます。 Markdown 形式で書式設定できるようになっているのが Chatdown という名前の由来ですね。
Bot Framework Emulator で会話を再現する Bot Framework Emulator で会話ファイルを読み込むと、チャット UI 上で会話を再現することができます。 ただし、Emulator が読み込むことのできるファイルは .</description></item><item><title>チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する</title><link>https://maku.blog/p/mgujykj/</link><pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mgujykj/</guid><description>Bot Builder SDK (Node.js) の botbuilder-core パッケージには、ActivityHandler という、ボットのイベントハンドラ部分の実装を簡略化するためのライブラリが含まれています。 ボットの世界では、「Activity」はひとつのメッセージの処理単位のことを示しています。 この Activity をうまくハンドルするためのクラスだから ActivityHandler という名前が付けられているんですね。
ここでは、独自のボットクラス (MyBot) を、ActivityHandler を利用せずに実装した場合と、利用して実装した場合で比較してみたいと思います。
ActivityHandler を使わない場合 例えば、下記のように BotFrameworkAdapter で受信したイベントの処理を MyBot.onTurn() に委譲するとします。
mybot.js const myBot = new MyBot(); const adapter = new BotFrameworkAdapter({}); const server = require(&amp;#39;restify&amp;#39;).createServer(); server.post(&amp;#39;/api/messages&amp;#39;, (req, res) =&amp;gt; { adapter.processActivity(req, res, async (context) =&amp;gt; { await myBot.onTurn(context); // あとは MyBot に丸投げ }); }); このイベントは、ユーザからメッセージを送られたときだけでなく、ユーザがチャットに参加したとき (ConversationUpdate) などにも発生するため、MyBot.onTurn() の実装の中でアクティビティタイプを見て分岐処理を行わなければなりません。
class MyBot { constructor() { // ... } async onTurn(context) { if (context.</description></item><item><title>チャットボット: ユーザーの参加／離脱のイベントをハンドルする</title><link>https://maku.blog/p/onctywi/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/onctywi/</guid><description>Bot Builder SDK の ActivityHandler を使って、ユーザーが会話に参加したこと、離脱したことをハンドルする方法を説明します。 ActivityHandler を使ったボット実装の基本に関しては下記を参照してください。
チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する 下記は、ユーザーが新しく会話に参加したときに、ボットから挨拶するように実装した例です。 ユーザー参加のイベントをハンドルするには、ActivityHandler#onMembersAdded() で、イベントハンドラを登録します。
mybot.js const { ActivityHandler, BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); // ボット実装 class MyBot extends ActivityHandler { constructor() { super(); this.onMessage(this.handleMessage); this.onMembersAdded(this.handleMembersAdded); } async handleMessage(context, next) { const name = context.activity.from.name; const utterance = context.activity.text; await context.sendActivity(`${name}さんは、${utterance}と言いました。`); await next(); } async handleMembersAdded(context, next) { const members = context.activity.membersAdded; for (let i = 0; i &amp;lt; members.length; ++i) { const m = members[i]; if (m.</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (Storage)</title><link>https://maku.blog/p/3fnyk44/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3fnyk44/</guid><description>ボットは基本的にステートレスで動作するので、ユーザとの会話のコンテキストを把握するには、ステートの管理を明示的に行う必要があります。 Bot Builder SDK にはそのためのユーティリティクラスが用意されています。 ここでは、Node.js の botbuilder パッケージを使って説明します。
Storage インタフェース botbuilder パッケージに含まれている Storage インタフェースは、抽象化されたストレージに JSON オブジェクトを保存するための API を定義しています。 write、read、delete の 3 つの API のみなのでとてもシンプルです。
write メソッド JSON オブジェクトをストレージに保存するための API です。 オブジェクトを保存するときには、名前（キー）を付けて、キー＆バリューの形のオブジェクトとして保存します。 下記の例では、保存したい state オブジェクトに、botState という名前を付けて保存しています。
state.topic = &amp;#39;someTopic&amp;#39;; await storage.write({ &amp;#39;botState&amp;#39;: state }); read メソッド ストレージに保存されたオブジェクトを読み出すための API です。 読み出したいオブジェクトの名前を配列で渡すと、オブジェクトの連想配列が返ってきます。 下記の例では、botState という名前で保存されたオブジェクトを、state 変数に取り出しています。
const items = await storage.read([&amp;#39;botState&amp;#39;]); const state = items[&amp;#39;botState&amp;#39;] || {}; delete メソッド ストレージに保存されたオブジェクトを削除するための API です。 削除したいオブジェクトの名前を配列で渡します。</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (BotState)</title><link>https://maku.blog/p/6wtzzq4/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6wtzzq4/</guid><description>BotState クラス Bot Builder SDK の BotState クラス は、ボットとの会話内の特定のコンテキストにおける状態を保持するためのクラスです。
というと難しいですが、簡単に言うと、会話ごとの状態保存や、ユーザーごとの状態保存を行うための便利クラスです。
BotState クラスには次のようなサブクラスが定義されています。
ConversationState クラス &amp;hellip; 会話ごとの状態を保存する UserState クラス &amp;hellip; ユーザーごとの状態を保存する PrivateConversationState クラス &amp;hellip; 会話ごとのユーザごとの状態を保存する これらのクラスは、内部で Storage オブジェクトを利用します。
≪生成コード&amp;#x1F4D6;≫ Storage がグローバルに状態保存を行っていたのに対し、BotState はネームスペースを考慮して状態保存を行うものだと考えることができます。 実際に、ConversationState クラスや UserState クラスの実装を覗いてみると、getStorageKey() というメソッドでストレージ用の保存キーを作成しており、それぞれ次のように構成しています。
ConversationState が使用する保存キー ${ channelId }/conversations/${ conversationId }/${ this.namespace } UserState が使用する保存キー ${ channelId }/users/${ userId }/${ this.namespace } PrivateConversationState が使用するキー ${ channelId }/conversations/${ conversationId }/users/${ userId }/${ this.namespace } 実用的なボットの状態管理を行うには、Storage インタフェースをそのまま使うのではなく、ConversationState / UserState / PrivateConversationState などを使うことになるでしょう。</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (1) ダイアログの基本</title><link>https://maku.blog/p/w36evii/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w36evii/</guid><description>Dialog を使わない会話管理 Bot Builder SDK の UserState や ConversationState を使う と、ユーザーや会話ごとの状態管理を行うことできるため、複数回のやりとりが必要な会話を実現することができます。
例えば、下記のような会話ができるボットを実装してみます。
User: こんにちは Bot: あなたの名前は？ User: まく Bot: こんにちは まく さん User: おやすみなさい Bot: また来てね まく さん 次のボット実装は、UserState クラスを使って、pos という名前のプロパティを作成し、会話がどこまで進んでいるかを管理しています。
mybot.js const { ActivityHandler, UserState } = require(&amp;#39;botbuilder&amp;#39;); class MyBot extends ActivityHandler { constructor(storage) { super(); this._createStateObjects(storage); this.onMessage(async (context, next) =&amp;gt; { const prop = await this.nameProp.get(context, { pos: &amp;#39;init&amp;#39; }); // プロパティの &amp;#39;pos&amp;#39; により処理を分岐させる if (prop.pos === &amp;#39;init&amp;#39;) { prop.</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (2) スタック管理</title><link>https://maku.blog/p/6arjar6/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6arjar6/</guid><description>ダイアログの基本 で説明したように、Dialog クラスを使用した会話フローでは、ユーザーからメッセージを受け取るたびに DialogContext#continueDialog() を呼び出すことで、1 ステップずつ処理を進めていきます。 ダイアログには、スタック構造で会話を管理する仕組みがあり、次のようなメソッドを使って、ダイアログの起動（スタックに積む）、ダイアログの終了（スタックから降ろす）という操作を行うことが可能です。
DialogContext#beginDialog(&amp;quot;ID&amp;quot;) &amp;hellip; ダイアログを開始する（スタックに積む） DialogContext#endDialog() &amp;hellip; アクティブなダイアログを終了する（スタックから降ろす） DialogContext#replaceDialog(&amp;quot;ID&amp;quot;) &amp;hellip; アクティブなダイアログを別のダイアログに置き換える（スタックの一番上を入れ替え） DialogContext#cancelAllDialog() &amp;hellip; すべてのダイアログを終了する（スタックをクリア） ここでは、RootDialog と GreetDialog という名前の 2 つのダイアログクラス作成し、RootDialog から GreetDialog を起動してダイアログのスタックを積むような実装を行ってみます。
図: ダイアログ遷移のイメージ 下記は、実際のチャットクライアントの表示例です。 右側のバーで示すように、 最初に RootDialog による選択肢が表示され、次に GreetDialog の処理に遷移し、最後に RootDialog に戻ってくるという流れです。
図: チャットのイメージ 下記は、最初に起動される RootDialog クラスの実装です。 前回の説明 で使用した DialogBot クラスを使って RootDialog を起動することを想定しています。 ウォーターフォールダイアログの最初のステップ (_step1) として、ユーザーに選択肢を提示し、「挨拶する」を選んだ場合に、GreetDialog を新たに起動するようにしています。
dialogs/rootDialog.js const { ChoiceFactory, ChoicePrompt, ComponentDialog, ListStyle, WaterfallDialog, } = require(&amp;#39;botbuilder-dialogs&amp;#39;); const { GreetDialog } = require(&amp;#39;.</description></item><item><title>チャットボット: Bot Builder SDK で画像やリストなどのリッチなメッセージを送る (MessageFactory)</title><link>https://maku.blog/p/q7vw95i/</link><pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7vw95i/</guid><description>Activity オブジェクトと MessageFactory Bot Builder SDK によるボット実装において、ユーザーにメッセージを送るには TurnContext クラス の sendActivity() メソッドを使用します。 下記は、単純なテキストメッセージを送る例です。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); sendActivity() の第一引数には、このように文字列を渡すことができますが、その名の通り Activity オブジェクトを渡すこともできるようになっています。 Activity オブジェクトを使うと、単純なテキストよりもリッチな形式で表示を行うことができます（どう表示されるかは各チャンネルの実装によりますが）。
Activity インタフェースは botframework-schema モジュール で定義されていますが、このインタフェースを意識してオブジェクトを作成することはあまりありません。 というのも、いろいろな用途の Activity オブジェクトを生成するためのファクトリーである MessageFactory クラス が用意されているからです。
例えば、MessageFactory#text() は単純なテキストメッセージを送るための Activity オブジェクトを生成します。
// const { MessageFactory } = require(&amp;#39;botbuilder&amp;#39;); const msg = MessageFactory.text(&amp;#39;Hello!&amp;#39;); await context.sendActivity(msg); これは実は下記のようにするのと同じです。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); TurnContext#sendActivity() に直接文字列を渡した場合は、内部で前者のような MessageFactory.text() による Activity 生成が行われています。 単純なテキストを送るだけであれば、sendActivity('Hello') としてしまうのが早いでしょう。
MessageFactory でリッチなメッセージを作成する MessageFactory が提供するファクトリメソッドを使って、リッチなメッセージを送る例をいくつか紹介します。 ここでは、Bot Framework Emulator の表示例を載せておきます。
画像・動画を表示する &amp;ndash; contentUrl() const msg = MessageFactory.</description></item><item><title>チャットボット: 独自のミドルウェアを作成してログを記録する</title><link>https://maku.blog/p/fn3amda/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fn3amda/</guid><description>ミドルウェアとは Bot Framework において、クライアントから受信したメッセージはアダプターを介してボットに届けられますが、アダプターにミドルウェアを設定しておくことで、メッセージがボットに届く前に割り込んで処理を行うことができます。
Adapter → Middleware1 → Middleware2 → Middleware3 → ... → YourBot ミドルウェアは上記のように複数登録することができ、登録された順に呼び出されていきます。 アダプターにミドルウェアを追加するには、BotFrameworkAdapter#use() メソッドを使用します。
ミドルウェアの追加 const { BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); const adpater = new BotFrameworkAdapter(endpoint); adapter.use(new Middleware1()); adapter.use(new Middleware2()); adapter.use(new Middleware3()); ミドルウェアを実装する 独自のミドルウェアを作成するには、Middleware インタフェース が提供する onTurn メソッドを実装します。
ここでは、ユーザーの入力をコンソールに出力するだけの ConsoleLogger というミドルウェアクラスを実装してみます。
middlewares/consoleLogger.js exports.ConsoleLogger = class ConsoleLogger { async onTurn(context, next) { if (context.activity.type === &amp;#34;message&amp;#34;) { console.log(context.activity.text); } await next(); // Invoke a next middleware } }; とても簡単ですね。 あと、onTurn() を抜ける前に忘れずに next() を呼び出して、後続のミドルウェアが正しく呼び出されるようにしておく必要があります。</description></item><item><title>チャットボット: 独自のミドルウェアを作成して禁止ワードを拒否するようにする</title><link>https://maku.blog/p/gt9g2na/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gt9g2na/</guid><description>前回の記事 では、チャットボットに独自のミドルウェアを追加して、ユーザー入力をログ出力できるようにしました。 今回は、ユーザーが NG ワードを入力したときに、警告を表示して処理を中断するようなミドルウェアを作成してみます。
その名も NgWordMiddleware です！
middlewares/NgWordMiddleware.js const NG_WORDS = /アホ|まぬけ|バカ/; exports.NgWordMiddleware = class NgWordMiddleware { async onTurn(context, next) { if (context.activity.type === &amp;#39;message&amp;#39;) { const line = context.activity.text; if (NG_WORDS.test(line)) { await context.sendActivity(&amp;#39;そんなこと言っちゃダメ&amp;#39;); return; } } await next(); // Invoke a next middleware } }; 上記の例では、NG_WORDS 定数に、禁止語句を正規表現の形で登録しています。 ユーザーが入力したテキストに、禁止語句が含まれていたら、「そんなこと言っちゃダメ」と返事して処理を進めないようにします（next() を呼び出さないことで後続の処理を打ち切る）。
このミドルウェアは、下記のようにアダプターに追加することで有効化できます。
// const { NgWordMiddleware } = require(&amp;#39;./middlewares/ngWordMiddleware.js&amp;#39;); const adapter = new BotFrameworkAdapter(botEndpoint); adapter.use(new NgWordMiddleware()); この例では、単純に禁止語句が含まれているかだけをチェックしているので、「バカルディ」と入力した場合にも弾かれてしまいます。 このあたりは工夫して処理しなきゃですね。</description></item><item><title>AWS CloudFormation で S3 バケットのリソースを作成する</title><link>https://maku.blog/p/ugt6gr4/</link><pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ugt6gr4/</guid><description>S3 バケット定義の基本 AWS CloudFormation で S3 バケットを作成・設定するには、次のようにテンプレートファイル内で AWS::S3::Bucket タイプのリソースを定義します。
template.yml AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Resources: MyBucket: Type: AWS::S3::Bucket 上記の例では、論理 ID (Logical ID) が MyBucket の S3 バケットを定義しています。 論理 ID はこのテンプレートで生成するスタック内で一意の ID です。 実際に生成される S3 バケット名（物理 ID）は CloudFormation が自動で生成します（後述）。
このテンプレートを使って、CloudFormation スタック（ここでは S3 バケットのみ含まれる）を生成するには、次のように aws cloudformation deploy コマンドを実行します。
mystack スタックを生成 $ aws cloudformation deploy --template-file template.yml --stack-name mystack スタック内に生成された AWS リソースの一覧は次のように確認できます。
$ aws cloudformation describe-stack-resources --stack-name mystack StackResources: - DriftInformation: StackResourceDriftStatus: NOT_CHECKED LogicalResourceId: MyBucket PhysicalResourceId: mystack-mybucket-bq8iux8uepew ResourceStatus: CREATE_COMPLETE ResourceType: AWS::S3::Bucket StackId: arn:aws:cloudformation:ap-northeast-1:123456789012:stack/mystack/c7e06a46-9902-11eb-9a29-8b1f770a16f7 StackName: mystack Timestamp: &amp;#39;2021-04-09T07:09:13.</description></item><item><title>React コンポーネントのプロパティでハンドラメソッドを渡す</title><link>https://maku.blog/p/e2dpycn/</link><pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e2dpycn/</guid><description>ここでは、次のようにプロパティ（属性）でハンドラメソッドを設定可能な React コンポーネントの実装例を示します。
&amp;lt;MyButton onClick={handleClick} /&amp;gt; ハンドラメソッドを設定可能なコンポーネントを実装する 次の MyButton コンポーネントは、ボタンクリック時に呼び出されるイベントハンドラを、onClick プロパティで設定できるようにしています。 この MyButton コンポーネントは、クリックするたびに内部のカウンタ (state.count) を +1 し、その値を指定されたイベントハンドラへ通知します。
components/myButton.tsx import * as React from &amp;#39;react&amp;#39;; // MyButton のプロパティ（属性）の型 export interface MyButtonProps { onClick?: (count: number) =&amp;gt; void; } // MyButton の状態（ステート）の型 interface MyButtonState { count: number; } // MyButton コンポーネント export class MyButton extends React.Component&amp;lt;MyButtonProps, MyButtonState&amp;gt; { constructor(props: MyButtonProps) { super(props); this.state = {count: 0}; } public render(): React.ReactNode { const {count} = this.</description></item><item><title>React コンポーネントのプロパティで配列データを渡す</title><link>https://maku.blog/p/av9mxak/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/av9mxak/</guid><description>React コンポーネントのプロパティには、文字列や数値などの単純なスカラ値だけではなく、配列などの複雑なオブジェクトを渡すことができます。 使用イメージは次のような感じです。
&amp;lt;MyComponent values={配列変数} /&amp;gt; 配列型のプロパティを扱うコンポーネントを作成する 次の Books コンポーネントは、プロパティ titles で文字列配列を受け取り、それぞれの値を li 要素で描画します。 配列の map メソッドを使用すると、複数の li 要素を簡単に生成することができます。
components/books.tsx（Books コンポーネント） import * as React from &amp;#39;react&amp;#39;; // Books コンポーネントのプロパティの型 export interface BooksProps { titles: string[] } // Books コンポーネントの定義 export const Books: React.FC&amp;lt;BooksProps&amp;gt; = (props) =&amp;gt; { // titles プロパティの要素数が 0 であれば何も描画しない if (props.titles.length == 0) return null; // titles プロパティの値を使って、複数の li 要素を作る const listItems = props.titles.map((title: string) =&amp;gt; &amp;lt;li&amp;gt;{title}&amp;lt;/li&amp;gt; ); // ul 要素の描画 return &amp;lt;ul&amp;gt;{listItems}&amp;lt;/ul&amp;gt;; }; この Books コンポーネントは次のような感じで使用します。</description></item><item><title>VS Code でビルドタスクやテストタスクを登録する (tasks.json)</title><link>https://maku.blog/p/zn2er4g/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zn2er4g/</guid><description>タスク設定とは VS Code のビルドタスク設定 (tasks.json) をしておくと、 Cmd + Shift + B (Ctrl + Shift + B) というショートカットキーで、任意のビルドタスクを実行できるようになります。
「ビルド」タスクと言っていますが、実際には任意のコマンドを実行することができます。 例えば、Node.js アプリを起動するための npm start や、シェル上でのコマンドを素早く実行できるようになります。
ここでは、下記のようなコマンドを実行するタスクを VS Code に登録してみます。
npm start コマンド（Node.js アプリの起動） echo コマンド（Hello World と表示するだけ） サンプルアプリの準備 npm start で起動するサンプルアプリとして、簡単な Node.js アプリを作成しておきます。 プロジェクト用のディレクトリと package.json を作成し、VS Code で開きます。
$ mkdir myapp $ cd myapp $ npm init -y # package.json の生成 $ code . # VS Code で開く VS Code にプロジェクトとして認識させるには、ファイルではなくディレクトリを開く必要があることに注意してください。 VS Code が開いたら、Cmd + N で新しくエディタを開き、次のような内容の main.</description></item><item><title>TypeScriptの型: 既存の JavaScript ライブラリに型情報を追加する（.d.ts ファイル）</title><link>https://maku.blog/p/s7wk5k3/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s7wk5k3/</guid><description>アンビエント宣言とは TypeScript の アンビエント宣言 (Ambient Declarations) を行うと、既存の JavaScript ライブラリに型情報を付加することができます。 この仕組みを利用すると、
サードパーティ製の JavaScript ライブラリ（npm パッケージ）や、自作の JavaScript ライブラリ（ただし TypeScript 化はしたくないもの）を TypeScript コードから使用する jQuery などのブラウザ上でロードされるライブラリを TypeScript コードから使用する といったことが可能になります。 ようするに、TypeScript トランスパイラに対して、このオブジェクトはこういう型のものとして外から提供されているので、型チェックエラーを出さないでね、と知らせることができます。
さらに、VisualStudio Code などのエディタを使用している場合は、アンビエント型宣言があることにより、エディタ上での補完入力ができるようになります。
アンビエント宣言 (declare) 参考: TypeScript - Declaration Reference どこか別の場所でロードされる予定の JavaScript モジュールに対して、自力で型情報を付けたい場合は declare キーワードを使用します。 例えば、jQuery はもともと JavaScript 用のライブラリなので、TypeScript 用の型情報は提供していませんが、次のように自力で型情報を付けることで、TypeScript コードから利用できるようになります（実際には、DefinitelyTyped プロジェクトが提供する @types/jquery を使用するのが簡単です）。
index.ts // $ という変数を参照できるようにする（実体は実行時に後付けで定義される予定） declare var $: any; // これで、$ という未定義の変数を参照してもエラーにならない $(&amp;#39;#id&amp;#39;).html(&amp;#39;Hello!&amp;#39;); この仕組みを使わずに、いきなり $ を参照してしまうと、そのような変数は定義されていないというエラーになってしまいます。 TypeScript トランスパイラは、declare によって付けられた型情報を正しいものと判断するため、この型情報は間違えないように指定する必要があります。 また、実行時にはそのオブジェクトの実体がどこかで生成されていなければいけません。</description></item><item><title>TypeScript プロジェクトに ESLint を導入する</title><link>https://maku.blog/p/xz9iry9/</link><pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xz9iry9/</guid><description>ESLint とは ESLint は JavaScript/TypeScript 向けの Lint ツール（静的解析ツール）です。 プロジェクト内のソースコードに対して eslint コマンドを実行することで、コーディングルールに従っていない部分や、不具合の原因になりそうな部分を検出してくれます。
☝️ eslint vs tslint もともと TypeScript 用には tslint という Lint ツールが提供されていましたが、Microsoft の TypeScript チームが eslint への統合を 公式に発表 してから（2019年以降）は、TypeScript においても eslint が事実上の標準 Lint ツールとなっています。参考: TypeScript の ESLint 対応プロジェクト ESLint のインストール eslint コマンドは npm でインストールできます。 TypeScript プロジェクトのディレクトリ内で、次のように開発用にインストールすることが推奨されています（package.json は作成済みだと想定します）。
ESLint のインストール $ npm install eslint --save-dev ESLint の初期設定 eslint コマンドを実行するためには、設定ファイル .eslintrc.{js,yml,json} を作成しておく必要があります。
設定ファイルの生成 $ npx eslint --init 上記のように実行すると、ウィザード形式でどのような用途に使用するかを質問されるので、順番に答えていくだけで設定ファイルを生成できます。 最後にその構成に必要なモジュールをまとめてインストールできます。 ここでは、eslint v7.26.0 における表示例を示しています。</description></item><item><title>TypeScriptの型: 環境変数 (process.env) 用の型情報を定義する</title><link>https://maku.blog/p/r8iry9g/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r8iry9g/</guid><description>Node.js で環境変数を参照するためのオブジェクト process.env の型情報は、@types/node で次のように文字列型ディクショナリ Dict&amp;lt;string&amp;gt; として定義されています。
node_modules/@types/node/process.d.ts（抜粋） declare module &amp;#34;process&amp;#34; { global { var process: NodeJS.Process; namespace NodeJS { interface ProcessEnv extends Dict&amp;lt;string&amp;gt; {} //... } } export = process; } この型定義は @types/node モジュールをインストールするだけで簡単に使用できるようになるのですが、具体的なキー名（環境変数名）が定義されていないので、Visual Studio Code などで process.env 以降の入力補完が効きません。
VS Code 上で環境変数名を補完入力 できるようにするには、次のような型定義ファイル (globals.d.ts) をソースツリーのルートに作成します。
globals.d.ts declare namespace NodeJS { // 環境変数名の定義 interface ProcessEnv { /** 現在の Node.js 実行環境 */ readonly NODE_ENV: &amp;#39;development&amp;#39; | &amp;#39;production&amp;#39; | &amp;#39;test&amp;#39;; /** GitHub アクセストークン */ readonly MYAPP_GITHUB_TOKEN: string; } } 環境変数 NODE_ENV の値は、決められた 3 種類の値 (development/production/test) のいずれかであると定義しているので、それ以外の値と比較しようとしたときに警告してくれます。</description></item><item><title>React コンポーネントで入力フォームを作成する (1) 自力編</title><link>https://maku.blog/p/tdpybmw/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tdpybmw/</guid><description>制御コンポーネント (controlled components) React コンポーネントでフォームを構成する場合、コンポーネントの状態 (state) に基づいて表示を行うように実装すると、フォームの表示内容を制御しやすくなります。
このように、コンポーネントの表示内容が、完全にその状態 (state) によって決まるように実装されたものを、制御されたコンポーネント (controlled components) と呼びます。
このように設計することで、若干コード量は増えますが、表示内容を変更したいときはコンポーネントの state を変更するだけで済むようになります。 例えば、ネットワークから取得したデータをフォームに表示するような場合、そのフォームの構造を知る必要はなく、単純に state を更新するだけでよくなります。 これは、データとビューが分離された設計になっており、アプリ設計におけるベストプラクティスのひとつです。
input 要素の実装例 下記は、&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt; 要素と &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt; 要素を持つ MessageForm コンポーネントの実装例です。 ユーザーがテキストを入力するたびに handleChange() が呼び出され、コンポーネントの状態 (state) が更新されます。 setState() の呼び出しにより state が変更が変更されると、再度 render() が実行され、表示内容が state の値に基づいて更新されます。
まずは、クラスコンポーネント形式での実装例。
components/MessageForm.tsx import * as React from &amp;#39;react&amp;#39;; interface IState { msg: string; } // テキスト入力エリアと、submit ボタンを持つフォームを表示するコンポーネント export class MessageForm extends React.Component&amp;lt;{}, IState&amp;gt; { constructor(props: {}) { super(props); // ステートの初期化（最初は入力エリアは空っぽ） this.</description></item><item><title>LUIS (1) LUIS とは？</title><link>https://maku.blog/p/mkwnnsz/</link><pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mkwnnsz/</guid><description>LUIS でできること Microsoft が提供している LUIS (Language Understanding Intelligent Service) サービスを使用すると、自然言語による文章（発話テキスト）を、コンピュータが理解しやすい形式に翻訳することができます。 主にチャットボットのバックエンドとして使用されることが想定されているようです。
LUIS (Language Understanding) - Cognitive Services - Microsoft Azure LUIS - Endpoint API メインのクエリ用 REST API LUIS - Authoring API アプリ管理用の REST API LUIS は、入力した発話テキストをインテントとエンティティに分解します。
インテント … 意図、目的。ユーザが何をしたいのかを表す。 エンティティ … 文章の中のプレースホルダに当たる部分の値。求めているものや、条件などを示す部分。 例えば、下記のような入力テキストがあったとすると、
15時から4人で使える部屋はない？ LUIS は次のようなインテント＋エンティティの情報に翻訳します。
インテント: SearchMeetingRoom エンティティ: Time=15時、People=4人 チャットボットのプログラムは、この翻訳された情報を見て、「ミーティングルームを探す」処理を、パラメータ「15時」、「4人」で行えばよいことになります。 LUIS は上記のような翻訳処理を行うためのサービスなので、その先のミーティングルームの検索処理などは独自に実装する必要があります。
LUIS の Web サイト上では、このような発話例 (Utterance) と、インテント、エンティティの情報を登録していくことで、モデルの学習を進めることができます。
LUIS のモデルを公開する LUIS ポータル上で作成した自然言語解析のモデルを、Web API (REST API) の形で使用できるようにするには、下記のようなステップを踏みます（QnA Maker のサービスと同様の手順です）。
Azure ポータルの リソースの作成 から Language Understanding (LUIS) のリソースを作成する LUIS ポータルで LUIS アプリ（モデル）を作成する（上記で作成した Azure の LUIS リソース経由でアクセスできるよう関連付ける） LUIS ポータルでモデルを Publish して REST API として呼び出せるようにする 上記のようにしてナレッジベースを公開すれば、Node.</description></item><item><title>gnuplot: グラフにタイトルを表示する</title><link>https://maku.blog/p/taoir3i/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/taoir3i/</guid><description>グラフにタイトルを入れる Syntax set title &amp;#34;&amp;lt;title&amp;gt;&amp;#34; [&amp;lt;x_offset&amp;gt;] [, &amp;lt;y_offset&amp;gt;] タイトルはシングルクォーテーション (') で囲んでも構いませんが、改行 (\n) を入れる場合はダブルクォーテーション (&amp;quot;) で囲む必要があります。 タイトルはデフォルトでは表の上部中央に表示されますが、x_offset に移動させる文字数を指定することができます。 タイトルを消したいときは、set title を実行します。
例: タイトルを「Normal Distribution (正規分布)」にする normal_distribution(x, a, b) = exp(-((x-b)**2)/(2*(a**2))) / sqrt(2*pi)*a set title &amp;#34;Normal Distribution&amp;#34; plot normal_distribution(x, 3, 0) タイトルを消す set title タイトルを消したい場合は、タイトル文字列を指定せずに set title を実行します。
複数行のタイトルを入れる set title &amp;#34;これは\n複数行にわたる\nタイトルだよ&amp;#34; タイトルに改行をいれるには \n を使います。 複数行のタイトルを指定する場合は、' (シングルクォーテーション) ではなくて &amp;quot; (ダブルクォーテーション) で囲む必要があります。</description></item><item><title>React コンポーネントで入力フォームを作成する (2) react-hook-form 編</title><link>https://maku.blog/p/k7it5fp/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k7it5fp/</guid><description>React Hook Form とは React アプリで入力フォームを自力で作ろうとすると、各入力エリアのステート管理などが 意外と大変だったりします。 React Hook Form ライブラリ (react-hook-form) を使用すると、そのあたりの定型処理をシンプルに記述することができます。
React Hook Form / npm / GitHub React Hook Form は次のような特徴を備えています。
軽量（別のライブラリに依存しない） TypeScript をサポート パフォーマンスがよい（不要なレンダリングを軽減） HTML 標準のフォームバリデーション との互換性 required / min / max / minLength / maxLength / pattern / validate React Native でも使える 2022 年 2 月時点で活発に開発が進められており、npm のダウンロード数は右肩上がりに増えています。 GitHub のスター数も 25,000 を超えているため、しばらくは安心して使えそうなライブラリです。
React Hook Form を導入する react-hook-form パッケージは、npm あるいは yarn で簡単にインストールできます。 既存の React プロジェクト内で次のように実行してください。
$ npm install react-hook-form あるいは $ yarn add react-hook-form React Hook Form の基本的な使い方 次の MyForm コンポーネントは、1 つのテキスト入力フィールドと、1 つの数値入力フィールドを持つフォームの実装例です。 ここでは TypeScript を使い、フォームの入力要素の型を FormData と定義しています。</description></item><item><title>ESLint の設定ファイル (.eslintrc) の各プロパティの意味を理解する</title><link>https://maku.blog/p/j6iu7it/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6iu7it/</guid><description>何を説明するか 下記は、TypeScript を使った React アプリ実装用に用意した ESLint 設定ファイル (.eslint.yml) の例です。 トップレベルのプロパティとして、env や extends などがありますが、これらが何を意味しているかをざっと説明します。
.eslint.yml（例） root: true env: browser: true es2021: true parser: &amp;#39;@typescript-eslint/parser&amp;#39; parserOptions: ecmaVersion: 2021 project: ./tsconfig.json plugins: - react - react-hooks - &amp;#39;@typescript-eslint&amp;#39; extends: - eslint:recommended - plugin:react/recommended - plugin:react-hooks/recommended - plugin:@typescript-eslint/recommended - plugin:@typescript-eslint/recommended-requiring-type-checking rules: react/react-in-jsx-scope: off 各プロパティの説明 root: true ESLint は、実行時のカレントディレクトリを起点にして、上位のディレクトリの設定ファイル (.eslintrc.*) を探していきます。 root: true の指定があると、この検索の振る舞いをそこで停止できます。 プロジェクトのトップディレクトリに置く .eslintrc.* には、この指定をしておくとよいです。
env: 実行環境の指示 どのようなグローバルオブジェクトを宣言なしで参照可能にするかを ESLint に知らせるための設定です。 例えば、Web ブラウザ上で動作させる JavaScript コードであれば browser、Node.</description></item><item><title>gnuplot: 座標軸にラベルを表示する</title><link>https://maku.blog/p/b3wwe4b/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b3wwe4b/</guid><description>座標軸にラベルを表示する Syntax set xlabel &amp;#34;&amp;lt;label&amp;gt;&amp;#34; [x [, y]] set ylabel &amp;#34;&amp;lt;label&amp;gt;&amp;#34; [x [, y]] set zlabel &amp;#34;&amp;lt;label&amp;gt;&amp;#34; [x [, y]] set x2label &amp;#34;&amp;lt;label&amp;gt;&amp;#34; [x [, y]] set y2label &amp;#34;&amp;lt;label&amp;gt;&amp;#34; [x [, y]] 例: x軸の名前を「経過時間(ms)」にする set xlabel &amp;#34;経過時間(ms)&amp;#34; 好きな位置にラベルを表示する set label &amp;#34;&amp;lt;label&amp;gt;&amp;#34; x, y y 軸のラベルを回転させて表示する set ylabel=&amp;#34;\rotate=270 ylabel&amp;#34; ※拡張版 gnuplot のみ対応。</description></item><item><title>ESLint + Prettier の設定方法まとめ</title><link>https://maku.blog/p/yfow6dk/</link><pubDate>Sun, 23 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yfow6dk/</guid><description>ここでは、とにかく混乱しがちな ESLint + Prettier の設定方法をまとめておきます。 まず、基本的な構成として、TypeScript (with React) の Lint をかけられるようにして、必要に応じて Airbnb スタイル を追加で設定する、という流れにしたいと思います。
TypeScript プロジェクトの準備 前提条件として、TypeScript (+ React) のプロジェクト自体は作成済みとします。 何も準備できていなければ、Next.js の create-next-app コマンドを使うと簡単に作成できます（typescript および @types/node、@types/react、@types/react-dom などの型情報が導入された状態のプロジェクトが作成されます）。
2 つやり方あるけど、大体中身は同じ # テンプレートを使う方法 $ create-next-app myapp --example with-typescript # typescript オプションを使う方法 $ create-next-app myapp --typescript 参考リンク Next.js で HelloWorld（プロジェクト作成からサーバー起動まで） Next.js のプロジェクトを TypeScript 化する Prettier + ESLint の基本設定 (for TypeScript with React) 必要なパッケージのインストール # Prettier 本体 $ yarn add --dev --exact prettier # ESLint 本体 $ yarn add --dev eslint # ESLint 用のプラグインおよび共有設定 $ yarn add --dev @typescript-eslint/eslint-plugin $ yarn add --dev @typescript-eslint/parser $ yarn add --dev eslint-plugin-react $ yarn add --dev eslint-plugin-react-hooks $ yarn add --dev eslint-config-prettier # npm スクリプトの並列実行用 $ yarn add --dev npm-run-all npm の場合 # Prettier 本体 $ npm install prettier --save-dev --save-exact # ESLint 本体 $ npm install eslint --save-dev # ESLint 用のプラグインおよび共有設定 $ npm install @typescript-eslint/eslint-plugin --save-dev $ npm install @typescript-eslint/parser --save-dev $ npm install eslint-plugin-react --save-dev $ npm install eslint-plugin-react-hooks --save-dev $ npm install eslint-config-prettier --save-dev # npm スクリプトの並列実行用 $ npm install npm-run-all --save-dev .</description></item><item><title>LUIS (2) LUIS のオーサリングキー、エンドポイントキーとは</title><link>https://maku.blog/p/mdyedwq/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mdyedwq/</guid><description>LUIS アプリで使用するキーの種類には、オーサリングキー (Authoring Key) とエンドポイントキー (Endpoint Key) の 2 種類があります。
オーサリングキー (Authoring Key) オーサリングキーは LUIS アカウントの作成時に自動的に作成される、無料のキーです。 オーサリングキーはリージョン内で共通であり、1 つだけ作成されます。 最初に作成されるので、スターターキー (Starter Key)、作成者キーとも呼ばれます。
オーサリングキーは、LUIS アカウントに結び付けられているので、LUIS 右上のアカウント名をクリックし、Settings を選択することで確認できるようになっています。
オーサリングキーは、LUIS アプリ自体の作成や、公開、コラボレーターの管理、バージョン管理などを行うときに必要になります。 つまり、あなたが作成する LUIS アプリの管理用のキーであり、LUIS の Web サイトで行えることほぼすべてをこのキーを使ったオーサリング API 経由で行えます。
LUIS ポータル上にログインして作業している間は、オーサリングキーの存在を意識しなくても LUIS アプリの管理を行うことができますが、Web API を使って LUIS アプリの管理作業を自動化したいときなどにオーサリングキーが必要になります。
作成した個々の LUIS アプリに対するクエリ実行のためにもオーサリングキーを使用できますが、これは実装中のテスト用途に限られます（権限の強いオーサリングキーを、公開アプリからのクエリ用途に使うのは避けるべきです）。 実運用でのクエリ実行は、後述のエンドポイントキーを使用します。
ちなみに、オーサリングキーは Microsoft のユーザアカウントごとに割り当てられるものです。 LUIS アプリのコラボレータとして登録されたユーザは、自分のオーサリングキーを使って LUIS アプリの管理を行います。
エンドポイントキー (Endpoint Key) 運用環境で LUIS アプリに対するクエリ実行を行うには、Azure の LUIS リソースとして作成されたエンドポイント URL とエンドポイントキーを使用します。 Azure ポータル にログインして、LUIS リソースを作成することでエンドポイントキーを取得できます。
Azure 上の LUIS リソースは、1 つのリソースグループに所属し、そのリソースグループは 1 つのサブスクリプションに所属します。 毎月の課金はサブスクリプションに対して行われます。 階層的には下記のような感じで LUIS リソースが配置されているイメージです。</description></item><item><title>LUIS (3) Node.js から LUIS の API を利用する</title><link>https://maku.blog/p/tewj3gs/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tewj3gs/</guid><description>LUIS API を呼び出すためのエンドポイント情報を調べる LUIS アプリの Publish REST API 経由で LUIS アプリによる発話解析を行うには、LUIS ポータル上で対象の LUIS アプリを Train し、Publish しておく必要があります（LUIS アプリというのは、いわゆる訓練されたモデルのことだと考えるとよいです）。
API 実行用のエンドポイント URL とキーを確認する Publish 処理が完了すると、エンドポイント URL と エンドポイントキー (Endpoint key) を使って、LUIS アプリに対してクエリ要求を投げることができるようになります。 テスト用途であれば、LUIS ポータル上で最初に作成される オーサリングキー (Authoring key) でもクエリを実行できますが、最終的なユーザ環境でのクエリ実行には Azure 上で作成したリソースに付けられたエンドポイント URL とエンドポイントキーのペアを使用する必要があります。
参考: オーサリングキー、エンドポイントキーとは LUIS の REST API を呼び出すための URL は、下記のような情報から構成されています（下記例の ID はデタラメです）。
Application ID: 5c548551-f6ba-4fc8-c695-529ac194317d Application version: 0.1 エンドポイントキー: ff824a1409f929c8e2a15301ccff431d Application ID と Application version は、MANAGE タブの Application Information のページで確認することができます。</description></item><item><title>gnuplot: 凡例（ラインの名前）を表示する</title><link>https://maku.blog/p/zsdpkyg/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zsdpkyg/</guid><description>凡例の名前を変える Syntax plot &amp;lt;expression&amp;gt; title &amp;#39;&amp;lt;線の名前&amp;gt;&amp;#39; 例 plot 0.5*x title &amp;#34;my line&amp;#34; title オプションは、with オプションよりも前に指定する必要があります。
凡例を消す set nokey 全ての凡例を消すには set nokey を実行します。 線ごとに凡例を消すには plot のオプションで notitle を指定します。
例: 特定のラインだけ凡例を消す plot 0.5*x notitle, -0.5*x 凡例と線種の表示順を逆にする set key reverse 凡例を四角で囲む set key box 四角を消したくなった場合は nobox をセットします。
set key nobox 凡例の行間を変える set key spacing &amp;lt;倍率&amp;gt; 凡例に表示する線の長さを変える set key samplen &amp;lt;長さ&amp;gt; 線の長さは文字数で指定します。 例えば 10 と指定した場合は 10 文字分の長さになります。
凡例の表示位置を指定する Syntax set key &amp;lt;y 座標&amp;gt;, &amp;lt;y 座標&amp;gt; set key left | right | top | bottom 例: 凡例を (100, 100) に表示 set key 100,100 例: 凡例を右下に表示 set key right bottom</description></item><item><title>ESLint (4) ESLint の設定方法まとめ (for Next.js 11)</title><link>https://maku.blog/p/dexgg8o/</link><pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dexgg8o/</guid><description>Next.js 11 が ESLint を組み込みサポート Next.js 11 で ESLint を Next.js が組み込みでサポートしました。 これで、create-next-app で新規作成するアプリでは、ESLint に関してもゼロコンフィグで next eslint とするだけで実行できるようになります。
ただ、ESLint には色々な共有設定 (config) があるわけで、Next.js がデフォルトで設定してくれているもの以外（TypeScript や Prettier 関連）は自分で設定する必要があります。 ここでは、Next.js 11 がデフォルトで提供する .eslintrc にそれらの設定を追加します。
Next.js 11 デフォルトの ESLint 設定 Next.js 11 が生成する .eslintrc ファイルは次のようなシンプルなものです。
.eslintrc { &amp;#34;extends&amp;#34;: [&amp;#34;next&amp;#34;, &amp;#34;next/core-web-vitals&amp;#34;] } 問題はこれらがどのような共有設定を含んでいるかですが、eslint-config-next のコードを見ると、次のような感じになっています。
module.exports = { extends: [ &amp;#39;plugin:react/recommended&amp;#39;, &amp;#39;plugin:react-hooks/recommended&amp;#39;, &amp;#39;plugin:@next/next/recommended&amp;#39;, ], // ... } React 系の共有設定はここに含まれているので、&amp;quot;extends&amp;quot;: [&amp;quot;next&amp;quot;] だけでカバーできそうです。 公式ドキュメントの ESLint - Base Configuration にも同様の説明が書かれています。 逆に、TypeScript 関連や、Prettier 関連の共有設定は自分で追加しなければいけません。</description></item><item><title>LUIS (4) botbuilder-ai ライブラリを使って LUIS の API を利用する</title><link>https://maku.blog/p/dtwckb9/</link><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtwckb9/</guid><description>こちらの記事（Node.js から LUIS の API を利用する） では、自力で LUIS の REST API を呼び出すための URL を構築していました。 ここでは、botbuilder-ai パッケージを使用して、もっと手軽に LUIS の機能を呼び出してみます。
☝️ ワンポイント 残念ながら botbuilder-ai が提供している LuisRecognizer などのクラスは、チャットボットの実装に使用する TurnContext オブジェクトに依存した設計になっています。 そのため、単純なコンソールアプリケーションから botbuilder-ai パッケージを使用することは難しく、チャットボットの実装でしか利用できません。 LUIS のエンドポイント情報（接続情報）を確認しておく LUIS API を使用するには、下記のような LUIS アプリの APP ID やエンドポイント情報が必要です。
APP ID: c39eb4df-fbcf-224f-b8b7-a0ee445d11b3 エンドポイント: https://japaneast.api.cognitive.microsoft.com エンドポイントキー（サブスクリプションキー）: c9162c5c0b5edff5270feb6145618acb APP ID とエンドポイントキーは、LUIS ポータル から対象のアプリケーションを開き、下記のように確認できます。
APP ID: MANAGEタブ → Application Information エンドポイント: MANAGEタブ → Keys and Endpoints → Endpoint カラムの URL の前半部分。 エンドポイントキー: MANAGEタブ → Keys and Endpoints → Key 1 カラム LUIS のエンドポイントキーは、Azure ポータル に作成した LUIS リソース の キー の項目に表示されるものと同じです。 念のため、同一のものが表示されているか確認しておくとよいでしょう。</description></item><item><title>gnuplot: 軸の目盛り表示を調整する</title><link>https://maku.blog/p/ezq5wy8/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ezq5wy8/</guid><description>軸の目盛りの間隔、開始座標、終了座標を設定する Syntax set xtics &amp;lt;start&amp;gt;, &amp;lt;incr&amp;gt;, &amp;lt;end&amp;gt; set x2tics &amp;lt;start&amp;gt;, &amp;lt;incr&amp;gt;, &amp;lt;end&amp;gt; set ytics &amp;lt;start&amp;gt;, &amp;lt;incr&amp;gt;, &amp;lt;end&amp;gt; set y2tics &amp;lt;start&amp;gt;, &amp;lt;incr&amp;gt;, &amp;lt;end&amp;gt; set ztics &amp;lt;start&amp;gt;, &amp;lt;incr&amp;gt;, &amp;lt;end&amp;gt; start と end を省略して、incr（ステップ数）だけを指定することもできます。
例: x 軸の目盛りを 1 刻みで 0～5 の間に表示（ついでにグリッドも ON） set xtics 0, 1, 5 set grid plot [-10:10] x あ、こうすると x=0 には目盛りが表示されないみたい。。。 x=0 にも表示したかったら -1, 1, 5 にしないとダメですね。
軸の目盛りを消す Syntax set noxtics set nox2tics set noytics set noy2tics set noztics 図形の形だけを示したい場合などは、軸の目盛りと、凡例を両方とも消してプロットします。</description></item><item><title>gnuplot: グラフに補助線を表示する</title><link>https://maku.blog/p/556wrds/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/556wrds/</guid><description>X=0, Y=0 の中心線 (axis) を表示する Syntax set [no]zeroaxis # x=0, x2=0, y=0, y2=0 軸の補助線を表示・非表示 set [no]xzeroaxis # x=0 軸の補助線を表示・非表示 set [no]x2zeroaxis # x2=0 軸の補助線を表示・非表示 set [no]yzeroaxis # y=0 軸の補助線を表示・非表示 set [no]y2zeroaxis # y2=0 軸の補助線を表示・非表示 show zeroaxis # 補助線の表示状態を確認する X=0, Y=0 の中心線はデフォルトでは非表示です。
例: x, y の中心線を表示 set zeroaxis plot 1/(1+exp(-x)) - 0.5 目盛りごとに補助線（グリッド）を表示する Syntax set [no]grid # グリッドの表示・非表示 show grid # グリッドの表示状態を確認 例: グリッドを表示 set grid plot log(x)</description></item><item><title>gnuplot: グラフの枠を表示・非表示する</title><link>https://maku.blog/p/3mgr3db/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3mgr3db/</guid><description>枠 (border) の表示・非表示 Syntax set [no]border グラフの枠はデフォルトでは表示されるので、特に枠を消したい場合のみ下記のように実行します。
例: グラフの枠を消す set noborder plot sin(x) 指定した軸だけ表示する Syntax set border &amp;lt;枠番号の論理和&amp;gt; &amp;nbsp;plot bordersplotsplot Sidesplot baseverticalstop bottom (south)116256 left (west)232512 top (north)4641024 right (east)81282048</description></item><item><title>gnuplot: グラフの描画範囲を指定する</title><link>https://maku.blog/p/afkbjc6/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/afkbjc6/</guid><description>描画する線の範囲を指定する Syntax plot [x_min : x_max] [y_min : y_max] &amp;lt;expression&amp;gt; # 二次元の場合 splot [x_min : x_max] [y_min : y_max] [z_min : z_max] &amp;lt;expression&amp;gt; # 三次元の場合 set xrange [min:max] set yrange [min:max] set zrange [min:max] 例: [-2π, 2π] の sin(x) のグラフを表示 plot [-2*pi:2*pi] sin(x) 開始座標だけを指定したり、終了座標だけを指定したりすることもできます。
例: x軸の範囲を 0 からにする plot [0:] sin(x) # set xrange [0:] ; plot sin(x) と同じ 例: x軸の範囲を π までにする plot [:pi] cos(x) # set xrange [:pi] ; plot cos(x) と同じ 例: y軸の範囲を [-π,π] にする plot [] [-pi:pi] sin(x**2) # set yrange [-pi:pi] ; plot sin(x**2) と同じ プロットのオフセットを設定 Syntax set offset &amp;lt;left&amp;gt;, &amp;lt;right&amp;gt;, &amp;lt;top&amp;gt;, &amp;lt;bottom&amp;gt; # マージン設定 show offset # マージン表示 例: オフセットを設定 set offset 2, 2, 1, 1 set grid plot [-2*pi:2*pi] cos(x) グラフのマージンを設定する Syntax set lmargin left # 左の余白を指定（文字数で指定） set rmargin right # 右の余白を指定（文字数で指定） set tmargin top # 上の余白を指定（文字数で指定） set bmargin bottom # 下の余白を指定（文字数で指定） グラフの外形だけを表示したい場合などは、タイトルやラベルなどを表示するためのマージンは必要ないので、次のようにすると余計な空白をなくすことができます。</description></item><item><title>gnuplot: 線のスタイル、ポイントのスタイルを変更する</title><link>https://maku.blog/p/e4vuhjy/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e4vuhjy/</guid><description>線のスタイルを変更する Syntax plot &amp;lt;expression&amp;gt; with &amp;lt;line_style&amp;gt; 線のスタイルを変更するには plot のオプションで with を使います。 with の後ろには次のようなものを指定できます。 括弧は省略形を示しています。
boxes (b) &amp;ndash; 箱（サブスタイル: linesize (ls), linetype (lt)） boxerrorbars &amp;ndash; 箱とエラーバー dots (d) &amp;ndash; 点 errorbars (e) &amp;ndash; エラーバー impulses (i) &amp;ndash; 縦棒 lines (l) &amp;ndash; 線 linespoints &amp;ndash; 線と記号 points (p) &amp;ndash; 記号（サブスタイル: pointtype (pt), pointsize(ps)） steps (s) &amp;ndash; 階段状 線種ごとにさらにサブスタイルを指定することができます。 例えば、記号でプロットする場合（with points (p) を指定した場合）は、オプションとして pointtype (pt) と pointsize (ps) を指定することができます。
例えば、記号のサイズを 3 にする場合は、plot コマンドのオプションとして with p ps 3（省略形での指定）を指定します。 線種や記号の種類にどんなものが指定できるかは、help with コマンドで調べることができます。</description></item><item><title>AWS CloudFormation で DyanamoDB のリソースを作成する</title><link>https://maku.blog/p/h3gsjs2/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h3gsjs2/</guid><description>SAM で簡単な DynamoDB テーブルを生成してみる DynamoDB のテーブルリソースも、Lambda 関数などのリソースと同様に AWS SAM で自動生成＆更新することができます。 CloudFormation のテンプレートをそのまま記述するより、拡張された SAM テンプレートの形式で記述することで、シンプルにリソースを定義することができます。
SAM テンプレート内で DynamoDB のテーブルを定義するときは、リソースタイプとして AWS::Serverless::SimpleTable を指定します（CloudFormation スタック内に実際に生成されるリソースのタイプは AWS::DynamoDB::Table になります）。
DynamoDB テーブルを作成するための最低限の SAM テンプレートはとてもシンプルです。 次の例では、MyTable という 論理 ID (Logical ID) で DynamoDB のテーブルを定義しています。 論理 ID はスタック内でリソースを特定するための名前です。
template.yml AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Transform: AWS::Serverless-2016-10-31 Description: My sample app Resources: MyTable: Type: AWS::Serverless::SimpleTable ひとつもプライマリキーを指定していませんが、その場合はデフォルトで id という名前のプライマリキー（String 型）が定義されます。 AWS CLI で次のように実行すると、CloudFormation のスタックを作成することができます。
$ aws cloudformation deploy --stack-name mystack \ --template-file template.yml CloudFormation スタック内に、実際にどのような AWS リソースが作成されたかを調べるには以下のようにします。 ここではリソースタイプと、その物理 ID (Pysical ID) を table 形式で出力してみました。</description></item><item><title>AWS CloudFormation で SNS トピックのリソースを生成する</title><link>https://maku.blog/p/ymzbmx9/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ymzbmx9/</guid><description>CloudFormation で SNS トピックを作成する CloudFormation スタック内に SNS トピックを生成するには、CloudFormation テンプレートで AWS::SNS::Topic というタイプのリソースを定義します。
このリソースのプロパティはすべてオプショナル（省略可能）なので、最低限のリソース定義は次のようになります。
template.yml AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Resources: MyTopic: Type: AWS::SNS::Topic トピック名 (Properties.TopicName) すら指定していませんが、その場合は、CloudFormation のスタック名と、トピックの論理 ID（上記の場合は MyTopic）の組み合わせから、自動的にトピック名が割り当てられるようになっています（例: mystack-MyTopic-WMD9B9WWLEXN）。
上記のテンプレートから CloudFormation スタックを生成するには、AWS CLI を使って次のように実行します。
mystack スタックの生成 $ aws cloudformation deploy --stack-name mystack \ --template-file template.yml \ --capabilities CAPABILITY_IAM 無事スタックが生成されたら、次のようにして生成された SNS トピックの物理 ID (ARN) を調べることができます。
SNS トピックの ARN を調べる $ aws cloudformation describe-stack-resources \ --stack-name mystack \ --output text \ --query &amp;#34;StackResources[].PhysicalResourceId&amp;#34; arn:aws:sns:ap-northeast-1:123456789012:mystack-MyTopic-WMD9B9WWLEXN Lambda 関数や S3 バケットから SNS トピックに対して publish するときは、この ARN を指定することになります。</description></item><item><title>React Context で複数のコンポーネント間でデータを共有する</title><link>https://maku.blog/p/qoz8fow/</link><pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qoz8fow/</guid><description>Context とは React の Context（コンテクスト） は、いわゆるグローバル変数の格納領域のようなもので、複数のコンポーネント間でのデータ共有に使用できます。 各コンポーネントから Context 情報にダイレクトにアクセスできるため、prop のように上位のコンポーネントから情報を伝搬させていく必要がありません。
Context をむやみに使うと、コンポーネントの再利用性が下がってしまいますが、アプリケーション全体で使用する次のような情報を Context で管理するとコードがすっきりします。
ログイン中のユーザー情報（認証情報） 言語設定 テーマ設定 Context の使い方 Context を作成する (createContext) Context オブジェクトは、React.createContext() で作成することができます。 複数のコンポーネントから参照することになるので、Context オブジェクトは単独のファイルとしてモジュール化しておきます。
React.createContext() の引数に任意のオブジェクトを渡すと、その値を初期値とする Context オブジェクトが生成されます。 次の例では、string 型のデータを保持する Context オブジェクトを生成しています。
MyContext.ts import * as React from &amp;#39;react&amp;#39;; export const MyContext: React.Context&amp;lt;string&amp;gt; = React.createContext&amp;lt;string&amp;gt;(&amp;#39;Default message&amp;#39;); Context を参照する (useContext) 関数コンポーネント内で、Context が保持するデータを参照するには、React.useContext() を使用します。 デフォルトでは、React.createContext() の引数に設定したデフォルト値が返されます。 上記の例では、Default message というデフォルトテキストを設定しているので、その値が返されることになります。
App.tsx import * as React from &amp;#39;react&amp;#39;; import { MyContext } from &amp;#39;.</description></item><item><title>React Context の情報をローカルストレージに保存する</title><link>https://maku.blog/p/bv9kv7h/</link><pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bv9kv7h/</guid><description>何をするか？ ここでは、React の Context オブジェクトにセットした値をローカルストレージに保存し、次回のアプリ起動時にそこから値を復帰させる方法を説明します。 Context の使い方の基本は、次の記事を参照してください。
React Context で複数のコンポーネント間でデータを共有する Context の実装 下記の UserContext.tsx モジュールでは、React.createContext() で UserContext というオブジェクトを作成しています。 このオブジェクトは、gitHubToken という文字列データと、その値を更新するための setGitHubToken 関数を保持しています。 次のように実装することで、UserContext のデータをローカルストレージと同期させることができます。
gitHubToken の初期値に localStorage.getItem() から取得した値を設定する setGitHubToken の呼び出し時に localStorage.setItem() で値を保存する UserContext.tsx import * as React from &amp;#39;react&amp;#39;; // UserContext が保持する値の型 export interface UserContextType { gitHubToken: string; setGitHubToken: (token: string) =&amp;gt; void; } // ローカルストレージ用のキー const KEY_GITHUB_TOKEN = &amp;#39;gitHubToken&amp;#39;; // UserContext の生成 export const UserContext = React.createContext&amp;lt;UserContextType&amp;gt;({ gitHubToken: localStorage.getItem(KEY_GITHUB_TOKEN), // デフォルト値 setGitHubToken: (token: string) =&amp;gt; {} // ダミーセッター }); // UserContext にセッター関数を登録するためのコンポーネント export const UserContextProvider: React.</description></item><item><title>QnA Maker (1) QnA Maker とは？</title><link>https://maku.blog/p/2t6xrbm/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2t6xrbm/</guid><description>QnA Maker でできること Microsoft が提供している QnA Maker というサービスを使用すると、「質問(Q)と回答(A)」のペアデータを登録するだけで、自然言語での FAQ 検索を行うための API を使用できるようになります。 Microsoft が提供している一連の Cognitive Service のひとつとして位置づけられていて、主に FAQ 系のチャットボット (Bot) を手軽に作成するために使用されています。
QnA Maker QnA Maker Documentation QnA Maker REST API V4.0 QnAMaker class | Microsoft Docs 例えば、下記のような Q&amp;amp;A のペアを登録していくだけで、機械学習によって回答のモデルが自動生成されます。 QnA Maker では、このモデルのことをナレッジベース (Knowledge base) と呼んでいます。
Q. お店の営業時間を教えてください。 A. 営業時間は午前10時から午後6時までです。 実際にユーザが入力する質問文章は、登録した Q&amp;amp;A データの質問文と完全に一致する必要はありません。 QnA Maker がどの質問に近いかを判別して、対応する回答文（と一致度）を返してくれます。
ユーザ入力: 営業時間は？ QnA Makerの回答: 営業時間は午前10時から午後6時までです。 簡単に言ってしまえば、QnA Maker の API が提供する機能はこれだけです（データ管理用の API などもありますが）。 回答文を自動生成してくれるようなこともなく、返される文章は、Q&amp;amp;A データとして登録した回答文そのままです。 とはいえ、サクッと FAQ 系のサービスを作成するときには便利に使用できるサービスです。</description></item><item><title>gnuplot サンプル: ホームページ用の GIF を出力する環境設定ファイル (output_gif.env)</title><link>https://maku.blog/p/idkxws2/</link><pubDate>Wed, 04 Dec 2002 00:00:00 +0000</pubDate><guid>https://maku.blog/p/idkxws2/</guid><description> lib/output_gif.env # # 使用例: output.gif というファイル名で出力する設定を行う場合 # # gnuplot&amp;gt; call &amp;#39;lib/hpgif.gp&amp;#39; &amp;#39;output.gif&amp;#39; # set terminal gif size 320, 240 transparent xffffff #set terminal gif size 320, 240 #set samples 200 set output &amp;#39;$0&amp;#39; set zeroaxis</description></item><item><title>QnA Maker (2) QnA Maker のサブスクリプションキー、エンドポイントキーとは</title><link>https://maku.blog/p/t6n6jc8/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t6n6jc8/</guid><description>サブスクリプションキー (Subscription Key) サブスクリプションキーは、QnA Maker アプリ自体の作成や編集を行うためのキーです。 後述のエンドポイントキーよりも厳重に管理しなければならないキーです。
このキーは、Azure ポータル上で QnA Maker のリソースを作成した際に生成されます。 QnA Maker アプリは、Azure 上にリソースを作ってからでないと作成できないため、QnA Maker アプリがすでに存在するのであれば、サブスクリプションキーも必ず存在することになります。
Azule の QnA Maker リソースに割り当てられたサブスクリプションキーは、Azure ポータルの QnA Maker リソースの Keys のページで確認することができます。
図: Azure ポータル上での QnA Maker のサブスクリプションキーの確認 LUIS の場合は、アプリ管理用のキーはオーサリングキーと呼んでいたりしますが、それの QnA Maker 版だと考えればよいです。 QnA Maker アプリの場合、このキーの管理は Azure ポータル上で管理されることになっており、Azure 上ではこのようなキーのことをサブスクリプションキーと呼んでいるんですね。 このあたりのチグハグ感に関しては こちらを参照。
エンドポイントキー (Endpoint Key) エンドポイントキーは、チャットアプリなどのユーザクライアント（Bot Framework では「チャンネル」と呼びます）が、QnA Maker に対してクエリを行うときに使用するキーです。 エンドポイントキーは、QnA Maker ポータルで対象となるナレッジベースを選択後、PUBLISH タブから Publish 処理を実行したとき、あるいは SETTING タブを選択することで確認することができます。
図: QnA Maker ポータル上での QnA Maker のエンドポイントキーの確認 チャットボットなどから QnA Maker を利用する場合、実運用時に設定する API アクセス用のキーは、こっちのエンドポイントキーです。</description></item><item><title>gnuplot サンプル: グラフの形だけ表示する環境設定 (only_form.env)</title><link>https://maku.blog/p/h2swmzv/</link><pubDate>Thu, 05 Dec 2002 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h2swmzv/</guid><description> lib/only_form.env #---------------------------- # グラフの形だけ表示する環境 #---------------------------- # マージンを枠が消えない程度になくす set lmargin 0 set rmargin 1 set tmargin 1 set bmargin 0 # 目盛りを消す set noxtics set noytics # 軸の名前を消す set nokey</description></item><item><title>QnA Maker (3) Node.js から QnA Maker の API を利用する</title><link>https://maku.blog/p/rgnvp2r/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rgnvp2r/</guid><description>QnA Maker API を呼び出すためのエンドポイント情報を調べる QnA Maker ナレッジベースの Publish REST API を使用して QnA Maker のナレッジベースを使用するためには、QnA Maker ポータル上で対象のナレッジベースを Publish しておく必要があります。
Publish 処理が完了すると、ナレッジベースにアクセスするための Endpoint key が発行されます。
curl での QnA Maker API の呼び出しテスト 任意の質問文に対する回答文を得るには、REST API として下記のような HTTP POST リクエストを送ります。
curl -X POST https://xxx.azurewebsites.net/qnamaker/knowledgebases/＜ナレッジベースID＞/generateAnswer -H &amp;#34;Authorization: EndpointKey ＜上記で発行したキー＞&amp;#34; -H &amp;#34;Content-type: application/json&amp;#34; -d &amp;#34;{&amp;#39;question&amp;#39;:&amp;#39;&amp;lt;質問文&amp;gt;&amp;#39;}&amp;#34; Linux の curl コマンドを使用できる環境であれば、上記のように実行するだけで JSON 形式のレスポンスを確認することができます。
Node.js から QnA Maker の REST API を呼び出す Node.js から HTTP POST リクエストを送って JSON レスポンスを取得してみます。 HTTP リクエストを行うためのモジュールとして、ここでは request モジュールを使用します。 JavaScript ファイルを作成するディレクトリと同じディレクトリ内で、下記のようにインストールしておいてください。</description></item><item><title>gnuplot サンプル: 関数のある点から x軸、y軸に向かって線を引く (cross_line.gp)</title><link>https://maku.blog/p/arfdp4b/</link><pubDate>Wed, 04 Dec 2002 00:00:00 +0000</pubDate><guid>https://maku.blog/p/arfdp4b/</guid><description> lib/cross_line.gp # # 関数のある点から x軸、y軸に向かって線を引きます。 # f(x) に対象の関数を指定し、x 座標を指定します。 # # 使用例: # f(x) = sin(x) # call &amp;#39;lib/cross_x.gp&amp;#39; &amp;#39;pi/4&amp;#39; # plot [-pi:pi] f(x) # set arrow from $0, 0 to $0, f($0) nohead lt 3 lw 3 set arrow from 0, f($0) to $0, f($0) nohead lt 3 lw 3 set zeroaxis</description></item><item><title>QnA Maker (4) Python から QnA Maker の API を利用する</title><link>https://maku.blog/p/fwyi2fh/</link><pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fwyi2fh/</guid><description>QnA Maker は REST API を提供しているので、HTTP リクエストを発行できるプログラミング言語から簡単に制御することができます。 ここでは、Python に標準で付属している urllib.request モジュールを使って HTTP リクエストを発行し、QnA Maker にアクセスしてみます。
事前準備（アクセスキーの準備） REST API を使用するには、HTTP リクエストのヘッダ情報としてアクセスキーを付加する必要があります。 こちらの記事 を参考に、下記のどちらかのアクセスキーを確認しておいてください。
サブスクリプションキー (Subscription Key) &amp;hellip; 管理用 エンドポイントキー (Endpoint Key) &amp;hellip; クエリ用 アクセスキーは 9d16b3e6345489ad4a57a0755eb4f96a のような 16 進数文字列です。 QnA のクエリ実行だけであればエンドポイントキーの方を使えば大丈夫ですが、ナレッジベースの作成や更新などを行う場合は、サブスクリプションキーの方を使う必要があります。
QnA Maker の REST API を呼び出す Python ライブラリ REST API は HTTP リクエストを送るだけで使用できるので、ここでは自力で QnA Maker の API を使用するライブラリを作ってみます。
下記の QnaRequest クラスは、ナレッジベースの一覧を取得する getAllKnowledgeBases メソッドと、指定したナレッジベースの情報を取得する getKnowledgeBase メソッドを提供しています。 戻り値は JSON 形式のテキストです。
mylib/qna.py import urllib.request class QnaRequest: BASE_URL = &amp;#39;https://westus.</description></item><item><title>gnuplot サンプル: いろんなグラフ用の関数 (functions.gp)</title><link>https://maku.blog/p/e2h3dg4/</link><pubDate>Fri, 06 Dec 2002 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e2h3dg4/</guid><description> lib/functions.gp # # Gabor のマザー・ウェーブレット # # 使用例: # plot [-20:20] gabor_mother(x, 8) # gabor_mother(x,sigma) = (1/(2*sqrt(pi)*sigma)) * exp(-x**2/sigma**2) * cos(x) # # メキシカン・ハット # mexican_hat(x) = (1-2*x**2)*exp(-x**2) # # 正規分布 # # 1 # f(x) = ----------- e ^(- (x-μ)^2 / 2σ^2) # √(2π)σ # # σ … 散らばり具合 -- a # μ … 平均値 -- b # # # 使用例： # plot normal_distribution(x, 3, 0) # normal_distribution(x, a, b) = exp(-((x-b)**2)/(2*(a**2))) / sqrt(2*pi)*a # シグモイド関数 sigm(x) = 1 / (1 + exp(-x))</description></item><item><title>gnuplot: スクリプト内での有限ループの書き方</title><link>https://maku.blog/p/92s2tau/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/92s2tau/</guid><description>ループ処理の回数を有限にするには、1 つのファイルでループ終了判定用変数を設定し、その中からループ処理を行うファイルを呼び出します。
loop_test.gp i = 0 call &amp;#39;sub.gp&amp;#39; sub.gp i = i + 1 print i if (i &amp;lt; 10) reread 上の 2 つのファイルを用意し、 次のようにすると、1～10 までを表示します。
call &amp;#39;loop_test.gp&amp;#39;</description></item><item><title>gnuplot: gnuplot を計算機として使う (print)</title><link>https://maku.blog/p/23a8fgp/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/23a8fgp/</guid><description>gnuplot の print コマンドを使えば、簡易電卓として使用できます。
例: e^x の値を表示 print exp(x)</description></item><item><title>gnuplot: gnuplot のテスト表示を行う (test)</title><link>https://maku.blog/p/sc7r4wm/</link><pubDate>Sat, 03 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sc7r4wm/</guid><description>gnuplot による描画をテストするためのコマンドとして test コマンドが用意されています。
表示サンプル gnuplot&amp;gt; test 図: test コマンドの出力</description></item><item><title>プロキシ環境から Electron をインストールできない場合の対処方法</title><link>https://maku.blog/p/t7gqxyf/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t7gqxyf/</guid><description>問題 プロキシ環境下で、Electron (9.0.5) をインストールしようとしたら、まぁいろいろとエラーになってハマりました。 どうも、node install.js の実行がうまくいっていないようです。
D:\sandbox&amp;gt; npm install electron --save-dev &amp;gt; core-js@3.6.5 postinstall D:\sandbox\node_modules\core-js &amp;gt; node -e &amp;#34;try{require(&amp;#39;./postinstall&amp;#39;)}catch(e){}&amp;#34; &amp;gt; electron@9.0.5 postinstall D:\sandbox\node_modules\electron &amp;gt; node install.js RequestError: read ECONNRESET at ClientRequest.&amp;lt;anonymous&amp;gt; (D:\sandbox\node_modules\got\source\request-as-event-emitter.js:178:14) at Object.onceWrapper (events.js:422:26) at ClientRequest.emit (events.js:327:22) at ClientRequest.origin.emit (D:\sandbox\node_modules\@szmarczak\http-timer\source\index.js:37:11) at TLSSocket.socketErrorListener (_http_client.js:467:9) ... ECONNRESET ってことはプロキシの設定かなぁと思ったけど、プロキシは npm config set proxy ... でちゃんとセットしているし、なんだろう。。。
解決方法 と調べていたら、下記の Electron のチュートリアルに書いてありました。
Installation - Proxies | Electron If you need to use an HTTP proxy, you need to set the ELECTRON_GET_USE_PROXY variable to any value, plus additional environment variables depending on your host system&amp;rsquo;s Node version.</description></item><item><title>AWS CloudFormation の設定例: SNS トピックを Lambda 関数からサブスクライブする</title><link>https://maku.blog/p/5q4epyb/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q4epyb/</guid><description>何をするか？ ここでは、CloudFormation (SAM) のテンプレートを使って、SNS トピックをサブスクライブする Lambda 関数を定義してみます。
サブスクライブ対象とする SNS トピック自体は、あらかじめ何らかの方法で作成済みであり、次のような ARN を取得できているものとします。
SNS トピックの ARN arn:aws:sns:ap-northeast-1:123456789012:mytopic 上記のような CloudFormation スタックが完成すると、マネージメントコンソールや CLI で SNS トピックのメッセージを発行して、Lambda 関数にイベントが届くことを確認できます。
参考リンク CloudFormation で SNS トピックの作成 CloudFormation の設定例: S3 通知を SNS トピックに Publish する テンプレートの記述例 次の SAM テンプレートでは、Lambda 関数を定義しつつ、そのイベントソースとして SNS トピックを設定しています。 イベントソースの指定は、実際には、SNS トピックに Lambda 関数をサブスクライブすることを意味しています。 SNS トピックの ARN は、入力パラメータ TopicArn のデフォルト値として指定しています。
template.yml AWSTemplateFormatVersion: 2010-09-09 Transform: AWS::Serverless-2016-10-31 Parameters: TopicArn: Type: String Default: arn:aws:sns:ap-northeast-1:123456789012:mytopic Resources: MyFunction: Type: AWS::Serverless::Function Properties: Runtime: python3.</description></item><item><title>React実装例: クリックで開閉可能なツリービューを作る</title><link>https://maku.blog/p/weow5dm/</link><pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/weow5dm/</guid><description>ここでは、React コンポーネントとして、開閉可能なツリービューを作ってみます。 コンポーネント名はツリーのノードを示す TreeNode です。
図: TreeNode コンポーネントの表示例 初期の表示内容としては、ルートの TreeNode を 1 つだけ配置し、そのラベルをクリックしたときに、子要素となる TreeNode を 3 つ生成して表示します。 実際のアプリケーションでは、このタイミングで GraphQL サーバーなどからデータを取得してツリー展開していく、といったことができると思います。
下記は TreeNode コンポーネントの実装です。
components/TreeNode.tsx import * as React from &amp;#39;react&amp;#39;; import styles from &amp;#39;./TreeNode.scss&amp;#39;; export const TreeNode: React.FC&amp;lt;{label: string}&amp;gt; = ({label}) =&amp;gt; { const [isOpen, setIsOpen] = React.useState(false); const [childNodes, setChildNodes] = React.useState(null); // チェックボックスのクリックで isOpen ステートを更新 const handleChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { setIsOpen(e.target.checked); } // isOpen ステートの変更を監視し、childNodes に子ノードとなる TreeNode をセットする React.</description></item><item><title>LUIS と QnA Maker でキーの管理方法が異なるのはなぜか？</title><link>https://maku.blog/p/8myms6s/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8myms6s/</guid><description>LUIS や QnA Maker サービスを利用するためのエンドポイントキーは、下記の 2 種類が提供されます。
実運用のためのキー: チャットクライアントなどからの、一般的な問い合わせを処理するためのキー。 管理用のキー: 各サービスの情報を取得したり、データを編集したりするためのキー。 LUIS も QnA Maker も便利なサービスなのですが、Azure リソースとの結びつけ方法や、キーの管理方法が異なっているため、最初はわけがわからなくなるかもしれません。 例えば、Azure ポータル上の RESOURCE MANAGEMENT / Keys のページで表示されるキー（サブスクリプションキー）が、LUIS の場合は実運用のためのキーであるのに対し、QnA Maker の場合は管理用のキー であったりします。
LUIS/QnA を使用する場合は、それぞれ、エンドポイントキーとしてどちらのキーを使用するかを間違えないようしなければいけません。
LUIS のサブスクリプションキー（実運用のためのキー）: Azure ポータルの LUIS リソースの Keys で表示されるもの LUIS のオーサリングキー（管理用のキー）: LUIS ポータルの Authoring Key で表示されるもの QnA Maker のエンドポイントキー（実運用のためのキー）: QnA Maker ポータルのプロファイル設定で表示されるもの QnA Maker のサブスクリプションキー（管理用のキー）: Azure ポータルの QnA Maker リソースの Keys で表示されるもの この時点で、キーの管理方法が QnA Maker と LUIS では完全に逆になっています。 Azure 上でのインタフェースは LUIS リソースと QnA Maker リソースで見た目が同じなので、混乱に拍車をかけています。</description></item><item><title>AWS CDK 入門: cdk コマンドのインストールから Hello World まで</title><link>https://maku.blog/p/nujyfsy/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nujyfsy/</guid><description>CDK とは AWS CDK (Cloud Development Kit) を使うと、TypeScript や Python を使って AWS リソースの生成を自動化することができます。 大きなプロジェクトでは、CloudFormation や SAM によるスタック生成用のテンプレートが長大になりがちですが、CDK を使うことで CloudFormation テンプレートの生成処理を隠蔽し、効率的にインフラ定義を行うことができます。 CDK の利点 をざっと挙げると以下のような感じです。
TypeScript、Python などのパワフルな言語機能を使ってインフラ定義を行うことができる。 各種リソース間の参照を、オブジェクトのプロパティ参照という自然な形で表現できる。 コンストラクト (Construct Library) という再利用可能なライブラリの提供により、様々なユースケースに対応した AWS リソース群を短いコードで定義できる。 VS Code (TypeScript) 、PyCharm (Python) などで型情報の補完が効くため、AWS リソースに設定可能なプロパティを見つけやすい。明らかに間違った設定はコンパイル時に気付くことができる。 Lambda 関数デプロイ時などに必要になる ZIP パッケージング、および S3 一時バケットの生成を自動で行ってくれる。 一方、CDK の欠点 としては、基本的に AWS に特化したツールであるため、Terraform や Serverless Framework のように様々なクラウド (Azure, AWS, GCP) に対応できないという点が挙げられます。 Terraform などの汎用ツールに比べて、CDK は学習コストも比較的高いです。 Azure なども同じツールで構築したいとか、それほど細かい制御は必要ないということであれば、Terraform などを使った方がいいかもしれません。 ただ、CDK を使っている限り、AWS の最新のリソースにも即対応できることが保証されますし、AWS CloudFormation に関しての知識は身につけやすいでしょう。
CDK Toolkit のインストール CDK によるデプロイには cdk コマンドを使用します。 まずはこのコマンドを使えるようにするため、aws-cdk パッケージをインストールします（CDK 本体の実行には Node.</description></item><item><title>Unityスクリプト: オブジェクトを移動する (Transform.position)</title><link>https://maku.blog/p/53o7p8p/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/53o7p8p/</guid><description>ゲームオブジェクトに設定された Transform コンポーネントを操作することで、ゲームオブジェクトを移動させることができます。 Transform コンポーネントのオブジェクトは下記のいずれかの方法で取得できます。
Transform tf = gameObject.GetComponent&amp;lt;Transform&amp;gt;(); Transform tf = gameObject.transform; Transform クラス には、ゲームオブジェクトを移動させるためのプロパティやメソッドが定義されています。
ワールド座標での位置 (Transform.position) Transform.position プロパティは、ワールド座標でのオブジェクトの位置を示します。 次の例では、3 つのオブジェクトの X 座標を -2、0、2 に設定しています。
using UnityEngine; public class Sample : MonoBehaviour { private void Start() { GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); GameObject sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere); GameObject capsule = GameObject.CreatePrimitive(PrimitiveType.Capsule); cube.transform.position = new Vector3(-2, 0, 0); sphere.transform.position = new Vector3(0, 0, 0); capsule.transform.position = new Vector3(2, 0, 0); } } += 演算子や -= 演算子を使用すれば、指定した数値分だけワールド座標での位置を移動できます。</description></item><item><title>WebGL入門 (1) WebGL コンテキストの取得</title><link>https://maku.blog/p/46jrh68/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/46jrh68/</guid><description>このブラウザは canvas タグに対応していません。 上記の canvas 要素は、WebGL により描画しています。 サーフェスをクリアしているだけなので、何も表示されていないのは正しいです。
WebGL のコンテキストを取得する WebGL は、Web ブラウザ上で OpenGL の機能を使用する仕組みです。 HTML の canvas 要素をレンダリング用のサーフェストとして使用します。 canvas 要素から WebGL のコンテキスト WebGLRenderingContext を取得したら、後は OpenGL ES を用いたアプリと同じ感覚で API を呼び出していけます。
下記は、WebGL でサーフェスをクリアするだけの最低限のコードです。 gl.clearColor() でクリア色を設定しています。
HTML &amp;lt;canvas id=&amp;#34;canvas&amp;#34; width=&amp;#34;300&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; JavaScript function main() { const canvas = document.getElementById(&amp;#39;canvas&amp;#39;); const gl = canvas.getContext(&amp;#39;webgl&amp;#39;); if (!gl) { console.error(&amp;#39;Failed to obtain WebGL context&amp;#39;); return; } gl.clearColor(0, 0, 0.5, 1.0); // RGBA（暗い青） gl.clear(gl.COLOR_BUFFER_BIT); } window.</description></item><item><title>Unityスクリプト: オブジェクトを回転する (Transform.rotation)</title><link>https://maku.blog/p/dx9is3c/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dx9is3c/</guid><description>ゲームオブジェクトに設定された Transform コンポーネントを操作することで、ゲームオブジェクトを回転させることができます。 Transform コンポーネントのオブジェクトは下記のいずれかの方法で取得できます。
Transform tf = gameObject.GetComponent&amp;lt;Transform&amp;gt;(); Transform tf = gameObject.transform; Transform クラス には、ゲームオブジェクトを回転させるためのプロパティやメソッドが定義されています。
ワールド座標での回転 (Transform.rotation) Transform.rotation プロパティは、ワールド座標でのオブジェクトの回転角度を示します。 次の例では、Y 軸（上下方向）を中心とした回転角度を 45° に設定しています。
using UnityEngine; public class Sample : MonoBehaviour { private void Start() { GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); cube.transform.rotation = Quaternion.Euler(0, 45, 0); } } Transform.rotation プロパティには Quaternion オブジェクト を設定するのですが、上記のように Quaternion.Euler() 関数 を使用すると、直感的に Quaternion オブジェクトを生成することができます。
ローカル座標での回転 (Transform.localRotation) オブジェクト自身の向きを考慮した軸（ローカル座標）での回転角度を設定するには、Transform.rotation プロパティの代わりに、 Transform.localRotation プロパティを使用します。
次の例では、親 Cube の上下に子 Cube を配置し、それぞれ Y 軸の回転角度として 30° を設定しています。 ただし、上の Cube は localRotation プロパティ、下の Cube は rotation プロパティで回転角度を設定しています。</description></item><item><title>WebGL入門 (2) シェーダーを使用する</title><link>https://maku.blog/p/8s4uhzv/</link><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8s4uhzv/</guid><description>このブラウザは canvas タグに対応していません。 上記の canvas 要素は、WebGL により描画しています。 canvas の中央に 1 つの点を表示しています。
シェーダーを使うまでの手順 WebGL は OpenGL ES 2.0、WebGL 2.0 は OpenGL ES 3.0 をベースに策定されているため、プリミティブをレンダリングするには、どちらも GLSL ES 言語で記述したシェーダーコード（頂点シェーダー、フラグメントシェーダー）を用意する必要があります。
シェーダーを使用して描画するまでの流れは下記のようになります。
シェーダーオブジェクトの準備（頂点シェーダーとフラグメントシェーダー） シェーダーオブジェクトを作成する (gl.CreateShader) シェーダーコードを設定する (gl.ShaderSource) シェーダーコードをコンパイルする (gl.CompileShader) 必要があればコンパイル結果のチェック (gl.getShaderParameter) 必要があればコンパイルエラーの内容を出力 (gl.getShaderInfoLog) プログラムオブジェクトの準備 プラグラムオブジェクトを作成する (gl.CreateProgram) 2 つのシェーダーオブジェクトをアタッチする (gl.AttachShader) 2 つのシェーダーオブジェクトをリンクする (gl.LinkProgram) 必要があればリンク結果のチェック (gl.getProgramParameter) 必要があればリンクエラーの内容を出力 (el.getProgramInfoLog) レンダリング前に使用するプログラムオブジェクトを選択する (gl.UseProgram) 頂点情報などを用意して描画 (gl.drawArrays) ユーティリティ関数の作成 シェーダーオブジェクトの準備 (createShader) 指定したシェーダーコードをコンパイルしてシェーダーオブジェクトを作成する createShader 関数を作成します。
/** * シェーダーコードをコンパイルしてシェーダーオブジェクトを作成します。 * 作成に失敗した場合は null を返します。 * * @param gl WebGL コンテキスト * @param type gl.</description></item><item><title>Azure 関連のアイコン集</title><link>https://maku.blog/p/bqodqji/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bqodqji/</guid><description>Azure 関連アイコンのダウンロード Microsoft Azure 関連のアイコンは下記のサイトからダウンロードできるようになっています。 PNG 形式や SVG 形式のファイルが入っているので、Azure 関連の構成図を作成するときに便利です。
Download Microsoft Azure, Cloud and Enterprise Symbol / Icon Set 例えばこーゆーアイコンがたくさん入っています。
アイコン 説明 Azure App Service - Web App Azure Cognitive Services Azure Cognitive Services - LUIS 全アイコンのリスト 上記のパッケージに含まれているアイコンを一覧表示できる HTML ファイルを用意しました。
icons.zip アーカイブを展開して、azure-icons/all_icons.html を開くと、下記のように全アイコンを一覧表示することができます。 ここから PowerPoint などにコピペして使うのも簡単です。</description></item><item><title>Unityスクリプト: オブジェクトを拡大縮小する (Transform.localScale)</title><link>https://maku.blog/p/neuatgr/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/neuatgr/</guid><description>ゲームオブジェクトに設定された Transform コンポーネントを操作することで、ゲームオブジェクトを拡大縮小することができます。 Transform コンポーネントのオブジェクトは下記のいずれかの方法で取得できます。
Transform tf = gameObject.GetComponent&amp;lt;Transform&amp;gt;(); Transform tf = gameObject.transform; オブジェクトの拡大率を指定する (Transform.localScale) オブジェクトの拡大縮小の設定は Transform.localScale プロパティで行います。 位置の設定 (position) や 回転角度の設定 (rotation) には、ワールド座標とローカル座標の区別がありますが、拡大縮小には、localScale の一種類しかないのでシンプルです。
次の例では、Cube オブジェクトを X 軸方向に 4 倍、Y 軸方向に 0.5 倍、Z 軸方向に 2 倍に拡大縮小しています。
using UnityEngine; public class Sample : MonoBehaviour { private void Start() { GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); cube.transform.localScale = new Vector3(4, 0.5f, 2); } } 全ての軸に同じ比率だけ拡大縮小したいのであれば、Vector3(1, 1, 1) を示す定数 Vector3.one を使って次のように記述できます。
cube.transform.localScale = Vector3.one * 2; 拡大率は親の拡大率を引き継ぐ オブジェクトが親子関係があるとき、Transform.</description></item><item><title>WebGL入門 (3) バッファーオブジェクトで頂点座標をシェーダーへ送る (VBO)</title><link>https://maku.blog/p/ogk9ogw/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ogk9ogw/</guid><description>このブラウザは canvas タグに対応していません。 はじめに WebGL (OpenGL) でアプリケーション側 (CPU) のコードから、シェーダー側 (GPU) へ図形の頂点情報を送るには、バッファーオブジェクト (Buffer Object) の仕組みを使用します。 WebGL 側に確保したバッファーオブジェクトに、頂点座標の配列データをまとめて書き込んでおいて、最後に描画開始要求を送ることで、CPU と GPU 間の通信回数を抑えることができます。 頂点座標を格納するために確保したバッファーオブジェクトのことを、特に VBO (Vertext Buffer Object) と呼んだりします。
WebGL でバッファーオブジェクトを使って図形を描画するまでの流れは以下のようになります。
WebGL 側にバッファーオブジェクトを作成する gl.createBuffer() バッファーオブジェクトをターゲットとバインドする gl.bindBuffer() バッファーオブジェクトに頂点情報を転送する gl.bufferData() 頂点シェーダーの attribute 変数でそのデータを1つずつ取り出せるようにする gl.getAttribLocation() gl.vertexAttribPointer() gl.enableVertexAttribArray() 描画要求を送る gl.drawArrays() 以下、単純な三角形を描画するまでの手順を示します。
バッファーオブジェクトを作成する まず、WebGL 側に頂点情報を格納するためのバッファーオブジェクトを生成します。 これは、gl.createBuffer() をパラメータなしで呼ぶだけなので簡単です。
const vertexBuffer = gl.createBuffer(); if (!vertexBuffer) { throw Error(&amp;#39;Failed to create the buffer object.&amp;#39;); } バッファーオブジェクトをターゲットにバインドする バッファーオブジェクトを作成したら、gl.bindBuffer() を使って、そのバッファーオブジェクトをターゲットとバインドします。 ターゲットというのは、そのバッファーオブジェクトをどのような用途で使用するかを示すためのもので、頂点属性のために確保したのであれば、gl.ARRAY_BUFFER というターゲットとバインドします。 頂点属性というのは、「頂点座標」、「頂点カラー」、「テクスチャ座標」などのことで、ここでは頂点座標だけを扱います。</description></item><item><title>WebGL入門 (4) 頂点属性をインターリーブしてバッファオブジェクトに格納する</title><link>https://maku.blog/p/wqjqbpi/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wqjqbpi/</guid><description>このブラウザは canvas タグに対応していません。 インターリーブとは インターリーブ (interleave) とは、一般的なコンピュータ用語で、データを交互に配置していくことを示します。 例えば、3D モデルの各頂点の「XY座標」「RGBカラー」をインターリーブして配列に詰めると、3 つの頂点の情報は、
X Y R G B X Y Z G B X Y R G B ... のようにレイアウトされることになります。
WebGL (OpenGL) では、このようにインターリーブされた頂点属性データを扱えるようになっています。 インターリーブする主な頂点属性は、頂点座標 (XYZ)、テクスチャ座標 (UV)、頂点カラー (RGBA) などです。
ここでは、頂点座標 (XY) と頂点カラー (RGB) をインターリーブした配列を JavaScript 側の Float32Array として作成し、それを WebGL 側のバッファオブジェクトに詰める方法を示します。
シェーダー側の実装 まずは、頂点シェーダーとフラグメントシェーダーを用意します。
頂点シェーダー attribute vec4 a_Position; // 入力（XY座標） attribute vec4 a_Color; // 入力（RGAカラー） varying vec4 v_Color; // 出力（RGAカラー） void main() { gl_Position = a_Position; v_Color = a_Color; } 頂点シェーダーでは、バッファオブジェクトから XY 座標を取り出すための attribute 変数 a_Position と、RGB カラーを取り出すための a_Color を定義します。 カラー値は最終的にはフラグメントシェーダー側で必要になるので、varying 変数の v_Color を介して値をフラグメントシェーダーへ渡します。</description></item><item><title>WebGL入門 (5) 三角形の 3 つの描画モード</title><link>https://maku.blog/p/9sxkmma/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9sxkmma/</guid><description>gl.drawArrays() や gl.drawElements で図形を描画するとき、第1引数で頂点をどのように使用するかの描画モードを指定します。 OpenGL ES では、四角形を描画することはできないので、面を表現するときには、三角形の組み合わせで描画することになります。 三角形の描画モードには、下記の 3 種類があります。
gl.TRIANGLE - 各三角形は頂点を共有しない gl.TRIANGLE_STRIP - ジグザグに頂点が配置されていると想定 gl.TRIANGLE_FAN - 扇形に頂点が配置されていると想定 gl.TRIANGLE は、隣接する面の描画においても、独立した頂点データが必要です。 よって、基本的には gl.TRIANGLE_STRIP か gl.TRIANGLE_FAN を使うのがよいのですが、多くの環境では gl.TRIANGLE_STRIP の描画効率がよいようです。
下記は、gl.drawArrays() に gl.TRIANGLE_STRIP を指定して 4 つの三角形を描画した例です。
このブラウザは canvas タグに対応していません。 コードでは、下記のように頂点座標と頂点カラーを定義しています。
const vertices = new Float32Array([ -1.0, 0.5, 1.0, 0.0, 0.0, // v0 (XYRGB) 赤 -0.6, -0.5, 0.0, 1.0, 0.0, // v1 (XYRGB) 緑 0.2, 0.5, 0.0, 0.0, 1.0, // v2 (XYRGB) 青 0.</description></item><item><title>WebGL入門 (6) インデックスバッファを使って頂点を使い回す (drawElements)</title><link>https://maku.blog/p/wbvv3ha/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wbvv3ha/</guid><description>インデックスバッファを用いた描画の概要 gl.drawArrays() による描画には、3 つの三角形の描画モードがあり、連なった三角形を描画するときには、gl.TRIANGLE_STRIP あるいは gl.TRIANGLE_FAN の描画モードを使用すると、頂点情報を使い回しながら効率的に描画することができます。
ただし、図形が少し複雑になってくると、一度の gl.drawArrays() 呼び出しではうまく描画できなくなってきます。 例えば次のような 3 つの三角形（トライフォース）を描画することを考えてみます。
面 A、B、C は独立した三角形に見えるので、それぞれに 3 つの頂点（合計 9 頂点）を用意して gl.drawArrays() の gl.TRIANGLES モードでレンダリングすればよさそうですが、頂点 1、2、4 に関しては座標が同じなので、本来であれば上記のように 6 つの頂点情報を用意するだけで足りそうです。 このような場合は、インデックスバッファと gl.drawElements() を使用すると、効率的な描画を行えます。
頂点バッファオブジェクト (VBO) に座標情報を入れておくのは gl.drawArrays() を使った場合と同様ですが、もう一つ別のバッファオブジェクトとして、インデックスバッファオブジェクト (IBO: Index Buffer Object) を作成します。 IBO には、VBO 内のどの頂点情報を使って図形描画を行うかを示す、頂点インデックスの情報を格納します。
頂点バッファオブジェクト (VBO) 頂点情報（座標、色など）を重複しないように格納する。 上記の例では、頂点 0～5 の 6 つの頂点情報を格納する。 インデックスバッファオブジェクト (IBO) 図形描画に VBO 内のどの頂点情報を使うかを示すインデックス配列。 上記の例では、面Aは 0,1,2、面Bは 1,3,4、面Cは 2,4,5 の頂点を使用するという情報。一次元で、0,1,2,1,3,4,2,4,5 と格納すればよい。 実装 このブラウザは canvas タグに対応していません。 ここでは、各頂点に異なる色をつけたトライフォースを描画してみます。
頂点バッファオブジェクト (VBO) を作成する const vertices = new Float32Array([ 0.</description></item><item><title>AWS CDK メモ: ブートストラップ処理を実行する (cdk bootstrap)</title><link>https://maku.blog/p/q7q8p6m/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7q8p6m/</guid><description>CloudFormation のスタックを生成するときに、一時的なファイル置き場として S3 バケットが必要になることがあります。 例えば、Lambda 関数をデプロイするときに、ZIP パッケージを置くためのステージングバケットが必要になります。 このステージングバケットへの実際のアップロード処理は CDK が自動でやってくれるのですが、バケットの準備だけはあらかじめ手動で行っておく必要があります。 このためのコマンドが cdk bootstrap コマンドです。 AWS アカウント（およびリージョン）内で一度だけ実行しておけばよいので、このタイミングで実行しておきます。 実行時には次のように「アカウント番号」と「リージョン名」を指定する必要があります。
cdk bootstrap aws://&amp;lt;アカウント番号&amp;gt;/&amp;lt;リージョン名&amp;gt; 実際の実行例 $ cdk bootstrap aws://123456789012/ap-northeast-1 ⏳ Bootstrapping environment aws://123456789012/ap-northeast-1... CDKToolkit: creating CloudFormation changeset... ... ✅ Environment aws://123456789012/ap-northeast-1 bootstrapped. これにより、ステージング用のバケットを含む CDKToolkit という名前のブートストラップ・スタックが生成されます。
ちなみに、現在使用している「アカウント番号」と「リージョン名」は、AWS CLI を使って次のように確認できます。
アカウント番号の確認 $ aws sts get-caller-identity --output text --query Account [--profile xxxx] 123456789012 リージョン名の確認 $ aws configure get region [--profile xxxx] ap-northeast-1</description></item><item><title>AWS CDK メモ: コンストラクトの概念を理解する</title><link>https://maku.blog/p/nqkav2m/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nqkav2m/</guid><description>コンストラクト・ツリー (Construct Tree) AWS CDK を使って CloudFormation スタックを作成するとき、そのリソース構成は、論理的な コンストラクト (construct) のツリー構造によって表現します。 下記は、典型的な CDK アプリケーションにおけるコンストラクト・ツリー構造です。
App +-- Stack | +-- Construct | +-- Construct | +-- ... +-- Stack +-- Construct | +-- Construct | +-- Construct +-- Construct +-- ... App、Stack、Construct はそれぞれ抽象度の異なるオブジェクトですが、すべて IConstruct インタフェース を実装したコンストラクトの一種です。 CDK アプリ―ケーションには、構成のエントリポイントとなる App コンストラクト が 1 つあり、複数の Stack コンストラクトを含むことができます。
Stack コンストラクト は、その名の通り CloudFormation スタックを表現するコンストラクトです。 App が複数の Stack から構成されている場合、cdk deploy コマンドでデプロイを実行したときに複数の CloudFormation スタックが生成されることになります。 cdk deploy &amp;lt;Stack名&amp;gt; とすれば、特定のスタックのみをデプロイすることも可能です。 指定可能な Stack 名の一覧を確認したいときは、cdk ls コマンドを使います。</description></item><item><title>AWS CDK メモ: CDK アプリのパッケージ管理に Yarn を使う方法</title><link>https://maku.blog/p/4h3jygw/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4h3jygw/</guid><description>cdk init app --language typescript で CDK アプリのひな型を生成すると、デフォルトではパッケージマネージャーとして NPM を使う想定になっています（package-lock.json などが作成されます）。 NPM の代わりに Yarn を使いたい場合は、次のように package-lock.json を削除して、yarn.lock ファイルを生成します。
$ git rm package-lock.json $ yarn install 生成された yarn.lock は忘れずに Git へコミットしてください。
ちなみに、package-lock.json が残っている状態で yarn install しようとすると、次のような感じの Warning が表示されます。
warning package-lock.json found. Your project contains lock files generated by tools other than Yarn. It is advised not to mix package managers in order to avoid resolution inconsistencies caused by unsynchronized lock files. To clear this warning, remove package-lock.</description></item><item><title>AWS CDK メモ: 謎の CDKMetadata を生成しないようにする</title><link>https://maku.blog/p/2asq4k4/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2asq4k4/</guid><description>AWS CDK で CloudFormation スタックを生成すると、デフォルトで CDKMetadata というリソースが生成されます（cdk synth コマンドで CloudFormation テンプレートを出力してみると確認できます）。
Resources: CDKMetadata: Type: AWS::CDK::Metadata Properties: Analytics: v2:deflate64:IsH4AAAAAAAA/L9ZNTs....9mAAAA Metadata: aws:cdk:path: CdkStack/CDKMetadata/Default Condition: CDKMetadataAvailable Conditions: CDKMetadataAvailable: Fn::Or: - Fn::Or: - Fn::Equals: - Ref: AWS::Region - af-south-1 - Fn::Equals: - Ref: AWS::Region - ap-east-1 ... 自分で何もリソース生成していないのにテンプレートが汚されて邪魔だなぁと思っていたら、この情報は、CDK を開発しているチームが利用状況などを把握して今後の改善のために使うようです。 下記、CDK のドキュメント より抜粋。
Every generated template contains a AWS::CDK::Metadata resource by default. (We haven&amp;rsquo;t shown it here.) The AWS CDK team uses this metadata to gain insight into how the AWS CDK is used, so we can continue to improve it.</description></item><item><title>AWS CDK で TypeScript で実装した Lambda 関数をデプロイする (NodejsFunction)</title><link>https://maku.blog/p/cj9i4m3/</link><pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cj9i4m3/</guid><description>何をするか？ ここでは、CDK アプリとして作成した CloudFormation スタック内に、TypeScript で実装した Lambda 関数 を追加してみます。 Lambda 関数のビルドもデプロイ時に自動で行われるようにします。
以降の説明では、CDK プロジェクトの作成自体は済んでいるものとします。
参考: AWS CDK 入門: cdk コマンドのインストールから Hello World まで TypeScript で Lambda 関数を実装する Lambda 関数のコードは、プロジェクトのルートに lambda ディレクトリを作成して、そこに配置していくことにします。
myapp/ +-- bin/ ... CDK の App コンストラクト (.ts) +-- lambda/ ... ラムダ関数の実装コード (.ts) ★これを追加 | +-- index.ts +-- lib/ ... CDK の Stack コンストラクトなど (.ts) ... Lambda 関数実装用の TypeScript 型情報をインストールします。
$ npm install @types/aws-lambda --save-dev # npm の場合 $ yarn add @types/aws-lambda --dev # yarn の場合 最低限の Hello World 的なラムダ関数を作成します。</description></item><item><title>AWS CDK で Go 言語で実装した Lambda 関数をデプロイする (GoFunction)</title><link>https://maku.blog/p/38jt3cm/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38jt3cm/</guid><description>何をするか？ ここでは、CDK アプリとして作成した CloudFormation スタック内に、Go 言語で実装した Lambda 関数 を追加してみます。 Lambda 関数のビルドもデプロイ時に自動で行われるようにします。
CDK のプロジェクト自体（スタックを定義する CDK コード）は TypeScript で作成します。 以降の説明では、CDK プロジェクトの作成自体は済んでいるものとします。
参考: AWS CDK 入門: cdk コマンドのインストールから Hello World まで Go 言語で Lambda 関数を実装する Lambda 関数のコードは、プロジェクトのルートに lambda ディレクトリを作成して、そこに配置していくことにします。
myapp/ +-- bin/ ... CDK の App コンストラクト (.ts) +-- lambda/ ... ラムダ関数用のディレクトリ (.go) | +-- go.mod | +-- go.sum | +-- main.go +-- lib/ ... CDK の Stack コンストラクトなど (.ts) ... lambda ディレクトリの下で、Go パッケージの依存情報 (go.</description></item><item><title>AWS CDK のサンプルコード集（TypeScript 版）</title><link>https://maku.blog/p/gzkzbny/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gzkzbny/</guid><description>AWS CDK を使った TypeScript サンプルコードいろいろです。
リソースにタグを付ける import * as cdk from &amp;#39;@aws-cdk/core&amp;#39; import { MyappStack } from &amp;#39;../lib/myapp-stack&amp;#39; const app = new cdk.App() new MyappStack(app, &amp;#39;MyappStack&amp;#39;, { tags: { Owner: &amp;#39;TeamA&amp;#39;, Purpose: &amp;#39;Project1&amp;#39;, }, }) AWS リソース用のコンストラクトの props パラメーターで、tags プロパティを指定することで、そのリソースにタグを設定できます。
タグの設定方法は、どの AWS リソース用のコンストラクトでも同様です。 上記のように Stack コンストラクトに対してタグを設定すると、その中に配置した AWS リソースにもそのタグが設定されます。
S3 バケットや DynamoDB テーブルをスタック削除時に自動削除する バケットが空のときだけ自動削除する import * as cdk from &amp;#39;@aws-cdk/core&amp;#39; import * as s3 from &amp;#39;@aws-cdk/aws-s3&amp;#39; new s3.Bucket(this, &amp;#39;MyBucket&amp;#39;, { removalPolicy: cdk.</description></item><item><title>D3.js でボタンなどの入力要素を扱う</title><link>https://maku.blog/p/s5zrgp3/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s5zrgp3/</guid><description>D3.js は主に SVG の描画に使われるライブラリですが、一般的な DOM 要素のイベントをハンドルするためにも使用できます。 ここでは、ボタンやテキスト入力要素を D3.js で扱う例を示します。
次の例では、ボタン (button) をクリックしたときに、その独自属性 (data-color) にセットされた値を取り出しています。 この仕組みを利用すれば、ボタンを押したときに SVG の表示内容を切り替えるといったことが可能です。
Green Yellow Red ボタンを押してみて
&amp;lt;div id=&amp;#34;buttonContainer&amp;#34;&amp;gt; &amp;lt;button data-color=&amp;#34;g&amp;#34;&amp;gt;Green&amp;lt;/button&amp;gt; &amp;lt;button data-color=&amp;#34;y&amp;#34;&amp;gt;Yellow&amp;lt;/button&amp;gt; &amp;lt;button data-color=&amp;#34;r&amp;#34;&amp;gt;Red&amp;lt;/button&amp;gt; &amp;lt;p id=&amp;#34;message&amp;#34;&amp;gt;ボタンを押してみて&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34;&amp;gt; import * as d3 from &amp;#34;https://cdn.jsdelivr.net/npm/d3@7/+esm&amp;#34;; d3.selectAll(&amp;#34;#buttonContainer button&amp;#34;) .on(&amp;#34;click&amp;#34;, function() { const color = d3.select(this).attr(&amp;#34;data-color&amp;#34;) d3.select(&amp;#34;#message&amp;#34;).text(`選択したカラーコード = ${color}`) }) &amp;lt;/script&amp;gt; 上記の例では、click ハンドラーの中で、d3.select() を使って D3 セレクションオブジェクトを生成していますが、次のように従来の DOM API だけを使って記述することも可能です。
.on(&amp;#34;click&amp;#34;, (event) =&amp;gt; { const color = event.target.dataset[&amp;#34;color&amp;#34;] // button の data-color の値を取得 document.</description></item><item><title>D3.js で各要素から任意のデータを取り出す (datum)</title><link>https://maku.blog/p/8m4drzr/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8m4drzr/</guid><description>図: D3 セレクションのデータを参照する D3 セレクションオブジェクトの datum() メソッドを使うと、任意のデータ（オブジェクト）を紐づけて、後から自由に参照できるようになります。 例えば、任意の要素上でマウスイベントが発生した場合に、その要素のデータを参照するというのが典型的な使用方法です。 D3 セレクションオブジェクトに紐づけられたデータを参照するときは、datum() メソッドを引数なしで呼び出します。 D3.js で複数要素をまとめて追加する際には data() メソッドを使用しますが、それでセットしたデータも datum() メソッドで参照することができます。
下記の例では、3 つの circle 要素のデータとして、name プロパティと color プロパティを持つ独自のオブジェクトを紐づけています。
&amp;lt;svg id=&amp;#34;svg-vmhww5v&amp;#34; w=&amp;#34;200&amp;#34; h=&amp;#34;100&amp;#34; /&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-vmhww5v&amp;#34;); // 3 つの circle 要素に紐づけるデータ const data = [ { name: &amp;#34;circle-1&amp;#34;, color: &amp;#34;cyan&amp;#34; }, { name: &amp;#34;circle-2&amp;#34;, color: &amp;#34;yellow&amp;#34; }, { name: &amp;#34;circle-3&amp;#34;, color: &amp;#34;magenta&amp;#34; }, ]; // 情報表示用の text 要素 const text = svg.</description></item><item><title>D3.js でマウスイベントを扱う (click, mousemove, mouseover, mouseout)</title><link>https://maku.blog/p/ffz4v3w/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ffz4v3w/</guid><description>D3.js でマウスイベントを扱うコードのサンプルです。
click イベント 図: click イベントをハンドルする D3.js でマウスのクリックイベントをハンドルするには、D3 Selection オブジェクトに click イベントハンドラを追加します。 上記の svg 要素内でクリックすると、その座標にピンク色の円が表示されます。
&amp;lt;svg id=&amp;#34;svg-vwuifrt&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;100&amp;#34; /&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-vwuifrt&amp;#34;); // D3 Selection オブジェクトを取得 svg.on(&amp;#34;click&amp;#34;, (event) =&amp;gt; { const [x, y] = d3.pointer(event) svg.append(&amp;#34;circle&amp;#34;) .attr(&amp;#34;cx&amp;#34;, x) .attr(&amp;#34;cy&amp;#34;, y) .attr(&amp;#34;r&amp;#34;, 10) .attr(&amp;#34;fill&amp;#34;, &amp;#34;deeppink&amp;#34;) .style(&amp;#34;fill-opacity&amp;#34;, 0.5) }) &amp;lt;/script&amp;gt; event.clientX や event.clientY でマウスカーソルの座標値を取得してしまうと、ブラウザのクライアント領域全体の座標値になってしまうので、d3.point() で svg 要素内の座標値に変換するところがポイントです。
mousemove イベント 図: mousemove イベントをハンドルする D3.js でマウスカーソルを動かしたときのイベントをハンドルするには、D3 Selection オブジェクトに mousemove イベントハンドラを追加します。 上記の svg 要素内でマウスカーソルを動かすと、現在の座標値を表示します。</description></item><item><title>SVG チートシート</title><link>https://maku.blog/p/kq6gwfn/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kq6gwfn/</guid><description>text 要素（テキストの描画） 属性 説明 値の例 x テキストアンカーポイントの X 座標 100, 50% y テキストアンカーポイントの Y 座標 100, 50% text-anchor 水平方向のアンカーポイント * start &amp;hellip; テキスト先頭（ltr 言語なら左端）
* middle &amp;hellip; 中央* end &amp;hellip; テキスト末尾（ltr 言語なら右端） dominant-baseline 垂直方向のベースライン * auto &amp;hellip; 通常は下端* middle &amp;hellip; 中央* hanging &amp;hellip; 通常は上端 font-size フォントサイズ 30 font-weight 文字の太さ 600 fill テキスト内部の色 redrgb(39, 250, 102)#ff0033 stroke テキスト周囲の線の色 red stroke-width テキスト周囲の線の太さ 2 text 要素の例 &amp;lt;text x=&amp;#34;100&amp;#34; y=&amp;#34;100&amp;#34; font-size=&amp;#34;30&amp;#34; fill=&amp;#34;blue&amp;#34;&amp;gt; 表示するテキスト &amp;lt;/text&amp;gt; text 要素のテクニック viewBox 内で水平方向に中央寄せする &amp;hellip; x=&amp;quot;50%&amp;quot; text-anchor=&amp;quot;middle&amp;quot; viewBox 内で垂直方向に中央寄せする &amp;hellip; y=&amp;quot;50%&amp;quot; dominant-baseline=&amp;quot;middle&amp;quot; line 要素（直線の描画） 属性 説明 x1 線の始点 X 座標 y1 線の始点 Y 座標 x2 線の終点 X 座標 y2 線の終点 Y 座標 stroke 線の色 stroke-width 線の太さ line 要素の例 &amp;lt;line x1=&amp;#34;0&amp;#34; y1=&amp;#34;0&amp;#34; x2=&amp;#34;50&amp;#34; y2=&amp;#34;30&amp;#34; stroke=&amp;#34;red&amp;#34; stroke-width=&amp;#34;3&amp;#34; /&amp;gt; rect 要素（矩形の描画） 属性 説明 x 矩形左上の X 座標 y 矩形左上の Y 座標 width 矩形の幅 height 矩形の高さ fill 塗りつぶし色。塗りつぶしを行わない場合、none あるいは transparent を指定できます。none の場合は場合はそこに何も存在しないかのように扱われます。mouseover などのイベントをハンドルする場合は、transparent の方を指定する必要があります。 stroke 枠線の色 stroke-width 枠線の太さ rx 角を丸くするときの半径（水平方向）。省略した場合は ry と同じ値が使われます。 ry 角を丸くするときの半径（垂直方向）。省略した場合は rx と同じ値が使われます。 rect 要素の例 &amp;lt;rect x=&amp;#34;10&amp;#34; y=&amp;#34;20&amp;#34; width=&amp;#34;100&amp;#34; height=&amp;#34;50&amp;#34; fill=&amp;#34;red&amp;#34; stroke=&amp;#34;blue&amp;#34; stroke-width=&amp;#34;2&amp;#34; /&amp;gt; circle 要素（円の描画） 属性 説明 cx 円の中央の X 座標 cy 円の中央の Y 座標 r 円の半径 fill 円の塗りつぶし色 stroke 円周の線の色 stroke-width 円周の線の太さ circle 要素の例 &amp;lt;circle cx=&amp;#34;50&amp;#34; cy=&amp;#34;50&amp;#34; r=&amp;#34;40&amp;#34; fill=&amp;#34;cyan&amp;#34; /&amp;gt; ellipse 要素（楕円の描画） 属性 説明 cx 楕円の中央の X 座標 cy 楕円の中央の Y 座標 rx 楕円の水平方向の半径 ry 楕円の垂直方向の半径 fill 塗りつぶし色 stroke 円周の線の色 stroke-width 円周の線の太さ circle 要素の例 &amp;lt;circle cx=&amp;#34;50&amp;#34; cy=&amp;#34;50&amp;#34; r=&amp;#34;40&amp;#34; fill=&amp;#34;cyan&amp;#34; /&amp;gt; その他 transform 属性 rotate(-65) &amp;hellip; 回転（text の場合、アンカーポイントを基準に回転） translate(100, 200) &amp;hellip; 平行移動 透過度は CSS の opacity で指定すればよい opacity: 0.</description></item><item><title>Svelte 応用: Svelte アプリを完全な静的サイトとしてビルドする (SSG: Static Site Generation)</title><link>https://maku.blog/p/4oudmxy/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4oudmxy/</guid><description>何をするか？ Svelte/SvelteKit を使ったプロジェクト全体を、完全な静的リソースの形にビルドする SSG (Static Site Genration) 機能の使い方について説明します。 AWS の S3 ストレージのようなファイルの配信機能しか持たないサービスで Web サイトをホスティングする場合、SSG によるビルドが必要になります。
ちなみに、Cloudflare Pages や Vercel のようなモダンなホスティングサービス上で Svelte アプリをビルドする場合は、このような設定は一切行わずにデプロイすることができます（ゼロコンフィグ）。 できればそういったサービスを使うことを推奨しますが、ここでは何らかの事情でそういった便利なサービスを使用できないケースを想定しています（会社のポリシーで S3 しか使えないなど）。
SvelteKit の SSG 設定 adapter-static のインストール SvelteKit の @sveltejs/adapter-static というモジュールが SSG 機能を提供しているので、まずはこのモジュールをインストールします。
adapter-static のインストール $ npm install --save-dev @sveltejs/adapter-static adapter-static の有効化 ビルド設定ファイル (svelte.config.js) で、adapter-static を使用するように設定します。 プロジェクトの初期状態では、次のような感じで adapter-auto というモジュールが使われるように設定されていると思います。
svelte.config.js（変更前） import adapter from &amp;#39;@sveltejs/adapter-auto&amp;#39;; import { vitePreprocess } from &amp;#39;@sveltejs/kit/vite&amp;#39;; /** @type {import(&amp;#39;@sveltejs/kit&amp;#39;).Config} */ const config = { preprocess: vitePreprocess(), kit: { adapter: adapter() } }; export default config; adapter-auto は、Vercel や Cloudflare Pages などのサービス上でビルドするときに使えるモジュールですが、SSG するときには使えないので、ここを adapter-static に置き換えてやります。</description></item><item><title>Svelte 応用: Svelte アプリから D3.js を使う</title><link>https://maku.blog/p/7acxmwo/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7acxmwo/</guid><description>何をするか？ Svelte を使用した Web アプリケーションの中から、SVG 描画ライブラリである D3.js を使用する方法を説明します。 Svelte のプロジェクトは、npm create svelte@latest コマンドなどで既に作成されていることを前提とします。
参考: Svelte を始める (SvelteKit で Hello World） D3.js のインストール Svelte はビルド時に実装コードをバニラ JS の形にコンパイルするので、D3.js (d3) などの外部ライブラリは devDependencies としてインストールすれば OK です。 TypeScript を使う場合は、型情報の @types/d3 も一緒にインストールしておきます。
d3 モジュールと型情報をインストール $ npm install --save-dev d3 @types/d3 D3.js による描画 ここでは、次のような簡単な棒グラフを Svelte アプリ内の D3.js で描画してみます。
D3.js による棒グラフの例 D3.js の d3.select() 関数は DOM 要素を参照するため、クライアントサイド JavaScript として実行しなければいけないことに注意してください。 具体的には、Svelte の onMount() コールバック内で呼び出すようにします。 直接 d3.select() 関数を呼び出してしまうと、ReferenceError: document is not defined のようなエラーが発生します。</description></item><item><title>Svelte 応用: Hamburger ボタンを作る</title><link>https://maku.blog/p/z5cwfjm/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z5cwfjm/</guid><description>Svelte コンポーネントによる Hamburger アイコンの実装例です。 ボタンをクリックすると open 変数の値が true になり、CSS アニメーションで×印に変化します。
図: Svelte コンポーネントによるハンバーガーアイコン src/lib/components/Hamburger.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let open = false; &amp;lt;/script&amp;gt; &amp;lt;button class:open on:click={() =&amp;gt; (open = !open)}&amp;gt; &amp;lt;svg width=&amp;#34;40&amp;#34; height=&amp;#34;40&amp;#34;&amp;gt; &amp;lt;line id=&amp;#34;top&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;10&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;line id=&amp;#34;middle&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;20&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;20&amp;#34; /&amp;gt; &amp;lt;line id=&amp;#34;bottom&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;30&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;30&amp;#34; /&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;style&amp;gt; button { display: inline-block; width: 40px; height: 40px; padding: 0; cursor: pointer; border: none; background: #333; box-shadow: inset 0 0 0 2px #cccccc; /* 内側に枠を付ける */ z-index: 20; /* （これは必要に応じて）他の要素より上に表示する */ } button:hover { background: #555; } svg line { stroke: currentColor; stroke-linecap: round; stroke-width: 3; stroke: #cccccc; transition: transform 0.</description></item><item><title>Svelte 応用: ページ遷移用のナビゲーションメニューを作成する</title><link>https://maku.blog/p/2nrgf2m/</link><pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2nrgf2m/</guid><description>Svelte サイト内でページ遷移を行うためのナビゲーションコンポーネントの作成例です。
現在の URL（パス）の取得方法 SvelteKit の $app/stores モジュールが提供する page ストアを利用すると、現在表示中のページの URL や、その一部であるパス情報を取得することができます。 この情報を利用することで、ナビゲーションコンポーネント内のカレントページに相当する項目をハイライト表示します（この URL 情報は、パンくずリストなどでも利用できます）。
現在のページのパス情報は、次のように $page.url.pathname 参照できます。
&amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;b&amp;gt;pathname = {$page.url.pathname}&amp;lt;/b&amp;gt; ページ遷移すると、pathname の値が、/ → /about → /blog のような感じで変化します。
Nav コンポーネントの実装例 次の Svelte コンポーネント (Nav) は、サイト内でページ遷移を行うためのボタンを表示します。 現在のページに相当するボタンには、赤色の下線を表示しています。
図: Nav コンポーネントの表示 src/lib/components/Nav.svelte &amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; const pages = [ { name: &amp;#39;Home&amp;#39;, path: &amp;#39;/&amp;#39; }, { name: &amp;#39;About&amp;#39;, path: &amp;#39;/about&amp;#39; }, { name: &amp;#39;Blog&amp;#39;, path: &amp;#39;/blog&amp;#39; } ]; &amp;lt;/script&amp;gt; &amp;lt;nav&amp;gt; {#each pages as p} {#if p.</description></item><item><title>Svelte 入門: 動的に class 属性を off/on する</title><link>https://maku.blog/p/x3vpkn4/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3vpkn4/</guid><description>HTML 要素の class 属性の値を動的に変化させることで、スタイルの切り替えをしたいことはよくあります。 ナビゲーションメニューで、現在表示しているページをハイライトするのは典型的な例です。
ここでは、ボタンを押すことで Off/On できる簡単なランプ (Lamp) コンポーネントを作ってみます。
図: class 属性の変更による表示切り替え Lamp.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; let active = false; // ランプの On/Off 状態 function toggle() { active = !active; } &amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;lamp {active ? &amp;#39;active&amp;#39; : &amp;#39;&amp;#39;}&amp;#34; /&amp;gt; &amp;lt;button on:click={toggle}&amp;gt; {#if active}OFF{:else}ON{/if} &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; align-items: center; gap: 0.5rem; } .lamp { display: inline-block; width: 30px; height: 30px; box-sizing: border-box; border: 4px ridge rgba(0, 0, 0, 0.</description></item><item><title>Svelte 入門: 複数のページで共通のレイアウトを定義する (+layout.svelte)</title><link>https://maku.blog/p/vwyvd5x/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vwyvd5x/</guid><description>レイアウトファイル (+layout.svelte) の基本 Svelte のフレームワークである SvelteKit は、複数のページで使用する共通レイアウトを定義するための仕組みを提供しています。 共通レイアウトを定義するのは簡単で、src/routes/+layout.svelte というファイルを作成するだけで、そのレイアウトが全ページ (src/routes/**/+page.svelte) に適用されます。
src/routes/&amp;#43;layout.svelte（共通レイアウト） &amp;lt;header&amp;gt; &amp;lt;h1&amp;gt;サイト名&amp;lt;/h1&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&amp;#34;main&amp;#34;&amp;gt; &amp;lt;slot /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; header { position: fixed; top: 0; left: 0; width: 100%; padding: 1rem 1.5rem; background-color: #333; color: #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); z-index: 1000; } h1 { margin: 0; } .main { margin: 7rem 2rem 4rem 2rem; } &amp;lt;/style&amp;gt; 各ページのコンテンツは、レイアウトファイル内の &amp;lt;slot /&amp;gt; 部分に展開されます（参考: スロットの仕組み）。
実際には SvelteKit で作成したアプリケーションは、最上位のページテンプレートとして src/app.</description></item><item><title>Svelte 入門: Svelte コンポーネントに子要素を渡せるようにする (&lt;slot />)</title><link>https://maku.blog/p/gcdawrj/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gcdawrj/</guid><description>スロットの基本 &amp;lt;slot /&amp;gt; Svelte コンポーネントを使用するときに子要素として渡した内容は、Svelte コンポーネントの中から &amp;lt;slot /&amp;gt; で参照することができます。 &amp;lt;slot /&amp;gt; の仕組みは、Vue.js や Astro でも採用されています（React.js では children prop で参照します）。
次の ExtLink コンポーネントは、外部サイトへのリンクを表示するコンポーネントの実装例です。
src/lib/ExtLink.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let href: string; &amp;lt;/script&amp;gt; &amp;lt;a {href} target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;&amp;lt;slot /&amp;gt;&amp;lt;/a&amp;gt; この ExtLink コンポーネントは次のように使用します。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import ExtLink from &amp;#39;$lib/ExtLink.svelte&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; &amp;lt;ExtLink href=&amp;#34;https://www.bing.com/&amp;#34;&amp;gt;Bing&amp;lt;/ExtLink&amp;gt; この例では、コンポーネント内の &amp;lt;slot /&amp;gt; という部分に Bing というテキストが展開されることになります。 よって、リンク部分は次のような HTML にコンパイルされます。
&amp;lt;a href=&amp;#34;https://www.bing.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;Bing&amp;lt;/a&amp;gt; 名前付きスロット &amp;lt;slot name=&amp;ldquo;name&amp;rdquo; /&amp;gt; 子要素を複数のパートに分けてコンポーネントに渡したいことがあります。 このような場合は、名前付きスロット という仕組みを使います。 次の Box コンポーネントは、3 つのスロットを受け取れるようにしています。</description></item><item><title>Linuxコマンド: ポートを開いているプロセスを調べる (lsof)</title><link>https://maku.blog/p/i7zokcv/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i7zokcv/</guid><description>迷ったらとりあえずコレ 次のように実行すると、TCP でポートを開いて LISTEN 状態になっているプロセスのコマンド名や PID の一覧を表示できます。
$ lsof -i tcp -s tcp:listen -P COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ControlCe 604 maku 24u IPv4 0xbf4647db74c55935 0t0 TCP *:7000 (LISTEN) ControlCe 604 maku 25u IPv6 0x27a96e6374c5592c 0t0 TCP *:7000 (LISTEN) ControlCe 604 maku 26u IPv4 0xbf46527374c55935 0t0 TCP *:5000 (LISTEN) ControlCe 604 maku 27u IPv6 0x27a9756374c5592c 0t0 TCP *:5000 (LISTEN) deno 8572 maku 14u IPv4 0xbc6a127374c55935 0t0 TCP *:8000 (LISTEN) hugo 10971 maku 6u IPv4 0xbcba127374c55935 0t0 TCP localhost:50001 (LISTEN) hugo 10975 maku 6u IPv4 0xbd35a81374c55935 0t0 TCP localhost:50002 (LISTEN) ruby 52070 maku 9u IPv4 0xbf461d7b74c55935 0t0 TCP localhost:4000 (LISTEN) ruby 52070 maku 12u IPv4 0xbd38681374c55935 0t0 TCP localhost:35729 (LISTEN) node 65924 maku 38u IPv6 0x27a9356374c5592c 0t0 TCP localhost:5173 (LISTEN) Dropbox 68519 maku 114u IPv4 0xbc67e81374c55935 0t0 TCP *:17500 (LISTEN) Dropbox 68519 maku 115u IPv6 0x27a8836374c5592c 0t0 TCP *:17500 (LISTEN) lsof -i の使い方 lsof (list open files) コマンドは、Linux や macOS で、現在開いているファイルやソケットの一覧を表示するコマンドです。 TCP/UDP ソケット（つまりネットワーク）に関する情報を表示するには、-i オプションを指定します。</description></item><item><title>Astro アプリから D3.js を使う</title><link>https://maku.blog/p/a8rq9gs/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a8rq9gs/</guid><description>D3.js はクライアントサイド JavaScript から SVG 画像を生成するためのライブラリです。 ここでは、Web サイト生成用のフレームワークである Astro 上で、D3.js を使う方法を紹介します。 前提条件として、Astro のプロジェクトはすでに作成済みであるとします。 まだ作成していない場合は、次のように作成できます。
Astro プロジェクトの生成 $ npm create astro@latest D3.js はコンポーネントスクリプトからは使えない D3.js はクライアントサイド JS として動作し、DOM ツリー上の SVG 要素を動的に操作することを想定して設計されています。 一方で、Astro コンポーネントのフロントマター部分に記述するスクリプトは、サーバーサイドで（ビルド時に）実行されることを想定しています。 つまり、D3.js を使ったコードは、Astro のフロントマタースクリプトとして記述することはできません。 残念！
Chart.astro（間違った方法） --- import * as d3 from &amp;#34;d3&amp;#34;; const svg = d3.select(&amp;#34;#mysvg&amp;#34;); // ここでは DOM 要素にアクセスできない！ // ... --- &amp;lt;svg id=&amp;#34;mysvg&amp;#34; width=&amp;#34;400&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; D3.js を使ったコードは、次のように &amp;lt;script&amp;gt; 要素の中に記述する必要があります。 ここに記述した JavaScript コードは、クライアントサイド（Web ブラウザ上）で実行されます。
Chart.astro（正しい方法） --- --- &amp;lt;svg id=&amp;#34;mysvg&amp;#34; width=&amp;#34;400&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; import * as d3 from &amp;#34;d3&amp;#34;; const svg = d3.</description></item><item><title>ChatGPT でテキストアドベンチャー (TRPG) を楽しむ</title><link>https://maku.blog/p/y7xwk4p/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/y7xwk4p/</guid><description>ChatGPT にゲームマスターになってもらう みなさま、ChatGPT を楽しんでいますか？ 今日は ChatGPT さんに、TRPG のゲームマスター になってもらいました。 まくには、一緒に TRPG してくれる友達はいないので、一人プレイです。
最初に次のような 2、3 行の指示をするだけで、それっぽいストーリーでロールプレイを始められます。
ChatGPT へ入力するプロンプト あなたは、「魔法が存在するファンタジー世界」を舞台とする TRPG のゲームマスターです。 何らかのストーリー設定をもとに、現在の状況を説明して行動を促してください。 10 回程度のやりとりでゲームクリアとなる規模のストーリーにしてください。 以下は、今回のゲームのリプレイです。 ゲームブック風に選択肢を提示してくれながらも、自由に行動できるのがとっても TRPG ぽいです。
リプレイ もちろんです、さっそくゲームを始めましょう！
背景設定
古代の魔法が息づく世界、ルーニア。ここには、禁断の魔法が封印された秘宝「クリスタルオブセリュナ」が存在しています。 この秘宝は、誤った手で開かれると大いなる災厄を招くと言われております。 プレイヤーたちは、セリュナ騎士団の一員として、秘宝を保護し、悪しき者たちから守る使命を担っています。
現在の状況
騎士団長からの突然の呼び出し。 邪悪なカルト団体がクリスタルオブセリュナを手に入れようとしているとの情報が入りました。 プレイヤーたちは、その秘宝を守り、カルト団体を倒す使命を帯びるのです。
プレイヤーへの説明
「騎士たちよ、クリスタルオブセリュナの危機が迫っている。カルト団体の手から秘宝を守り、この世界を救うため、すぐに出発せよ。」
プレイヤーへの行動の選択肢
すぐに出発する。 より多くの情報を集める。 騎士団長に具体的な計画を問いただす。 他の選択肢（プレイヤーからの提案） プレイヤーの皆さん、どう行動しますか？
&amp;gt; 3
素晴らしい、詳細な計画を知りたいという判断ですね。
騎士団長は深いため息をついてから、目の前の地図に指を当てます。
「確かに計画を共有するべきだ。クリスタルオブセリュナは、ここルーニア山脈の秘密の神殿に隠されている。カルト団体は既にその場所を突き止めている可能性がある。彼らを倒すためには、急ぎつつも注意深く進まねばならぬ。地下通路から神殿に忍び込む計画だ。」
そして、騎士団長は目を細めます。
「最も重要なのは、秘宝の力を誤って解放しないことだ。魔法の封印は複雑で、非常にデリケートだからだ。」
プレイヤーへの行動の選択肢
すぐに出発する。 騎士団内で援助を募る。 地下通路の地図や危険な箇所について詳しく聞く。 他の選択肢（プレイヤーからの提案） プレイヤーの皆さん、次の行動は？
&amp;gt; 1
勇敢にも、プレイヤーたちはすぐに出発することを選びました。騎士団長は皆の決意を認め、肩を叩きます。
「偉大なセリュナ騎士団の誇りを胸に、クリスタルを守り抜いてくれ。神々の加護がありますように。」
シーン2: 山脈への道中
プレイヤーたちは、ルーニア山脈へと急ぎます。道中は険しいものが予想され、カルト団体のスパイも潜んでいるかもしれません。
突然、道をふさいでいる倒木が目の前に現れます。それは自然のものではなく、明らかに何者かの仕業です。
プレイヤーへの行動の選択肢
倒木を取り除く。 迂回路を探す。 この場所で待ち伏せを警戒し、周囲を探索する。 他の選択肢（プレイヤーからの提案） プレイヤーの皆さん、どう行動しますか？</description></item><item><title>Terraform の導入</title><link>https://maku.blog/p/tacgbjy/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tacgbjy/</guid><description>Terraform とは Terraform は、Azure、AWS、GCP など様々なクラウドプラットフォームに対応したインフラ構築ツールです。
HCL (HashiCorp Configuration Language) という言語を使って、どのようにインフラを構築するかをコードで定義することができます (IaC: Infrastructure as Code)。 Azure や AWS などの個々のサービスと通信する機能は、プロバイダー と呼ばれる Terraform のプラグインとして提供されており、何千ものプロバイダーが Terraform Registry で公開されています。 適切なプロバイダーが見つからなければ、Golang（Go 言語）で自作することも可能です。
インストール Terraform の CLI ツール（terraform コマンド）は、下記公式サイトの手順に従って簡単にインストールできます。
Install | Terraform | HashiCorp Developer 各 OS のパッケージマネージャー（macOS の brew など）でインストールするのが手っ取り早いですが、1 バイナリーで提供されているので、バイナリ―をダウンロードして適当なディレクトリに配置する方がむしろ簡単かもしれません。 Golang 製のツールは、1 バイナリ―で提供されていているのでよいですね。
次のように terraform コマンドを実行できるようになれば OK です。
$ terraform -version Terraform v1.5.4 on windows_amd64 Terraform コード (main.tf) の作成 ここでは、Terraform によるリソース作成の Hello World として、AWS の S3 バケットを作成してみます。 EC2 インスタンスを作成する例などがよくありますが、消し忘れが怖いので S3 バケットにしておきます。 前提条件として、AWS CLI（aws コマンド）の実行が可能になっているものとします（参考: AWS の初期設定: AWS CLI と認証情報の設定。</description></item><item><title>読書メモ『Think clearly』Rolf Dobelli</title><link>https://maku.blog/p/8tirvxf/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8tirvxf/</guid><description>Think clearly - 最新の学術研究から導いた、よりよい人生を送るための思考法 Rolf Dobelli（著）、安原実津（訳） サンマーク出版 → 『ビジネス・経済』 売れ筋ランキング
よりよい人生を送るためには、日々どのように考えて過ごせばよいのでしょうか？
この本には、シンプルだけど大切な考え方が 52 の思考法としてまとめられています。 幸せって何なのか、成功って何なのか、それを手に入れるためにはどうしたらいいのか、といった人生の根底となる部分から、ストレスを減らして心地よく生きるための具体的な方法まで、学術研究から導き出された根拠をもとに学ぶことができます。 大学生から社会人くらいの人におすすめしたい本です。
まとめメモ 下記は個人的に大切だと思ったところをピックアップしたものなので、52 の思考法はすべては列挙してません。 詳しくは書籍で読んでね！
考えるより、行動しよう 考えているだけではそれ以上進めない。行動に移すこと。 他人の行動に コメントするだけの人が多い のは、考える方が簡単だからだ。 なんでも柔軟に修正しよう より重要なのは、スタートの条件設定ではなく、スタート後の修正技術 である。 早く初めて、早く軌道修正 できる人の方がうまくいく可能性が高い。 「計画そのものに価値はない。計画し続けることに価値がある」 ─ ドワイト・アイゼンハワー（元・米軍司令官、大統領） よい人生とは何か？ ◯ 修正を繰り返すことで初めて手に入れられるもの × 一定の決まった状態 大事な決断をするときは、十分な選択肢を検討しよう 少ないサンプルの中から最適なものを選択できる可能性は低い。 常にオープンな姿勢で、偶然が与えてくれたものをすべて試す ようにしよう。 いろいろな本を読もう。小説でたくさん疑似体験 しよう。 支払いを先にしよう 起きた出来事は変えられないが、その捉え方は自分で変えられる（メンタル・アカウンティング、心の会計、心の錯覚）。お金を盗まれたのであれば、貧しい人を救ったんだと考える。　自分への寄付用口座に一定額をプールしておき、罰金などはそこから払うようにする。これは想定通りの支出だと考える。 ホテルの料金は前払いすることで、記憶に残る最後（ピークエンドの法則）を支払いで終わらせずに済む。 行列で待っているときにイライラしない。イライラは心と体を蝕む。自分で余計なストレスを抱え込まなければ、人生は長くなる。 大きな事故にあった人は、ただ生きているだけで尊いと感じ、すべての出来事が愛おしいと考える。これは究極のメンタル・アカウンティングである。 簡単に頼みごとに応じるのはやめよう 頼みごとをつい引き受けてしまうのは、「互恵的利他主義」「≒ 囚人のジレンマにおけるしっぺ返し戦略」からくる生き物の本能的な反応である。 人生を豊かなものにしたいなら、チャーリーマンガーが実践する「5 秒ルール」を身につけた方がいい。頼みごとをされたときに、その無理な要求を検討する時間はきっかり 5 秒とする。ほとんどの答えはノーになるはずだ。 戦略的に「頑固」になろう 柔軟を褒め称えるのはやめよう。優柔不断な決断は、不満を募らせ、疲れがたまり、気づかないうちに目標から遠ざかってしまう。 重要な事柄、長期的な目標に対しては、頑固の姿勢を貫く方がうまくいく（誓約の下に生活する）。 「週末は徹底的に仕事をしない」 ─ クレイトン・クリステンセン（『イノベーションのジレンマ』 の著者） 「事後交渉は受け付けない。最初の提示価格がすべてだ」 ─ ウォーレン・バフェット 好ましくない現実こそ受け入れよう 失敗したときに、ありのままを受け入れ、そこから学習する たびに人生は向上する。 失敗の原因を突き止め、完全に取り除く。そうしなければ、あなたは同じ失敗を繰り返す。 必要なテクノロジー以外は持たない 本当は必要ないものを排除すること。特にテクノロジーに関しては、このルールがぴたりと当てはまる。 幸せを台無しにするような要因を取り除こう ダウンサイドを取り除けば、アップサイドは自然に姿を表す。勝つことではなく、負けないことが大事。 何が人間を幸せにするかを突き止めるのは難しいが、逆に幸せを損なうものは明らかである。 アルコール依存、麻薬、慢性的なストレス、騒音、長い通勤時間、嫌な仕事、失業、不安定な結婚生活、自分への過度な期待、貧困、借金や経済的依存、孤独、愚痴っぽい人たちとの付き合い、評価を気にしすぎること、他人と比較されること、被害者意識、自己嫌悪、慢性的な睡眠不足、怒りや嫉妬。 「私たちはただ賢くあろうとする代わりに、愚か者になるのを避けているだけだ」 ─ チャーリー・マンガー 謙虚さを心がけよう 幸運に恵まれたことへの感謝の念を忘れないこと。感謝の気持ちは人を幸せにしてくれる。 ものごとを全体的にとらえよう 「フォーカシング・イリュージョン」に惑わされない。 特定の要素に意識を集中してしまうと、それが人生に大きな影響を与えていると感じてしまう。自分の人生をできるだけ距離を置いて見ること。 お金がたくさんあることが幸せなのか？住む場所が変わったら幸せなのか？ 買い物は控えめにしよう 私たちは「モノ」が与えてくれる幸せの効果を過大評価し、「経験」が与えてくれる幸せの効果を過小評価している。 あなたの所得が貧困ラインを超えて金銭的な余裕ができたら、よい人生を手に入れられるかどうかは「お金以外の要素」で決まる。本当の成功は、経済的な成功とはまったく別のところにある。 自分の向き不向きの境目をはっきりさせよう ウォーレン・バフェットの「能力の輪」の話。 人間は、自分の「能力の輪」の内側にあるものはとてもよく理解できる。だが「輪の外側」にあるものは理解できない、あるいは理解できたとしてもほんの一部だ。 自分の「能力の輪」を意識しながらキャリアを気づくことは、いい人生を送るためのコツのひとつだ。 静かな生活を大事にしよう 多くの人々は、よい人生には冒険や旅行や引越しや、さらには人生の絶頂期がつきものだと思い込んでいる。だが、人生は、静かな方が生産性が高い。 せわしなく動き回るのを控え、何事にも落ち着いて、長期的に取り組むこと。 天職を追い求めるのはやめよう 「明日こそはノーベル文学賞をもらえるはず」と考えるより、「今日は少なくとも 3 ページは書こう」と考える方がずっと健全だ。 「得意」で「好き」で「評価される」ことを仕事にする。 SNS の評価から離れよう 自分で何かを成し遂げたり、胸を張れるような生き方 をすることに注力した方がいい。 一番大事なのは、あなた自身がどう判断するかだ。 目標を立てよう 目標を必ず達成できるとは限らないが、はじめから目標そのものがなければ何も達成できない。 「人生の目標」の意味はきわめて大きい。 人が幸せを感じるかどうかは所得の額によって決まるのではなく、目標を達成できたかどうかで決まる。 目標はわざと少し曖昧にしておいたほうがいい。 「現在」を楽しもう 「いま現在の経験」を存分に楽しもう。夕日を写真に撮るより、夕日そのものを楽しんだほうがいい。 すばらしい瞬間を積み重ねてできた人生は、たとえそれらの記憶が残らなくてもすばらしい人生に違いない。 本当の自分を知ろう 本当のあなたを知りたければ、日記をつけること。 何年も前の自分が書いたことをときどき読み返してみると、きっとその内容に驚くに違いない。あなたの矛盾や欠点や闇の部分も含め、できるだけありのままの自分を見つめるのも、よい人生にするための条件のひとつだ。 楽しさとやりがいの両方を目指そう 幸せの基盤は、楽しいことと意義のあることの組み合わせだ。どちらか一方に偏ってはいけない。楽しいことと意義のあることを交互に繰り返すなど、バランスのよい配分を心がけよう。 自分を守ろう 自分の中にある「信念」を外に向かって発信 しなければ、あなたは次第に、操り人形になっていく。 不要な心配ごとを避けよう 恒常的な不安感は慢性的なストレスにつながり、私たちの寿命にまで影響を与える。 私たちは客観的に見れば、不安を覚える必要性など何もないことに不安を抱える。 具体的なアドバイス: 心配事を書き下す 保険をかける 仕事に精神を集中させる 性急に意見を述べるのはやめよう 軽率に意見を述べる頻度が少なければ少ないほど、あなたの人生は向上する。 あなたが述べる意見で本当に重要なのは、ほんの 1 パーセント程度である。 本当に「自分の意見」をつくりあげたいときは、落ちついて、自分の考えを書き出してみる とよい。 「精神的な砦」を持とう 幸運は脆くはなかく、永遠に続くものではない。幸運はあなたに一時的に貸し出されただけのもので、いつまた取り上げられてもおかしくないのだと思うこと。遅くとも、死ぬ時にはすべて失ってしまうのだから。 あなたの思考や、思考の道具や、不運や損失や状況の悪化に対する精神的な対処法だけは、誰もあなたから取り上げられることはない。 幸せはあなたの「精神的な砦」の内側にある。ポルシェのコレクションに精を出して物質的な充実を図るより、砦の内側を充実させよう。 嫉妬を上手にコントロールしよう 嫉妬は、あらゆる感情の中でもっとも無意味で役に立たない有害な感情である。 「嫉妬に対する対処法」は自然と明らかである。他人と自分を比較するのを一切やめてしまえばいい。 謙虚さは、世の中のためになる。成功した後の最大の課題は、その成功について口をつぐんでおけるかどうかだ。 注意の向け方を考えよう あなたがどこに注意を向けるかで、あなたが幸せを感じるかどうかが決まる。 あなたの意識は常にあなたが注意を向けている場所にある。どこに注意を向けるかを意識したほうが、人生は豊かになる。 読書の仕方を変えてみよう 2 度読んだときの読書効果は、一度しか読まないときの倍どころではない。もっとずっと高くなる。一読後に記憶に残るのは 3 パーセント程度だが、2 度読めば 30 パーセントにまで増える。 30 歳を過ぎたら、人生の残りの時間を出来の悪い本に費やすのはもったいない。 「心の引き算」をしてみよう すばらしい出来事についてただ考えるより、「心の引き算」のほうが幸福度を上げる効果がはるかに高い。まだ持ってないものについて考えるよりも、いま持っているものを持てていなかった場合、どのくらい困っていたかについて考えたほうがいい。 バルセロナオリンピックのメダリストを対象に行われた調査では、「銀メダル」を獲得したメダリストは、「銅メダル」を獲得したメダリストより、幸福度が低かった。 ピアノを弾いているのに、その音が聞こえない状態を想像してみるといい。「心の引き算」をすれば、あなたはピアノの音も思う存分楽しめるようになるはずだ。 相手の立場になってみよう 役割を交換すると、ほかの方法よりずっと効率よく、迅速に、コストをかけずに相互理解が可能になる。 だから、小説を読もう。できるだけたくさん、それもできるだけ質の良いものを。 専門分野を持とう 石器時代には、人間は「多才」でなければ生きられなかった。いまでは「スペシャリスト」でなければ生きられず、「多才な人」にはチャンスはない。 一般的な教養は、驚くほど急速に、利用価値がなくなってしまった。 少数の勝者が市場の利益のほぼすべてを手中にし、残りの大多数は、市場の隅でなんとか生きていける程度の収入しか得られなくなってしまった。 軍拡競争に気をつけよう 軍拡競争に巻き込まれないよう気をつけよう。ひとつひとつ軍備を拡張していく過程は有意義に思えるので、渦中にいる本人が起こっている事態に気づくのはなかなか難しい。 よい人生を手にしようと人々が競い合っている場所で、よい人生は見つからない。 組織に属さない人たちと交流を持とう 組織に属さない人たちは、その内部にいる人たちよりも迅速に行動できるため、早く結果を出せることが多い。 それでも、どの組織のメンバーでもない「完全な部外者」にはならないほうがいい。属する組織を持たないと、社会があなたを拒絶しようとする。 少なくともあなたの「片方の足」は、社会の組織の中にしっかりと固定しておくこと。その上で、「どの組織にも属していない人たち」と交友関係を結べばいい。その際は、社交辞令ではなく、心の底から彼らの仕事に関心を持つこと。 世界を変えるという幻想を捨てよう 「私たちには、たまたまタイミングよくその場所にいた聡明な人物を、褒め称えすぎる傾向がある」 ─ 『進化は万能である』 マット・リドレー（イギリスのサイエンス・ライター＆政治家） 「マルティン・ルターは宗教改革をもたらしたことになっている。だが、宗教改革はいずれにせよ起きていただろう。ルターがいなければ、ほかの誰かが改革していたはずだ」 ─ モンテスキュー 歴史を作った人物などいないのだ。 「偉人」崇拝をしないのも、よい人生の条件のひとつである。いうまでもなく、あなた自身が「偉人」になれるかもしれないなどという幻想を抱かないようにすること。 自分の人生に集中しよう あなた個人が世界に与えられる影響は、きわめて小さい。 あなたが、本当に重要な役割を担っているのは、あなた自身の人生に対してだけだ。 「外の世界」ではなく、「自分の内側」に意識を集中させよう。 自分の内側はコントロールできても、常に偶然の要素が働く外の世界に対しては、私たちは力を持たない。お金や、権力や、人気といったものを、自分でコントロールするのはほぼ不可能だ。それなのにそうしたものに重きを置いていると、それらを失ったときにひどく動揺してしまう。 「内なる成功」に向けて努力して、いますぐに人生を充実させたほうがいい。 Think シリーズ紹介 ロルフ・ドベリ氏は、Think clearly の他にもいくつか Think シリーズを出しています。 思考法のバイブル として手元に置いている人も多いみたいですね。</description></item><item><title>セキュリティ雑多メモ: 脆弱性の分類とデータベース</title><link>https://maku.blog/p/m8688y4/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m8688y4/</guid><description>大規模なソフトウェア開発プロジェクトにおいて脆弱性を体系的に扱うには、それらの分類方法や、脆弱性データベースの存在を認識しておく必要があります。
セキュリティマネジメントには「既知」と「未知」のものがある 既知の脆弱性 (known vulnerabilities) 開発時、出荷時などにすでに発見されている脆弱性。管理は容易。 未知の脆弱性 (unknown vulnerabilities) 定期的なチェックの仕組み を導入して発見する必要がある。 脆弱性データベース 各種プログラミング言語用に配布されているライブラリで脆弱性が発見されると、下記のような脆弱性データベースに登録されて公開されます。
NVD: National Vulnerability Database NIST（アメリカ国立標準技術研究所）が管理している脆弱性データベースです。 GitHub Advisory Database GitHub が管理している脆弱性データベースです。いろいろなデータベースを横断的に検索できるので便利です（参考: GitHub Advisory Database について）。 JVN: Japan Vulnerability Notes 脆弱性 ID と指標 CVE: 脆弱性の識別子 脆弱性の ID 体系としては、CVE-ID が有名です。 NVD で管理されている脆弱性には、一意の CVE: Common Vulnerabilities and Exposures（共通脆弱性識別子） という ID が割り当てられています（CVE-2022-0123 のような形式）。 これにより、脆弱性の報告、追跡、共有が簡単になります。
CWE: 脆弱性のカテゴリ CWE: Common Weakness Enumeration（共通脆弱性タイプ一覧） という脆弱性カテゴリも定義されています。
CVSS: 脆弱性の深刻度 脆弱性の深刻度を評価するための、CVSS: Common Vulnerability Scoring System（共通脆弱性評価システム） という枠組みが定義されており、脆弱性の影響、機密性、可用性、完全性、およびその他の要因を評価して、それぞれの脆弱性に 0 ～ 10 の CVSS スコアが割り当てられています。 CVSS スコアにより、組織は脆弱性を優先順位付けして対処することができます。</description></item><item><title>Amazon Cognito の ID トークンを使った認証付き API の仕組み</title><link>https://maku.blog/p/p4462y2/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p4462y2/</guid><description>Amazon Cognito サービスを使うと、アプリケーションにユーザー認証（サインイン）の仕組みを提供し、認証されたユーザーだけが呼び出し可能な Web API などを実現できます。 その際に内部的に使用される ID トークンやアクセストークンなどの関係が若干複雑なのでメモしておきます。
Cognito で認証が必要な API を実現する仕組み graph LR; browser[Web ブラウザ] --サインイン--> cognito[Cognito
ユーザープール]; cognito --ID トークン--> browser browser --"認証が必要な API の呼び出し
（with ID トークン）"--> gateway["API Gateway
（ユーザープールと連携させておく）"] Web アプリなどで Amazon Cognito の ユーザープール を使って認証（サインイン）すると、Cognito は ID トークン を返します（JWT: JSON Web Token）。 この ID トークンは、サービスの正式なユーザーであるということを証明するものです。 この ID トークンを API 呼び出し時に検証することで、認証が必要な API を実現することができます。
AWS で何らかの Web API を作成する場合は、API Gateway (REST API) や AppSync (GraphQL API) などを使うことになりますが、これらのリソースには Cognito ユーザープールをオーソライザーとして設定することができます。 これにより、Web ブラウザからの API Gateway アクセスを、Cognito でのサインインが終わったユーザーに限定することができます（認証付き API）。 デフォルトでは、Authorization ヘッダーで ID トークンを送ってもらう設定になっています。 ID トークンはセッション情報として保存されます。</description></item><item><title>HMAC-SHA256 コードを生成する</title><link>https://maku.blog/p/uqhbb5p/</link><pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uqhbb5p/</guid><description>Python で HMAC-SHA256 を生成する 下記の siggen.py スクリプトは、コマンドライン引数で渡された「秘密鍵テキスト」と「メッセージ」をもとに HMAC (Hash-based Message Authentication Code) 署名を生成します。
siggen.py import sys import hashlib import hmac def usage(): print(&amp;#39;python &amp;#39; + sys.argv[0] + &amp;#39; &amp;lt;key&amp;gt; &amp;lt;message&amp;gt;&amp;#39;) sys.exit(1) if __name__ == &amp;#39;__main__&amp;#39;: if len(sys.argv) &amp;lt; 3: usage() key = sys.argv[1] msg = sys.argv[2] sig = hmac.new(key.encode(&amp;#39;ascii&amp;#39;), msg.encode(&amp;#39;ascii&amp;#39;), hashlib.sha256) print(sig.hexdigest()) 使用例 $ python siggen.py &amp;#39;SecretKey&amp;#39; &amp;#39;YourMessage&amp;#39; 8aff2951003c218bd26ee43c99e30527a0c30e06042008a60935ef1ab28891ec ここでは、SHA256 ハッシュ関数を使用していますが (HMAC-SHA256)、hashlib.sha256 の部分を変更すれば、他のハッシュ関数を適用することができます。
openssl コマンドで HMAC-SHA256 を生成する Linux や macOS などの、openssl コマンドを使用できる環境では、下記のようにして簡単に HMAC-SHA256 を求めることができます。</description></item><item><title>Nginx の設定: Web サイトのドメインを移転したときの 301 リダイレクト設定</title><link>https://maku.blog/p/mjs29go/</link><pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mjs29go/</guid><description>nginx で URL リダイレクト用のレスポンスを返す Web サイトのドメイン（URL プレフィックス）を次のような感じで移転することを考えます。
旧アドレス: https://old.example.com 新アドレス: https://new.example.com 多くのユーザーが旧アドレスでブックマークしている可能性があるので、しばらくは旧アドレスにアクセスしてきたユーザー（ブラウザ）に対して、リダイレクト用のレスポンスを返すよう nginx を設定しておく必要があります。 下記は、旧アドレスでのアクセス時に 301 (Moved Permanently) リダイレクトレスポンスを返す設定例です。
/etc/nginx/conf.d/old.example.com.conf # これは http から https へリダイレクトする設定（オプション） server { server_name old.example.com; listen 80; return 301 https://$host$request_uri; } # https://old.example.com から # https://new.example.com へリダイレクトする設定 server { server_name old.example.com; listen 443 ssl http2; ssl_certificate /etc/letsencrypt/live/old.example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/old.example.com/privkey.pem; return 301 $scheme://new.example.com$request_uri; } ポイントは最後の return ディレクティブです。 1 つ目の引数に 301 を指定することで、301 (Moved Permanently) の HTTP レスポンスコードを返すことができます。 このコードを省略した場合は、302 (Moved Temporarily) になります。</description></item><item><title>rclone コマンドで Cloudflare R2 とファイルを同期する</title><link>https://maku.blog/p/p6o6m3i/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p6o6m3i/</guid><description>rclone とは？ rclone は、Cloudflare R2 や AWS S3、Azure Blob Storage などのクラウドストレージにファイルを同期アップロードするためのコマンドラインツールです。 似たようなコマンドラインツールとしては rsync がありますが、rsync が SSH での通信をベースとしているのに対し、rclone は様々なクラウドサービスへの接続をターゲットにしています。
ここでは、同期先のストレージサービスとして Cloudflare R2 を使うことを想定し、ローカル PC 上のファイル（ディレクトリ）を同期してみます。
☝️ R2 vs S3 R2 は AWS S3 や Azure Blob Storage と比べて、エグレス料金が無料（下り転送が無料）という太っ腹な料金体系になっており、今後の展開が楽しみなサービスです。 ちなみに、R2 という名前は、S3 より前という意味が込められているとのこと。 rclone のインストール rclone コマンドは Golang で実装されているため、単一の実行バイナリとして提供されています。 下記のページから各 OS 用の実行ファイルをダウンロードして、パスの通ったディレクトリに置くだけでインストールは完了です。
Rclone downloads macOS や Windows であれば、パッケージマネージャでインストールするのが簡単です。
macOS の Homebrew でインストール $ brew install rclone Windows の Chocolatey でインストール $ choco search rclone $ choco install rclone Windows の Scoop でインストール $ scoop install rclone 次のように rclone コマンドを実行できるようになれば OK です。</description></item><item><title>VS Code で YAML ファイルの構文をチェックする（YAML 拡張）</title><link>https://maku.blog/p/c7sp7ut/</link><pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c7sp7ut/</guid><description>YAML 拡張とは？ VS Code の YAML 拡張 (redhat.vscode-yaml) をインストールすると、スキーマ定義に基づいて、YAML ファイルの記述内容が正しいかをチェックすることができます。 スキーマ定義を JSON スキーマファイル の形で作成し、YAML ファイルの先頭に次のようなコメントを記述することで適用できます。
YAML ファイルの先頭に追加 # yaml-language-server: $schema=./schema.json YAML ファイルの構文チェックなのに JSON スキーマ？と思うかもしれませんが、YAML と JSON のデータ形式には互換性があるので、スキーマは JSON スキーマでよいんですね。
スキーマによる YAML ファイルの構文チェック 公開スキーマファイルを参照する スキーマファイルは、インターネット上に公開されているものを URL で指定できるようになっています。 有名どころの設定ファイルのスキーマは、下記のサイトに一覧があるので、いろいろなプロジェクトからそのまま利用できます。
JSON Schema Store Ansible Playbook など、内容が複雑になりがちな YAML ファイルに設定しておくと役に立ちそうです。
playbook.yml（の先頭に記述する） # yaml-language-server: $schema=https://raw.githubusercontent.com/ansible/ansible-lint/main/src/ansiblelint/schemas/ansible.json GitHub Actions のワークフローファイル (.github/workflows/*.yml) などは、そのファイルパスから、どのスキーマを使用すればいいかを推測できるので、上記のようなコメント行すら記述せずに自動的に GitHub Actions 用のスキーマ を適用してくれます。 つまり、VS Code に YAML 拡張をインストールするだけで、GitHub Actions のワークフローファイルの構文チェックが有効になります。 便利！
独自定義したスキーマファイルを参照する アプリケーション独自の設定ファイルやデータファイルを YAML 形式で作成する場合は、そのスキーマも独自であることが多いので、専用の JSON スキーマファイルを作成することになるでしょう。 例えば、次の JSON スキーマファイルでは、ユーザー情報を表現するためのスキーマを定義しています（コメントを記述できるようにするために、拡張子を .</description></item><item><title>VS Code で YAML ファイルをソートする（YAML Sort 拡張）</title><link>https://maku.blog/p/2apzood/</link><pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2apzood/</guid><description>YAML Sort の概要 VS Code に YAML Sort 拡張 をインストールすると、YAML ファイルの内容をキー名でソートすることができます。 主にソート用に使うものですが、YAML フォーマッターとしても利用できます。 次のような簡単なカスタマイズを行うこともできます。
指定したキーを優先的に上から並べる 1 階層目の各キーの間に空白行を入れる リスト要素をソートする YAML Sort の使い方 YAML Sort のページで Install ボタンを押すだけで、VS Code への拡張のインストールは完了です。 ここでは、次のような YAML ファイルをソートしてみます。
sample.yml（ソート前） root2: ccc: 300 aaa: 100 bbb: 200 root1: fruits: - grape - apple - banana animals: [&amp;#39;wolf&amp;#39;, &amp;#39;fox&amp;#39;, &amp;#39;dolphin&amp;#39;, &amp;#39;eagle&amp;#39;] VS Code で YAML ファイルを開いた状態で、コマンドパレットを開いて (Ctrl/Cmd + Shift + P)、YAML Sort: Sort YAML を選択すると、YAML ファイルの内容がソートされます。
sample.yml（ソート後） --- root1: animals: [&amp;#39;wolf&amp;#39;, &amp;#39;fox&amp;#39;, &amp;#39;dolphin&amp;#39;, &amp;#39;eagle&amp;#39;] fruits: - grape - apple - banana root2: aaa: 100 bbb: 200 ccc: 300 先頭行に自動でセパレーター (---) が挿入され、すべてのキーがアルファベット順にソートされていることが分かります。 キー間の空白行はすべて削除されています。 一方で、リスト要素は自動ではソートされないようです（順番が意味を持つことがあるので当然ですが）。</description></item><item><title>React アプリの中で D3.js を使ってチャートを描画する</title><link>https://maku.blog/p/j52iy4k/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j52iy4k/</guid><description>何をするか？ D3.js は、Web ブラウザ上で様々なデータをビジュアライズするためのデファクトスタンダードな描画ライブラリです。 ここでは、React (Next.js) アプリ内で、D3.js を使って簡単なチャートを描画してみます。
☝️ ほかの描画ライブラリ JavaScript による描画ライブラリには、他にも Chart.js や Mermaid.js などいろいろなものがあります。 Chart.js を使うと、は折れ線グラフや散布図などを簡単に描画することができます。 Mermaid.js を使うと、独自フォーマットのテキストをもとにフローチャートなどを描画することができます。 これらの描画ライブラリは、D3.js と比べて簡単に使うことができますが、描画可能な図の種類は限られています。 一方、D3.js は高度なカスタマイズや自由度の高いデータの可視化が可能ですが、初学者にとってはやや学習コストが高くなっています。 D3.js のインストール NPM あるいは Yarn で、プロジェクトに D3.js の依存を追加します。 TypeScript を使用している場合は、D3.js 本体 (d3) に加え、型情報 (@types/d3) もインストールします。
D3.js のインストール（NPM の場合） $ npm install d3 $ npm install --save-dev @types/d3 D3.js のインストール（Yarn の場合） $ yarn add d3 $ yarn add --dev @types/d3 React コンポーネント内で D3.js を使う React アプリは作成済みであるとし、D3.js を使って描画を行うコンポーネントを新しく作成します。 次の HelloChart コンポーネントは、D3.</description></item><item><title>Next.js アプリに Google Analytics を設定する (next/script)</title><link>https://maku.blog/p/zycmw6f/</link><pubDate>Tue, 21 Mar 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zycmw6f/</guid><description>何をするか？ Google Analytics で Web サイトのアクセス解析を行うには、次のような感じのコードを各ページに埋め込む必要があります。
Google Analytics 用の埋め込みコード &amp;lt;!-- Google tag (gtag.js) --&amp;gt; &amp;lt;script async src=&amp;#34;https://www.googletagmanager.com/gtag/js?id=G-ABCDE12345&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(&amp;#39;js&amp;#39;, new Date()); gtag(&amp;#39;config&amp;#39;, &amp;#39;G-ABCDE12345&amp;#39;); &amp;lt;/script&amp;gt; ここでは、Next.js が提供する Script コンポーネント (next/script) を使用して、Next.js アプリに同等のコードを埋め込む方法を説明します。 HTML 標準の script ではなく、Next.js の Script コンポーネントを使用することで、Next.js アプリのレンダリング処理に合わせて実行タイミングを最適化できます。
事前準備（Google Analitics でプロパティとデータストリームを追加する） 事前準備として、Google Analytics のサイトで、サイドバーの 管理 メニューから対象アプリ用に プロパティ を追加しておいてください。 さらに、そのプロパティに対して データストリーム を追加すると、Web サイトや Android アプリの利用状況を監視できるようになります。
図: プロパティにデータストリームを追加する データストリームを追加すると、次のように 測定 ID が発行されます。 これが、前述の JavaScript コードで指定する ID になります。</description></item><item><title>React で入力フォームの onChange イベントを IME ON のときに無視する</title><link>https://maku.blog/p/cv6fpx7/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cv6fpx7/</guid><description>何をするか？ React のテキスト入力フォーム（input コンポーネントや mui の TextField など）で onChange イベントハンドラーを設定すると、入力テキストが変化したときに任意の処理を行うことができます。 ただ、onChange イベントは IME での日本語変換中にも呼び出されてしまう ので、おそらく、想定しているよりも多く呼び出されてしまいます。 インクリメンタルサーチなどで、入力のたびに API 呼び出しをしているようなケースでは、この振る舞いは抑制しなければいけません。
ここでは、IME が ON になっているとき（つまり日本語変換中）に、onChange イベントを無視する実装例を紹介します。 このあたりの実装は、ブラウザごとの微妙な振る舞いの差（特に Esc キーで IME 入力をキャンセルした場合など）を考えると、結構複雑だったりします。
実装してみる React の input コンポーネントの onCompositionStart と onCompositionEnd イベントハンドラーを設定すると、IME を ON/OFF したタイミングを知ることができます。 そのタイミングで、isImeOn のようなフラグを制御すれば、必要に応じて onChange イベントを無視できるようになります。
// import { FC, useRef, useState } from &amp;#39;react&amp;#39; const SearchBox: FC = () =&amp;gt; { // 現在 IME ON（変換中）かどうかのフラグ const isImeOn = useRef(false) // 以前の入力テキスト（ブラウザごとの onChange の振る舞いの差異への対策） const [prevText, setPrevText] = useState(&amp;#39;&amp;#39;) // 入力テキストを処理する const handleChange = (text: string) =&amp;gt; { if (prevText === text) return if (text === &amp;#39;&amp;#39;) { // Chrome ではテキストクリア時に onCompositionEnd が呼ばれないことがある isImeOn.</description></item><item><title>Meilisearch サーチエンジンを使ってみる</title><link>https://maku.blog/p/bo8q8p7/</link><pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bo8q8p7/</guid><description>Meilisearch とは？ Meilisearch は、簡単に使えることをポリシーとして作られた OSS のサーチエンジンで、これを利用すると、アプリの フロントエンドに高速な検索機能 を組み込むことができます。 個人や中小企業でも手軽に導入でき、柔軟な設定により様々な用途に対応できます。 Meilisearch には次のような特徴があります。
高速な応答（検索結果は 50 ミリ秒以内に得られる。ただし、1,000 万件以上の大規模なデータは想定していない） インクリメンタルサーチ（入力するたびにプレフィックスで絞り込んで結果を返す） タイポ入力補正（検索語句を多少間違えて入力してもそれっぽい単語で検索してくれる） プレースホルダー検索（キーワードを入力せずにカテゴリーなどで結果を絞り込む） カスタムランキング処理（ranking rules による検索結果のソート） 検索結果のハイライト表示（入力キーワードに一致した位置がわかる） 日本語を含む各種言語に対応（形態素解析エンジンに Lindera を採用） 同義語の定義 Meilisearch は 簡単であること を哲学としているので、類似の検索フレームワークに比べて全体的にシンプルな構成になっています。 Elasticsearch などでは大袈裟すぎるというニーズにマッチするかもしれません。 JSON 形式のドキュメントを REST API で登録してインデックスを作成するだけで、REST API による検索が可能になります。 最終的にはフロントエンドから直接 REST API を呼び出すように UI を作り込んでいく必要がありますが、プレビュー用の Web サーバー（ダッシュボード UI）が内蔵されているので、コーディングなしでインクリメンタルサーチを試すことができます。
図: Meilisearch ダッシュボード 似たような検索エンジンとしては、Algolia という SaaS があります。 Meilisearch は Algolia にインスパイアされて作られているので、アルゴリズム等は似ていますが、オープンソース であるという大きな違いがあります（Algolia は個人で使うには高すぎるというのもあります&amp;hellip;）。
Meilisearch サーバーを起動する Docker Hub に getmeili/meilisearch というイメージが公開されているので、これを使えば簡単に Meilisearch のサーバーを立ち上げることができます。</description></item><item><title>Deno で MongoDB にアクセスする</title><link>https://maku.blog/p/3pwojuj/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3pwojuj/</guid><description>Deno 用の MongoDB ドライバーとして、deno_mongo が公開されています。 Deno Deploy 上でも使えるので、Deno Deploy で公開する Web API から MongoDB Atlas に接続する、といったことが簡単に行えます。
mongo | Deno GitHub - denodrivers/mongo: MongoDB driver for Deno MongoDB サーバーへ接続する ローカルホスト上で起動した MongoDB サーバーへ接続するには次のようにします。
import { MongoClient } from &amp;#34;https://deno.land/x/mongo@v0.31.1/mod.ts&amp;#34;; const client = new MongoClient(); await client.connect(&amp;#34;mongodb://127.0.0.1:27017&amp;#34;); // 後は client インスタンスを使って MongoDB を操作する 実運用を考えると、MONGO_URI のような環境変数で接続先の MongoDB サーバーを指定できるようにしておいた方がよいでしょう。 例えば、MongoDB Atlas サービスを使用している場合は、次のような接続文字列 (SRV URI) が発行されますが、ここには接続パスワードなどが含まれるので、この URI をハードコーディングすることはできません。
mongodb+srv://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@cluster-name.abcde.mongodb.net/?retryWrites=true&amp;amp;w=majority 次の client.ts モジュールは、MongoClient インスタンスを MONGO_URI 環境変数が示す MongoDB サーバーに接続し、export しています。 MONGO_URI 環境変数がセットされていない場合は、代わりに 127.</description></item><item><title>Docker で MongoDB サーバーを立ち上げる</title><link>https://maku.blog/p/y6zgrg2/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/y6zgrg2/</guid><description>Docker のオフィシャルイメージとして、mongo イメージが公開されています。
mongo - Official Image | Docker Hub このイメージには、MongoDB サーバー (mongod) や、MongoDB クライアント (mongosh) が含まれており、コマンドを省略してコンテナを起動すると、デフォルトで MongoDB サーバーが立ち上がります。
MongoDB サーバーのコンテナを起動する 次のように mongo コンテナを起動すると、ローカルホスト上で MongoDB サーバーを立ち上げたのと同様に振舞います。
$ docker container run --rm -d -p 27017:27017 --name mongo mongo オプションの意味:
--rm &amp;hellip; コンテナを停止したときにコンテナを削除します。コンテナを削除したくなければ、このオプションは外してください。 -d &amp;hellip; デーモンをバックグラウンドで動作させます。 -p 27107:27017 &amp;hellip; ローカルホストの 27107 ポートへのアクセスを、コンテナ内の MongoDB サーバーの 27107 ポートへ転送します。 --name mongo &amp;hellip; 起動するコンテナに mongo という名前を付けます。 mongo &amp;hellip; Docker イメージとして mongo:latest を使用します（デフォルトで :latest が使われます)。 次のようにして、mongo コンテナが起動していることを確認できます。</description></item><item><title>Deno のタスクランナーの使い方 (deno task)</title><link>https://maku.blog/p/ho4gs5h/</link><pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ho4gs5h/</guid><description>Deno のタスクランナーとは？ npm スクリプトとの違いは？ Deno は標準で deno task コマンド を提供しており、deno.json（あるいは deno.jsonc）の tasks プロパティで定義したタスクを実行できるようになっています。 これは、Node.js で言うところの npm スクリプト (npm run) に相当するものですが、deno task の場合は、クロスプラットフォームなタスクを定義できる ところが大きな特徴になっています。
deno.json でのタスク定義 { &amp;#34;tasks&amp;#34;: { &amp;#34;hello&amp;#34;: &amp;#34;echo Hello, Deno Task Runner!&amp;#34; } } タスクの実行方法 $ deno task hello npm スクリプトの場合は、定義したタスクが OS のシェル上で実行されることが前提だったので、シェルの機能をうかつに使ってしまうと、Linux では動くけど Windows では動かないというタスクなってしまいがちでした。 例えば、ファイルをまとめて削除するタスクを作りたい場合、Linux に依存した rm -rf コマンドは使えず、いちいち rimraf モジュールをインストールするといったことが必要でした。 一方、Deno 場合は、クロスプラットフォームで動作する 組み込みコマンドとして rm コマンドを備えています。 他にも、cp、mv、mkdir、echo、cat といったよく使うコマンドが、Linux や Windows、macOS などで共通で使えるようになっています。
また、Linux と Windows では、パイプやリダイレクトの記述方法も微妙に異なっていますが、Deno のタスクランナーでは、組み込みでパイプやリダイレクトの構文を処理する ようになっており、連続したコマンド実行も OS のシェルに依存せずに定義できます。</description></item><item><title>Deno で JSON ファイルを読み込む方法いろいろ</title><link>https://maku.blog/p/a83hr2b/</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a83hr2b/</guid><description>Deno で JSON ファイルを読み込んで、JavaScript のオブジェクトとして参照できるようにするには、import で直接インポートする方法と、Deno.readTextFile で読み込んでから JSON.parse する方法があります。 ここでは、それぞれの方法で次のような JSON ファイルを読み込んでみます。
books.json [ { &amp;#34;title&amp;#34;: &amp;#34;Title 1&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;Author 1&amp;#34; }, { &amp;#34;title&amp;#34;: &amp;#34;Title 2&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;Author 2&amp;#34; }, { &amp;#34;title&amp;#34;: &amp;#34;Title 3&amp;#34; } ] JSON モジュールとしてインポートする方法 Deno では、import 文で JSON ファイルを直接インポートできるようになっています。 JSON ファイルをインポートするときは、import assertions の機能を使って、JSON ファイルであることを明示する必要があります。
import 文で静的インポート main.ts import books from &amp;#34;./books.json&amp;#34; assert { type: &amp;#34;json&amp;#34; }; for (const b of books) { console.log(`title: ${b.title}, author: ${b.author ?</description></item><item><title>Deno Deploy の例: JSON ファイルを読み込んで返す REST API を作る (oak)</title><link>https://maku.blog/p/zt3birz/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zt3birz/</guid><description>何をするか？ Deno Deploy を使うと、Web API を簡単にデプロイすることができます。 ここでは、よくある例として、サーバー側で JSON ファイルを読み込んで、その内容をレスポンスとして返す REST API を作ってみます。 ここでは、次のような関数やモジュールを使用します。
Deno.readTextFile テキストファイルを読み込むために使用する Deno の標準 API です。 x/oak モジュール HTTP サーバーを作るときに使えるミドルウェアフレームワークです。リクエストのパスに応じて、処理を簡単に振り分けることができます。Node の express と同じように使えます。 前提条件 Deno Deploy の基本的な使い方は下記ページを参考にしてください。
参考: Deno Deploy で Deno のサーバープログラムを公開する 後述の記事では、デプロイ用の deployctl コマンドを使用するので、上記ページに従って先にインストールしておいてください。
JSON ファイル サーバー側で読み込む、サンプルの JSON ファイルを用意しておきます。
data/books.json [ { &amp;#34;id&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;Title 1&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;2&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;Title 2&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;3&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;Title 3&amp;#34; } ] 3 冊の書籍データが格納されているという想定です。 実際のアプリケーションでは、RDB や mongoDB などのデータベースから情報取得することになると思います。</description></item><item><title>GraphQL スキーマの Lint ツール (graphql-schema-linter) を導入する</title><link>https://maku.blog/p/adxcp3g/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/adxcp3g/</guid><description>graphql-schema-linter とは？ graphql-schema-linter は、GraphQL スキーマファイル (*.graphqls) の記述の不備を指摘してくれる Linter です。 スキーマファーストなアプローチで GraphQL サーバー／クライアントを実装している場合は、Linter は早い段階で導入しておくことをお勧めします。
graphql-schema-linter のインストール graphql-schema-linter コマンドは、yarn あるいは npm でインストールできます。 依存パッケージである graphql も一緒にインストールする必要があります（package.json ファイルがない場合は、先に npm init で作成しておいてください）。
graphql-schema-linter のインストール # yarn の場合 $ yarn add --dev graphql graphql-schema-linter # npm の場合 $ npm install --save-dev graphql graphql-schema-linter 次のように実行できるようになっていれば OK です。
コマンドを実行できるか確認 $ npx graphql-schema-linter --help ...（ヘルプ表示）... コマンド名が長いので、npm スクリプトを定義して、yarn lint だけで実行できるようにしておくと便利です。 最低限の package.json ファイルは次のような感じになります。
package.json { &amp;#34;license&amp;#34;: &amp;#34;UNLICENSED&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;lint&amp;#34;: &amp;#34;graphql-schema-linter graph/*.</description></item><item><title>.proto の文法: repeated ラベル（フィールドを配列にする）</title><link>https://maku.blog/p/b2q2jmh/</link><pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b2q2jmh/</guid><description>Protocol Buffers (protobuf) のフィールドを配列／リスト扱いにするには、.proto ファイルのフィールド定義の先頭に repeated ラベルを付加します。 次の FindBookResponse メッセージ型は、Book 配列のフィールドを持っています。
books.proto（抜粋） message FindBookResponse { repeated Book books = 1; } message Book { string title = 1; } repeated ラベルを付けたフィールドの名前は複数形にしましょう（上記例の場合は books）。
Protocol Buffers では repeated を連続させた多次元配列は定義できませんが、任意のメッセージ型に repeated を付けることはできるので、そのメッセージ型の中に repeated フィールドを配置すれば、多次元配列と同様のデータを表現することができます。
repeated ラベルは、oneof フィールドに付加することはできません。
参考: .proto の文法: oneof 型</description></item><item><title>.proto の文法: optional ラベル（フィールドを省略可能にする）</title><link>https://maku.blog/p/sp9q7o5/</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sp9q7o5/</guid><description>.proto のフィールドを省略可能にする (option) Protocol Buffers（.proto ファイル）のフィールド定義で optional というラベルを付けると、そのフィールドへの値のセットがオプショナルであることを示すことができます。 optional ラベルは、protoc コンパイラの v3.15.0 以降で使用できます。
sample.proto syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/maku77/myapp/pb&amp;#34;; message SampleMessage { string message = 1; // 通常のフィールド optional string description = 2; // 省略可能なフィールド } 例えば、上記のような .proto ファイルから、次のように Golang コードを生成すると、
$ protoc --go_out=. --go_opt=paths=source_relative sample.proto 次のような SampleMessage 型のコードが生成されます。
sample.pb.go type SampleMessage struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Message string `protobuf:&amp;#34;bytes,1,opt,name=message,proto3&amp;#34; json:&amp;#34;message,omitempty&amp;#34;` // 通常のフィールド Description *string `protobuf:&amp;#34;bytes,2,opt,name=description,proto3,oneof&amp;#34; json:&amp;#34;description,omitempty&amp;#34;` // 省略可能なフィールド } Golang の場合は、オプショナルな string フィールドは、*string として表現されるようですね。</description></item><item><title>.proto の文法: oneof 型</title><link>https://maku.blog/p/vxixbp3/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vxixbp3/</guid><description>Protocol Buffers の oneof 型 は、定義したフィールドのうち、いずれか 1 つのフィールドのみに値が格納されていることを示す型です。 次の SampleMessage メッセージ型は、1 つの oneof 型フィールド status を持っています。
message SampleMessage { string content = 1; oneof status { int32 status_code = 2; string status_name = 3; } } 上記の oneof ブロックには status_code フィールドと status_name フィールドが定義されていますが、これらのいずれかのフィールドに値が格納されることを示しています。 実際にどのフィールドに値が格納されているかを調べる方法は、各言語の protobuf ライブラリ実装によって異なります。 下記は C++ の例です。
SampleMessage message; message.set_status_code(123); if (message.has_status_code()) { // ... } oneof のフィールドに値をセットすると、同じ oneof に含まれる他のフィールドの値はクリアされることに注意してください。
oneof フィールドに、repeated ラベル や optional ラベル を設定することはできません。</description></item><item><title>.proto の文法: マップ型 (map)</title><link>https://maku.blog/p/xpbnycm/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xpbnycm/</guid><description>Protocol Buffers でマップ型のフィールドを定義するには、map&amp;lt;key_type, value_type&amp;gt; という形式で型を指定します。 次の SampleMessage メッセージ型は、string 型のキーと Project 型の値を持つマップフィールドを定義しています。
sample.proto（map 型フィールドの例） message SampleMessage { // ... map&amp;lt;string, Project&amp;gt; projects = 3; } message Project { // ... } キーの型 (key_type) には、整数あるいは文字列 を指定することができます。 浮動小数点数 (float, double) やバイトデータ (bytes) を key_type にすることはできません。
値の型 (value_type) としては、ほぼすべての型 を指定できますが、マップ型だけは value_type にすることはできません。 つまり、マップのマップは表現できないことになるのですが、value_type として他のメッセージ型を持たせることができるので（上記の例では Project）、実際にはほぼ同様の情報を表現できます。
あと、あまり困ることはないでしょうが、Protocol Buffers ではマップの配列（リスト）は表現できません（つまり、repeated map&amp;lt;xxx, yyy&amp;gt; とはできません）。</description></item><item><title>.proto の文法: 列挙型 (enum)</title><link>https://maku.blog/p/p5wjbwq/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p5wjbwq/</guid><description>列挙型とは Protocol Buffers の 列挙型 は、取り得る値が、あらかじめ定義された定数の中からのみ選択可能であることを示す型で、.proto ファイルの中で enum キーワードを使って定義します。 列挙型は、ひとことで言うと、複数の定数をグルーピングする機能です。 下記の例では、Corpus という列挙型を定義し、SearchRequest メッセージ型のフィールドとして使用しています。
sample.proto enum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7; } message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; Corpus corpus = 4; } .proto のコーディングスタイル では、すべての列挙値の名前には、型名に相当するプレフィックス を付けるべしとされています（上記の CORPUS_ の部分）。 型名が 3 語以上で構成されていたりして長い場合は、略称のプレフィックスが使われることもあるようです。</description></item><item><title>.proto の文法: 別の .proto ファイルをインポートする (import)</title><link>https://maku.blog/p/e8yeofc/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e8yeofc/</guid><description>.proto ファイルをインポートする (import) Protocol Buffers の .proto 内で import ステートメントを使用すると、他の .proto ファイルの内容を取り込むことができます。 次の例では、main.proto から other.proto の内容をインポートして、OtherMessage というメッセージ型を参照しています。
proto/message/main.proto（インポートする側） syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/maku77/myapp/message&amp;#34;; import &amp;#34;message/other.proto&amp;#34;; message MainMessage { OtherMessage other = 1; } proto/message/other.proto（インポートされる側） syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/maku77/myapp/message&amp;#34;; message OtherMessage { string content = 1; } インポートのパスは、デフォルトでは protoc コマンドを実行したディレクトリからの相対パスで指定します。 起点となるディレクトリを変更したい場合は、protoc コマンドの --proto_path オプションで、.proto ファイルを配置したルートディレクトリを指定します。
.proto ファイルが proto ディレクトリ以下にある場合 $ protoc --go_out=. --go_opt=paths=source_relative --proto_path=proto message/main.proto 上記のように実行すると、proto/message/main.proto ファイル（およびそこからインポートされているファイル）を入力情報として、message/main.</description></item><item><title>.proto の文法: サービス型 (service)</title><link>https://maku.blog/p/napwb4e/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/napwb4e/</guid><description>Protoco Buffers の サービス型 は、クライアントとサーバー間の通信方法 (RPC メソッド群) を定義するための型で、.proto ファイルの中で service キーワードを使って定義します。
次の例では、Echo メソッドを持つ EchoService サービス型を定義しています。
// Echo メソッドを持つ EchoService の定義 service EchoService { rpc Echo (EchoRequest) returns (EchoResponse); } // Echo に送るリクエストメッセージの定義 message EchoRequest { string message = 1; optional string payload = 2; } // Echo が返すレスポンスメッセージの定義 message EchoResponse { string message = 1; } 引数と戻り値の方には、上記のように単一のメッセージ型を指定します。 スカラー型を指定することはできないので、単一の値を渡したいときも、独自のメッセージ型を用意する必要があります。 慣例として、引数の型には Request、戻り値の型には Response というサフィックスを付けます。
引数や戻り値が存在しない場合は、Google が用意している google.protobuf.Empty 型を使用することができます。
import &amp;#34;google/protobuf/empty.proto&amp;#34;; service HelloService { rpc Hello(google.</description></item><item><title>Cloudflare Workers をはじめる (wrangler)</title><link>https://maku.blog/p/rn7p7n5/</link><pubDate>Sun, 11 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rn7p7n5/</guid><description>Workers とは？ Cloudflare Workers は、Cloudflare 社が提供しているサーバレスプラットフォームで、Web リクエストに応じたレスポンスを返すサービスを簡単に構築することができます。 Workers は世界中に配置されたエッジサーバーで実行されるため、クライアントからの要求に高速に応答することができます。 Azure Functions や AWS Lambda と同じようなサービスですが、それらに比べて Workers は、より高速かつ安価という特徴を持っています。 毎日 10 万リクエストまで無料 で使えるので、趣味用途であれば、無料枠だけでいろいろ試せます。
本記事の作業を進めるには、あらかじめ Cloudflare のアカウントを作成しておく必要があります。 下記から無料で作成できます。
Cloudflare Workers を開始する - Sign Up Wrangler をインストールする Worker の開発やデプロイには、wrangler という公式のコマンドラインツールを使用します。 Node.js の npm コマンドを使って、次のようにインストールできます。
wrangler コマンドのインストール $ npm install wrangler -g Cloudflont へのアクセスを許可する (wrangler login) wrangler コマンドを実行できるようになったら、wrangler login を実行して、Cloudflare のアカウントと関連づけます。
Cloudflare へのサインイン $ wrangler login ⛅️ wrangler 2.6.2 ------------------- Attempting to login via OAuth... Web ブラウザーが自動的に開いて、Wrangler から Cloudflare のデータにアクセスしてよいか尋ねられるので Allow ボタンを押して許可します。 これで、wrangler の各種コマンドを実行できるようになります。 サインインした状態で wrangler whoami コマンドを実行すると、どの Cloudflare ユーザーでサインインしているかを確認できます。</description></item><item><title>Protocol Buffers の .proto ファイルから API ドキュメントを自動生成する (protoc-gen-doc)</title><link>https://maku.blog/p/ikw7gpz/</link><pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ikw7gpz/</guid><description>protoc-gen-doc とは？ David Muto 氏が公開している protoc-gen-doc という protoc コマンドのプラグインを使用すると、.proto ファイルから、HTML 形式や Markdown 形式のドキュメントを自動生成することができます。 複数の .proto ファイルの内容をまとめて 1 つのページとして出力してくれるので、シンプルで見通しのよいドキュメントになります。
生成されたドキュメントの例: HTML 形式 / Markdown 形式 / JSON 形式
protoc-gen-doc は protoc コマンドのプラグインとして動作するのですが、実行環境が Docker イメージとして提供されているので、docker コマンド一発で、簡単に .proto ファイルからドキュメントを生成できます。 もちろん、protoc コマンドと protoc-gen-doc を両方インストールして実行することもできますが、Docker を使った方が断然お手軽です。
Protocol Buffers Compiler（protoc コマンド）に関しては、こちらを参考にしてください。
.proto ファイルからのドキュメント生成 protoc-gen-doc コマンドの基本 protoc-gen-doc の Docker イメージを使って、.proto ファイルからドキュメントを生成してみます。 Docker の実行環境は、Docker Desktop などでインストールしてください。 .proto ファイルが手元になければ、とりあえず下記のファイルをダウンロードして試せます。
Vehicle.proto（サンプル .proto ファイル） proto/Vehicle.proto のように、proto ディレクトリに格納すれば準備完了です。 あとは次のように実行すると、docs ディレクトリに index.html ファイルが生成されます。</description></item><item><title>Nginx の設定: Nginx の設定内容を確認する (nginx -T)</title><link>https://maku.blog/p/bm6n5k2/</link><pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bm6n5k2/</guid><description>nginx サーバーが読み込む設定情報を確認するには、nginx -T コマンドを使用します。 正確には、このコマンドは設定ファイルの検証 (nginx -t) と、内容の出力を同時に行うコマンドです。
nginx が実際に読み込む設定を確認 $ nginx -T 下記は、nginx -T コマンドを実行したときの出力例です。 最初の 2 行が設定ファイルの検証結果で、3 行目以降が具体的な設定内容です。
出力例 nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful # configuration file /etc/nginx/nginx.conf: user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39; &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39; &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;; access_log /var/log/nginx/access.</description></item><item><title>読書メモ『アルテミス』アンディ・ウィアー</title><link>https://maku.blog/p/vt4bjry/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vt4bjry/</guid><description>アルテミス アンディ・ウィアー 早川書房 『火星の人』 の著者、アンディ・ウィアーの SF 小説です。 前作は、マット・デイモン主演の映画版『オデッセイ』の方が有名かもしれません。 今回は 月が舞台 で現実味があります。 上下巻構成ですが、一人称で軽い調子で話が進んでいくのでサクッと読めてしまいます。
アルテミスは、月面に作られた居住区の名前で、5 つのドーム（バブル）から構成されています。 それぞれのバブルの名前は、アポロ計画の宇宙飛行士の名にちなんで、「アームストロング」「コンラッド」「オルドリン」「ビーン」「シェパード」という名前になっていてシャレオツ。
子供のころから月で暮らしている女性、ジャズ・バシャラは、地球から送られてくる品物を運ぶポーターをして生活していますが、決して裕福ではなく、非合法な仕事にも手を出しています。 あるとき、大物実業家から引き受けた依頼で一攫千金を狙うのですが、それは、月での酸素供給に関わる仕事でした。 その時点でヤバイでしょ。 酸素の供給施設は、すなわち 2000 人の住民全員の命を握っています。 そんな任務を受けてしまったジャズは、大きな陰謀に巻き込まれていきます。
地球の 1/6 の重力下での命懸けのアクションや、監視だらけの月面での無謀なミッションは、読んでいてハラハラします。 そんな中でもジャズは、一人で微妙なギャグを飛ばしながら任務を進めていきます。 頭のネジがぶっ飛んでいるのでしょう。
月での暮らしはこんな感じになるのかぁ・・・</description></item><item><title>SSH キーの管理: SSH キーのコメントを確認する／変更する (ssh-keygen -c)</title><link>https://maku.blog/p/o3m4j2h/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o3m4j2h/</guid><description>SSH 鍵ファイルのコメントを確認する OpenSSH の ssh-keygen コマンド で生成した SSH キーペア（秘密鍵＋公開鍵）には、デフォルトで ユーザー名@ホスト名 という形のコメントが付加されます。 このコメントは、公開鍵ファイル (~/.ssh/id_XXX.pub) の末尾を見ると確認できます。
~/.ssh/id_ed25519.pub ssh-ed25519 AAA3NzaC1AA...省略...COst+87ciWFY maku@macobook.local あるいは、ssh-keygen -l コマンドで確認することもできます。
SSH キーの内容を確認 $ ssh-keygen -l -f ~/.ssh/id_ed25519 256 SHA256:vd6Ab577wzS6/so1BR1zGP8r7br0smWV4Wklw28Rre0 maku@macbook.local (ED25519) SSH 鍵ファイルのコメントを設定する SSH キーのコメントは、キーの作成時に -C オプションで自由に設定できます。
コメントを指定して SSH キーを生成 $ ssh-keygen -t ed25519 -C &amp;#34;your_email@example.com&amp;#34; 既存の SSH キーのコメントを修正するには、ssh-keygen -c コマンドを使用します。
SSH キーのコメントを変更 $ ssh-keygen -c -C &amp;#34;新しいコメント&amp;#34; -f ~/.ssh/id_ed25519 オプションの大文字と小文字に注意してください。 最初は小文字 (-c) で、後ろは大文字 (-C) です。</description></item><item><title>SSH キーの管理: SSH キーのパスワードを変更する (ssh-keygen -p)</title><link>https://maku.blog/p/as2ahpw/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/as2ahpw/</guid><description>既存の SSH キー（秘密鍵）のパスワード（パスフレーズ）を変更するには、ssh-keygen -p コマンドを使用します。
$ ssh-keygen -p [-a rounds] [-f keyfile] [-m format] [-N new_passphrase] [-P old_passphrase] 変更する SSH キーのファイルパス (-f) や、旧パスワード (-P)、新パスワード (-N) をオプションで指定することもできますが、次のようにオプションなしで実行すれば、対話的に変更内容を入力していけます。
$ ssh-keygen -p Enter file in which the key is (/Users/maku/.ssh/id_rsa): Enter old passphrase: ******** Key has comment &amp;#39;maku@macbook.local&amp;#39; Enter new passphrase (empty for no passphrase): ******** Enter same passphrase again: ******** Your identification has been saved with the new passphrase. パスワードはオプションで指定すると入力内容が見えてしまうので、上記のように対話的に入力した方がよいでしょう。</description></item><item><title>SSH キーの管理: SSH キーの種類やフィンガープリントを確認する (ssh-keygen -l)</title><link>https://maku.blog/p/m2k4j2h/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m2k4j2h/</guid><description>作成済みの SSH 鍵ファイルの種類（暗号アルゴリズム）やフィンガープリントを確認したいときは、ssh-keygen -l コマンドを使用します。 -f オプションで指定する鍵ファイルのパスは、秘密鍵でも公開鍵でも構いません。 次の例では、OpenSSH の ssh-keygen コマンドで作成したさまざまな種類の SSH キーの内容を表示しています。
$ ssh-keygen -l -f ~/.ssh/id_ed25519.pub 256 SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yourname@example.com (ED25519) $ ssh-keygen -l -f ~/.ssh/id_ecdsa.pub 256 SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yourname@example.com (ECDSA) $ ssh-keygen -l -f ~/.ssh/id_rsa.pub 2048 SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yourname@example.com (RSA) $ ssh-keygen -l -f ~/.ssh/id_dsa.pub 1024 SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yourname@example.com (DSA) 各フィールドは、「鍵のビット長」「フィンガープリント」「コメント」「暗号アルゴリズム」を示しています。
Windows PC の場合は、~/.ssh の部分は %USERPROFILE%\.ssh と読みかえてください。</description></item><item><title>Apollo Client の ApolloLink チェーンで HTTP リクエストをカスタマイズする</title><link>https://maku.blog/p/xa62yo4/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xa62yo4/</guid><description>ApolloLink とは？ 図: Apollo Client の Link チェ―ン Apollo Client を使って GraphQL API を呼び出すとき、GraphQL サーバーに対して HTTP リクエストが送られるわけですが、Apollo Client は内部で Link チェーンというものを作って具体的な HTTP リクエストを構築します。 この構築処理を実装するものが Link オブジェクトであり、具体的には ApolloLink クラスのインスタンスです。 Link オブジェクトは図のように Link チェーンの形で連結して使用できるようになっており、通信内容を加工する一連のミドルウェア として機能します。 Link オブジェクトの用途としては、次のようなものがあります。
HTTP リクエストヘッダの付加 認証情報の付加（authorization ヘッダー） GraphQL サーバーで独自定義したヘッダー アクセス先 URL（GraphQL エンドポイント）の切り替え デバッグログの出力 自動リトライ（参考: RetryLink） リクエスト回数をカウント サーバー応答速度（ラウンドトリップ時間）の計測 複数のクエリのバッチ送信（参考: BatchHttpLink） Persisted クエリ（参考: PersistedQueryLink） Link オブジェクトは任意の順序でチェーンできますが、末端の GraphQL サーバーに接続する部分は Teminating link として振る舞う必要があり、通常は HttpLink クラスのインスタンスを設定します。 HttpLink クラスは ApolloLink を継承して実装されています。
ApolloClient に ApolloLink を設定する ApolloClient コンストラクタに渡すオブジェクトの link プロパティで、任意の ApolloLink インスタンスを設定できるようになっています。 下記は、GraphQL API のエンドポイントやリクエストヘッダーを設定する簡単な HttpLink を生成して設定する例です。</description></item><item><title>GraphQL スキーマ仕様: ページネーション (pagination)</title><link>https://maku.blog/p/vuo4px3/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vuo4px3/</guid><description>ページネーションとは？ GraphQL API で数百件を超えるような大量のデータを取得できるようにする場合は、ページネーション処理を考慮した API 定義を行うのが一般的です。 ページネーションというのは、Google の検索結果にあるような「次へ」「前へ」というような機能のことです。 ページネーションをどう実装すべきかは、GraphQL の仕様として定義されているわけではないのですが、デファクトスタンダードな実装方法が確立されており、大きく次の 2 種類の実装方法があります。
オフセット・ページネーション (offset pagination) カーソル・ページネーション (cursor pagination) それぞれの方法を順に見ていきます。
オフセット・ページネーション (offset pagination) オフセット・ページネーションは、複数のデータを取得するときに、どの位置（オフセット）から取得するかを、ページやデータのインデックスで指定する方法です。
type Query { books(limit: Int!, page: Int!): [Book!] } クエリパラメーターの意味 limit &amp;hellip; いくつのデータを取得するか page &amp;hellip; どの位置から取得するか（絶対位置） オフセット・ページネーションは実装が簡単で使いやすいという利点がありますが、いくつかの問題があります。
DB アクセスのコスト問題（スケールしない） 例えば、上記のような books クエリが次のような SQL にマッピングされたとします。
SELECT * FROM books LIMIT 100 OFFSET 500; クライアントは 100 件分のデータしか要求していませんが、RDB 側の処理としては、500 + 100 件分の読み出しが必要になります。 しかも厄介なことに、OFFSET が増加するごとに読み出し量が増えていくため、ページを進めていくたびにパフォーマンスが悪化していきます。 クラウド系の RDB サービスを使っている場合は、多額の料金を請求されることになります。
結果の一貫性を保てないことがある あるページを表示しているときに、バックグラウンドでレコードが追加されると、その次のページに移ったときに、同じレコードが表示される可能性があります。 逆にレコードが削除された場合は、次のページに移ったときに、表示されるべきレコードが飛ばされてしまったりします。 これは、表示位置を常に先頭レコードからのオフセットで指定していることが原因です。</description></item><item><title>IGDB API でゲーム情報のデータベースにアクセスしてみる</title><link>https://maku.blog/p/mu7gqya/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mu7gqya/</guid><description>IGDB は、世の中の（ビデオ）ゲームの情報をデータベースとして集約しようとしている壮大なプロジェクトで、現在 Twitch が運営しています。 この情報には IGDB API という Web API でアクセスできるようになっていて、簡単に試す程度なら無料で利用できます。 ちょっと試してみたのでメモに残しておきます。 とりあえず、curl コマンドで API のレスポンスを確認するところまで。
大まかには、Twitch developers console でアプリクライアントを登録し、アクセストークンを発行して API を叩く、という流れになります。
Twitch アカウントを登録する IGDB API を使うには、Twitch developers コンソールでアプリケーション（クライアント）の登録が必要です。 このサイトにサインインするには、Twitch のアカウントが必要 なので、下記から作成します。 すでに Twitch アカウントを持っている場合は、そのまま使えます。
Twitch Developers - Login さらに、API を使用する場合は、さらに二段階認証の設定が必須になっているので、次のような感じでたどって設定しておきます。 メールアドレスや電話番号を登録すれば二段階認証を有効化できます。
Twitch - 設定 - セキュリティとプライバシー アプリケーションを登録してクライアント ID とシークレットを発行する Twitch developers コンソール の アプリ管理画面 でアプリを登録すると、クライアント ID とシークレットキーを取得できます。
アプリケーションを登録 ボタンをクリック 名前: 適当な名前を入力（グローバルに一意な名前じゃないといけないっぽい） OAuthのリダイレクトURL: 決まっていないなら http://localhost:3000 などを入力しておけば OK カテゴリー: プルダウンから適当に選択（Website Integration など） 作成 ボタンを押して完了 作成されたアプリの 管理 ボタンをクリック 新しい秘密 ボタンを押してクライアントシークレットを発行 上記の手順で、IGDB API を呼び出すためのクライアント ID とシークレットを確認できます。</description></item><item><title>GraphQL スキーマ仕様: ユニオン型 (Union types) を定義する</title><link>https://maku.blog/p/vqsyz9j/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vqsyz9j/</guid><description>ユニオン型を定義する GraphQL スキーマの ユニオン型 (Union types) は、複数の型のうち、いずれかの型であることを表現する型です。 典型的には、検索系のフィールドにおいて、様々な種類のデータを返す場合に使われます。 ユニオン型は、union キーワードを使って次のように定義します。
ユニオン型の定義 union TaskOrTodo = Task | Todo type Query { search(term: String!): [TaskOrTodo!] } 下記は GitHub の GraphQL スキーマで定義されているユニオン型の例です。
GitHub API の union 型の例 &amp;#34;&amp;#34;&amp;#34; Used for return value of Repository.issueOrPullRequest. &amp;#34;&amp;#34;&amp;#34; union IssueOrPullRequest = Issue | PullRequest &amp;#34;&amp;#34;&amp;#34; Types that can be inside a Milestone. &amp;#34;&amp;#34;&amp;#34; union MilestoneItem = Issue | PullRequest クエリでユニオン型を使う GraphQL クエリにおいてユニオン型のフィールドを参照するときは、インラインフラグメント を使って、具体的な型ごとにフィールドを参照する必要があります。
ユニオン型のフィールドを参照するクエリ query QueryRecentActivities { search(type: ISSUE, query: &amp;#34;repo:graphql/graphql-spec&amp;#34;, last: 10) { nodes { .</description></item><item><title>GraphQL Code Generator でスキーマから TypeScript の型情報を生成する (graphql-codegen)</title><link>https://maku.blog/p/n2k2hxd/</link><pubDate>Mon, 03 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n2k2hxd/</guid><description>GraphQL Code Generator とは GraphQL Code Generator (graphql-codegen) は、GraphQL スキーマ (schema.graphqls) とクエリ用のドキュメント (query {...}) を入力として与えることで、さまざまな言語とライブラリに対応した型情報を生成するツールです。
公式 Web サイト - GraphQL Code Generator GitHub リポジトリ - dotansimha/graphql-code-generator 図: graphql-codegen の動作概要 C# や Dart 用のコードも生成できるようですが、ツール自体が NPM パッケージとして提供されているので、やはり TypeScript がメインターゲットですね。 クライアント側で、React + Apollo Client のフレームワークを使用している場合は、Apollo Client のフック API (useQuery) に渡すためのオブジェクトを生成してくれます。 GraphQL サーバー側のリゾルバー実装に使用する型情報を生成するのにも使用できますが、GraphQL サーバーを Golang の gqlgen で作る 場合などは、スキーマから Golang コードを生成する仕組みがそれ自体に備わっていたりするので、そこではこのツールは使いません。 一方、フロントエンドは React + TypeScript で作ることが比較的多いので、このツールの出番も多くなります。
入力するスキーマ情報としては、スキーマファイル（schema.graphqls など）を指定することも、GraphQL サーバーのアドレスを指定して Introspection 機能で取得することもできます。 GraphQL クライアントの開発中は、接続先の GraphQL サーバーも動いているでしょうから、そこから直接スキーマ情報を取得するのは理にかなっています。 例えば、GraphQL サーバー側の Git リポジトリでスキーマファイルを管理している場合、クライアント開発時にこのスキーマファイル自体を共有しなくて済みます。</description></item><item><title>Go アプリを実行する軽量な Docker コンテナイメージを作成する</title><link>https://maku.blog/p/wbtbr8o/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wbtbr8o/</guid><description>何をするか？ Go 言語 (Golang) で簡単な Web サーバーを作成して、それを動かす軽量な Docker コンテナイメージを作成します。 Dockerfile には マルチステージのビルド構成 を適用し、Go 言語アプリのビルドと、実行イメージのビルドのステージを分けます。 実行用のコンテナイメージとしては、Alpine Linux ベースと、scratch ベースの 2 種類のイメージを作成してみます。
Golang は軽量なシングルバイナリを生成するのに適した言語で、Docker イメージの生成にも向いています。 Node.js などでイメージを作ろうとすると、Hello World でも 100MB 超えになってしまいますが、Golang を使えば、その 1/10 程度のサイズのイメージを生成できます。 軽量のイメージを作れるようになると、頻繁なビルドとデプロイを気兼ねなく行えるようになります。
Golang アプリを準備する Golang で作るアプリは何でもよいのですが、ここでは Golang 標準の net/http パッケージを使って、Hello World というレスポンスを返すだけの簡単な Web サーバーアプリを用意します。
まずは、お馴染みの go.mod の作成から。
$ mkdir hello &amp;amp;&amp;amp; cd hello $ go mod init hello あとは、次のような main.go ファイルを作成すれば完成です。
main.go package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.</description></item><item><title>GraphQL クエリ仕様: クエリで変数を使用する</title><link>https://maku.blog/p/dtwtpzj/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtwtpzj/</guid><description>変数定義と変数値の指定 特定のパラメーターのみ値を変えて複数の GraphQL のクエリを発行したい場合は、ドキュメント内で query や mutation を定義するときに、変数定義 (variable definitions) を追加します。
次の GetBook クエリでは、$id: String! という変数定義を行っています。 これは、クエリ実行時に id という名前の文字列変数を参照することを示しています。 そして、型名に ! が付いているので、変数値の指定は必須です。
変数を参照するクエリの例 query GetBook($id: String!) { book(id: $id) { id title price } } 指定された id 変数の値は、book フィールドの id 引数として渡され、対応する書籍を取得するリクエストとして処理されます。
肝心の変数の値は、query や mutation などのドキュメントとは異なる variables という HTTP ペイロード・フィールドで GraphQL サーバーへ送ります（HTTP POST 経由での GraphQL API 呼び出しの場合）。 ただ、このあたりの variables フィールドの送信に関しては、通常は各種言語用の GraphQL ライブラリに隠蔽されているため、明示的に HTTP POST リクエストのペイロードを設定することはありません。 例えば、React 用の Apollo Client ライブラリは、次のような感じで変数を設定するインタフェースを提供しています。
const { loading, error, data } = useQuery&amp;lt;QueryType, VarType&amp;gt;(query, { variables: { id: &amp;#34;book-123&amp;#34; } }) Web ブラウザ上で GraphQL API のテストを行える GraphiQL（グラフィカル） の UI では、次のようにドキュメントと変数を別々に記述できるようになっています。</description></item><item><title>GraphQL スキーマ仕様: ミューテーションを定義する（データ更新 API）</title><link>https://maku.blog/p/pk9c9qs/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pk9c9qs/</guid><description>GraphQL API でサーバーサイドのデータを更新するには、ミューテーション操作 (mutation) を含むクエリを送信します。 このときどのようなミューテーションを行えるかは、GraphQL スキーマの中で、Mutation 型のフィールドとして定義します。
ミューテーションのスキーマを定義する 次の例では、書籍データを新規作成するための createBook ミューテーションと、削除するための deleteBook ミューテーションを定義しています。 フィールド名は変更内容を表す動詞で始めるのが一般的です。
GraphQL スキーマ定義 type Mutation { createBook(title: String!, author: String!): Book! deleteBook(id: ID!): Boolean! } 各フィールドにはパラメーター（上記の title など）を定義することができ、そのパラメーターの指定が必須である場合には、型名の末尾に ! を付けます (String!)。
ミューテーションが呼び出されたときの実際の処理内容は、GraphQL サーバー側のミューテーション・リゾルバーで実装します。 リゾルバーの実装方法は、各言語の GraphQL サーバーライブラリによって異なります。 例えば、下記は Golang の gqlgen パッケージを使った場合のリゾルバー実装の例です。
ミューテーション・リゾルバーの実装 // CreateBook is the resolver for the createBook field. func (r *mutationResolver) CreateBook( ctx context.Context, title string, author *string, ) (*model.Book, error) { id := uuid.</description></item><item><title>GraphQL スキーマ仕様: 入力型 (input type) を定義する</title><link>https://maku.blog/p/nhhwqtu/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nhhwqtu/</guid><description>GraphQL スキーマで定義する 入力型 (input type) は、クエリ／ミューテーション要求時のフィールド引数にのみに使用できるオブジェクト型です。 入力型を使うと、複数のフィールド引数をひとつのオブジェクトにまとめることができます。
次の Mutation 型の createBook フィールドは、フィールド引数として CreateBookInput という入力型を使っています。
スキーマ定義 type Mutation { createBook(input: CreateBookInput!): Book } 入力型を定義するときは input キーワードを使用します（フィールド自体を表す型の定義には type キーワードを使用します。こちらは出力型と呼ばれたりします）。 フィールドの定義方法は type も input も同じです。
次のスキーマは、上記の createBook フィールドの型 (Book) と、その引数の型 (CreateBookInput) を定義しています。 type キーワードと input キーワードを使い分けていることに注意してください。
スキーマ定義 type Book { id: ID! title: String! author: String year: Int } input CreateBookInput { title: String! author: String year: Int } Book 型と CreateBookInput 型のフィールドはほとんど共通ですが、Book 型には GraphQL サーバー側で自動生成される id 情報が含まれています。</description></item><item><title>GraphQL スキーマ仕様: 列挙型 (enum type) を定義する</title><link>https://maku.blog/p/isotm77/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/isotm77/</guid><description>列挙型の基本 GraphQL スキーマでは、enum キーワードを使って列挙型を定義することができます。 列挙型は、スカラー型と同様に単一の値を表しますが、とり得る値があらかじめ限定されています。 String や Int などの代わりに適切な列挙型を使えば、API の使い方が明確になり、クライアントによる誤用を防ぐことができます。
次の例では、Episode という名前の列挙型を定義しています。
GraphQL スキーマでの列挙型の定義 enum Episode { NEWHOPE EMPIRE JEDI } 列挙型は、フィールドのパラメーターの型として使用することができます。
type Query { hero(episode: Episode): Character } 列挙型は、フィールドの型としても使用できます。
type Character { name: String! appearsIn: [Episode]! } 列挙型の使用例 列挙型の典型的な使用例として、ソート用のフィールド・パラメーターがあります。 下記は、GitHub の GraphQL スキーマで定義されている列挙型の例です。 GistOrder 入力型 のフィールドに、GistOrderField 列挙型が使われています。
GitHub の GraphQL スキーマ（抜粋） &amp;#34;&amp;#34;&amp;#34; Ordering options for gist connections &amp;#34;&amp;#34;&amp;#34; input GistOrder { &amp;#34;&amp;#34;&amp;#34; The ordering direction. &amp;#34;&amp;#34;&amp;#34; direction: OrderDirection! &amp;#34;&amp;#34;&amp;#34; The field to order repositories by.</description></item><item><title>メカニカルキーボードが逝く</title><link>https://maku.blog/p/pziygwd/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pziygwd/</guid><description>メカニカルキーボードのタイピング時の若干こすれるような音が気になったので、キーキャップを全部外して、シリコンスプレーをブワーッと吹きかけました。 タイピングがぬるぬるになって、とってもいい感じです。
ウェーイ 乁( ˙ω˙ )厂 シリコンスプレー最強！ 一週間後 &amp;hellip;
キーがまったく反応しなくなりました 調べてみると、シリコンスプレーは絶縁性のある膜を作るので、電子的なスイッチ類に使うのは厳禁とのこと。 あと、別に無水エタノールみたいに基板に対して安全に使えるものでもないことも発覚。
ウェーイ 乁( ˙ω˙ )厂 と言いながら、キーボードに水よりも危険な液体をぶっかけてたようなもんですね。。。
高い勉強代になりました。 悲しいので寝ます。。。シクシク(-.-)Zzz
（追記）2022-09-24 新しいの買ってしまったー！ これは新しいの買えという啓示だったのです。
Keychron K3 ていうキーボードです。 初めての赤軸メカニカル＆ Bluetooth キーボード。 選定のポイントは、(1) 英字配列で、(2) 無線で、(3) 静音で、(4) バッククォートキーが独立していること。
ロープロファイルという、キーの背丈が低いメカニカルなのですけど、今のところキータッチはいい感じです。 できれば静音赤軸（ピンク軸）というめっちゃ静かなやつがよかったのですが、このモデルは茶軸、赤軸、青軸の 3 種類しかないのでしょうがない。
肝心の Bluetooth 接続は、入力のラグが結構ありますね。。。 いや、Bluetooth が遅いんじゃない、わたしが速すぎるのだ｜ω☆）</description></item><item><title>GraphQL スキーマ仕様: 組み込みのスカラー型とカスタムスカラー型</title><link>https://maku.blog/p/tw75a7p/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tw75a7p/</guid><description>5 つの組み込みスカラー型 (Scalar types) GraphQL 仕様で定義されているスカラー型は次の 5 つで、これらを各オブジェクト型のフィールドの型や、フィールド引数の型として使用します。
型名 意味 Int 符号付き 32 ビット整数 Float 符号付き倍精度浮動小数点数 String 文字列（UTF-8 エンコーディング） Boolean true または false ID 一意の識別子。データ形式としては String と同様ですが、ID はリーダブル（意味のある単語）にはなっていないことを示唆します。ID は GraphQL サーバーとクライアントの間でオブジェクトの同一性を示すために使用します。 これ以外の型を使用したいときは、独自のオブジェクト型、スカラー型、列挙型を定義して使用します。
カスタムスカラー型 (Custom scalar types) スカラー型にフォーマット制約を設けたいときや、任意のクラスのインスタンスとして扱いたいときは、独自の カスタムスカラー型 を定義します。 例えば、日時や E メールアドレス、UUID、URI などは、カスタムスカラーを使うべき典型的なフィールドの例です。 カスタムスカラーは、スキーマドキュメント内で scalar キーワードを使って定義できます。
カスタムスカラー型の定義 &amp;#34;&amp;#34;&amp;#34; 日時を表すスカラー型 (ISO 8601 形式の文字列) &amp;#34;&amp;#34;&amp;#34; scalar DateTime type Event { title: String! startAt: DateTime } ライブラリの実装によりますが、カスタムスカラー型をそのまま使おうとすると、単なる String 型として扱われます。 カスタムスカラー型のデータを GraphQL サーバー型でどのようにハンドルするかは、サーバーライブラリごとに実装方法が提供されています。 例えば、下記は Golang の gqlgen ライブラリにおけるカスタムスカラー型のドキュメントです。 実装例として、yes や no として送られてきた文字列データを、Golang の bool 型として参照できるようにする方法が紹介されています。</description></item><item><title>GraphQL クエリ仕様: ディレクティブによる条件分岐 (@include, @skip)</title><link>https://maku.blog/p/dcdv7rv/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dcdv7rv/</guid><description>GraphQL クエリで、各フィールド名（あるいはフラグメント）の後ろに @include ディレクティブや @skip ディレクティブを配置すると、if 引数で指定した条件によってそのフィールドを取得するかどうかを制御できます。
fieldName @include(if: $someTest) fieldName @skip(if: $someTest) @include ディレクティブと @skip ディレクティブの違いは、if 引数の判定が逆転しているだけです。
@include(if: Boolean) ディレクティブ if 引数の値が true のときにのみフィールドを取得します @skip(if: Boolean) ディレクティブ if 引数の値が false のときにのみフィールドを取得します クエリ内での @include ディレクティブによる条件分岐 query QueryOrganization($org: String!, $details: Boolean = false) { organization(login: $org) { name description websiteUrl @include(if: $details) { } } variables { &amp;#34;org&amp;#34;: &amp;#34;graphql&amp;#34;, &amp;#34;details&amp;#34;: true }</description></item><item><title>GraphQL クエリ仕様: フィールド名にエイリアスを付ける</title><link>https://maku.blog/p/vnkd4ur/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vnkd4ur/</guid><description>GraphQL クエリ言語の フィールド・エイリアス 機能を使うと、取得したフィールド値を参照するときに、任意の別名を付けて参照することができます。 例えば、GraphQL スキーマとしては company というフィールド名で定義されているものを、companyName という JSON プロパティ名で返して欲しいときは、次のようにフィールド・エイリアスを使用します。
GraphQL クエリ query ProfileInfoWithAlias { user(login: &amp;#34;maku77&amp;#34;) { name companyName: company bio } } レスポンス { &amp;#34;data&amp;#34;: { &amp;#34;user&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Makkuma&amp;#34;, &amp;#34;companyName&amp;#34;: &amp;#34;maku maku company&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;すーぱーぷにぐらまー&amp;#34; } } } フィールド・エイリアスは、同名のフィールドを異なる引数で取得するときに役立ちます。
GraphQL クエリ query { maku77: user(login: &amp;#34;maku77&amp;#34;) { ...basicUserInfo } puni: user(login: &amp;#34;puni&amp;#34;) { ...basicUserInfo } } fragment basicUserInfo on User { name bio } 上記のように 1 つのクエリの中で同名のフィールド（ここでは user）を要求する場合に、フィールド・エイリアス（ここでは maku と puni）を付けることで、レスポンスのプロパティ名がコンフリクトしないようにします。 というより、このケースではエイリアスを設定しないと、リクエスト時にエラーになります。</description></item><item><title>GraphQL スキーマ仕様: @deprecated ディレクティブで非推奨のフィールドを示す</title><link>https://maku.blog/p/bg9g8rc/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bg9g8rc/</guid><description>GraphQL スキーマ内のある型のフィールドや Enum 値が非推奨になったことを表すには、@deprecated ディレクティブを使用します。 reason 引数で非推奨とされた理由を記述することができるので、その文章中に代替となるフィールド名を記述しておくと親切です。
次の例では、email フィールドが非推奨 (deprecated) になり、代わりに emailAddress フィールドを参照して欲しいことを示しています。
type User { emailAddress: String email: String @deprecated(reason: &amp;#34;Use &amp;#39;emailAddress&amp;#39;.&amp;#34;) }</description></item><item><title>GraphQL スキーマ仕様: インタフェース型 (interface type) を定義する</title><link>https://maku.blog/p/yp9mv5d/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yp9mv5d/</guid><description>インタフェース型を定義する GraphQL のインタフェース型は、複数の型が共通して持つフィールドを定義するための抽象型で、interface キーワードを使って定義します。 次の ScheduleItem インタフェースは、2 つのフィールド（id と title）を持つことを示しています。
スキーマ定義 # 共通のインタフェースを定義 interface ScheduleItem { id: ID! title: String! } インタフェースを実装する (imlements) 側の型は、必ず id と title フィールドを持つ必要があります。 次の Task オブジェクト型と Milestone オブジェクト型は、ScheduleItem というインタフェースを実装しています。
スキーマ定義（続き） # Task 型は必ず id と title フィールドを持つ type Task implements ScheduleItem { id: ID! title: String! content: String } # Milestone 型は必ず id と title フィールドを持つ type Milestone implements ScheduleItem { id: ID! title: String! date: DateTime } scalar DateTime type Query { allItems(): [ScheduleItem!</description></item><item><title>GraphQL スキーマ仕様: 型やフィールドに説明文 (description) を記述する</title><link>https://maku.blog/p/c5pbs6p/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c5pbs6p/</guid><description>GraphQL スキーマで定義する型には、Python の docstring と同様のフォーマットで description というドキュメントを付加できます。 description は型の直前、あるいはフィールドの直前に、3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲む形で記述します。
description の記述例 &amp;#34;&amp;#34;&amp;#34; Represents an auto-merge request for a pull request &amp;#34;&amp;#34;&amp;#34; type AutoMergeRequest { &amp;#34;&amp;#34;&amp;#34; The email address of the author of this auto-merge request. &amp;#34;&amp;#34;&amp;#34; authorEmail: String &amp;#34;&amp;#34;&amp;#34; The commit message of the auto-merge request. If a merge queue is required by the base branch, this value will be set by the merge queue when merging. &amp;#34;&amp;#34;&amp;#34; commitBody: String .</description></item><item><title>Ansible で facts 情報を表示する</title><link>https://maku.blog/p/zw7emu3/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zw7emu3/</guid><description>Ansible の Playbook を実行すると、最初にリモートホストの情報 (Ansible facts) の収集が行われます。 ここには、OS の情報や IP アドレスの情報などが含まれており、タスクの中でこれらの情報を参照することができます。 実際に Ansible facts にどのような情報が含まれているかは、次のような Playbook で確認することができます。
show-facts.yml - hosts: all gather_facts: true tasks: - name: Show facts ansible.builtin.debug: var: ansible_facts 実行結果（抜粋） TASK [Show facts] ********************************* ok: [example.com] =&amp;gt; { &amp;#34;ansible_facts&amp;#34;: { &amp;#34;all_ipv4_addresses&amp;#34;: [ &amp;#34;172.xxx.xx.xx&amp;#34;, &amp;#34;160.xxx.xx.xx&amp;#34; ], &amp;#34;all_ipv6_addresses&amp;#34;: [ &amp;#34;xxxx:xxxx:xxxx:xxx:xxx:xxx:xx:xx&amp;#34;, &amp;#34;xxxx::x:xxxx:xxxx:xxxx&amp;#34; ], ... ansible_facts 変数の値がからっぽになってしまう場合は、gather_facts: false と指定していないか確認してください。
ansible_facts オブジェクトの個々のプロパティを参照するには次のようにします。
- name: Show architecture ansible.builtin.debug: msg: &amp;#34;Architecture: {{ ansible_architecture }}&amp;#34;</description></item><item><title>Ansible タスク例: ユーザーを特定のグループに参加させる (ansible.builtin.user)</title><link>https://maku.blog/p/s2fs5gs/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s2fs5gs/</guid><description>Ansible の ansible.builtin.user モジュール を使用すると、ターゲットノード上に指定したユーザーを作成することができます。 このモジュールは、既存のユーザーの情報を変更する場合にも使えるので、例えば、あるユーザーを指定したグループに参加させる、といったことが可能です。
次の Playbook では、ユーザー maku をグループ docker に参加させています。 ユーザーが存在しない場合は、ユーザー自体の作成も行います。
- hosts: all become: true tasks: - name: Append the group &amp;#39;docker&amp;#39; to the user&amp;#39;s groups ansible.builtin.user: name: maku groups: [docker] append: yes 注意点としては、groups でグループ名を列挙すると同時に、append: yes と指定するところです。 この指定により、ユーザー maku がすでに存在している場合に、現在のグループ情報はそのままで、追加で docker グループに参加するという意味になります。
逆に、純粋に docker グループにしか参加していないユーザーにしたいのであれば、append: yes の指定は省略して次のように記述すれば OK です（デフォルトは append: false です）。
ansible.builtin.user: name: maku groups: [docker] ユーザー名をハードコードするのではなく、SSH 接続しているカレントユーザーを対象にしてグループ参加させたいときは、ユーザー名として &amp;quot;{{ ansible_facts.env.SUDO_USER }}&amp;quot; を指定します。 これにより、sudo 実行前のユーザー名を取得できます。
- hosts: all gather_facts: true become: true tasks: - name: Append the group &amp;#39;docker&amp;#39; to the current user&amp;#39;s groups ansible.</description></item><item><title>Ansible タスク例: Docker と Docker Compose をインストールする</title><link>https://maku.blog/p/8k4j2gw/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8k4j2gw/</guid><description>何をするか？ 下記の Docker のインストールマニュアルに従い、Ansible で Ubuntu 22.04 に Docker の実行環境をセットアップします。
Install Docker Engine on Ubuntu | Docker Documentation Playbook の例 次の YAML ファイルは、Docker の公式サイトのインストール手順をほぼそのまま Playbook 化したものです。 この Playbook を ansible-playbook で実行することで、Docker (+ Docker Compose) のインストール、および Docker デーモンの起動まで完了します。
install-docker.yml - hosts: all gather_facts: false become: true tasks: - name: Install APT packages to use a repository over HTTPS ansible.builtin.apt: pkg: - ca-certificates - curl - gnupg - lsb-release update_cache: yes cache_valid_time: 86400 # cache for 1 day - name: Create APT&amp;#39;s keyrings directory ansible.</description></item><item><title>Ansible タスク例: 任意のコマンドを実行する (ansible.builtin.command/shell)</title><link>https://maku.blog/p/ihqz7em/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ihqz7em/</guid><description>Ansible のターゲットノード上で任意のコマンドを実行するには、次のような組み込みモジュールを使用します。
ansible.builtin.command モジュール 任意のコマンドを実行します。 シェルを経由せず、指定したコマンドを直接実行するので、シェル特有の機能は使えません。 Windows の場合は代わりに ansible.builtin.win_command を使用します。 ansible.builtin.shell モジュール シェル (/bin/sh) で任意のコマンドを実行します。 シェルの機能（$HOSTNAME のような変数展開や * によるファイルグロブ、&amp;gt; によるリダイレクトなど）を使用することができます。 Windows の場合は代わりに ansible.builtin.win_shell を使用します。 command モジュールの基本 指定したコマンドを実行したいときは、command モジュールの cmd パラメーターでそのコマンド（と引数）を指定します。
- name: Run command ansible.builtin.command: cmd: cat /etc/hostname 上記のような簡単なコマンドであれば、次のように省略して記述できます。
- name: Run command ansible.builtin.command: cat /etc/hostname 実行するコマンドの引数として &amp;quot;user name&amp;quot; のようなスペースを含む値を渡したいときは、次のように argv を使ってコマンドと各引数を分割して指定します（この場合、cmd パラメーターは使用しません）。
- name: Run command ansible.builtin.command: argv: - /usr/bin/add_user_to_db.sh - user name - database name ファイルの有無で実行するかどうか制御する (creates/removes) command モジュールで指定したコマンドは、デフォルトで毎回実行されますが、creates および removes パラメーターを使用すると、特定のファイルの有無によってコマンドを実行するかしないかを制御することができます。</description></item><item><title>Ansible タスク例: 空のディレクトリを作成する (ansible.builtin.file)</title><link>https://maku.blog/p/25gqyai/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/25gqyai/</guid><description>Ansible で空のディレクトリ作成するには、ansible.builtin.file モジュール の state パラメーターに directory を指定します。
空のディレクトリを作成する - hosts: all gather_facts: false become: true tasks: - name: Create directory ansible.builtin.file: path: /var/cache/myapp state: directory path パラメーターで指定したディレクトリ /var/cache/myapp を作成します。 すでにディレクトリが存在する場合は、このタスクはスキップされます。 ディレクトリは再帰的に作成されるので、深い階層のパスを指定しても大丈夫です（mkdir の -p オプションに相当）。
ディレクトリのパーミッションや所有者を指定する - hosts: all gather_facts: false become: true tasks: - name: Create directory ansible.builtin.file: path: /var/cache/myapp state: directory mode: &amp;#34;0755&amp;#34; owner: myapp-user group: myapp-group ディレクトリ作成時のパーミッションは mode、所有ユーザーは owner、グループは group で指定することができます。 パーミッションは、0755 のような 8 進数指定の代わりに、u=rw,g=r,o=r のようなシンボリックモードでも指定可能です。</description></item><item><title>Ansible タスク例: 空のファイルを作成する (ansible.builtin.file)</title><link>https://maku.blog/p/uas9p6m/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uas9p6m/</guid><description>Ansible で空のファイルを作成するには、ansible.builtin.file モジュール の state パラメーターに touch を指定します。 Linux の touch コマンドに相当する動きをするので、ファイルがなければ空のファイルを作成し、ファイルが存在する場合はタイムスタンプを更新する、という振る舞いになります。
空のファイルを作成する tasks: - name: Create file ansible.builtin.file: path: ~/sample.txt state: touch 上記のようにすると、path で指定したファイルを作成します。 ファイルが既に存在する場合は、ファイルの中身は変更せずに、タイムスタンプを更新します。 つまり、このタスクはすでにファイルが存在する場合も実行されます（changed になる）。
タイムスタンプを更新しない - name: Create empty file ansible.builtin.file: path: ~/sample.txt state: touch access_time: preserve modification_time: preserve ファイルがすでに存在する場合に、タイムスタンプを更新しないようにするには、access_time および modification_time パラメーターに preserve を指定します（両方とも指定する必要があります）。 この指定により、ファイルがすでに存在している場合は、このタスクはスキップされるようになります。</description></item><item><title>GitHub Actions でコンテナイメージをビルドして Docker Hub へ push する</title><link>https://maku.blog/p/v9r8o5k/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v9r8o5k/</guid><description>何をするか？ Docker イメージを作成するための Dockerfile を GitHub のリポジトリで管理しているとします。 ここでは、GitHub Actions のワークフローを作成して、GitHub リポジトリにコードを push したときに次のような処理が自動で実行されるようにします。
Dockerfile を使ってイメージをビルド Docker Hub にイメージを push 前提条件として、Docker Hub のアカウントは作成済みとします。
Dockerfile の準備 GitHub のリポジトリを作成して、ルートディレクトリに次のような Dockerfile をコミット＆プッシュしておきます。
Dockerfile FROM alpine:3 CMD [&amp;#34;echo&amp;#34;, &amp;#34;Hello World&amp;#34;] 上記のサンプルコードは、軽量の Alpine Linux で Hello World と出力するだけの Dockerfile ですが、もちろん好きなように記述していただいて構いません。
GitHub Actions の Secrets 情報を登録 GitHub Actions から Docker Hub にイメージをプッシュできるようにするため、GitHub リポジトリの Secrets 情報として、Docker Hub のユーザー名およびアクセストークンを登録しておきます。
Docker Hub のアクセストークンは次のように発行できます。
Docker Hub にサインイン 右上のユーザー名をクリックして、Account Settings を選択 Security → New Access Token と選択して、トークンの説明文を入力 Access Token description: Deploy hello world など適当に入力 Access permissions: 少なくとも Read, Write を付ける Generate ボタンを押して生成 これで、次のような感じのアクセストークンが発行されるので、どこかにコピーしておきます（後から確認することはできません）。</description></item><item><title>Jekyll と Hugo を共存させて GitHub Actions でビルドする</title><link>https://maku.blog/p/qbmv6fp/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qbmv6fp/</guid><description>何をするか？ こことは違う Web サイト (GitHub Pages) の話ですが、いい加減 Jekyll での Web サイト管理は限界 になってきたので、重い腰を上げて全面的に Hugo に乗り換えようと思います。 待っていれば Jekyll も高速化されるかなという淡い期待を抱いて 3 年が経ちましたが、一向にその気配はないので、残念ですがここで Jekyll は見限ります（決して Ruby と Golang の速度の差だけだとは思いませんが、やはり Golang 製のツールの方が高速な傾向はあるのかも）。
とはいえ、現状 Jekyll で管理している Web ページは何千ページにも膨れ上がっており、一気に乗り換えるのは困難です。 そこで、Jekyll 運用されている Web サイトに、少しずつ Hugo 管理のページを加えていく、という作戦を取りたいと思います。 ドメイン名はそのまま xxx.github.io を使いたいので、ホスティングはこれまで通り GitHub Pages で行い、ビルドやデプロイには GitHub Actions を使うことにします。
基本方針 GitHub Pages のデフォルトの仕組みとして、Markdown ファイルをソース用リポジトリに置いておくだけで、Jekyll で HTML に変換して公開してくれるというのがあるのですが、今回はこの仕組みは使えません。 なぜなら、Jekyll によるビルド結果と、Hugo によるビルド結果をマージしたものをデプロイしなければいけないからです。 イメージとしては、GitHub リポジトリに push したときに、GitHub Actions で次のような処理を実行できればうまくいくはずです。
図: GitHub Actions でやること Jekyll プロジェクトの Markdown ファイルをビルドする Jekyll のビルド対象から Hugo のディレクトリを除外しておきます Hugo プロジェクトの Markdown ファイルをビルドする Hugo プロジェクトのビルド結果を Jekyll プロジェクトのビルド結果にマージする 同名のファイルは上書きしないことにします（先輩である Jekyll の出力を優先） GitHub Pages のホスティング先にデプロイ ここでは gh-pages ブランチを公開ブランチとして使います Hugo のプロジェクトをフラットに配置してしまうと、content ディレクトリや layouts ディレクトリが混在してわかりにくくなるので、Hugo 側のファイル群は、hugo-files ディレクトリを作ってそこに配置することにします。 最終的に、Jekyll から Hugo への以降がすべて完了したら、この中のファイル群をルートに移動させる想定です。</description></item><item><title>読書メモ『1999年のゲーム・キッズ』渡辺浩弐</title><link>https://maku.blog/p/whs4dnv/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whs4dnv/</guid><description>1999年のゲーム・キッズ（上） 渡辺浩弐 講談社・星海社 1999年のゲーム・キッズ（下） 渡辺浩弐 講談社・星海社 25 年以上前に書かれた SF 短編小説集ですが、今読んでも面白いです。 『ファミ通』で 1 話ずつ掲載されていたものをまとめたものみたいですが、全く記憶にないですね（活字記事は見ていなかったのかも^^;）。 もっと昔に『デジタルな神様』という似た内容の小説も出ていますが、ゲームキッズシリーズ の中ではこれが最初の本でしょうか？ 上のリンクは講談社・星海社からの復刊ですが、わたしが読んだのは幻冬舎文庫のふる〜い 1997 年初版の方なのでちょっと内容が違うのかもｗ
図: 1997 年初版の方 題材になっている AI や VR といった技術が、今では普通に実現されていたりします。 SF プロトタイピングといって、商品開発にも SF が取り入れられたりする昨今ですが、kozy さんのショートストーリーは、とっかかりとしてよさそうですね。
以下、超絶 ネタバレ注意 です。 各話のストーリーを自分のためにオチ入りでまとめてます。 短くするためにだいぶ脚色してるので、本物の文章は、本物の書籍を手に入れて楽しんでくださいね。
各話まとめ 第1話「家族の絆」Family Computer おもしろいゲームをやってみたんだ。これは『DNA シミュレーション』っていって、人間同士の掛け合わせで子供を作って育てていくゲームなんだ。実は本物の人間のデータを入れることもできて、どんな素質の子供が生まれるかがわかるんだ。パパとママのデータを入れてみたら、やっぱり僕は生まれつきダメな、平凡な男なんだよね。だから、いくら僕ががんばって勉強しても無駄なものは無駄なんだ。ゲームだったらリセットできるんだけどね。 ── うわぁ、ママ、急に何するんだよ。冗談はやめろよ。く、苦しいよ。 第2話「起き抜けの悪夢」Daydream Believer マシンで脳をリフレッシュするブレイン・ジムが流行になっていた。僕は近所にオープンしたジムに、ひやかし半分に立ち寄ったのだが、5 分だけの試体験であまりの気持ちよさに仰天してしまった。会員になりたかったが、その料金はあまりにも高かった。 ── 「大丈夫ですよ。ひとつ方法があります。よく考えてください。このマシンに入れば、あなたはいつまでも無限にエクスタシーを得られるのです。人生のすべての努力は “エクスタシー” という最終目標のためにあるのですよ。契約して、このマシンに入ってしまえば、あなたはもう何をする必要もなくなるのです」マネージャーは書類の束を出した。 ── そこまで思い出した僕は、焦げ臭い煙の匂いに気がついた。火事か何かでマシンが急停止してしまったらしい。立ちあがろうとして、僕はベッドから転げ落ちた。ない……。僕の両足がない。右腕もない。残った左腕に、札のようなものが貼り付けられていた。 ── “売約済” 第3話「チャンネル戦争」Channel Good! 多視点映像、ゲーム、映画、電話、いまやテレビのチャンネルはあふれかえっている。僕は必死にチャンネルを変えて、やっと目的のチャンネルに辿り着いた。僕は、フーと息をついた。画面には何も映っていない。この “オフタイム” は、静寂のための番組。視聴率 30 ％を超える人気番組だ。テレビには OFF スイッチがなくなってしまっていた。 第4話「ゴーグルライフ」See Through It ゴーグラーをかけると、自分の見たものをすべてサーバーに保存しておくことができる。でも、そのシステムはハッカーたちの標的になっていた。今、僕は、近所の女子大生の視界に忍び込んだ。やがて、女子大生の部屋に中年男性がやってきて、2 人は外へ飛び出した。ある部屋のドアを蹴破り、中へ入る。「盗視の現行犯で逮捕する！」 ── 僕は、手錠をかけられるゴーグラーをした少年を見ていた。 第5話「人間もどき」Behind The Mask 皮膚を貼り付けて、どんな顔にでもなれる “トランス” 技術。宮沢りえの顔を持った彼女の顔を触ると、皮膚が剥がれ落ち、どろどろの醜い生物の顔が現れた。彼女は、ひとつ前に出た欠陥技術の被害者だった。彼女はそもそも男だったのか女だったのかすらも分からない。 ── 「ま、どっちでもいいか」アタシ、いや “オレ” はそう思った。 第6話「高校教師」Teaching Machine 小型のコンピューターや AI に自分の身体のようにアクセスできる今、教師の威厳はなくなり、テスト（試験）に価値が見いだせなくなっていた。身につけた機械は自分達のカラダの一部であり、テスト時にそれに頼ってもカンニングではないというのだ。われわれの学校の授業は、教育ロボットに置き換えられようとしている。そうなったら、私も含め、教師は皆クビというわけである。 ── 「……かくのごとき状況において、この教師の立場で、生徒の能力を正確かつフェアに判断する試験の方法を考えよ」 ── 僕は気が重くなった。また、浪人かなぁ……。 第7話「机上の空論」Desk-Top-News 昨日まで極悪非道として知られていた中東軍事国家の指導者が、今日のニュースでは柔和な紳士の顔に変わっている。新聞の一面を見ると、アメリカ大統領とその指導者が肩を抱き合っている写真にパッと入れ替わった。たったいま、国際情勢が大きく変わったのだ。 ── 親友から電話が入り、「おかしい、おかしい」と騒ぎ立てている。 ── その後、心配になって彼に電話をしようとしたら、スクリーンに連絡先が出てこない。“ソノナマエノ データハ ミアタリマセン” きっとそんな人はもともと存在しなかったのだ。 第8話「コピー・ブレイク」Copy Break これを読んでいるクローンの君へ。現在、記憶注入オペレーションの最中である。実際はほんの数時間の作業なのだが、君には何年もの歳月が流れているかのように感じられることだろう。このことを知らせるのは、君が目覚めたときのショックを和らげるためだ。さぁ、静かに目を上げたまえ。そこには見慣れた日常が戻ってきているはずだ。 第9話「究極のビジネス」Death For Sale 人工冬眠のビジネスを始めてみませんか？ 冷凍された人間が、本当に将来生き返るのかが心配ですって？ 大丈夫です。万が一、この技術に欠陥があっても、絶対にキャンセルも返品もないはずです。 （カリフォルニア州の アルコア延命財団 は、1960 年代から人工冬眠ビジネスを始めている） 第10話「逃げろ！」Run このペンダントは、超小型の気分コントロール・マシン。今、敵に襲われ追いかけられている俺は、＜やる気＞モードを最大にして、死に物狂いで逃げ続けた。そして、ついに振り切った。助かった……。 ── 「世界新記録だ！」コーチはそう言ってペンダントを外してくれた。42.</description></item><item><title>MUI で GitHub のようなリソース削除の確認ダイアログを作る（AreYouSure ダイアログ）</title><link>https://maku.blog/p/cbuan5h/</link><pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cbuan5h/</guid><description>何を作るか？ GitHub や AWS などで、何らかのリソースを削除するときに、次のような確認ダイアログが表示されることがあります。
図: GitHub のリポジトリ削除時の確認ダイアログ ユーザーは、削除対象のリソース名をタイピングするまで、削除ボタンを押すことができません。 これは、不用意にリソースを削除してしまわないための措置で、このようなダイアログは様々な場所で活用できます。 ここでは、MUI (Material-UI) で同様のリソース削除確認ダイアログ (AreYouSureDialog) の実装例を紹介します。 コードをシンプルにするために、表示テキストをハードコーディングしていますが、props に切り出せば汎用的な確認ダイアログとして使えるはずです。
AreYouSureDialog を実装する 完成時のイメージはこんな感じです。 UI のベースは、MUI の Dialog コンポーネントです。
ダイアログコンポーネントの実装 components/AreYouSureDialog.tsx import { FC, useCallback, useState } from &amp;#39;react&amp;#39; import { Button, Dialog, DialogContent, DialogContentText, DialogTitle, TextField, Typography, IconButton, } from &amp;#39;@mui/material&amp;#39; import CloseIcon from &amp;#39;@mui/icons-material/Close&amp;#39; /** ダイアログコンポーネントの props の型定義 */ type Props = { /** ダイアログを表示するなら true */ open: boolean /** 操作対象のリソース名（= ユーザーに入力させるテキスト） */ targetName: string /** * ダイアログを閉じるべきときに呼び出されます。 * * ユーザーが処理を承認したときは、submit の値が true となり、 * 捜査対象のリソース名が targetName に格納されます。 */ onClose?</description></item><item><title>Ansible で SSH サーバーをセキュアにする (ansible.builtin.lineinfile, ansible.builtin.service)</title><link>https://maku.blog/p/hufvdta/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hufvdta/</guid><description>SSH サーバーを安全に運用するには、いくつかのベストプラクティスがあります。 ここでは、root ユーザーでの SSH 接続を拒否 (PermitRootLogin no) する設定例を紹介します。
secure-sshd.yaml (Playbook) --- - hosts: all gather_facts: false become: true tasks: - name: Prohibit root login ansible.builtin.lineinfile: path: /etc/ssh/sshd_config state: present regexp: &amp;#39;^PermitRootLogin &amp;#39; line: &amp;#39;PermitRootLogin no&amp;#39; notify: - Reload ssh daemon handlers: - name: Reload ssh daemon ansible.builtin.service: name: sshd state: reloaded この Ansible Playbook では、次のようなことを行っています。
lineinfile モジュールで /etc/ssh/sshd_config の内容を修正する PermitRootLogin で始まる行が見つからない場合は、ファイルの末尾に PermitRootLogin no を追加する PermitRootLogin で始まる行が見つかった場合は、PermitRootLogin no に置換する（ただし、最初からその設定が記述されていたら何もしない） service モジュール で SSH デーモンに設定をリロードさせる この設定を行うと、root ユーザーでの SSH 接続ができなくなるので注意してください。 必ず、root ユーザー以外で SSH 接続できることを確認してから実行してください。</description></item><item><title>Linuxメモ: ユーザーのデフォルトシェルを変更する (chsh)</title><link>https://maku.blog/p/cqaq7n4/</link><pubDate>Fri, 05 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cqaq7n4/</guid><description>ユーザーが Linux にログインしたときに起動するデフォルトシェルは、chsh (change login shell) コマンドで変更することができます。
カレントユーザーのログインシェルを /bin/bash に変更する $ chsh -s /bin/bash -s オプションではシェルのフルパスを指定する必要があることに注意してください。 例えば、Bash を使いたければ、bash ではなく /bin/bash と入力します。 -s オプションを省略すると、インタラクティブにシェルのパスを入力できます。
参考リンク Linux のユーザーを管理する (useradd, userdel, passwd) ユーザーを追加する (useradd) ときに、ついでにログインシェルを指定できます。 現在のシステムで選択可能なシェルの一覧は、/etc/shells ファイルで確認できます。
/etc/shells（Ubuntu 22.04 の場合） # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /usr/bin/sh /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen ユーザーごとのログインシェルが現在どう設定されているかは、/etc/passwd ファイルで確認できます。
$ cat /etc/passwd ...（省略）... maku:x:1000:1000::/home/maku:/bin/bash</description></item><item><title>TypeScript を使った Node.js アプリを Docker コンテナ化する</title><link>https://maku.blog/p/ehxgwt4/</link><pubDate>Fri, 29 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ehxgwt4/</guid><description>何をするか？ TypeScript + Node.js で作成したサーバーアプリを、Docker コンテナ化する話です。 サーバーアプリは Express で簡単な Hello レスポンスを返すようなものを用意します。 Docker イメージビルド用の Dockerfile ファイルは、マルチステージビルドの構成にして、最終的な実行イメージができるだけ小さくなるようにします（それでも Node.js アプリだと、どうしても 100MB 超えになってしまいますが）。 NPM パッケージの管理には yarn を使わず、シンプルに npm だけでいきます。
Node.js アプリの用意 Node.js アプリは何でもよいのですが、ここでは Express で簡単な Web サーバーを作ることにします。
TypeScript プロジェクトのセットアップ $ npm init --yes # package.json を生成 $ npm install express $ npm install --save-dev typescript @types/express @types/node $ npx tsc --init # tsconfig.json を生成 package.json に、TypeScript のビルドと、サーバー起動のための NPM スクリプトを追加しておきます。
package.json（抜粋） &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;node out/index.</description></item><item><title>MUI のスナックバーを簡単に表示できるようにする (@mui/material/Snackbar)</title><link>https://maku.blog/p/jbv7gox/</link><pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jbv7gox/</guid><description>何をするか？ React 用の UI ライブラリである mui（旧: Material-UI）が提供している Snackbar コンポーネント を使うと、次のようなスナックバーを表示することができます。
ただ、MUI はあくまで UI ライブラリなので、表示の制御は React コンポーネントのステート管理の仕組み（useState など）を使って自力で行わなければいけません。 ただメッセージを表示したいだけなのに、ステート管理とか面倒です。 ここでは、MUI のスナックバーを簡単に表示できるようなフック関数 (useSnackbar) を作成してみます。 使い方のイメージは次のような感じです。
pages/sample.tsx import { NextPage } from &amp;#39;next&amp;#39; import { Button } from &amp;#39;@mui/material&amp;#39; import { useSnackbar } from &amp;#39;../libs/snackbar/Snackbar&amp;#39; const SamplePage: NextPage = () =&amp;gt; { const { showSnackbar } = useSnackbar() return ( &amp;lt;Button onClick={() =&amp;gt; showSnackbar(&amp;#39;This is an error message!&amp;#39;, &amp;#39;error&amp;#39;)}&amp;gt; Show &amp;lt;/Button&amp;gt; ) } export default SamplePage 任意の React コンポーネント（あるいは Next.</description></item><item><title>Ansible タスク例: APT パッケージをインストールする (ansible.builtin.apt)</title><link>https://maku.blog/p/efqyair/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/efqyair/</guid><description>Debian 系の Linux ディストリビューション（Ubuntu など）では、パッケージ管理に APT を使用します。 Ansible 組み込みの ansible.builtin.apt モジュールを使用して、APT パッケージのインストールを行うことができます。
APK パッケージを 1 つインストールする - name: Install Apache ansible.builtin.apt: name: apache2 state: present update_cache: yes state: present の指定はデフォルトなので省略できます。 update_cache: yes を指定しておくと、事前に apt update を実行してパッケージリスト情報を更新してくれます。 さらに、cache_valid_time: 3600 のように、キャッシュの有効期間（秒）を指定しておくこともできます。
複数のパッケージをインストールする - name: Install a list of packages ansible.builtin.apt: pkg: - git - iproute2 - ...</description></item><item><title>Ansible タスク例: UFW でファイアウォールを設定する (community.general.ufw)</title><link>https://maku.blog/p/evdubr7/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/evdubr7/</guid><description>Ubuntu のファイアウォール（パケットフィルタ）設定には、UFW というツールが使用されています。
参考: Linux コマンド: ufw による Ubuntu のファイアウォール設定 Ansible の community.general.ufw モジュールを使用して UFW (Uncomplicated Firewall) の設定を行うことができます。 community.general コレクションは、Ansible のコミュニティパッケージをインストールした場合は標準でインストールされています。
UFW をインストールする UFW の設定は community.general.ufw モジュールで行うのですが、UFW の本体（ufw コマンド）はあらかじめ APT でインストールしておく必要があります。
- name: Install UFW ansible.builtin.apt: name: ufw state: present update_cache: yes UFW を有効化する UFW をインストールしたら、有効化する必要があります。 次の例では、デフォルトポリシーを接続拒否 (deny) にして UFW を有効化しています。
- name: Enable UFW community.general.ufw: state: enabled policy: deny 特定ポートへのアクセスを許可する 次の例では、22 番ポート (SSH) と、80 番ポート (HTTP)、443 番ポート (HTTPS) へのアクセスを許可しています。</description></item><item><title>Ansible タスク例: Web からファイルをダウンロードする (ansible.builtin.get_url)</title><link>https://maku.blog/p/s9tctaq/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s9tctaq/</guid><description>参考: ansible.builtin.get_url module HTTPS でファイルをダウンロードする - name: Download foo.conf ansible.builtin.get_url: url: https://example.com/path/file.conf dest: /etc/foo.conf mode: &amp;#39;0440&amp;#39; パラメーターの説明: url &amp;hellip; （必須）ダウンロードするファイルの URL dest &amp;hellip; （必須）保存先の絶対パス。ディレクトリ名かファイル名。ディレクトリ名の場合は、ダウンロード元のファイル名が使われます。 mode &amp;hellip; （オプション）作成するファイルのモード (permission) dest で指定したファイルが既に存在する場合は、ダウンロードはスキップされます。 ただし、dest で指定したパスがディレクトリの場合は、ファイルは毎回ダウンロードされてしまうので、dest ではファイルのパスを指定すべきです。 force: yes オプションを指定すると、ファイルは必ずダウンロードされます。
SSL エラーが発生する場合 Ubuntu の Docker イメージには CA 証明書がインストールされておらず、get_url モジュールで HTTPS アクセスしたときに次のように SSL 関連のエラーが出ることがあります。
Request failed: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:997)&amp;gt; このような場合は、get_url の validate_certs: no オプションを指定して SSL 検証をスキップしてしまうこともできますが、次のように CA 証明書をインストールするのが正しい対処方法です。</description></item><item><title>Ansible タスク例: when による Playbook の条件分岐</title><link>https://maku.blog/p/o4o7o6m/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o4o7o6m/</guid><description>コマンドが既に存在するかどうかチェックする 次の例では、docker コマンドが存在しない場合のみ、get-docker.sh スクリプトを実行して Docker をインストールしています。
- name: Check if docker command exists ansible.builtin.shell: cmd: command -v docker register: docker_exists ignore_errors: yes - name: Install Docker when: docker_exists is failed ansible.builtin.shell: cmd: sh ~/get-docker.sh command -v &amp;lt;コマンド名&amp;gt; とすると、指定したコマンドがインストールされているときのみリターンコードが 0（成功）になることを利用しています。 この振る舞いは、次のように $?（リターンコード）の値を参照することで確かめられます。
$ command -v pwd pwd $ echo $? 0 （pwd コマンドは存在するのでリターンコードは 0） $ command -v hoge $ echo $? 1 （hoge コマンドは存在しないのでリターンコードは 1）</description></item><item><title>Ansible の SSH 接続で使用するユーザーと秘密鍵を指定する</title><link>https://maku.blog/p/n3jygwd/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n3jygwd/</guid><description>Ansible コマンド（ansible や ansible-playbook）でマネージドノードを制御するとき、デフォルトでは SSH ユーザーとしてコントロールノードのカレントユーザーが使用されます。 異なる SSH ユーザー（と秘密鍵）で接続したい場合は、コマンドライン引数やインベントリファイルで指定することができます。
コマンドライン引数で指定する方法 インベントリファイルで指定する方法 ansible.cfg でデフォルトユーザーを指定する方法 ~/.ssh/config で接続先ごとにユーザーを指定する方法 コマンドライン引数で SSH ユーザーを指定する方法 ansible-playbook コマンドの、-u (--user) オプションと --private-key オプションで、SSH 接続に使用するユーザー名と秘密鍵を指定することができます。
$ ansible-playbook -i hosts.ini site.yml -u maku --private-key ~/.ssh/maku/id_rsa インベントリファイルで SSH ユーザーを指定する方法 インベントリファイルで指定する場合は、ansible_user 変数と ansible_ssh_private_key 変数を使います。
hosts.ini（ホストごとに指定する場合） [servers] www1.example.com ansible_user=maku ansible_ssh_private_key_file=~/.ssh/maku/id_rsa www2.example.com ansible_user=maku ansible_ssh_private_key_file=~/.ssh/maku/id_rsa hosts.ini（グループ単位で指定する場合） [servers] www1.example.com www2.example.com [servers:vars] ansible_user=maku ansible_ssh_private_key_file=~/.ssh/maku/id_rsa YAML 形式でインベントリファイルを記述する場合も、同様の変数で設定できます。
hosts.yml all: hosts: www1.example.com: www2.example.com: vars: ansible_user: maku ansible_ssh_private_key_file: ~/.ssh/maku/id_rsa ~/.ssh/config で接続先ごとにユーザーを指定する方法 インベントリファイルに SSH のユーザー名や秘密鍵のパスを記述するのが煩わしいときは、SSH クライアントの設定ファイル (~/.</description></item><item><title>Docker コンテナで Ansible のテストベッド環境を用意する</title><link>https://maku.blog/p/csctaq7/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/csctaq7/</guid><description>何をするか ansible-playbook を使って何らかの Linux 環境のセットアップを自動化するとき、Playbook のテスト用に使い捨ての Docker コンテナ（テストベッド環境）があると便利です。
Ansible には、Playbook 実行後の冪等性を保つという性質がありますが、一度 Playbook を実行してしまうと元の状態に戻すことはできません。 一方通行の冪等性はあっても、可逆性はないということですね。 Playbook を試行錯誤して作っている段階では、何度も ansible-playbook を実行することになるので、本当にその Playbook がまっさらな状態の OS に対して適用できるのか不安になってきます（冪等性があるので理論的には動作するはずですが）。 異なるディストリビューションに対して実行できるのか試したくなることもあります。
ここでは、Ansible のテストベッド環境として Docker コンテナを作成し、各種 Ansible コマンド (ansible / ansible-playbook) で制御してみます。
テストベッド用のコンテナを起動する Ansible は一般的にはマネージドノードに SSH 接続して Playbook を実行しますが、実は Docker コンテナに直接接続することもできます。 つまり、テストベッド用の Docker コンテナには、sshd (OpenSSH) などのサービスをわざわざインストールする必要はありません。
ただし、Ansible マネージドノードの要件として、Python3 だけはインストールしておく必要があります。 次の Dockerfile では、Ubuntu を親イメージとして、Python3 だけ追加しています。
Dockerfile FROM ubuntu:22.04 # Python3 のインストール RUN apt update &amp;amp;&amp;amp; apt install --no-install-recommends -y python3 Dockerfile をビルドして、testbed イメージを作成します。</description></item><item><title>Linux で起動しているサービスの一覧を表示する</title><link>https://maku.blog/p/co7n5jy/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/co7n5jy/</guid><description>pstree コマンドを使う方法 $ pstree systemd─┬─ModemManager───2*[{ModemManager}] ├─acpid ├─2*[agetty] ├─cron ├─dbus-daemon ├─fail2ban-server───4*[{fail2ban-server}] ├─irqbalance───{irqbalance} ├─multipathd───6*[{multipathd}] ├─networkd-dispat ├─ntpd───{ntpd} ├─packagekitd───2*[{packagekitd}] ├─polkitd───2*[{polkitd}] ├─rsyslogd───3*[{rsyslogd}] ├─snapd───10*[{snapd}] ├─sshd───sshd───sh───pstree ├─sshd───sshd───sshd ├─systemd───(sd-pam) ├─systemd-journal ├─systemd-logind ├─systemd-network ├─systemd-resolve ├─systemd-udevd ├─udisksd───4*[{udisksd}] └─unattended-upgr───{unattended-upgr} systemd で各種サービスが動作していることを確認できます。
systemctl コマンドを使う方法 $ systemctl list-unit-files --type=service UNIT FILE STATE VENDOR PRESET acpid.service enabled enabled apparmor.service enabled enabled apport-autoreport.service static - apport-forward@.service static - apport.service generated - apt-daily-upgrade.service static - apt-daily.service static - autovt@.service alias - blk-availability.service enabled enabled bolt.service static - cloud-config.</description></item><item><title>SSH キーの管理: SSH の接続先ごとにキーを使い分ける (~/.ssh/config)</title><link>https://maku.blog/p/szajt4d/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/szajt4d/</guid><description>何をするか？ SSH 鍵を使って複数の SSH サーバーに接続する場合、1 つの SSH 鍵ファイルを使い回すこともできますが、場合によっては SSH サーバーごと（SSH ユーザーごと）に鍵ファイルを使い分けたいこともあるかもしれません。 ここでは、SSH サーバーごとの SSH キーを用意する方法を説明します。
鍵ファイルを作成する 例えば、ConoHa VPS に maku というユーザーで SSH 接続するための SSH キーを作成するとします。 一般的に SSH のキーペアは ~/.ssh ディレクトリ以下に保存しますが、次のような感じで接続先ごとにディレクトリ (&amp;lt;接続先&amp;gt;-&amp;lt;ユーザー&amp;gt;) を作ると管理しやすくなります（ファイル名で表現することもできます）。
~/.ssh/conoha-maku/id_rsa &amp;hellip; 秘密鍵 ~/.ssh/conoha-maku/id_rsa.pub &amp;hellip; 公開鍵 # SSH キーペア用のディレクトリを作成 $ mkdir -p -m 0700 ~/.ssh/conoha-maku # SSH キーペアを作成 $ ssh-keygen -t rsa -f ~/.ssh/conoha-maku/id_rsa 公開鍵を SSH サーバーに登録 SSH キーで SSH 接続するには、接続先の SSH サーバーの ~/.ssh/authorized_keys に公開鍵を登録しておく必要があります。 この作業は、ssh-copy-id コマンドを使うと簡単に済ませられます（参考: ssh-id-copy で SSH の公開鍵をリモートホストに登録する）。</description></item><item><title>SSH サーバー (sshd) の起動・停止・再起動方法まとめ</title><link>https://maku.blog/p/9gs3cmu/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9gs3cmu/</guid><description>各 OS（ディストリビューション）で SSH サーバーを起動・停止するときのコマンドのまとめです。
Debian 系 (Ubuntu/Debian) Ubuntu 15.04 以降 $ sudo systemctl start ssh （起動） $ sudo systemctl stop ssh （停止） $ sudo systemctl restart ssh （再起動） $ sudo systemctl reload ssh （設定リロード） Ubuntu 14.10 以前 $ sudo service ssh start （起動） $ sudo service ssh stop （停止） $ sudo service ssh restart （再起動） $ sudo service ssh reload （設定リロード） ☝️ ssh でも sshd でも OK /lib/systemd/system/ssh.service ファイルに、エイリアスとして sshd.service が定義されています。 なので、上記コマンドの ssh の部分は sshd としても動作します。 サービス名のサフィックス (.</description></item><item><title>SSH サーバー (sshd) 設定のベストプラクティス</title><link>https://maku.blog/p/42cmu5d/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/42cmu5d/</guid><description>これは何？ SSH をできるだけ安全に使うための sshd（OpenSSH サーバー）の設定方法です。
sshd の設定は、/etc/ssh/sshd_config ファイルで行います。 sudo などで設定ファイルを編集後、sshd サービスにリロード要求することで反映できます。
典型的な sshd の設定変更手順 $ sudo vim /etc/ssh/sshd_config # エディタで設定を変更 $ sudo systemctl reload ssh # sshd を再起動 参考: SSH サーバー (sshd) の起動・停止・再起動方法まとめ sshd の再起動や設定のリロードを行っても、作業中の SSH 接続が切れることはありません。 設定変更後は、別のターミナルから接続できることを確認してから、作業用の SSH 接続をクローズするようにしましょう。
root ユーザーでの接続を拒否する (PermitRootLogin) PermitRootLogin を no に設定することで、このサーバーには root ユーザーで SSH 接続することができなくなります（ssh root@example.com できなくなる）。
/etc/ssh/sshd_config PermitRootLogin no 管理者権限での作業が必要な場合は、一般ユーザーでの接続後に sudo 実行することになります。 root ユーザーで直接 SSH 接続できるようになっていると、悪意のあるユーザーによるパスワード総当たり攻撃を許してしまうことになります。 後述の PasswordAuthentication 設定でパスワードによる認証を拒否している場合でも、root ユーザーでの直接接続は避けるべきです。 なぜなら、いきなり root ユーザーで接続してしまうと、実際に誰が root 接続して作業したのかをログから判別できなくなってしまうからです。 一般ユーザーでログインして sudo することを強制しておけば、誰が管理者権限でコマンド実行したのかをログから確認することができます (sudo grep COMMAND /var/log/auth.</description></item><item><title>Docker コンテナで Nginx サーバーを立ち上げる</title><link>https://maku.blog/p/99qo8zf/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/99qo8zf/</guid><description>何をするか？ VPS などで Web アプリをホスティングする場合、各種サーバーを Docker コンテナとして立ち上げるようにすると OS 環境をクリーンに保てます。 特に、1 つのホスト（VPS サーバー）で複数の Web アプリを提供するような場合は、各アプリをコンテナで構成することで、関係ないアプリの設定が混ざってしまうのを防げます。 もちろん、Azure Container Instances や AWS Fargate といったコンテナ実行用のクラウドサービスを使えば、より独立した環境を構築できるのですが、これらのサービスは個人が趣味で使うにはまだまだ高価なので、VPS などの環境で Docker コンテナを立ち上げることには価値があります。
ここでは、Nginx サーバーを Docker コンテナとして立ち上げる方法を示します。 Docker Hub で公開されている Nginx イメージ は、デフォルトでコンテナ内の /usr/share/nginx/html ディレクトリに配置されたコンテンツを公開するようになっています。 大きく分けて、次の 2 つのいずれかの方法で簡単にコンテンツを公開できます。
bind マウントで Docker ホスト側のコンテンツを参照する方法 コンテンツを含んだコンテナイメージを作成する方法 以下、それぞれの方法を順番に見ていきます。
bind マウントで Docker ホスト側のコンテンツを参照する方法 Nginx のコンテナを起動するときに、Docker ホスト側のコンテンツディレクトリを bind マウントして、コンテナの /usr/share/nginx/html ディレクトリとして参照できるようにする方法です。
まず、簡単なコンテンツファイルとして次のような HTML ファイルを用意しておきます。
public/index.html &amp;lt;html&amp;gt;Hello&amp;lt;/html&amp;gt; あとは、docker container run コマンドで nginx コンテナを起動するだけです。
$ docker container run --rm -d -p 8000:80 -v &amp;#34;$(pwd)/public&amp;#34;:/usr/share/nginx/html --name web nginx 各引数は次のような意味を持っています。</description></item><item><title>MUI コンポーネント (v5) に独自のスタイルを設定する (sx prop、styled)</title><link>https://maku.blog/p/87p5o2d/</link><pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/87p5o2d/</guid><description>MUI v5 以降のカスタムスタイル設定 MUI v5 以降でコンポーネントにカスタムスタイル (CSS) を割り当てる方法には、大きく下記の 2 つのやり方があります。
sx prop を使う方法 MUI のコンポーネントには sx prop が定義されていて、ここにスタイルオブジェクトを渡すことで、個別にスタイルを調整できます。つまり、使い捨てのスタイル設定を行う方法です。sx prop は HTML 要素本来の style プロパティと比べて簡潔な構文で記述できます。例えば、margin や padding の設定用に 1 文字 (m, p) のプロパティ名が定義されていたりします。 styled API を使う方法 既存のコンポーネントをラップする形で、スタイル拡張したコンポーネントを生成します。sx prop を使った方法に比べて再利用性が高い方法で、複数個所で使用するコンポーネントにスタイル設定したいときに便利です。styled() 関数は内部的には Emotion というライブラリが提供する関数につながっていますが、MUI では @mui/material/styles パッケージをインポートすることで使えるようになっています。 いずれの方法でも、テーマ設定（theme オブジェクト）に基づいたカスタマイズが可能で、この仕組みにより、アプリ全体のデザインに一貫性を持たせやすくなっています。
☝️ Emotion と JSS MUI v4 以前は、スタイルエンジンとして JSS ライブラリベースの withStyles() や createStyles() といった関数を使用していましたが、MUI v5 以降は、動的スタイルにおけるパフォーマンスがよい Emotion の styled() 関数を使うように変更されました。 MUI v5 を使用するアプリケーションでも @mui/styles パッケージをインポートすれば withStyles() や createStyles() 関数を使用できますが、@mui/styles パッケージは deprecated（非推奨）扱いとなっています。 代わりに、@mui/material/styles パッケージの styled() 関数を使いましょう。 以下、2 つのやり方を詳しく見ていきます。</description></item><item><title>Linuxメモ: sudo で管理者権限でコマンド実行できるようにする (/etc/sudoers, visudo)</title><link>https://maku.blog/p/h5v6gqz/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h5v6gqz/</guid><description>sudo とは？ Linux の sudo コマンドは、一時的に root ユーザー（あるいは任意のユーザー）としてコマンドを実行できるようにするためのコマンドです。 システムの管理者的な立場の人であっても、常に root ユーザーとして作業するのはリスクがあるため、必要に応じて sudo でコマンド実行することが推奨されています。
sudo コマンドは、次のような形で実行します。
$ sudo ＜管理者権限が必要なコマンド＞ 例えば、/etc/shadow ファイルの閲覧は root ユーザーにしか許可されていませんが、カレントユーザーが sudoers（後述）に登録されていれば、次のようにして読み込むことができます。
$ sudo cat /etc/shadow [sudo] password for maku: （カレントユーザーのパスワードを入力） APT パッケージのインストールでも sudo はよく使われますね。
$ sudo apt install ansible [sudo] password for maku: （カレントユーザーのパスワードを入力） sudo 経由でコマンドを実行するときにパスワードの入力を求められますが、このとき入力するパスワードは root のものではなく、カレントユーザーのパスワードであることに注意してください（OpenSUSE の場合は例外的に root のパスワード）。 つまり、sudo は一般ユーザーが自分のパスワードで実行権限を切り替えてコマンドを実行する仕組みであり、sudoers の設定は慎重に行わなければいけません。
/etc/sudoers ファイルと visudo コマンド /etc/sudoers ファイル どのユーザーが、どのコマンドを、どのユーザーとして実行できるかを管理しているのが /etc/sudoers ファイルです。 ただし、このファイルは次のように編集ができないよう権限設定されており、直接エディタで開いて編集することはできません。
$ ls -l /etc/sudoers -r--r----- 1 root root 1671 Feb 8 17:41 /etc/sudoers visudo コマンド /etc/sudoers ファイルを編集するには、特別に用意された visudo コマンドを使用する必要があります。 次のように実行すれば、デフォルトエディタで /etc/sudoers ファイルを開くことができます。</description></item><item><title>Linux ディストリビューションのバージョンの調べ方まとめ</title><link>https://maku.blog/p/vdweubq/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vdweubq/</guid><description>Linux ディストリビューションのバージョン情報を調べる方法はいくつかありますが、/etc/os-release ファイルの内容を見るのが簡単です。
/etc/os-release ファイル Ubuntu 22.04 の場合 $ cat /etc/os-release PRETTY_NAME=&amp;#34;Ubuntu 22.04 LTS&amp;#34; NAME=&amp;#34;Ubuntu&amp;#34; VERSION_ID=&amp;#34;22.04&amp;#34; VERSION=&amp;#34;22.04 (Jammy Jellyfish)&amp;#34; VERSION_CODENAME=jammy ID=ubuntu ID_LIKE=debian HOME_URL=&amp;#34;https://www.ubuntu.com/&amp;#34; SUPPORT_URL=&amp;#34;https://help.ubuntu.com/&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.launchpad.net/ubuntu/&amp;#34; PRIVACY_POLICY_URL=&amp;#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;#34; UBUNTU_CODENAME=jammy Debian 11 の場合 $ cat /etc/os-release PRETTY_NAME=&amp;#34;Debian GNU/Linux 11 (bullseye)&amp;#34; NAME=&amp;#34;Debian GNU/Linux&amp;#34; VERSION_ID=&amp;#34;11&amp;#34; VERSION=&amp;#34;11 (bullseye)&amp;#34; VERSION_CODENAME=bullseye ID=debian HOME_URL=&amp;#34;https://www.debian.org/&amp;#34; SUPPORT_URL=&amp;#34;https://www.debian.org/support&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.debian.org/&amp;#34; Rocky Linux 8.6 の場合 $ cat /etc/os-release NAME=&amp;#34;Rocky Linux&amp;#34; VERSION=&amp;#34;8.6 (Green Obsidian)&amp;#34; ID=&amp;#34;rocky&amp;#34; ID_LIKE=&amp;#34;rhel centos fedora&amp;#34; VERSION_ID=&amp;#34;8.6&amp;#34; PLATFORM_ID=&amp;#34;platform:el8&amp;#34; PRETTY_NAME=&amp;#34;Rocky Linux 8.6 (Green Obsidian)&amp;#34; ANSI_COLOR=&amp;#34;0;32&amp;#34; CPE_NAME=&amp;#34;cpe:/o:rocky:rocky:8:GA&amp;#34; HOME_URL=&amp;#34;https://rockylinux.</description></item><item><title>Linuxメモ: Linux のユーザーを管理する (useradd, userdel, passwd)</title><link>https://maku.blog/p/7m5k3hx/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7m5k3hx/</guid><description>Linux をインストールしたばかりの状態では、通常は特権ユーザーの root でログインできる状態になっています。 システム管理以外の日常的な作業には、useradd コマンドで作成した一般ユーザーを用います。
ユーザーを作成する (useradd) 新しいユーザーを作成するには、useradd コマンドを使用します。 -m オプションを指定することで、ユーザーのホームディレクトリを同時に作成することができます。
ユーザー maku を作成する # useradd maku （ユーザーを作成するだけ） # useradd -m maku （ホームディレクトリを同時に作成する） # useradd -m -s /bin/bash maku （さらに、ログインシェルを設定する） # useradd -m -s /bin/bash -G admin maku （さらに、admin グループに所属させる） オプションの意味 -m &amp;hellip; ユーザーのホームディレクトリを同時に作成します -s /bin/bash &amp;hellip; ログインシェルを /bin/bash に設定します。省略した場合は、/etc/default/useradd ファイルで定義されているシェルが設定されます（Ubuntu 22.04 の場合は /bin/sh ですが、dash へのシンボリックリンクです）。ユーザー生成後にログインシェルを変更したい場合は、chsh コマンド を使用します。 -G admin &amp;hellip; ユーザーを admin グループに所属させます（admin は Debian/Ubuntu で管理者を表すグループです）。グループの制御 はユーザー作成後にも行うことができます。 /etc/passwd ファイルを見ると、ユーザーが追加されていることを確認できます。 デフォルトでは、最初に作成したユーザーのユーザー ID は 1000 になります（その後追加するユーザーは、1001、1002、1003 となります）。</description></item><item><title>Linuxメモ: firewalld による Linux のファイアウォール設定</title><link>https://maku.blog/p/ij6kxeq/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ij6kxeq/</guid><description>Red Hat 系 Linux のネットワークのアクセス制御には、従来 iptables が用いられていましたが、現在は firewalld に置き換えられています。 Fedora 18 や CentOS 7、および CentOS の後継的な位置付けの Rocky Linux 8、AlmaLinux 8 には firewalld が標準搭載されています（nftables というのもあります）。
CentOS 6 の頃は iptables が使われていました。 iptables のルールは /etc/sysconfig/iptables というファイルに保存され、システム再起動時にはこのファイルから設定を復帰させるという動作をしていました。 iptables はコマンド体系が煩雑すぎるという問題があり、より直感的な設定が可能な firewalld が作成されました。 firewalld では「一時的な」ルール設定などにも対応しています。
ファイアウォールの設定ツールは変化してきていますが、下回りとして Linux カーネルの Netfilter (netfilter firewall) が使用されていることに変わりはありません。
firewalld のインストール apt でのインストール $ sudo apt install firewalld firewalld の使い方 firewalld の起動・停止と自動起動設定 firewalld は、systemd のサービスとして自動起動できます。
$ systemctl status firewalld # 現在の状態を確認 $ systemctl start firewalld # 直ちに firewalld を起動 $ systemctl stop firewalld # 直ちに firewalld を停止 $ systemctl enable firewalld # 自動起動する $ systemctl disable firewalld # 自動起動しない firewalld の設定を確認する $ firewall-cmd --list-all firewalld の設定を変更する firewalld で HTTP 通信を許可するには次のようにします。</description></item><item><title>Linuxコマンド: TCP/TDP ポートの通信状態を確認する (ss)</title><link>https://maku.blog/p/sg2m6wm/</link><pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sg2m6wm/</guid><description>関連コマンド: ip コマンド
ss コマンドとは Linux の ss コマンド (socket statistics) は、TCP ポートや UDP ポートの通信状態を確認するためのコマンドで、過去に使われていた net-tools パッケージの netstat コマンドの後継です。 Cent OS 7 ではデフォルトで ss コマンドが採用されています。
APT の iproute2 パッケージをインストールすると、ss コマンドを使用できるようになります。
ss コマンドのインストール $ apt update # パッケージリストの更新 $ apt install -y iproute2 iptable2 パッケージをインストールすると、一緒に ip コマンド などもインストールされます。
ss サブコマンド コマンド 説明 対応する旧コマンド ss -nat TCP ポートの通信状態を確認 netstat -nat ss -nlt LISTEN（待ち受け）状態の TCP ポートを確認 netsta -nlt ss -nau UDP ポートの通信状態を確認UDP ソケットの State カラムは UNCONN と表示される netstat -nau</description></item><item><title>Linux コマンド: ufw による Ubuntu のファイアウォール設定</title><link>https://maku.blog/p/drar8o4/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/drar8o4/</guid><description>ufw とは ufw (Uncomplicated Firewall) は Debian/Ubuntu 系 Linux でパケットフィルタリングの設定（ファイアウォール設定）を行うためのツールです。 従来、パケットフィルタリングのツールとしては iptables が使われていましたが、iptables は設定が煩雑で扱いづらいという問題を抱えていたため、直感的な設定を行うためのツールとして ufw が開発されました。 ufw は Ubuntu 8.04 LTS 以降で使用することができます。
ufw のサブコマンド 通常コマンド コマンド 説明 ufw enable enables the firewall ufw disable disables the firewall ufw default ARG set default policy ufw logging LEVEL set logging to LEVEL ufw allow ARGS add allow rule ufw deny ARGS add deny rule ufw reject ARGS add reject rule ufw limit ARGS add limit rule ufw delete RULE|NUM delete RULE ufw insert NUM RULE insert RULE at NUM ufw prepend RULE prepend RULE ufw route RULE add route RULE ufw route delete RULE|NUM delete route RULE ufw route insert NUM RULE insert route RULE at NUM ufw reload reload firewall ufw reset reset firewall ufw status show firewall status ufw status numbered show firewall status as numbered list of RULES ufw status verbose show verbose firewall status ufw show ARG show firewall report ufw version display version information アプリケーションプロファイル コマンド 説明 ufw app list list application profiles ufw app info PROFILE show information on PROFILE ufw app update PROFILE update PROFILE ufw app default ARG set default application policy ufw の基本的な使い方 ufw で現在の設定を確認する (ufw status) $ sudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) 1 行目の表示で、ufw によるファイアウォールが有効 (Status: active) になっているか、無効 (Status: inactive) になっているかを確認することができます。</description></item><item><title>Linuxメモ: Linux のグループを管理する (groupadd, groupdel, gpasswd)</title><link>https://maku.blog/p/uexfvcs/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uexfvcs/</guid><description>グループの作成と削除 (groupadd, groupdel) Linux でグループを作成／削除するには、groupadd および groupdel コマンドを使用します。 グループ作成時にグループ ID（数値）が自動的に割り当てられますが、-g オプションで明示することもできます。
グループ admin を作成する $ sudo groupadd admin # グループ ID は自動で割り当てる $ sudo groupadd -g 1234 admin # グループ ID を明示する グループ admin を削除する $ sudo groupdel admin ☝️ プライマリ・グループ useradd コマンドでユーザーを作成すると、デフォルトでそのユーザーは、ユーザー名と同じ名前のグループに所属することになります。 このグループをプライマリ・グループと呼びます。 例えば、useradd maku でユーザー maku を作成すると、同時に maku というプライマリ・グループが作成されます。 groupdel コマンドでプライマリ・グループを削除することはできません。 グループにユーザーを追加する (gpasswd) Linux のグループに既存のユーザーを追加／削除するには、gpasswd コマンドを使用します。
グループ admin にユーザー maku を追加する $ sudo gpasswd -a maku admin Adding user maku to group admin グループ admin からユーザー maku を削除する $ sudo gpasswd -d maku admin これらの設定を反映させるには、そのユーザーでログインし直す必要があります。</description></item><item><title>Docker で Ansible の実行環境用のコンテナを作成する</title><link>https://maku.blog/p/euevcs8/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/euevcs8/</guid><description>何をするか？ Ansible の実行環境は Python がインストールされている環境であれば比較的簡単にインストールできますが、Docker の実行環境があれば、ホスト環境に何もインストールせずに Ansible の実行環境を手に入れることができます（もちろんコンテナは作る必要はありますが）。
Docker Hub を見ると、Alpine Linux ベースの Ansible 実行環境用イメージ alpine/ansible があるようですが、ここでは Dockerfile を使って自分でイメージを作成することにします。
Ansible 実行環境用イメージを作成する Dockerfile で Alpine Linux ベースの Ansible 実行環境を定義します。
Dockerfile FROM alpine:3 WORKDIR /app # --no-cache を付けることで /var/cache/apk 以下にキャッシュが残るのを防ぐ # --update-cache を付けることで先に apk update するのと同じ効果になる RUN apk --no-cache --update-cache add ansible openssh sshpass APK (Alpine Package Keeper) で次のようなパッケージをインストールしています。
ansible &amp;hellip; Ansible Community パッケージ（ansible コマンドや ansible-playbook コマンドなど） openssh &amp;hellip; ssh コマンドのため sshpass &amp;hellip; ターゲットホストにパスワード認証 (--ask-pass) で接続するときのため Ansible Community パッケージ (ansible) ではなく、Ansible Core (ansible-core) を使うようにすれば、イメージサイズは 500MB 弱から 80MB 程度に削減できますが、サイズを気にしなくてよいなら Ansible Community パッケージを使っておいた方が楽です。</description></item><item><title>ConoHa VPS を借りて独自ドメインでアクセスできるようにする</title><link>https://maku.blog/p/n5emu3a/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n5emu3a/</guid><description>何をするか？ ConoHa の VPS を借りたので、そのときの設定手順をメモしておきます。 大体こんな感じのことをしています。
ConoHa VPS を契約 して Ubuntu 22.04 を起動 お名前.com で独自ドメインを取得 独自ドメインで ConoHa VPS にアクセスできるようにする（IPv6 も有効化） ConoHa VPS はリーズナブルかつ API でのサーバー管理ができたりして、徐々に人気が高まってきてるみたいです。 安いプランであれば月額数百円で借りることができます。 Docker コンテナやデータベース (RDB) をホストするサーバーが欲しかったのですが、AWS や Azure はプライベートで使うには高すぎるので、今回は ConoHa VPS を採用しました。
VPS にはグローバル IP アドレスが割り当てられるので独自ドメインは必須ではないですが、やはりドメイン名でアクセスできた方がよいので、いつも通り お名前.com でドメイン取得しました。 ここでは、example.com というドメインを取得したものとして説明しています。
ConoHa のアカウントを作って VPS を契約 何はともあれ、まずは ConoHa のアカウントを作って ConoHa VPS を借ります。 ポチポチやってけば終わります。
図: ConoHa VPS での OS の選択 VPS の初期 OS として、Ubuntu 22.04 を選択しました。 上記は選択できる OS の一例ですが、他にもいろいろあります。</description></item><item><title>Node.js で URL のパスを結合する (url-join)</title><link>https://maku.blog/p/oj9nzgt/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oj9nzgt/</guid><description>José F. Romaniello 氏 (jfromaniello) が公開している NPM パッケージの url-join を使うと、バラバラになった URL のパスをうまいこと結合してくれます。
url-join のインストール $ npm install url-join 使用例 import urlJoin from &amp;#39;url-join&amp;#39; urlJoin(&amp;#39;https://example.com&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;/b/c&amp;#39;)) //=&amp;gt; https://example.com/a/b/c urlJoin(&amp;#39;https://example.com/&amp;#39;, &amp;#39;/a&amp;#39;, &amp;#39;/b/c/&amp;#39;)) //=&amp;gt; https://example.com/a/b/c/ urlJoin(&amp;#39;https://example.com&amp;#39;, &amp;#39;/foo&amp;#39;, &amp;#39;?q=123&amp;#39;)) //=&amp;gt; https://example.com/foo?q=123 urlJoin(&amp;#39;https://example.com&amp;#39;, &amp;#39;foo/&amp;#39;, &amp;#39;/?q=123&amp;#39;)) //=&amp;gt; https://example.com/foo?q=123 URL の末尾にクエリ文字列 (?q=123) があるときは、パス部分の末尾の / は消されちゃうみたいですね。
☝️ path.join は URL 結合には使えない path モジュールの path.join は、ローカルファイルシステム用のパス結合関数なので、URL の結合には使ってはいけません。 例えば、Windows 環境ではバックスラッシュが使われてしまったりします。</description></item><item><title>Linuxコマンド: ip コマンドの使い方</title><link>https://maku.blog/p/p7q7n4i/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p7q7n4i/</guid><description>関連コマンド: ss コマンド
ip コマンドとは Linux の ip コマンドを使うと、ネットワークデバイスやルーティングテーブル、ARP テーブルなどの確認・設定を行うことができます。 過去に net-tools パッケージで提供されていた、ifconfig、route、arp、netstat コマンドは deprecated（非推奨）扱いになっています。
ip コマンドをインストールする ip コマンドは APT の iproute2 パッケージに含まれています。 Docker の Ubuntu コンテナなどで ip コマンドが見つからない場合は、次のようにインストールできます。
$ apt update # パッケージリストの更新 $ apt install -y iproute2 iproute2 パッケージには、ip コマンド以外にもいろいろなコマンドが含まれています（参考: iproute2 に含まれるファイルのリスト ─ Debian / archlinux）。
iproute2 のインストールで使えるようになるコマンド arpd - userspace arp daemon
bridge - show / manipulate bridge addresses and devices
devlink - Devlink tool
ip - show / manipulate routing, devices, policy routing and tunnels</description></item><item><title>Apollo Server で GraphQL サーバーを作成する (Hello World)</title><link>https://maku.blog/p/q7q4ahp/</link><pubDate>Wed, 08 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7q4ahp/</guid><description>何をするか？ apollo-server NPM パッケージは、Node.js で GraphQL サーバーを実装するためのライブラリです。 Apollo Graph 社が OSS として公開しており、2022 年時点で最も使用されている JavaScript 用の GraphQL ライブラリです。
ここでは、簡単な GraphQL スキーマとリゾルバーを定義して、GraphQL サーバーを立ち上げてみます。 apollo-server は標準で TypeScript の型情報に対応しているため、ここでは TypeScript を使って実装しますが、JavaScript でもほぼ同様に実装できます。
TypeScript 用プロジェクトの準備 TypeScript の実行環境自体は、下記の記事などを参考にしてセットアップします。
参考: TypeScriptの環境: Visual Studio Code で TypeScript の開発環境を構築する でもここでは、.ts ファイルをそのまま実行できる ts-node を使って楽をしちゃいます。
プロジェクトの作成 $ mkdir myserver &amp;amp;&amp;amp; cd myserver $ npm init -y $ npm install --save-dev typescript ts-node package.json を少し修正して、npm run dev で main.ts を起動できるようにしておきます。
package.json // .</description></item><item><title>Firestore のデータバンドルを作成してドキュメントの読み込み回数を削減する</title><link>https://maku.blog/p/dtdtbr8/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtdtbr8/</guid><description>何をするか？ Firestore はクライアントアプリから直接アクセスできることが利点ですが、多数のクライアントから複数のドキュメントを読み込んでいると、あっという間に無料枠を超えて高額な請求が発生してしまいます。
図: 同じデータなのに何度もドキュメントの Read が発生する Firebase 8.2.0 でリリースされた Cloud Firestore Data Bundles という仕組みを使用すると、Firestore から取得したデータ（クエリ結果）をバンドルというデータにまとめておいて、それを使いまわすことができます。 データバンドルを CDN でキャッシュ、あるいはクライアントサイドでキャッシュすることにより、Firestore へのアクセスを発生させずに、あたかも Firestore からデータフェッチしたかのように動作させることが可能です。 ユーザー数の多いアプリに導入すれば、大きなコスト削減につながります。
データバンドルは Cloud Functions を使って作成してしまうのが簡単です。 下記のような構成にすれば、クライアントアプリは Firestore にアクセスする代わりにデータバンドルを取得して動作するようになります。
図: Cloud Functions でバンドルを生成する しかし、これだけでは複数のクライアントから Cloud Functions へのアクセスが発生してしまうので、結局はその都度 Firestore へのアクセスが発生してしまいます。 各クライアントアプリではキャッシュが有効ですが、そのキャッシュでさえ、Ctrl(Cmd) + R によるスーパーリロードで無視されてしまいます。 そこで、次のようにさらに CDN (Firebase Hosting) を挟んでデータバンドルをキャッシュすることで、各クライアントからのアクセスで Cloud Functions が起動されてしまうのを防ぎます。
図: CDN でバンドルをキャッシュする この構成になっていれば、クライアントがいくら強制リロードしようが、CDN (Firebase Hosting) にキャッシュされたデータバンドルのみが参照されるようになります。 Firestore へのアクセスが発生するのは、CDN 上のキャッシュが無効になったときのみです。 クライアント側のキャッシュ時間や、CDN のキャッシュ時間は、Cloud Functions の関数が返すレスポンスヘッダ (Cache-Control) で制御できます。
Cloud Functions でデータバンドルを作成する 下記のコードでは、Cloud Functions に登録する createBundle 関数を定義しています。 処理の流れは次のようになっています。</description></item><item><title>Firebase の Cloud Functions で Hello World</title><link>https://maku.blog/p/fvevcs8/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fvevcs8/</guid><description>何をするか？ Cloud Functions に関数をデプロイすると、Google Cloud Platform 上でサーバーレス関数として実行できるようになります（Amazon の AWS Lambda や、Microsoft の Azure Functions に相当するものです）。 この関数は、次のように、様々なイベントをトリガーにして呼び出されます。
HTTP でのアクセス スケジュールされたタイミング Firestore データベースの更新時 ここでは、HTTP によるアクセス時に Hello from Firebase! というレスポンスを返すだけの関数を Cloud Functions に追加してみます。 また、Firebase にデプロイする前に、エミュレーターでのローカルテストを行います。
☝️ Firebase なのか GCP なのか Cloud Functions は Firebase プロジェクトからも使用できますが、実体は GCP で提供されているサービスです。 このようなサービスは他にもあり、Firebase のサービスのうち、頭に Cloud と付いてるものは実際には GCP が提供しています（例:「Cloud Firestore」「Cloud Functions」「Cloud Storage」）。 事前準備 最初に Firebase プロジェクトを作成し、Firebase CLI をインストールしておきます。 既存の Firebase プロジェクトに Cloud Functions を追加する場合は、プロジェクトの作成は必要ありません。
Firebase のアカウントを作成します Firebase コンソール から新規プロジェクトを作成します firebase コマンドでもプロジェクトを作成できますが、上記サイトから作成してしまった方が楽です（名前の重複チェックなどをしてくれます） Firebase CLI をインストール して、firebase コマンドを実行できるようにします Firebase CLI をインストールしたら、次のように Firebase アカウントでサインインしておきます。</description></item><item><title>Go 言語で gRPC 通信してみる（Echo サーバー＆クライアント）</title><link>https://maku.blog/p/ij4jv9k/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ij4jv9k/</guid><description>何をするか？ ここでは、Go 言語用の gRPC ライブラリである gRPC-Go (google.golang.org/grpc) を使って、簡単な gRPC サーバーとクライアントを作ってみます。 通信用のスタブコードなどは、protoc コマンド (Protocl Buffers Compiler) で .proto ファイルから自動生成するので、あらかじめ protoc コマンドをインストールしておいてください。
参考: protoc コマンドで .proto ファイルをコンパイルする (Protocol Buffers Compiler) protoc コマンドで Go 言語用のコードを生成するには、protoc-gen-go プラグインと protoc-gen-go-grpc プラグインをインストールしておく必要があります。 前者がシリアライズ用のコード、後者が gRPC 用のスタブコードを生成するための protoc プラグインです。
# バージョンを指定してインストールする方法（推奨） $ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 # 最新バージョンをインストールする方法 $ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest プロジェクトの作成と gRPC-Go のインストール まずは Go 言語用のプロジェクトを作成します。 モジュール名は com.example/grpc-sample としていますが、GitHub で管理する予定であれば、リポジトリ名に合わせて github.</description></item><item><title>Next.js でローカル開発時 (next dev) のみ有効なデバッグページを作成する (getStaticProps)</title><link>https://maku.blog/p/3vbr2bm/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3vbr2bm/</guid><description>何をするか？ Next.js アプリを作っていると、開発中にだけ表示したいデバッグ用のページを作りたくなることがよくあります。 ここでは、ローカルサーバー (next dev) での開発中のみ有効になるデバッグページの作り方を説明します。
デバッグページの作成 Next.js の各ページのビルド時には、必要に応じてデータフェッチなどを行うための getStaticProps 関数が呼び出されます（参考: Next.js のプリレンダリング機能を使用する (getStaticProps)）。
この関数の戻り値として、notFound プロパティ を true にしたオブジェクトを返すと、そのページがないものとして扱うことができます（404 Not Found になる）。
export const getStaticProps: GetStaticProps = () =&amp;gt; { // ... return { // Return the default 404 page with a status code of 404. notFound: true } } この仕組みを利用して次のように実装すれば、ローカルサーバーでの開発中のみ表示可能なデバッグページを作ることができます。 ローカルサーバー (next dev) で実行されているかどうかは、環境変数 process.env.NODE_ENV の値で判断できます（参考: Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV)）。
src/pages/debug/info.tsx import { GetStaticProps, NextPage } from &amp;#39;next&amp;#39; type EmptyProps = { [key: string]: never } /** * デバッグページのビルド時の前処理。 * 開発サーバー (next dev) での実行時のみ、このページが存在するようにします。 * 本番サーバー (next start) での実行時は、404 Not Found になります。 */ export const getStaticProps: GetStaticProps&amp;lt;EmptyProps&amp;gt; = () =&amp;gt; { const isLocalDev = process.</description></item><item><title>HTTP/1.1 の認証スキームに関するメモ</title><link>https://maku.blog/p/ufpqqno/</link><pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ufpqqno/</guid><description>認証スキーム とは、HTTP のリクエストヘッダに指定する Authentication ヘッダーの先頭部分に指定する文字列のこと。
Basic &amp;hellip; RFC2617 Web ブラウザが標準でサポートしている。 Bearer &amp;hellip; RFC6750 OAuth 2.0 で使われている認証スキームのひとつ。 署名を行う必要はなく、受け取った値をそのまま使える。 Digest &amp;hellip; RFC2617 Web ブラウザが標準でサポートしている。 Negotiate &amp;hellip; RFC4559 OAuth &amp;hellip; RFC5849 OAuth 1.0 で使われていた認証スキーム。 署名のルールが複雑すぎて廃れた。 参考リンク
RFC7235 - Hypertext Transfer Protocol (HTTP/1.1): Authentication RFC7236 - Initial Hypertext Transfer Protocol (HTTP): Authentication Scheme Registrations</description></item><item><title>ウェブサイトのリンク切れを自動でチェックする (muffet)</title><link>https://maku.blog/p/s7q8o5k/</link><pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s7q8o5k/</guid><description>muffet のインストール muffet はウェブサイトのリンク切れをチェックしてくれるコマンドラインツールです。 Go 言語で実装されており、いろいろな OS (Linux、macOS、Windows) で利用することができます。
raviqqe/muffet: Fast website link checker in Go インストール方法は、上記サイトに記述されていますが、例えば macOS であれば、homebrew を使って次のように簡単にインストールできます。
macOS の場合 % brew install muffet 各 OS 用の実行バイナリが欲しければ、Release ページ からダウンロードできます。
muffet の使い方 基本的な使い方は、次のように調べたいウェブページのアドレスを入力するだけです。
% muffet http://localhost:51000 リンク元のサイトアドレスと、アクセスできなかったサイトアドレスの組み合わせが一覧表示されます。
http://localhost:51000/p/eu7djpv/ 404 http://localhost:51000/assets/favicon/180x180.png 404 http://localhost:51000/assets/favicon/192x192.png http://localhost:51000/p/ckahx6k/ 404 http://localhost:51000/assets/favicon/180x180.png 404 http://localhost:51000/assets/favicon/192x192.png 404 http://video.google.com/videoplay?docid=973149761529535925 404 (following redirect https://www.example.com/p/44327.html) http://www.example.com/44327/2005/04/tipsinbox.html muffet は複数スレッドで高速にリンクチェックを行いますが、ひとつのドメインに対する同時接続数を制限したいときは、--max-connections-per-host オプションを指定します。 Web サーバーへの負荷を考慮したいときに使えます。
同時接続数を制限する % muffet --max-connections-per-host=5 http://localhost:51000 --exclude オプションを使うと、チェック対象外とするアドレスを正規表現で指定できます。 例えば、次のようにすれば、https:// で始まるリンクをチェック対象外にできます。 ローカル Web サーバーで開発している場合、このオプション指定によって外部サイトのリンクだけをチェック対象外にできます。</description></item><item><title>protoc コマンドで .proto ファイルをコンパイルする (Protocol Buffers Compiler)</title><link>https://maku.blog/p/37e6uck/</link><pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/37e6uck/</guid><description>Protcol Buffers とは プロトコルバッファー (Protocol Buffers、または protobuf) は、Google が開発した、構造化したデータをシリアライズするためのフォーマットです。 同じく Google が開発した gRPC 通信プラットフォームで採用されており、XML や JSON などのテキストベースの API より効率的な通信を行うことができるという特徴を持っています。
データをコンパクトに表現できるため、通信やパース処理が高速 強い型付けを行うことでき、サーバー、クライアントの安全なコーディングが可能 定義変更時の互換性を考慮したフォーマット OS やプログラミング言語などに非依存 データ構造やサービス形式の定義は、.proto 拡張子を持つ プロトコル定義ファイル (Proto Definition file) で行います。 この .proto ファイルを protoc コマンド（プロトコルバッファーコンパイラ）でコンパイルすると、各言語用のソースコードを生成することができます。
図: protoc コマンドによるコード生成 protoc コマンドは各種プログラミング言語用のコードを生成するわけですが、そのためには、protoc コマンド本体 と 各言語用のプラグイン（protoc-gen-go など）がインストールされている必要があります。 C++ や C#、Kotlin、Python、Ruby などのコード生成は組み込みで対応していますが、Go 言語用のプラグインなどは別途インストールする必要があります。
protoc 本体のインストール protoc コマンド (Protocol Buffers Compiler) は、Linux（Ubuntu 系）や macOS ではパッケージマネージャーを使ってインストールしてしまうのが簡単です。 インストールするパッケージの名前は protobuf や protobuf-compiler であることに注意してください。
macOS (Homebrew) の場合 $ brew install protobuf # インストール $ brew upgrade protobuf # バージョン更新 Linux (apt) の場合 $ apt install -y protobuf-compiler プリビルド版を使う場合 あるいは、各 OS 用のバイナリを GitHub のリリースページ からダウンロードし、protoc コマンドにパスを通します。 例えば、Windows であれば protoc-3.</description></item><item><title>AWS CDK で API Gateway に Cognito 認証によるアクセス制御を追加する</title><link>https://maku.blog/p/vujw9jv/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vujw9jv/</guid><description>何をするか？ ここでは、API Gateway で提供している REST API にアクセス制御を追加するため、既存の Cognito ユーザープールによるオーソライザーを API Gateway に設定してみます。 これにより、Cognito のユーザープールで認証済みのユーザーのみが REST API を呼び出せるようになります。
後述の CDK コードでは、API Gateway と Lambda 関数、オーソライザーを生成していますが、Cognito ユーザープールは既存のものを参照しています（こういったユースケースは多いと思います）。
なお、CDK による API Gateway の作成方法（Lambda プロキシ統合）については下記の記事を参考にしてください。 ここでは、Cognito ユーザープールによるオーソライザーの作成方法にフォーカスします。
AWS CDK で API Gateway の REST API を作成する Lambda 関数を作成する REST API のバックエンドである Lambda 関数は最低限の実装で用意します。 ユーザー認証後に、API Gateway 経由で正しくこのハンドラを呼び出せるかの確認用です。
lambda/info.ts import { APIGatewayProxyHandler } from &amp;#34;aws-lambda&amp;#34; /** GET /info */ export const handler: APIGatewayProxyHandler = async (event) =&amp;gt; { console.</description></item><item><title>AWS CDK で API Gateway の REST API を作成する</title><link>https://maku.blog/p/k7eoer5/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k7eoer5/</guid><description>概要 API Gateway は HTTPS で Lambda 関数を呼び出す API Gateway で REST API のエンドポイントを定義すると、HTTPS リクエストで Lambda 関数を呼び出せるようになります。
クライアント ─(HTTPS)─&amp;gt; API Gateway ─(AWS API)─&amp;gt; Lambda 関数 API Gateway には Cognito のユーザープールと連携する機能を備えており、認証済みのユーザーにのみ API 呼び出しを許可するといったことが可能です（具体的に言うと、API Gateway が見えないところで ID トークンの正当性を確認してくれたりします）。
☝️ 新しい Lambda 関数 URL 2022 年 4 月に公開された Lambda 関数 URL の仕組みを使うと、直接 Lambda 関数にエンドポイント URL を割り当てて呼び出すことができます。 Cognito 連携などを使わないシンプルな Web API であれば、Lambda 関数 URL の仕組みで作ってしまうのが手っ取り早いかもしれません。 Lambda プロキシ統合 Lambda 関数は様々な AWS サービスからのイベント通知によって起動する仕組みになっており、API Gateway からの HTTPS リクエストもそのうちのひとつです。 Lambda 関数のハンドラが呼び出されるとき、そのパラメーターとして「イベントオブジェクト」を受け取ることができるのですが、このイベントオブジェクトの中身は発生源によって異なります。</description></item><item><title>Go 言語で AWS CDK V2 を使う (1) 導入編</title><link>https://maku.blog/p/54s6es8/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/54s6es8/</guid><description>何をするか？ CDK プロジェクトでは多くのケースでは TypeScript を使ってコード記述されていると思いますが、Go 言語の勢いが出てきていることもあり、ここでは Go 言語を使った CDK プロジェクトを作成してみます。
CDK 自体の概要については下記に簡単にまとまっています。
参考: AWS CDK 入門 (1) インストールから Hello World まで 以下、Go 言語のインストールや、AWS の認証情報の設定 (~/.aws/credentials, ~/.aws/config) はできているものとします。
参考: Go 言語で AWS SDK を使う開発環境を整える AWS CDK のインストール Go 言語で CDK のコードを記述する場合でも、AWS CDK のコマンドラインツール (cdk) 自体は、Node.js の NPM パッケージで提供されているものを使います。
$ npm install -g aws-cdk ... $ cdk --version 2.20.0 (build 738ef49) CDK プロジェクトを作成する (cdk init) CDK の Scaffold 機能を使って、Go 言語用の CDK プロジェクトを生成します。</description></item><item><title>Amazon API Gateway をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/qwb6v89/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwb6v89/</guid><description>AWS CLI（コマンドラインkツール）で Amazon API Gateway を操作するには、aws apigatewayv2 コマンドを使用します。 API Gateway の作成や更新を行うためには、IAM ユーザーに適切な権限が必要ですが、AmazonAPIGatewayAdministrator 管理ポリシーを付けるとほとんどの操作が可能になります。 通常、REST API を作成する場合は、バックエンドの Lambda 関数も合わせて必要になるので、AWSLambdaFullAccess などの管理ポリシーも必要になります。
REST API を作成する (apigateway create-rest-api) リファレンス: apigateway create-rest-api
$ aws apigateway create-rest-api --name &amp;#34;My First API&amp;#34; \ --description &amp;#34;This is my first API&amp;#34; \ --region ap-northeast-1 apiKeySource: HEADER createdDate: &amp;#39;2022-04-18T15:46:00+09:00&amp;#39; description: This is my first API disableExecuteApiEndpoint: false endpointConfiguration: types: - EDGE id: mk6mj65po6 name: My First API --name オプションのみが必須です。 API の作成に成功すると、上記のように ID (mk6mj65po6) が返されます。</description></item><item><title>Go 言語で AWS SDK を使う開発環境を整える</title><link>https://maku.blog/p/xnogqgm/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xnogqgm/</guid><description>何をするか？ ここでは、Go 言語用の AWS SDK V2 をセットアップして、各種 AWS サービス用の API を呼び出す準備をします。
Go 言語は Google が開発したプログラミング言語で、ライブラリインポートの手軽さや、生成された実行バイナリの実行速度に定評があるため、今後も利用ユーザーは増えていきそうです。
参考: Go 言語とは？／Go をインストールする | まくまくHugo/Goノート Go の実行環境は Go のインストーラー で簡単にインストールできます。 これ以降の説明では、Go の実行環境はインストール済みであると想定しています。
テスト用の Go プロジェクトを作成する Go プロジェクト用に適当なディレクトリを作成し、その中で go mod init コマンドを実行して go.mod （依存関係などが保存されるファイル）を作成しておきます。 このファイルが存在するディレクトリを、Go はモジュールとして認識します。
$ mkdir aws-study $ cd aws-study $ go mod init aws-study 上記の例では、go mod init の引数（モジュールパス）を aws-study としましたが、GitHub リポジトリで管理する前提であれば、github.com/&amp;lt;user&amp;gt;/aws-study のようなモジュールパスを指定するようにしてください。 これで、Go 言語プロジェクトの準備完了です。
AWS SDK でコンフィグ情報を参照してみる AWS SDK を使って AWS のサービスにアクセスするには、認証情報として IAM ユーザーの「アクセスキー ID」や「シークレットアクセスキー」などが必要になります。 これらは、一般的には AWS CLI の aws configure コマンドによって、~/.</description></item><item><title>Go 言語と AWS SDK V2 で Amazon Cognito を操作する</title><link>https://maku.blog/p/nej9wjb/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nej9wjb/</guid><description>ここでは、AWS SDK for Go V2 を使って、Go 言語から Amazon Cognito を操作するサンプルコードを示します。 Go 言語で AWS SDK を使うための開発環境 は構築済みとします。
指定したユーザープール内のユーザーリストを取得する (ListUsers) list_users.go package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/aws&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/config&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider&amp;#34; ) var userPoolId = &amp;#34;ap-northeast-1_XXXXXXXXX&amp;#34; // ユーザープールの ID func main() { listUsers() } func listUsers() { client := cognitoidentityprovider.NewFromConfig(loadAwsConfig()) input := &amp;amp;cognitoidentityprovider.ListUsersInput { UserPoolId: &amp;amp;userPoolId, } output, err := client.ListUsers(context.TODO(), input) if err != nil { panic(err) } for _, user := range output.</description></item><item><title>Jest で TypeScript コードのユニットテストを記述する</title><link>https://maku.blog/p/9xxpe4t/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9xxpe4t/</guid><description>Jest とは Jest は Facebook が公開した JavaScript 用のシンプルなテストフレームワークで、Node.js 環境で実行することができます。
Jest · 🃏 Delightful JavaScript Testing Jest は下記のような特徴を持っています。
ゼロコンフィグで使い始められる（設定ファイルなしで実行可能） テストを並列実行するので高速 コードカバレッジレポートの出力を標準搭載 わかりやすいマッチャー表現 (expect ～ toBe、toContain など、自然な文章として読める） TypeScript に対応（ts-jest を利用） Jest 用のテストコードは、次のようなコードジェネレーターでも採用されており、利用者は増え続けています（2022 年現在）。
create-react-app &amp;hellip; React アプリのジェネレーター cdk init app &amp;hellip; AWS のインフラ生成コードのジェネレーター Jest のインストール Jest 本体の jest モジュールをインストールします。 TypeScript を使用する場合は、Jest ライブラリの型情報である @types/jest と、Jest 用の TypeScript プロセッサ (ts-jest) もインストールする必要があります。 これらはすべてテスト時のみ使用する NPM モジュールなので、devDependencies としてインストールします。
Jest 本体と TypeScript 関連モジュールをインストール ### npm の場合 $ npm install --save-dev jest @types/jest ts-jest ### yarn の場合 $ yarn add --dev jest @types/jest ts-jest package.</description></item><item><title>NPM パッケージを作るときの package.json ファイルの書き方に関してのメモ</title><link>https://maku.blog/p/ryq6it6/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ryq6it6/</guid><description>name, version フィールド name と version フィールドは、パッケージを公開するつもりがないなら指定する必要はありません。
description フィールド description プロパティは、ユーザーがこのパッケージを探しやすくするための説明文で、npm search を実行したときに表示されます。
パッケージ対象外にするファイル (.npmignore / .gitignore) NPM パッケージを作るときに、.npmignore に書かれたファイルはパッケージングされなくなります。 .npmignore ファイルがない場合は、.gitignore ファイルが代わりに参照されます。 これらの設定にかかわらず、下記のファイルは必ずパッケージングされます。
package.json
README（大文字小文字と拡張子は問わない）
CHANGES / CHANGELOG / HISTORY（大文字小文字と拡張子は問わない）
LICENSE / LICENCE（大文字小文字と拡張子は問わない）
NOTICE（大文字小文字と拡張子は問わない）
main フィールドで指定されたファイル
bin フィールド NPM パッケージで何らかの実行コマンドを提供したいときは、bin フィールドを使用します。 例えば、mycommand コマンドを提供するときは次のように記述します。
{ // ... &amp;#34;bin&amp;#34;: { &amp;#34;mycommand&amp;#34;: &amp;#34;./cli.js&amp;#34; } } 単独のコマンドをインストールするための NPM パッケージを作る場合は、bin フィールドのコマンド名を省略して次のように記述できます。
{ &amp;#34;name&amp;#34;: &amp;#34;mycommand&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.2.5&amp;#34;, &amp;#34;bin&amp;#34;: &amp;#34;./path/to/program.js&amp;#34; } 上記の bin フィールドは次のように記述するのと同様に振舞います。
{ // .</description></item><item><title>Firebase の Cloud Functions で定期的に Firestore の集計処理を行う</title><link>https://maku.blog/p/vgs4dox/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dox/</guid><description>何をするか？ Firestore データベースは、コレクションデータを手軽に格納していくのにはとても便利ですが、全データを集計するような処理は苦手です。 例えば、各ドキュメントに付けられた「タグ」情報をすべて回収して、タグの一覧を生成したい場合、全てのドキュメントを read する必要があるため、ドキュメント数が Firebase の使用料金にダイレクトに効いてきます。 もし、Firestore にドキュメントが追加されるたびに Cloud Functions を起動してこのような集計処理を行うと、凄まじい勢いで課金されてしまいます。
ここでは、Cloud Functions による 集計処理を定期的なスケジュールで起動する ことで、Firestore ドキュメントの read 処理を削減してみます。 もちろん、リアルタイムな更新が必要なデータには使えませんが、カタログ的なデータであれば、定期的なデータ更新で間に合うケースは多いはずです。
事前準備 Firebase コンソール からテスト用のプロジェクトを作成してください。ここでは、自動生成されたアプリ ID を myapp-58138 とします。 Firestore データベースに books コレクションを追加し、次のようなサンプルドキュメントを追加してください。tag フィールドは本来は配列 (tags) であるべきですが、ここではシンプル化のために文字列型のスカラデータとしています。 id: 001 (title: Title1, author: Author1, tag: Tag1) id: 002 (title: Title2, author: Author2, tag: Tag2) id: 003 (title: Title3, author: Author3, tag: Tag3) Firebase CLI をインストール して、firebase コマンドを使用できるようにしてください。作成した関数を Cloud Functions にデプロイするために使います。 プロジェクトの雛形の生成 プロジェクト用のディレクトリを作成します。</description></item><item><title>GitHub Actions で Hugo サイトをビルドして VPS サーバーに rsync デプロイする</title><link>https://maku.blog/p/un3gu8m/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/un3gu8m/</guid><description>何をするか？ Web サイトのコンテンツを GitHub で管理し、さくらの VPS や、お名前.com の VPS で Web サーバーを運用している場合、GitHub Actions でビルドとデプロイを自動化すると便利です。 ここでは、Web サイトのビルドに Hugo、VPS サーバーへのデプロイに rsync を使う前提で、次のような手順で自動化を進めていきます。
SSH 鍵を作成する（自動デプロイのためパスワードは設定しない） VPS 側に SSH 公開鍵を登録する GitHub Actions のシークレットとして SSH 秘密鍵を登録する GitHub Actions のワークフローを作成し、ビルド (Hugo) とデプロイ (rsync) を自動化する Web サイトのビルドには何を使ってもよいのですが、現時点でおそらく最速の静的サイトジェネレーターである Hugo を例にして説明しています。 GitHub Actions による自動化が完了すると、GitHub の main ブランチに Web サイトコンテンツを push するだけで、Hugo によるビルドと rsync による VPS へのデプロイが自動で行われるようになります。
SSH キーペアを作成して VPS へ公開鍵を登録する rsync コマンドで使用する SSH 鍵を ssh-keygen コマンドで作成しておきます。 GitHub Actions から rsync コマンドを実行するので、SSH 秘密鍵にはパスワードを設定しないようにします。 次の例では、github-actions / github-actions.</description></item><item><title>Next.js でブラウザ履歴で戻るボタンを表示する (router.back)</title><link>https://maku.blog/p/m4dmu4c/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4dmu4c/</guid><description>Next.js の next/router モジュールが提供する NextRouter オブジェクトの back メソッド を呼び出すと、ブラウザの履歴に従って 1 つ前のページに遷移することができます。 つまり、ブラウザの「戻る」ボタンを押した場合と同じ振る舞いをします。 NextRouter オブジェクトは、useRouter フックで取得することができます。
次の BackButton コンポーネントはシンプルな「戻る」ボタンを表示し、クリック時に NextRouter#back() を呼び出します。
図: 戻るボタン（標準の button 版） components/BackButton.tsx import { FC } from &amp;#39;react&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; export const BackButton: FC = () =&amp;gt; { const router = useRouter() return ( &amp;lt;button alia-label=&amp;#34;戻る&amp;#34; type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; router.back()}&amp;gt; 戻る &amp;lt;/button&amp;gt; ) } 上の例では、素の button コンポーネントを使っていますが、mui (Material-UI) などの UI ライブラリを使えばリッチなボタンを表示できます。
図: 戻るボタン（mui 版） components/BackButton.</description></item><item><title>Linuxメモ: Bluetooth 関連コマンドのメモ (hciconfig, bluetoothctl)</title><link>https://maku.blog/p/ter3doz/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ter3doz/</guid><description>Bluetooth デバイスの情報を表示する (hciconfig) hciconfig は、Bluetooth デバイスの情報表示や設定を行うためのコマンドです。 HCI プロトコルで Bluetooth コントローラーと通信します。 hciconfig コマンドが見つからない場合は、bluez パッケージをインストールします。
Ubuntu への bluez パッケージのインストール $ apt update &amp;amp;&amp;amp; apt install -y bluez Bluetooth のデバイス名には hci0 や hci1 といった名前が付けられ、hciconfig コマンドでそれらの一覧を表示することができます。 次の実行例は、Raspberry Pi 4 に USB Bluetooth ドングルを接続した状態で hciconfig コマンドを実行したときの結果です（アドレスは一部伏せてます）。
$ hciconfig hci1: Type: Primary Bus: USB BD Address: 00:E0:4C:XX:XX:XX ACL MTU: 1021:6 SCO MTU: 255:12 UP RUNNING RX bytes:2186 acl:0 sco:0 events:105 errors:0 TX bytes:12322 acl:0 sco:0 commands:105 errors:0 hci0: Type: Primary Bus: UART BD Address: DC:A6:32:XX:XX:XX ACL MTU: 1021:8 SCO MTU: 64:1 UP RUNNING RX bytes:1514 acl:0 sco:0 events:90 errors:0 TX bytes:2061 acl:0 sco:0 commands:90 errors:0 USB ドングルの Bluetooth デバイスが hci1 (Bus: USB)、Raspberry Pi 4 組み込みの Bluetooth デバイスが hci0 (Bus: UART) として認識されているのが分かります。 hciconfig コマンドに -a (--all) オプションをつけて実行すると、詳細情報を表示できます。</description></item><item><title>Ansible モジュールのヘルプを表示する (ansible-doc)</title><link>https://maku.blog/p/xx7enu3/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xx7enu3/</guid><description>ansible-doc コマンドを使うと、Ansible モジュールのドキュメントを表示することができます。
ping モジュールのドキュメントを表示 $ ansible-doc ping &amp;gt; ANSIBLE.BUILTIN.PING (/Users/maku/Library/Python/3.10/lib/python/site-packages/ansible/modules/ping.py) A trivial test module, this module always returns `pong&amp;#39; on successful contact. It does not make sense in playbooks, but it is useful from `/usr/bin/ansible&amp;#39; to verify the ability to login and that a usable Python is configured. This is NOT ICMP ping, this is just a trivial test module that requires Python on the remote-node. For Windows targets, use the [ansible.</description></item><item><title>SSH キーの管理: ssh-id-copy で SSH の公開鍵をリモートホストに登録する</title><link>https://maku.blog/p/2mzbmw8/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2mzbmw8/</guid><description>ssh-id-copy とは SSH で公開鍵認証方式を使ってリモートホストに接続するには、リモートホスト側の ~/.ssh/authorized_keys ファイルに公開鍵を書き込んでおく必要がありますが、ssh-copy-id コマンドを使うと、この作業を一撃で済ますことができます。 ssh-copy-id コマンドは Linux 環境であれば標準でインストールされているはずです。
前提条件として、接続先ホストにパスワード認証で SSH 接続できる状態 にしておく必要があります。 公開鍵の内容をコピーする段階では、まだ SSH キーを使った接続ができないからです。 例えば、次のような感じで、接続先ホストに登録されている「ユーザー名」と「ユーザーパスワード」のペアで接続できるようになっていれば OK です。
パスワード認証で接続できるか確認 $ ssh maku@192.168.1.20 maku@192.168.1.20&amp;#39;s password: （接続先ホストのユーザー maku のパスワードを入力） 本記事の作業が完了すれば、SSH 接続時に「ユーザーパスワード」を送信する必要はなくなり、代わりに「SSH 秘密鍵」を使って接続できるようになります。 SSH 秘密鍵のパスフレーズを入力する必要があるかもしれませんが、このパスフレーズがネットワーク上に流れることはないので安全です。
（必要があれば）鍵ファイルの作成 (ssh-keygen) 接続元のマシンに次のような秘密鍵＆公開鍵のペアが存在しないときは、ssh-keygen コマンドなどで作成しておきます。
~/.ssh/id_rsa &amp;hellip; 秘密鍵 ~/.ssh/id_rsa.pub &amp;hellip; 公開鍵（これをリモートホストに登録します） 秘密鍵と公開鍵を生成する $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/Users/maku/.ssh/id_rsa): （このパスでよければ Enter） Enter passphrase (empty for no passphrase): （鍵のパスワードを入力） Enter same passphrase again: （パスワードを再入力） Your identification has been saved in /Users/maku/.</description></item><item><title>Firebase Auth で admin ユーザーのみ Firestore に書き込みできるようにする</title><link>https://maku.blog/p/dw9jt4e/</link><pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dw9jt4e/</guid><description>何をするか？ ユーザーデータの管理に Firestore を使うと、Web アプリやモバイルアプリから手軽にデータを読み書きできるので非常に便利です。 一方で、データの書き込み (write) を誰にでもできるようにしていると、大切なデータを勝手に書き換えられてしまいます。
Firestore の危険なセキュリティルールの例 rules_version = &amp;#39;2&amp;#39;; service cloud.firestore { match /databases/{db}/documents { match /{doc=**} { allow read, write: if true; // 危険！ } } } ここでは、Firestore へのデータ書き込みを admin ユーザー（自分）だけに制限してみます。
なお、FirebaseApp インスタンスの初期化 (initializeApp) や、Firebase Auth の導入 自体は完了しているものとします。 ユーザーごとにアクセス制御をしたいので、Firebase Auth による認証処理はほぼ必須になります。 とはいえ、Firebase アプリの認証まわりの実装はとても簡単で、最初に FirebaseApp インスタンスを初期化して、UI ライブラリ（react-firebaseui など）を使ってサインイン画面を出してユーザーにサインインさせるさせるだけです。 サインイン状態は Firebase が内部で管理してくれるので、Firestore API の呼び出し時には特に意識する必要はありません。 Firestore サービス側のセキュリティルールで、認証状態を意識した制限をかければよいだけです。
何をもって admin ユーザーとするか？ Firestore のデータ書き込み (write) を admin ユーザーだけに制限するといっても、そもそも何をもって admin ユーザーとみなすのかという問題があります。 このあたりは、ひとことで言うと「自由」です。 例えば、次のようなやり方が考えられます。</description></item><item><title>Firestore ドキュメントを TypeScript のユーザー定義型オブジェクトに変換する (withConverter)</title><link>https://maku.blog/p/bw9kv6g/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bw9kv6g/</guid><description>Firestore の JavaScript SDK でドキュメントを参照するときに、withConverter 関数を組み合わせて使用すると、ドキュメントの読み書きを行うときに、TypeScript のユーザーデータ型との変換処理を自動的に呼び出すことができます。
例えば、次のような Book 型のデータを、Firestore の books コレクションに保存するとします。
export type Book = { id: string title: string price?: number } Firestore ドキュメントとユーザーデータ型の変換処理は、次のように FirestoreDataConverter インタフェースを実装する形で定義します。 今回は Book 型に id プロパティを含めましたが、Firestore はドキュメントの ID をパス情報として表現するので、そのあたりの変換処理に注意する必要があります。
// import { // DocumentData, FirestoreDataConverter, QueryDocumentSnapshot, // SnapshotOptions, serverTimestamp } from &amp;#39;firebase/firestore&amp;#39; /** * Firestore のドキュメントと Book オブジェクトの型変換を行います。 */ const bookConverter: FirestoreDataConverter&amp;lt;Book&amp;gt; = { /** * Book オブジェクトを Firestore ドキュメントデータへ変換します。 */ toFirestore(book: Book): DocumentData { // id は Firestore のパスで表現されるのでドキュメントデータには含めない。 // 下記の updatedAt のように、自動で更新時刻のフィールドを追加することも可能。 return { title: book.</description></item><item><title>TypeScriptの型: 既存の型をちょっと変えた型を作る（ユーティリティ型）</title><link>https://maku.blog/p/9t6gr3c/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9t6gr3c/</guid><description>ユーリティティ型とは？ TypeScript には、既存の型を加工して新しい型を生み出す ユーティリティ型 (Utility Types) というものが用意されています。 例えば、Partial を使用すると、ある型のプロパティをすべてオプショナルにした型を簡単に作ことができます。 以下、使いやすそうなユーティリティ型を紹介しておきます。
ユーティリティ型 概要 Omit 指定したプロパティを取り除く Pick 指定したプロパティだけ抽出する Partial 全プロパティをオプショナルにする Required 全プロパティを必須にする Readonly 全プロパティを readonly にする ユーティリティ関数の使用例 Omit / Pick &amp;hellip; プロパティを削除・抽出する Omit を使用すると、既存の型から指定したプロパティを取り除いた型を作成できます。 次の例では、Book 型から id プロパティを取り除いて、新しい NewBook 型を定義しています。
type Book = { id: string title: string price: number } type NewBook = Omit&amp;lt;Book, &amp;#39;id&amp;#39;&amp;gt; // 上記は以下と同様 // type NewBook = { // title: string // price: number // } // 使用例: 新しい書籍を登録する関数（id は自動生成する想定） function addBook(book: NewBook): Book { // .</description></item><item><title>SBOM（ソフトウェア部品表）とは</title><link>https://maku.blog/p/bw9qjeu/</link><pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bw9qjeu/</guid><description>ソフトウェア開発の世界で、SBOM という用語がよく出てくるようになったので簡単にまとめておきます。
SBOM とは SBOM とは、ソフトウェア製品の部品表（Software Bill of Materials）の略称で、ソフトウェア製品が構成されている部品のリストを指します。 SBOM は、ソフトウェア製品がどのように構成されているかを明確にするために使用されます。 2021 年 5 月の米国大統領令に SBOM の作成と脆弱性対策を義務付ける条項 が盛り込まれました。
SBOM の目的 SBOM を作成することにより、以下のような恩恵を得ることができます。
セキュリティ向上（セキュリティ・マネージメント）: SBOM を利用することで、ソフトウェア製品がどのような部品から構成されているかを正確に把握することができ、悪意のある部品が含まれているかどうかを特定することができます。 規制遵守（コンプライアンス・マネージメント）: SBOM は、製品のライセンス情報、サードパーティー製品の使用状況、およびその他の規制要件に関する情報を提供するため、規制遵守に役立ちます。 品質向上: SBOM は、ソフトウェア製品がどのように構成されているかを明確にするため、品質管理プロセスの改善に役立ちます。 SBOM の代表的なフォーマット SPDX: Software Package Data Exchange 標準: ISO/IEC 5962:2021 サポート団体: The Linux Foundation SPDX Group CycloneDX: CycloneDX specification サポート団体: OWASP Foundation SWID: Software Identification Tags 標準: ISO/IEC 19770-2:2015 GitHub から SBOM を出力する GitHub で管理しているプロジェクトであれば、GitHub の Web サイト上で SBOM ファイル（SPDX 形式）を出力することができます。</description></item><item><title>Linuxメモ: Netplan で Ubuntu のネットワーク設定を行う</title><link>https://maku.blog/p/7q3dnx8/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7q3dnx8/</guid><description>Netplan とは Netplan は Linux のネットワーク設定を簡潔な YAML ファイルで行う仕組みで、Ubuntu 18.04 以降（正確には 17 以降）で採用されています。 昔の Ubuntu/Debian で使用されていた /etc/network/interfaces という設定ファイルはもう使われていません。
実際のネットワーク管理は、バックエンドで動作する NetworkManager や systemd-networkd といったネットワークデーモンが行うのですが、Netplan は YAML 設定ファイルの内容を適切な形に変換して、これらのネットワークデーモンに渡してくれます。 つまり、バックエンドでどのようなネットワークデーモンが動いているかを意識せずに、統一されたわかりやすい YAML ファイルでネットワーク設定を行うことができます。
Netplan は次のように振る舞います。
システム起動時に Netplan が設定ファイル (/etc/netplan/*.yaml) を読み込んで、各ネットワークデーモン用の設定値を /run 以下へ書き出す 各ネットワークデーモンが渡された情報に基づいてネットワーク設定を行う 図: netplan.io のサイトより バックエンドのネットワークデーモンとして何を使うかは、設定ファイルの renderer 部分で指定できるようになっていますが、デフォルトでは次のように動作します。
Wifi や 無線 WAN/LTE の設定 &amp;hellip; NetworkManager に渡される それ以外のネットワーク（有線LANなど）の設定 &amp;hellip; networkd に渡される よって、通常はどのネットワークデーモンを使うかを明示する必要はありません。
設定ファイルの読み込まれる順序 Netplan はすべての /etc/netplan/*.yaml ファイルを読み込みます。 複数のファイルが存在する場合は、ファイル名のアルファベット順に読み込まれ、後に読み込まれたファイルの設定値が優先的に使用されます。 例えば、
/etc/netplan/50-cloud-init.yaml /etc/netplan/99-custom.yaml というファイルがある場合、50-cloud-init.yaml で設定された値は 99-custom.yaml の設定値によって上書きされます。</description></item><item><title>Raspberry Pi に Ubuntu 20.04 を入れて WiFi 接続できるようにする</title><link>https://maku.blog/p/n9kv7gq/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9kv7gq/</guid><description>ひょんなことから、Ubuntu Server の入った Raspberry Pi 4 が必要になったので、セットアップ手順をメモしておきます。 なんか昔より簡単にインストールできるようになっててビックリしました。
何をするか？ ここでは、Raspberry Pi 4 Model B に Ubuntu 20.04 をインストールして、Wi-Fi 経由の SSH ログインができるところまでセットアップします。 なお、有線 LAN では一度も接続せずに Wi-Fi 接続できるようにします。 ただし、初期設定のために HDMI でのディスプレイ出力は必要になります。
準備するもの Raspberry Pi 4 （たぶん別のバージョンでもOK） SD カードに OS をインストールするための PC HDMI ケーブルとディスプレイと USB キーボード SD カードに OS をインストール 公式の Raspberry Pi Imager というソフトウェアを使うと、ものすごく簡単に SD カードに各種 OS をインストールできます。 Raspberry Pi Imager を起動したら、次のようにポチポチやっていくだけでインストール完了です。
Operating System の項目で、Other general purpose OS → Ubuntu → Ubuntu Server 20.</description></item><item><title>読書メモ『やっぱりおまえはバカじゃない』吉野敬介</title><link>https://maku.blog/p/2kw8is3/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2kw8is3/</guid><description>やっぱりおまえはバカじゃない 吉野敬介 小学館 受験生が「やる気」を出すための本。アツい、アツすぎる。
著者の吉野敬介氏の経歴が素敵で、中学と高校で、ずっと不良、暴走族のリーダー をやってきたんだけど高校の終わりに急に大学に行きたくなって、文字通り本当に死ぬ気で勉強してみごと志望大学に合格したという人です（実話）。 ずっと予備校の講師をしてきて、2020年にはYouTuberになったみたいです。
そういえば私が高校生だったころ、吉野氏の詳細は知らなかったけど、『吉野のピタリとでる古文単語』略してピコタンという本は確かにまわりに存在してた記憶があります。 その本自体はたぶん買ってないのですけど、ピコタンって響きが面白かったので、別の単語集の表紙をすげかえて、自分でピカチュウとかピコピコリナちゃんの絵を描いて、「ピカタン」とか「ピコタン」と呼んでいました（どうでもいいですね^^;）
著者の経験の中で、試験の終わりでぶっ倒れたというのは、ちょっとやりすぎな気もしましたが、人間やればできるんだという気持ちにさせてくれる本です。 基本的にモチベーションを上げるための本だと思いますが、妙に実践的な内容もチラホラ。
形容詞や形容動詞は、どんなことがあっても辞書を引かない。これがわからないということは、ぜんぜん文章が読めていないということだからだ。 &amp;hellip; いっぽう、動詞と名詞は完全に頭に叩き込んでおこうと思い、辞書を引に引きまくった。 &amp;hellip; 訳を紙に書いてみる。かならず紙に書かなければだめだ。頭で思っていることと実際思っていることとは違うからだ。なんとなくわかるというのは、わかっていないのと同じこと。
ところどころ挟まる不良時代のエピソードで、「バカだなぁ」と思わせつつ、物事への打ち込み方の核心をついてきたり。
オレには東大の大学院へ行くなどという芸当はできないが、オレがやったのと同じことを「やれるもんならやってみろ」という自信はある。 &amp;hellip; スタート地点がちがうからといって、劣等感に陥ってもしかたがないじゃないか、ということだ。客観的に見たら、競争するだけムダに見えるかもしれないが、受験をするときの最大の敵は自分だということを忘れちゃいけない。やる気と集中力があればなんとかなるんだ。
世の中には自分よりすごい人、環境にめぐまれた人なんてたくさんいます。 そんな中で達成感を味わうには、著者のように「オレほどがんばれるならやってみろ！」というくらい物事に打ち込む姿勢が大切ですね。 仕事でも遊びでも、とにかくがんばろうという気持ちにさせてくれる本です。</description></item><item><title>Firebase CLI でコマンドラインから Firebase を操作する</title><link>https://maku.blog/p/pamw7hr/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pamw7hr/</guid><description>Firebase CLI のインストール Firebase CLI をインストールすると、firebase というコマンドで Firebase の各種サービスを操作できるようになります。 インストール用に各 OS 用のバイナリが用意されていますが、どの OS でも共通で使える Node.js の npm でインストールすることをお勧めします。
$ npm install -g firebase-tools Firebase CLI をバージョンアップしたいときも同じコマンドでいけます。 インストールが終わったら、firebase コマンドを実行できるか確認しておきます。
$ firebase --version 10.0.1 firebase コマンドの使い方 firebase コマンドは、firebase &amp;lt;サブコマンド&amp;gt; という形で使用します。 firebase コマンドを引数なしで実行するとヘルプを表示できますが、公式サイトのコマンドリファレンス の方がわかりやすいです。 以下に、いくつかのサブコマンドを紹介しておきます。
サインイン (firebase login) Firebase プロジェクトの情報を取得するには、まずは Firebase アカウントにサインインしておく必要があります。 次のように実行すると、Web ブラウザが開き、Firebase にサインインできます。
$ firebase login サインインとアクセス権限が終わったら、Web ブラウザは閉じて大丈夫です。
Firebase プロジェクトの一覧を取得する (projects:list) $ firebase projects:list ✔ Preparing the list of your Firebase projects ┌──────────────────────┬──────────────┬────────────────┬──────────────────────┐ │ Project Display Name │ Project ID │ Project Number │ Resource Location ID │ ├──────────────────────┼──────────────┼────────────────┼──────────────────────┤ │ MyApp1 │ myapp1-12345 │ 123456789001 │ asia-northeast1 │ ├──────────────────────┼──────────────┼────────────────┼──────────────────────┤ │ MyApp2 │ myapp2-12345 │ 123456789002 │ asia-northeast1 │ └──────────────────────┴──────────────┴────────────────┴──────────────────────┘ 2 project(s) total.</description></item><item><title>Firebase Admin SDK で Firebase の各種サービスを操作する</title><link>https://maku.blog/p/yfov4bi/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yfov4bi/</guid><description>Firebase Admin SDK とは Firebase Admin SDK を使うと、Firebase の管理者（おそらくあなた）用に提供された API キーを使って、Firebase 上のデータを管理することができます。 例えば、ローカル PC にある JSON データを解析して Firestore データベースのドキュメントとして登録するといったことができます。
Firebase Admin SDK がサポートしている言語としては、Node.js、Java、Python、Go、C# などがありますが、Node.js から順番に機能提供されていくようです。 ここでは Node.js (TypeScript) で Firestore の API を呼び出してみます。
☝️ サーバーライブラリとクライアントライブラリ Firebase Admin SDK はしばしば サーバーライブラリ とも呼ばれます。 一方で、Web アプリやモバイルアプリなどで使う SDK は クライアントライブラリ と呼ばれ、Firebase が提供するセキュリティルールという仕組みでアクセス制御を行います。 具体的には、Firebase Auth などでユーザー認証を行うことで、各クライアントに対してアクセス権限を付与します。 これに対して、Firebase Admin SDK はあらかじめローカルに保持しているアクセスキーを使って API を呼び出すので、セキュリティルールを無視した特権アクセスが可能です。 秘密鍵のダウンロード Firebase Admin SDK を使って API 呼び出しを行うには、秘密鍵（API キー）を取得する必要があります。
Firebase コンソール にサインインして、対象のプロジェクトを選択する。 プロジェクトの設定 を開き、サービスアカウント タブを選択する。 新しい秘密鍵の生成 をクリックして、秘密鍵ファイル (.</description></item><item><title>Next.js で Firebase: Cloud Firestore データベースを使う</title><link>https://maku.blog/p/m3bjrz7/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m3bjrz7/</guid><description>何をするか Cloud Firestore は、Firebase サービス（あるいは GCP）が提供するサーバーレスな NoSQL データベースです。 Firestore データベースには様々な環境からアクセスできますが、ここでは Web サイトからアクセスすることを想定して、Firebase が提供する JavaScript SDK（クライアントサイド SDK）を使って Firestore データベースを操作してみます。
☝️ Firebase と GCP の使い分け Firebase と GCP (Google Cloud Platform) の両方に Firestore の記載があるので混乱しますが、どちらのプロジェクトで作った Firestore データベースも内部的には共有されているようです。 Firebase プロジェクトも、GCP プロジェクトとして参照できるようになっています。 一方で、SDK は共通化されておらず、主に Firebase はクライアントサイド用の SDK を提供し、GCP はサーバーサイド用の SDK を提供しています。 前提条件として、Firebase プロジェクトの作成は完了し、FirebaseApp インスタンスの初期化コードは準備できているものとします。
参考: Next.js で Firebase: プロジェクトの作成と接続準備 Firestore データベースの作成 クライアントアプリの実装を始める前に、Firebase プロジェクトに Firestore データベースを作成します。
Firebase コンソール にサインインして、対象のプロジェクトを開く。 サイドバーから Firestore Database を選択し、データベースの作成 をクリックする。 保護ルールは 本番環境モード を選んでおけば OK ロケーションは asia-northeast1（東京）を選んでおけば OK 次のように空っぽのデータベースが作成されれば準備 OK です。</description></item><item><title>Next.js で Firebase: Authentication 機能でユーザー認証できるようにする</title><link>https://maku.blog/p/8t6gq2b/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8t6gq2b/</guid><description>何をするか？ Firebase の Authentication 機能 を使用すると、ウェブアプリ（やモバイルアプリ）にユーザー認証機能を付けて、各種リソースへのアクセスを制御できるようになります。 例えば、「Firestore に格納されているユーザー情報の編集は、そのユーザーにのみ許可する」といったことができます。 Firebase のクライアントアプリでユーザーデータを扱う場合は、Firebase Authentication はほぼ必須の機能だといえます。
ここでは、Next.js (React) アプリで Firebase Authentication を使い、ユーザー認証を行えるようにしてみます。 ユーザー認証に使う UI は、Firebase が用意している FirebaseUI を使って表示します。
事前準備として、Firebase プロジェクトの作成は済んでおり、Next.js アプリから各種 Firestore 関連インスタンスを取得できるようになっていると想定します。
参考: Next.js で Firebase: プロジェクトの作成と接続準備 ログインプロバイダの設定 Firebase Authentication では、サインイン方法として、新規に登録するメールアドレスや電話番号を使う方法（ネイティブプロバイダ）と、既存の Google アカウントや Facebook アカウントなどを使う方法（追加のプロバイダ）が準備されています。 まずは、シンプルに「メールアドレス」でユーザー登録できるようにしてみます。
Firebase コンソール の Authentication タブを選択して機能を有効化する。
ログインプロバイダ (Sign-in method) で メール／パスワード を選択する。
有効にする にチェックを入れて 保存 をクリック。
これで、Firebase Authentication で「メールアドレス」による認証を行えるようになります。
サインイン状態を扱う React フックを作成する Next.js (React) アプリから Firebase Authentication を使う場合は、サインイン状態を扱うためのカスタムフックを作成しておくと便利です。 サインインボタンなどの UI を先に作りたいところですが、ボタンを表示すべきかどうかの判断のために結局このカスタムフックが必要になるので、先にカスタムフックを作成します。</description></item><item><title>Next.js で Firebase: プロジェクトの作成と接続準備</title><link>https://maku.blog/p/73eq2cm/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/73eq2cm/</guid><description>何をするか？ ここでは、Firebase を Next.js (React) ウェブアプリから使用するための準備 として、「Firebase プロジェクトの作成」「Next.js アプリの作成」「FirebaseApp インスタンスの初期化」までを行います。 なお、ここでは Firebase JS SDK ver.9 以降を対象とします（ver.8 以前は初期化方法が若干異なります）。
Firebase サービスを使うと、Web アプリやモバイルアプリに必要なバックエンド環境を簡単に整えることができます。 例えば、Firebase は次のような機能を提供しており、小規模のアプリであれば無料の Spark プランで動かすことができます（参考: Firebase の料金プラン）。
Firebase Authentication &amp;hellip; ユーザー管理と認証（ログイン UI もある） Firebase Hosting &amp;hellip; Web アプリのホスティング（独自ドメインにも対応） Cloud Firestore &amp;hellip; NoSQL データベース Cloud Function &amp;hellip; サーバレス関数 Cloud Storage for Firebase &amp;hellip; ファイル管理 Web アプリから上記のような機能にアクセスするには、まずは FirebaseApp インスタンスの設定（初期化）が必要になります。 以下では、Next.js アプリから各種 Firebase インスタンスにアクセスするところまでの準備を行います。
Firebase プロジェクトの作成 Firebase コンソールにサインイン して、Firebase のプロジェクトを作成します。 プロジェクト名は、自分の Google アカウント内で一意の名前になっていれば OK です。 例えば、MyApp のような名前を付けて作成してください。 Google アナリティクスは有効にしなくても OK です。</description></item><item><title>MUI でカスタムコンポーネントに sx プロパティを渡せるようにする</title><link>https://maku.blog/p/5e4cikn/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5e4cikn/</guid><description>何をするか？ MUI (Material-UI) ver.5 以降では、各コンポーネントのスタイル設定に便利な sx props を使うことができます。
The sx prop - MUI MUI コンポーネントをラップするようなカスタムコンポーネントを作成するときは、カスタムコンポーネント経由で sx props を渡せるようにしておくと、利用するときにマージン設定などを簡単に行えて便利です。
実装例 下記は、sx props を渡せるようにした CustomButton コンポーネントの実装例です。 sx props の値は、MUI の Button コンポーネントにそのまま渡しています。 型情報として SxProps&amp;lt;Theme&amp;gt; を使うところがポイントです。
src/components/CustomButton.tsx import { FC, ReactNode } from &amp;#39;react&amp;#39; import Button from &amp;#39;@mui/material/Button&amp;#39; import { SxProps, Theme } from &amp;#39;@mui/material/styles&amp;#39; type Props = { children: ReactNode sx?: SxProps&amp;lt;Theme&amp;gt; } export const CustomButton: FC&amp;lt;Props&amp;gt; = ({ children, sx }) =&amp;gt; { return ( &amp;lt;Button variant=&amp;#34;contained&amp;#34; sx={sx}&amp;gt; {children} &amp;lt;/Button&amp;gt; ) } これで、次のように sx prop 流のマージン設定などを行えるようになります。</description></item><item><title>Next.js で useState とローカルストレージ (localStorage) を連動させる</title><link>https://maku.blog/p/cwdyhec/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cwdyhec/</guid><description>何をするか？ React (Next.js) の useState フックは、Web ページの状態を保持するものですが、ページのリロードや、ブラウザの再起動を行うと、その状態はリセットされてしまいます。
一方、Web ブラウザに搭載されている localStorage や sessionStorage を使用すると、キー＆バリュー（両方とも文字列のみ）の形でデータを保存することができます。
ここでは、これらを一緒に使うことで、useState で管理している状態をローカルストレージに保存・復帰できるようにしてみます。
使い方のイメージ 例えば、Web サイト上でダークモードの On/Off を行うスイッチがあるとして、その状態をローカルストレージに保存できるようにしたいとします。
図: ダークモード切り替えのイメージ ダークモードの状態は useDarkMode のようなカスタムフックを作成して、次のように扱えると便利です。
src/pages/sample.tsx import { NextPage } from &amp;#39;next&amp;#39; import { useDarkMode } from &amp;#39;../hooks/useDarkMode&amp;#39; const SamplePage: NextPage = () =&amp;gt; { // 一見 useState と同様だが localStorage と連動している const [isDark, setDark] = useDarkMode(false) return ( &amp;lt;div style={{ width: &amp;#39;100vw&amp;#39;, height: &amp;#39;100vh&amp;#39;, color: isDark ? &amp;#39;white&amp;#39; : &amp;#39;black&amp;#39;, background: isDark ?</description></item><item><title>エミュレーター: FCEUX で TAS 動画を作る</title><link>https://maku.blog/p/ys8myer/</link><pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ys8myer/</guid><description>ファミコンのプレイ動画を作る機会があったので、その操作手順をメモメモ。 いわゆる TAS (Tool-Assisted Superplay) と呼ばれているもので、うまくプレイできたものだけを繋げた動画を作ります。
今回使うのはファミコンのエミュレーター FCEUX で、ムービーの保存機能がついています（実際には各フレームの操作内容を記録しているだけ）。 これとセーブ機能を組み合わせて、何度もプレイをやり直すことで、ノーミスプレイの動画を作ることができます。
録画手順 ゲームの ROM をロードした状態で、メニューから Movie → Movie Record と選択すると録画（操作内容の記録）を開始できます。
このとき、Record の項目で Start を選択しておくと、ゲームがリセットされたところから操作の記録が開始されるので、普通にゲームを進めていきます。
録画を終了したいときは、メニューから Movie Stop を選択します。 FCEUX の場合、プレイ内容は .fm2 という拡張子の Movie ファイルとして保存されます。
プレイのやり直し（録画内容の上書き） スロット（0〜9）を使ったステートのセーブ＆ロード機能を使うと、任意の地点からプレイをやり直すことができます。
Shift + F1〜F10 &amp;hellip; スロット 0〜9 へのセーブ F1〜F10 &amp;hellip; スロット 0〜9 からロード このロード機能は Movie Record による録画にも反映されるため、適宜 Shift+F1 でセーブしつつ、F1 でロードすることによって、うまくいったプレイだけの Movie ファイルを作ることができます。
次のようにすると、既存の Movie ファイル (.fm2) を再生して、途中から操作をやり直し（記録内容を上書き）することができます。 Movie ファイルを上書きするときは、ファイルをバックアップしておくと安心です。
メニューから Movie → Movie Play を選択 Open Read-Only のチェックを外す Play ボタンで Movie ファイルを再生開始 早送りキー（後述）などでやり直したいところまで進めて、Shift+F1 などでステートセーブ F1 キーでステートロードすると、その地点からの録画が開始される あとは、納得のいくプレイができるまでステートセーブ＆ロードを繰り返すだけです。</description></item><item><title>VS Code で Python 用のフォーマッター (Black) を使う</title><link>https://maku.blog/p/4oybku6/</link><pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4oybku6/</guid><description>何をするか？ Visual Studio Code に Python 拡張 を入れることで、Python コードの編集（自動補完など）ができるようになりますが、コードの自動フォーマットを行うには、フォーマッターを別途インストールしておく必要があります（いろんなフォーマッターがあるため）。
Python のフォーマッターとしては、autopep8 や yapf などもありますが、ここでは、最近人気がある Black を VS Code の自動フォーマッターとして設定します。 Facebook や Dropbox、Mozilla などでも導入されており、採用実績としては申し分なさそうです。
☝️ 頑固なフォーマッター Black は自分自身を The uncompromising code formatter と説明しています。 ようするに、「私が定義する設定に従いなさい」という意味で、ユーザーにほとんど設定の余地を残していません（行の長さ程度は設定できます）。 このようにすることで、チーム内でのフォーマット論争を防ぐ効果があります。 TypeScript (JavaScript) でよく使われている Prettier フォーマッターも同様の思想で作られており、ほとんど設定ができないようになっています（こちらは opinionated という単語を使っています）。
参考: TypeScript コードを Prettier で自動整形する （2023-06 追記）Python 拡張とは別に、Black Formatter 拡張 が単独で提供されています。 この拡張には black コマンドがバンドルされているため、別途外部コマンドとして black をインストール (pip install black) する必要がありません。 VS Code での開発が前提であれば、Black Formatter 拡張を使うのが手っ取り早いです。 ここでは、下記の 2 種類の方法を説明します。
方法1: Python 拡張 ＋ Black Formatter 拡張を使う方法 方法2: Python 拡張から外部の black コマンドを使う方法 Python 拡張と Black Formatter 拡張は、両方とも Microsoft 公式の拡張なので、将来的には統合されるかもしれません。</description></item><item><title>読書メモ『シンプルリスト』ドミニック・ローホー</title><link>https://maku.blog/p/d7fhhhg/</link><pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d7fhhhg/</guid><description> シンプルリスト ドミニック・ローホー 講談社 いろいろなリストを作ることによって、たくさんの小さな幸せに気付くためのヒント集のようなものです。 そのようなリストを集めていくことで、自分の本質が見えてきます。 物事を豊かにとらえることができるようになります。
リストとは リストは、人生を前に進めるための貴重な道具となる。 リストは、、、 記憶を助けるものである。ささやかな望み、大事な決意、一時的な情熱、心に誓った人生の信条など。 セラピーのようなものである。あなたが道を見失い、心にぽっかりと穴があいてしまったときに、忘れてしまった人生の意味を取り戻してくれる。 私たちの鏡である。人生そのものであり、本質を映し出してくれる。 リストを書くコツ 最初のページは、リストのリスト（目次）にする リストは作ってみたいものから始めればよい できるだけ的確で簡潔な文章を書く 日付や見出しの欄を設けて、見た目にも気を配る 分類や書き方は試行錯誤していけばいい 同じテーマのことを複数のノートに分散させない 思い出や夢のリストはこの瞬間から少しずつ育てていく（さかのぼって書く必要はない） 本当の自分 これが私と言えるものが見つかるリスト。自らの価値観をはっきりさせることが大切。 それをすることで生き生きとできること 好きな話題と嫌いな話題 似合う衣服やアクセサリ 嫌いなもののリスト。自分が好きではないものを知ることは、自分を知ることである。 好きではないこと・もの いらいらすること・もの 2度としたくないこと 嫌なことで変えたいこと 時間を費やしてしまった大切じゃないこと ある人の長所と短所のリスト。自分自身のありたい姿が見えてくる。 親友（好きなところ） 思春期の友達（一緒にしたこと） 恋人（どこに惹かれたか） 先生（教えられたこと） 家族（長所、短所） 強い印象を受けた人（何を感じたか） 小説や映画で印象に残った登場人物 シンプルに生きる 習慣をシンプルにするリスト。 1日に1つだけ美のお手入れをする 掃除は1度に1か所だけにする 取引銀行は1行だけにする 1週間のうち1日は何もしない日を作る 美術館では1枚の絵をじっくりと見る 持ち物をシンプルにするため、ひとつだけあればいいものをまとめる。 デビッド・アレンの GTD のコツは、具体的な行動を書き出すということ。タイヤを交換しなければいけないならば、「タイヤを替える」ではなく、「自動車整備工場の予約をする」と書く。 モチベーションを上げる特効薬は、「デスクの整理」や「請求書の選別」といった、簡単にできることのリスト。 行動のポリシー、モットー、ルールを決めておく。 自然と接する時間を持つ。少なくとも1日に1回は自然を見るなど。 人と話して不快に感じたら、「腹が立つなぁやり返してやる！」ではなく、「自分も同じようなことをしたことがないか？反対の行動をとろう」と考える。 哲学者アリストテレスの言葉「注意深く観察をする能力が発達すればするほど、幸せになる能力が発達する」 時間がないという焦燥感にかられるのは、段取りが悪いからではない。うまく集中できていないことに原因がある。 幸せを再生産する 小さな幸せの瞬間のリストは、幸せな人生そのものである。本当の幸せは、人に自慢するものでも、人に見せるものでもない。五感を意識するのがコツ。 遠くから聞こえるピアノの音 公園の子供たちのはじける笑顔 夕暮れの空を行く渡り鳥 降りしきる雨を眺めながらバッハを聞く ふかふかの絨毯の上をはだしで歩く 起きがけに漂う焼き立てのパンとコーヒーの香り 冬に上質な暖かいコートに身を包み散歩に出かける 雪降る露天風呂につかる 年月を経て味わいの出る皮、家具、ジーンズ 小さな幸せを見つけるヒント。 季節、一日の流れを感じる 食（おいしくて幸せになったもの） 大切な人といるとき、ひとりのときの幸せ 待ちですれ違った印象的だった人 美しいと思った言葉、表現 場所（お気に入りの場所） これまでに見た美しい自然の景色 体験した魔法のようなひととき 自分の理想的な環境 音楽リストはシチュエーションごとに聞くものをまとめる。 悩みから解放される 「ネガティブ思考」は人生の質を悪化させる。くだらない考えはそれを意識すること捨てられる。 ルイーズ・L・ヘイ 『すべてがうまくいく「やすらぎ」の言葉』 「しなければならない」「できない」といったネガティブな言葉を使わずに、「したい」「できる」といったポジティブな言葉を意識して使うこと。 ネガティブ思考を追い払うリスト ポジティブな文章 夢中になれる楽しいこと5つ 気分転換になること 生まれつき陽気な人 にぎやかで楽しい場所 悩み・心配事のリストを書き出すと、客観的になれる。それほど恐ろしいものではないことに気付くことができる。そして不要な感情（不安）は捨てる。 仕事の悩み・心配 交友関係の悩み・心配 体のこと そのトラブルによって引き起こされる感情 理想的な解決法、代替案 不安に耐えられないのは、不安の対象が何かわからないときである。 病気は病名が分かれば治療ができるのと一緒で、自分が苦しい理由を意識できれば、窮地を脱することができる。 不安や不満は一度紙の上に書き出してしまえば、あなたのもとを離れてあなたに影響を与えることはない。不満は紙の中に閉じ込められたのだから。 誰かがいないから寂しいのではなく、自分をしっかり持っていないから寂しいと感じる。そういうときは独り言を書きとめてみる。 魔法 なりたい姿を決めて、それを書きとめる。 見たいこと、感じたいこと、考えたいこと、望ましいことだけを選ぶ。そうでないものはくどくど書かない。 人生の挫折とは、新しい日々よりも過ぎ去ったことを大切にし、現状維持と安定を望むこと。そうではなく、これからの人生の可能性を考える。 困難に直面したとき、まずは逃げないことから始めてみる。苦しみから逃れようとすると、ますます苦しみを意識することになる。これまで耐えてきたことをリストにすると、人生の苦しみや過ち、忍耐、挑戦、経験から拾い集めた知恵を自分のものにできる。 人生で成功するために必要なのは、ほんの少しのユーモアのセンスと想像力である。── チャーリー・チャップリン 人は年をとればとるほど、笑いが減っていく。笑いは若さの証拠でもある。笑いのリストを作る。 笑うための話 笑った映画 笑ったシチュエーション 笑わせてくれる人たち まわりを笑顔にするアイデア 「願望リスト」は想像以上の力を秘めている。日付と願望を記入して手元に置いておくだけでいい。矛盾点を気にする必要はなく、人知を超えた神秘と奇跡を信じること。 いつかしたいこと いつかなりたい自分 いつか実現したいこと 神秘を信じなくなったとき、人は死ぬのだ。── アルベルト・アインシュタイン 自分がどうしたいかを知っている人は、ほかの人よりもずっと早く目的を達成できる。それは、自分がどこへ向かっているかを知っているから。まず何から始めればよいかをわかっているから。</description></item><item><title>DynamoDB を Python で操作する (boto3)</title><link>https://maku.blog/p/wht5epz/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wht5epz/</guid><description>（AWS SDK を使うときは、aws configure によるアクセスキーの設定は完了しているものと想定します）
Boto3 のインストール Python 用の AWS SDK として Boto3 が用意されているので、これをインストールして使います。 PC のグローバル環境を汚さないように、venv による仮想環境を作って作業する ことをオススメします。
まず、仮想環境を作ってそこに入ります。
$ mkdir myapp &amp;amp;&amp;amp; cd myapp # アプリ用のディレクトリを作成 $ python3 -m venv .venv # 仮想環境の作成 $ source .venv/bin/activate # 仮想環境に入る 仮想環境 (.venv) 内に boto3 パッケージをインストールします。
(.venv) $ python3 -m pip install boto3 これで準備完了です。簡単！
高レベル API と低レベル API Boto3 の API は、抽象度の高い API と、低い API の二種類が用意されています。
高レベル API（リソース API） 各 AWS リソースを、オブジェクト指向なコードで扱うことができる。boto3.resource(リソース名) でインスタンスを取得できる。（参考: Resources） 低レベル API（クライアント API） AWS のサービス API と 1:1 で対応する構成になっており、各種 API の戻り値は単純な dict オブジェクト。boto3.</description></item><item><title>Next.js で開発環境で実行しているときに Web サイト上に dev 表示する (TargetEnvIndicator)</title><link>https://maku.blog/p/d4p4fr4/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d4p4fr4/</guid><description>何をするか？ Next.js (React) などで Web サイトの開発を行うとき、その開発フェーズに応じて、開発環境 (dev)、ステージング環境 (stg)、本番環境 (prod) などを分けてリリースしていくことが多いと思います。 このとき、ブラウザ上でどのフェーズのサイトを表示しているのかが分かるように、画面上に dev 環境 のようなインジケーターを表示すると便利です（上図）。
ここでは、環境変数 NEXT_PUBLIC_TARGET_ENV の値が prod 以外のときに、上記のような表示をすることにします。
参考: Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV) 実装例 次のコンポーネント TargetEnvIndicator は、画面右下に環境名（例: dev 環境）を表示します。
components/common/TargetEnvIndicator.tsx import { FC } from &amp;#39;react&amp;#39; /** * ビルド時のターゲット環境が `prod` 以外のときに、画面右下に環境名を表示します。 */ export const TargetEnvIndicator: FC = () =&amp;gt; { const target = process.env.NEXT_PUBLIC_TARGET_ENV ?? &amp;#39;dev&amp;#39; // 本番環境 (prod) の場合は何も表示しない if (target === &amp;#39;prod&amp;#39;) return null return ( &amp;lt;div style={{ position: &amp;#39;fixed&amp;#39;, right: 10, bottom: 10, padding: &amp;#39;0.</description></item><item><title>読書メモ『HEALTH HACKS!』川田浩志</title><link>https://maku.blog/p/raz82p6/</link><pubDate>Mon, 25 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/raz82p6/</guid><description> HEALTH HACKS! 川田浩志 ディスカヴァー・トゥエンティワン 健康は何よりも重要！
本書には、健康に効果があって（エビデンスがあって）、かつ続けられる方法がいろいろと示されています。 著者は、「年収が上がると健康度が上がる」のではなくて、「健康度が上がると年収が上がる」と考えています。 だから、健康への自己投資は若いときから続けるのがよいと。 ごもっとも。
以下、参考になったことをメモメモ。
メモ 考え方 健康度は主観的なものだが、自分の健康度が高いと思っているほど寿命が長いという結果がある。 健康度を挙げるには、正しい知識を付けて、自信をもって健康に良いことをする 必要がある。 ジムや健康食品、健康法などの問題は、続けられないこと（▽RIZAPとかはこのあたりに目を付けてますね^^）。だから、効果があって続けられそうなこと から少しずつ自分の生活に取り込んでいくのがよい。 周りの人たちの健康も考えてあげることで、Win-Win で健康になっていく。 明るい、楽天的、活動的 → 長寿 運動 『家庭用トレッドミル』 はおすすめ。テレビを見ながらでもできるので時間の節約になるし、雨の日でも、真夏で外に出られなくても、毎日続けられる。外出用に着替える必要もない。折り畳み式のものであれば、場所もとらない。音楽を聴きながら、目をつぶって歩くととても気持ちがよい。 運動にはがん予防の効果がある（大腸がん、乳がん）。 筋トレは何歳で始めても必ず効果が出る。 食事 白パン、マーガリン、ハム、ソーセージみたいない朝食を続けるくらいなら、朝食は抜いたほうがまし。 現在では、カロリーの接種を控えめにすることが一番 健康保持と長寿に有力。お腹いっぱい食べるのではなく、腹七分ないし八分目を意識すべし。 寿命を延ばすには、インスリンの濃度を低く保つ こと。GI 値が高い商品（炭水化物）は、血糖値を上げるのでインスリンが出て細胞の寿命がどんどん縮む。野菜から食べ始める のがやはり効果的。 リスベラトロール を摂ると、インスリンの分泌を低く保つことができる。 皮ごと食べられるブドウ、赤ワイン、グレープジュース カリフォルニア・レーズン アーモンドの皮 年を取ると、のどの渇きを感じにくくなるので、水は決めた量を飲むようにする。これは血液の流れをよくするため。男性2ℓ、女性1.5ℓ くらい（食事に含まれる水分を含む）。 水の取りすぎで「むくむ」ことはなく、むくみの原因は塩分の取りすぎにある（血液の浸透圧が高くなるから）。 飲酒は少量であっても様々ながんの発症リスク を高めてしまう。乳がん、食道がん、大腸がん、肝臓がんなどのリスクが上がる。顔が赤くなる人は特に注意。飲酒がメリットになる日本人は少ない。 ミネラルウォーターの含有ヒ素濃度は、水道水の 5 倍まで認可されている。▽日本の水道水は安全度が高いということ。 善玉コレステロールを増やすには、よい油を摂る。グレープシードオイル や エゴマ油 をドレッシングにするとよい。 サプリメント サプリメントでおすすめなのは、ビタミン A の代わりに ベータカロテン を使っている マルチビタミン・ミネラル サプリメント。ベータカロテンは体内で必要なだけビタミン A に変換してくれる。 マルチビタミン・ミネラルのサプリメントは毎日飲み続ける必要はなく、食生活が不規則だなと感じたときに数日間飲むといい。ただし、肉やワインをよく接種する人は鉄の取りすぎになるので、鉄抜きのものを選ぶとよい。 見た目 歯が白いだけで印象はだいぶよくなる。リンゴ酸入りの歯磨き粉 などを使うとよい。見た目を先に改善 することで、健康を維持しようというモチベーションが上がる。 人と会う前には目薬をしておくとよい。 顔を若く保つには UV ケアが何より大切。現在では、シワの原因のほとんどは日光からの紫外線 であることが分かっている。昔は日光に当たることがよいなどと言われていたことがあったが、日光に直接当たるのは百害あって一利なし。木陰に 10 分いるだけでビタミン D の活性化にも十分。 普段の日焼け止めの SPF は 10 程度 で十分。SPF が高くなると皮膚に有害 だが、日本ではほとんど規制されておらず、高いものが出回っている。</description></item><item><title>AWS SSM のポリシーステートメントの記述例</title><link>https://maku.blog/p/s3o57jv/</link><pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s3o57jv/</guid><description>参考: AppSync / Lambda
パラメーターの説明情報の取得 すべてのパラメーターの説明情報を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:DescribeParameters&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } ssm:DescribeParameters は、SSM パラメーターストアに格納されたパラメーターの説明情報を取得する権限です。 この権限だけでは、パラメーターの「値」自体は取得できないことに注意してください。
パラメーターの値の取得 prod- で始まるパラメーターの値を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:GetParameter*&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; } ] } パラメーターの Get 系アクションには、GetParameter/GetParameters/GetParameterHistory/GetParametersByPath など いろいろある ため、上記のように ssm:GetParameter* とワイルドカード指定しておくと確実に取得できるようになります。 GetParameter だけだと、パラメーターの一覧取得などが許可されません。
パラメーターの追加・削除 prod- で始まるパラメーターの追加と削除を許可する { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:PutParameter&amp;#34;, &amp;#34;ssm:DeleteParameter&amp;#34;, &amp;#34;ssm:DeleteParameters&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; } ] } 暗号化されたパラメーター (SecureString) の取得 暗号化された prod- で始まるパラメーターを読み込む { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:GetParameter*&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; ] }, { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;kms:Decrypt&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:kms:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:key/&amp;lt;KmsKey&amp;gt;&amp;#34; ] } ] } SSM パラメーターストアに SecureString タイプとして格納されたパラメーターは、KMS キーによって暗号化されています。 このパラメーターの値を取得するには、ssm:GetParameter* によるパラメーター読み取り権限と、kms:Decrypt による複合化の権限が必要です。</description></item><item><title>AWS KMS をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/m8jv7hr/</link><pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m8jv7hr/</guid><description>SSM パラメーターストア用の AWS マネージドキーを確認する $ aws kms describe-key --key-id alias/aws/ssm 実行結果 KeyMetadata: AWSAccountId: &amp;#39;123456789012&amp;#39; Arn: arn:aws:kms:ap-northeast-1:123456789012:key/d7ce1afa-a7d4-fe43-2da2-4ddd769480d7 CreationDate: &amp;#39;2021-10-14T03:34:31.467000+09:00&amp;#39; CustomerMasterKeySpec: SYMMETRIC_DEFAULT Description: Default key that protects my SSM parameters when no other key is defined Enabled: true EncryptionAlgorithms: - SYMMETRIC_DEFAULT KeyId: d7ce1afa-a7d4-fe43-2da2-4ddd769480d7 KeyManager: AWS KeyState: Enabled KeyUsage: ENCRYPT_DECRYPT Origin: AWS_KMS KMS キーを作成する (kms create-key) aws kms create-key KMS キー (CMK: Customer Master Key) は作成は一瞬でできますが、削除は最低 7 日かかるので注意してください。
KMS キーを削除する (kms schedule-key-deletion / cancel-key-deletion) KMS キーの削除にはリスクを伴うので、削除するまでの猶予期間として 7～30 日を指定する必要があります（kms delete-key のような即削除のコマンドは用意されていません）。</description></item><item><title>AWS SSM をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/aug76s5/</link><pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aug76s5/</guid><description>パラメーターストアにパラメーターを格納する (ssm put-parameter) String（文字列） /myapp/param1 という名前のパラメーターとして value1 を格納 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;value1&amp;#34; --type String \ --tags &amp;#34;Key=key1,Value=value1&amp;#34; 既存のパラメーターの値を更新する場合は、--overwrite オプションが必要です（Version 情報がインクリメントされます）。
/myapp/param1 の値を value2 に書き換え $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;value2&amp;#34; --type String --overwrite Tier: Standard Version: 2 SecureString（暗号化された文字列） デフォルトの AWS マネージドキーを使って暗号化 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;secret_value&amp;#34; --type SecureString デフォルトのキーは、アカウントで共通のものになります。
作成した KMS キーを使って暗号化 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;secret_value&amp;#34; --type SecureString \ --key-id &amp;#34;&amp;lt;KeyId&amp;gt;&amp;#34; \ KeyId は次のいずれかの形式で指定できます。</description></item><item><title>AWS CDK で外部パラメーターを扱う（コンテキスト・バリューと環境変数）</title><link>https://maku.blog/p/vx5ta85/</link><pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vx5ta85/</guid><description>CDK コードに外部パラメーターを与える方法 AWS CDK による CloudFormation スタックの構築時に、外部からキー＆バリューの形でパラメーターを設定したいときは、主に次の 3 つの方法があります（クラウド上に値を保存するパラメーターストアなどは対象外とします）。
Context values （コンテキスト・バリュー） Environment variables （環境変数） CloudFormation parameters （CloudFormation パラメーター） S3 バケットの名前をパラメーター化したり、デプロイターゲットを staging と production の間で切り替えたりするときに使えます。
Context values（コンテキスト・バリュー） コンテキスト・バリューは、CDK 特有の仕組みで、cdk deploy 実行時のコマンドライン引数や、cdk.json ファイルの中で、キー＆バリューのペアを設定することができます。 キーの型は string で、バリューの型は JSON がサポートするデータ型のいずれかです（string、number、オブジェクト、およびそれらの配列）。 コンテキスト・バリューは CDK の仕組みなので、CDK コードの中からしか参照できません。 Lambda 関数の中から値を参照したい場合は、Lambda 関数のコンストラクトを生成するときに、environment props などで間接的に渡す必要があります。
コマンドライン引数で指定する方法 cdk deploy コマンド（あるいは diff、synth）を実行するときに、--context (-c) オプションで、コンテキスト・バリューを設定できます。
$ cdk deploy --context key=value 複数のキー＆バリューペアを設定したいときは、単純にオプション指定を繰り返します。
$ cdk deploy -c key1=value1 -c key2=value2 コンテキスト・バリューは CDK アプリ内の全スタックに渡されますが、特定のスタックにのみ反映させることもできます。
$ cdk deploy -c Stack1:key1=value1 -c Stack2:key2=value2 cdk.</description></item><item><title>AWS CDK メモ: Lambda 関数コードだけ高速デプロイする (cdk deploy --hotswap)</title><link>https://maku.blog/p/ap8p7n4/</link><pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ap8p7n4/</guid><description>AWS CDK によるデプロイ (cdk deploy) の実行には結構時間がかかりますが、Lambda 関数のコードだけ更新したいときは、hotswap オプションを付けて実行することで高速にデプロイできます。
Lambda 関数だけ高速更新 $ cdk deploy --hotswap ただし、これは開発時のみ使うべき機能として提供されており、Production 環境においては、通常通り CDK アプリ全体のデプロイを行うことが推奨されています。</description></item><item><title>読書メモ『夏への扉』ロバート・A・ハインライン</title><link>https://maku.blog/p/m9o2dyj/</link><pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m9o2dyj/</guid><description>夏への扉 [新版] ロバート・A・ハインライン（訳：福島正実） 早川書房 タイムトラベルものの小説のひとつ、というかそのジャンルを確立させたとも言われているのがこの『夏への扉』です。 ロバート・A・ハインラインがはるか昔の1956年に書いたものですが、今読んでもまったく色褪せておらず、夏になると読み直したくなるという人が多いというのも納得です（別に夏に読む必要はないけどね）。 日本で SF ランキングを取ると今でも上位に出てくるので、日本人の感性に合っているのかもしれません。 そして、長い年を経て（65年！）、今年ついに映画化 されました。 なんと舞台は日本です。
原作では1970年と2000年の間を時間旅行する設定になっており、ハインラインが1950年代に想像した2000年の世界が描かれているのですが、さすがにインターネットの登場までは予想できなかったらしく、情報のやりとりが手紙だったり、新聞が配達チューブで届くところなんかは時代を感じさせます。 それでもリアリティが損なわれていないのはさすがです。
ちなみに、物語に登場する牡猫のピートは、ハインラインが実際に飼っていた猫のピクシーがモデルみたいです。 ピートは決しておとなしい猫ではないけれど、その振る舞いの描写から、著者の猫への愛が伝わってきます。 しかし、この傑作をハインラインはわずか13日間で書き上げてしまったというのは本当でしょうか？
ストーリーまとめ 以下、あらすじ、まとめ、ネタバレ注意です。 章のタイトルは私が勝手につけました。
第1章 逃亡 主人公（ダン・デイビス）は、コールドスリープして未来にいきたい理由をつらつらと語り出す。 ベル・ダーキンと、マイルズ・ジェントリーのいなくなった世界に行きたい。 もうあの2人と関わりたくない。 目標は30年後の西暦2000年だ。 猫のピートも連れていきたい。
コールドスリープに入る前の身体検査で医者に言われた。
「きみはどのくらいの期間このどんちゃん騒ぎを続けている？」
▼デイビスは黙って「2週間あまりです」と答えるが、まだ読者には何のことなのか分からない。
デイビスは手続きを済ませ、翌日コールドスリープに入ることが決まった。
第2章 裏切り 人間の新陳代謝を止める方法は、1930年代から理論的には実現可能であることが知られていた。 しかし、実際に何に使われていたかというと、戦争だった。 人間を兵器のように保存しておいて、必要なときに蘇生させるのだ。 戦争が終わると、この技術がコールドスリープとして保険会社の商品として扱われるようになった。
デイビスはドライブインで食事を済ませて落ち着くと、本当にコールドスリープに入っていいのか自問自答を始める。 この状況から逃げ出すことが正しい答えなのか？ ベルとマイルズの問題は片付けなくていいのか？ いや、今からマイルズのところに行ってぶん殴ってやる！
マイルズ・ジェントリー は、徴兵時代の親友だった。 その娘の リッキー（フレデリカ）が、猫のピートの世話をしてくれていた。
デイビスとマイルズは、一緒に事業を始めた。 ハイヤーガールの制作だ。 賢い掃除ロボットしてヒットし、その後、ベル・ダーキン という女性が仲間に加わった。 株式会社の登録も済ませ、開発のほとんどを担当していたデイビスは51％の株式を保有することになった。 デイビスは容姿端麗なベルに惚れて、事業の拡大が落ち着き次第結婚しようという約束をした。 だから、持株の一部も彼女に譲渡した。
一方、マイルズの娘のリッキーは激しく嫉妬していた。 小さい頃、デイビスと恋人ごっこをして将来結婚しようと約束していたからだ（年は大分離れているが）。
ベルは猫のピートのことも好きだった（かのように見せかけていた）。 それはデイビスが好きなものを自分も好きなのだと思わせるためだった。
ある日、マイルズの提案で緊急の株主総会が開かれることになる（3人だけだが）。 マイルズからのとんでもない株主提案は2対1で可決されることになり、デイビスはベルから「相当なおバカさんね」と捨てゼリフを吐かれる。 デイビスの知らないうちに、マイルズとベルは結婚していた。 2人に裏切られたデイビスは解雇され、いつの間にかベルによって強制的にサインさせられていた書類によって、5年間は同業種に就くことさえ許されない状態になっていた。 最後に発明した「万能フランク」も消え去っていた。
第3章 口論 デイビスがマイルズの家に到着すると、ベルもそこにいて、3人の壮絶な口論が始まる。 デイビス vs マイルズ＆ベルという構図だったが、最後に「どうしてベルは2人に近づいたのか？」という核心に迫りそうになると、ベルの態度が豹変する。 そのとき、デイビスはうかつにもベルに背中を見せてしまった。
第4章 冷凍睡眠 ベルが本性を表し、デイビスは薬で催眠状態にされてしまう。 デイビスの荷物の中からコールドスリープの書類を見つけたベルは策略を練り始める。 ベルは書類を偽造するために、マイルズに会社のタイプライターを取りに行かせようとするが、そのとき、デイビスが乗ってきたはずの車がなくなっていることに気づく。</description></item><item><title>Apollo Client の fetchMore を自動で呼び出して GitHub GraphQL の100件制限を乗り越える (useAutoFetchMore)</title><link>https://maku.blog/p/w7igunc/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7igunc/</guid><description>何をするか？ GitHub の GraphQL API で Issue 情報などを取得しようとすると、リソース制限 のため一度に 100 件までの情報しか取得できません。 Apollo Client が提供する useQuery や useLazyQuery などの React フック関数を使用すると、戻り値で返される fetchMore 関数を使って追加読み込み（ページネーション処理）を行うことができますが、この関数の使用例として提示されているものは、ユーザーによるボタンクリックなどを必要とするものばかりです。 ここでは、useQuery 実行後に自動で fetchMore を繰り返し呼び出して、100 件を超える情報を取得する方法の例を示します。
fetchMore のための設定 前提として、Apollo Client の fetchMore 関数の基本的な使い方は理解しているものとします（下記記事などを参考にしてください）。
Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す 今回サンプルコードで使う GraphQL クエリには、次のような search コネクションが含まれていることを想定しています。 ページネーションの対象となるのは、この search コネクション部分です。
query QueryIssues($cursor: String) { search(type: ISSUE, first: 100, after: $cursor, query: &amp;#34;...&amp;#34;) { ... } } そのため、ApolloClient に設定するキャッシュのフィールドポリシーとして、search フィールドの値が fetchMore 時にマージされるように設定しておきます。 cache オブジェクトの生成時に呼び出している relayStylePagination 関数あたりがポイントです。</description></item><item><title>読書メモ『うつヌケ』田中圭一</title><link>https://maku.blog/p/wht6fq2/</link><pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wht6fq2/</guid><description>うつヌケ 田中圭一 KADOKAWA コロナで引きこもり生活が多くなって、鬱（ウツ）な気分になっている人も多いかと思います。 そこで、前から気になっていた田中圭一氏の『うつヌケ』を読んでみました。 マンガです。
内容は、ウツを経験したことのある人たちの経験談（どうしてウツになったのか、どうやって抜け出したのか）です。 ウツな気分なときは、活字は読む気さえ起こらないと思うので、マンガになっているのはいいですね。
まとめ。
自分をキライになるとウツになる。朝起きたときに、まず自分を褒めるといい「ボクは自分が大好き！」。寝起きはボーッとしていて、ウツな気分を受け入れてしまいやすいので、強制的に自分を肯定するのがいい。 不安な日は、天気と同じようにやってくる。時間が立てば去っていったりする。 気温差の変動が激しいとウツになる、みたいな簡単な原因だったりする（著者の場合）。気温と精神状態を毎日記録することで気付けた。 つらいのは自分だけじゃない。克服の仕方の本を参考にする（ネットじゃなくて書籍）。 自分を否定するものからは遠ざかり、肯定してくれるものに近づけばいい。小さなことでもいい。模型を買い込んで熱中してみるとか、山に登って綺麗な景色をみるとか。ペットと遊ぶとか。 心の故障を直すくらい気楽に「心療内科」に行けばいい。医者から処方される薬や治療法を信じよう。 ウツの渦中にある人は、周囲のものに気づく余裕がない。見えていなかった物に気づけたらウツトンネルから抜けられた証拠「ここにピアノが置いてあったんだ！」 ウツなときは思考に歪みがあるので、物事を客観視するための日記を書くとよい。「客観的に何が起きたか」「主観的にどう感じたか」を両方を 1:1 の比率で書いておく。後から見直して、なんでこんなことで悩んでいたんだと実感できる。 実際に重度の鬱になったら、上記のようなアドバイスを受け入れる余裕すらないかもしれません。 そう考えると、ウツを予防するための知識としてこういったことを知っておくのがよさそうです。</description></item><item><title>Next.js で src からの相対パスで import できるようにする (tsconfig.json)</title><link>https://maku.blog/p/qgvamzc/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qgvamzc/</guid><description>何をするか？ Next.js (TypeScript) のプロジェクトで、src ディレクトリ以下の階層構造が深くなってくると、別のディレクトリのモジュールをインポートするときの相対パスがわかりにくくなってきます。
import { sleep } from &amp;#39;../../../../../utils/timeUtil&amp;#39; このような場合は、次に説明するような tsconfig.json の設定をしておくと、シンプルなパスでインポートできるようになります。
compilerOptions.paths プロパティ (module alias) tsconfig.json の compilerOptions.paths プロパティ（と baseUrl プロパティ）を設定すると、特定のパスに配置されたモジュール（.ts ファイル）を、エイリアス名（ここでは @）を使って参照できるようになります。
tsconfig.json { &amp;#34;compilerOptions&amp;#34;: { // ... &amp;#34;baseUrl&amp;#34;: &amp;#34;.&amp;#34;, &amp;#34;paths&amp;#34;: { &amp;#34;@/*&amp;#34;: [&amp;#34;./src/*&amp;#34;] } } } 上記のように設定すると、プロジェクトルートの src ディレクトリ以下のモジュールを、どの階層にあるコードからでも、@/moduleName という名前で参照できるようになります。 例えば、src/utils/timeUtil.ts というモジュールをインポートするとき、これまでは、次のようにカレントディレクトリからの相対パスで指定しなければいけなかったところを、
import { sleep } from &amp;#39;../../../../../utils/timeUtil&amp;#39; 次のように src ディレクトリを示すエイリアス名 @ を使って指定できるようになります。
import { sleep } from &amp;#39;@/utils/timeUtil&amp;#39; ☝️ ワンポイント 上記のようなエイリアス名を使った場合でも正しくモジュールを参照できるのは、Next.js のビルドシステムが JavaScript へのトランスパイル時に本来のモジュールのパスに変換してくれるおかげです（おそらく webpack などによるバンドル時に処理されています）。 このあたりにも、Next.</description></item><item><title>『世界樹の迷宮』やってる</title><link>https://maku.blog/p/weow6dm/</link><pubDate>Sun, 22 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/weow6dm/</guid><description>ウィザードリィ風だけどライトな感じの 3D ダンジョンゲームの 『世界樹の迷宮 (DS) 』 をやってました。 シリーズものはできるだけ 1 からクリアしたい派なので、ニンテンドー DS の 1 から始めてやっとクリアしました。 ちなみに、上記のレンジャーはこのタイトルで最強と呼ばれている職業で、最大レベルにしたもの。スキル配分も多分こんな感じが最強。
3D ダンジョンゲームは明らかに人を選ぶジャンルですけど、だんだん深くまで潜っていけるようになる 中毒性 達成感 があってやめられません。 古代祐三氏の BGM はやっぱり素晴らしいです。 日向悠二氏のキャラクター はかわいすぎです。 第五階層に到達したときに広がる世界は神秘的でグッときました。
というわけで 『世界樹の迷宮 2 (DS)』 も続けてやることに決定しました。
ラスボスを倒すと上のようなパスワードが発行されて、2 を始めるときに「エトリアの勲章」を持った状態でスタートできます（HP:+10、TP:+10、全能力:+1）。 実質引き継げるのはこのアイテムくらいなのに、なんて長いパスワードなんでしょう（笑）。 まぁタッチペンなので数分あれば入力できますけど。
あと全体の印象としては、
序盤のカマキリみたいなやつが倒せなくて 一度詰む（みんな漏れなく一度詰んでいるみたい） 苦労して見つけた 宝箱の中身が全部ゴミ（ほんと最後の最後までゴミしか入ってない） セーブポイント少なすぎ 裏ボスとか竜を倒すときはパラディン入れて毎回ガードするのが必須の パターンゲームと化す（一度でもガードをミスると即死） 最終フロアとか雷属性使わないと倒せない敵が出てきて詰む（レベル上げしたいだけなのに ザコが倒せない） 最後はほぼ Max レベル 70 にしないと勝てない（比較的早く Max レベルになるので、ボスをあっさり倒すという爽快感は味わえない） な感じですね（不満しか書いてないw）。 中でもラスボス前のレベル上げ修行は大変でした。 「一日中、わたしは何をやっているのだろう&amp;hellip;」という気持ちになることもしばしば。 でもこれがキャラクターを育てるという愛なのですね。
ちなみに、『世界樹の迷宮 2』では、キャラのレベルを最大の 70 まで上げて引退させてレベル 30 に戻すと、引退ボーナスで最大レベルが 1 上がって 71 になるらしいです。 そしてもう一度最大レベル 71 にして引退させてレベル 30 に戻すと、次はレベル 72 まで上がると&amp;hellip;（嫌な予感しかしない&amp;hellip;）。</description></item><item><title>Next.js のページコンポーネントが Client と Server どちらで実行されているか調べる (isServer, isClient, NoSsr)</title><link>https://maku.blog/p/m7is4dn/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7is4dn/</guid><description>Next.js のページコンポネント (src/pages/*.tsx) の関数は、静的な HTML ファイルを生成するためにビルド時にも実行されます（参考: Next.js のプリレンダリング機能を使用する）。 従来の React による SPA アプリはクライアントサイド JavaScript でしか実行されないので、同じような感覚で実装していると振る舞いの違いでハマることがあります。 例えば、ページコンポーネントから次のように window オブジェクトを参照しようとすると、Next.js によるプリレンダリング時にエラーになります。 これは、window オブジェクトは、Web ブラウザ上で JavaScript を実行しているときにしか存在しないからです。
src/pages/hello.tsx import { FC } from &amp;#39;react&amp;#39; const HelloPage: FC = () =&amp;gt; { console.log(window.location) // ReferenceError: window is not defined return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; } 逆に言うと、実行時に window オブジェクトが存在しているかどうかを調べることによって、ページコンポーネント内のコードが、どのタイミングで実行されているかを判別できます。
const isClient = () =&amp;gt; typeof window !== &amp;#39;undefined&amp;#39; // const isServer = () =&amp;gt; typeof window === &amp;#39;undefined&amp;#39; const HelloPage: FC = () =&amp;gt; { if (isClient()) { console.</description></item><item><title>Apollo CLI の codegen で GraphQL クエリレスポンスの TypeScript 型を自動生成する</title><link>https://maku.blog/p/bnrrqpn/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bnrrqpn/</guid><description>何をするか TypeScript プロジェクトにおいて、Apollo Client の useQuery フックで GraphQL クエリ呼び出しを行っていると、レスポンスの型情報が any になってしまうことに悩むことになります。 例えば、GitHub の GraphQL クエリで、次のようにログイン中のユーザー情報を取得するとします。
import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; export const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` const Viewer: FC = () =&amp;gt; { const { error, loading, data } = useQuery(QUERY_VIEWER) // ... } useQuery 関数の戻り値の data はデフォルトで any 型なので、そのままだと ESLint などに怒られることになります。
Unsafe array destructuring of a tuple element with an any value @typescript-eslint/no-unsafe-assignment</description></item><item><title>Next.js アプリでのリンク方法まとめ（mui/Material-UI との連携なども） (next/link, next/router)</title><link>https://maku.blog/p/vgs4dnw/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dnw/</guid><description>アプリ内ページへのリンク（基本） // import Link from &amp;#39;next/link&amp;#39; &amp;lt;Link href=&amp;#34;/about&amp;#34;&amp;gt;About us&amp;lt;/Link&amp;gt; Next.js でアプリ内部で閉じるページリンクを張るには、next/link モジュールを使用します。 上記のようにすると、pages/about.tsx ページコンポーネントが生成するページへのリンクになります。
☝️ a 要素は必要ない Next.js 12 以前は Link 要素の下に明示的に a 要素を配置する必要がありました。 これは、HTML 的に正しく a 要素を配置するためでしたが、Next.js 13 では自動的に a 要素を挿入するようになったので、a 要素の記述は必要ありません。 遷移前の履歴を置き換える replace オプション &amp;lt;Link href=&amp;#34;/about&amp;#34; replace&amp;gt; 上記のように replace オプションを指定すると、ページ遷移前の URL がブラウザの履歴に残りません（戻るキーで戻らなくなります）。
外部リンク https:// で始まる外部リンクを出力したい場合は、&amp;lt;a&amp;gt; コンポーネントをそのまま使用します。 next/link（や react-router) が提供する Link コンポーネントは、アプリ内のルーティング用なので使えません。 外部リンクを開く場合は、安全性のために一律で rel=&amp;quot;noopener noreferrer&amp;quot; を付けましょう。 リンククリック時に必ず別タブで開きたいときは、target=&amp;quot;_blank&amp;quot; を指定してください。
&amp;lt;a href=&amp;#34;https://example.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt; Website title &amp;lt;/a&amp;gt; mui (Material-UI) を採用したサイトの場合は、a の代わりに mui が提供する Link コンポーネントを使用することで、サイト内のデザインを統一することができます。 next/link が提供する Link コンポーネントと混同しないように、次のように別名 (MuiLink) を付けて使用すると分かりやすくなります。</description></item><item><title>Next.js の public 以下のファイルのパスを正しく扱う</title><link>https://maku.blog/p/xjjbwes/</link><pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjjbwes/</guid><description>Next.js アプリでは、/public ディレクトリ以下に配置した静的リソースファイル（画像ファイルなど）は、次のような感じで URL のドメイン直下に配置されたファイルとして参照できるようになります。
// import Image from &amp;#39;next/image&amp;#39; &amp;lt;Image src=&amp;#34;/me.png&amp;#34; alt=&amp;#34;Picture of the author&amp;#34; width={500} height={500} /&amp;gt; 仮に、作成した Web サイトを GitHub Pages の「プロジェクトサイト」として公開する場合は、https://username.github.io/reponame/ のように一階層深い URL パスがアプリのルートになりますが、next.config.js で次のようにベースパスを設定しておけば、Next.js の Image コンポーネントは正しいパス (/reponame/me.png) に補正して画像ファイルを参照してくれます。
next.config.js const urlPrefix = &amp;#39;/reponame&amp;#39; module.exports = { // ... assetPrefix: urlPrefix, basePath: urlPrefix, trailingSlash: true, } 参考: Next.js アプリを GitHub Actions でビルドして GitHub Pages で公開する 一方で、Next.js が提供する Image コンポーネントなどを使わず、img 要素をそのまま使った場合、このような URL プレフィックスの付加は自動では行われず、画像が参照できなくなるという問題が発生します。
画像が参照できなくなる &amp;lt;img src=&amp;#34;/me.png&amp;#34; alt=&amp;#34;Picture of the author&amp;#34; /&amp;gt; Vercel 以外のサーバーで Web サイトをホスティングする場合、Image コンポーネント (next/image) は使えないことが多いので、この問題には意外とよく遭遇します。 次のユーティリティ関数 url() は、public ディレクトリ以下のファイルを参照するときに、正しい URL に補正するための関数です。</description></item><item><title>VS Code の Explorer で特定のファイルやディレクトリを非表示にする (files.exclude)</title><link>https://maku.blog/p/raku5dn/</link><pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/raku5dn/</guid><description>VS Code のエクスプローラービューは、サイドバー上にプロジェクト内のファイル一覧を表示してくれる便利な機能ですが、編集対象ではないファイルまで表示されていると地味に邪魔だったりします。 例えば、Node.js アプリの node_modules ディレクトリなどは常に表示されていてもあまり役に立たないかもしれません。
図: 不要なディレクトリが表示されている このような場合は、設定ファイル (settings.json) の files.exclude プロパティで非表示にしたいファイルやディレクトリのパターンを指定します。
settings.json { // Explorer で非表示にするもの &amp;#34;files.exclude&amp;#34;: { &amp;#34;**/.next&amp;#34;: true, // Next.js サーバーのキャッシュ &amp;#34;**/node_modules&amp;#34;: true, &amp;#34;out&amp;#34;: true // Next.js の export 先 }, // その他の設定... } 上記のようにパターンに out と指定すると、トップディレクトリの out という名前のファイルおよびディレクトリが非表示になります。 **/node_modules と指定すると、任意の階層の node_modules という名前のファイルおよびディレクトリが非表示になります。 末尾にスラッシュ (/) を付けるのは何も効果がないようです。 グロブパターン（** など）の詳細な指定方法は、Advanced search options のドキュメントが参考になります。
図: 指定したディレクトリが非表示になった ちなみに、デフォルト設定では次のようなファイルとディレクトリが非表示になります。
{ // Configure glob patterns for excluding files and folders. // For example, the file Explorer decides which files and folders // to show or hide based on this setting.</description></item><item><title>React の props.children の型定義には ReactNode を使う</title><link>https://maku.blog/p/xenv4bh/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xenv4bh/</guid><description>children の型定義 TypeScript で React の関数コンポーネントを定義するときには、下記のような React.FC (React.FunctionComponent) を使用します。
type FC&amp;lt;P = {}&amp;gt; = FunctionComponent&amp;lt;P&amp;gt;; interface FunctionComponent&amp;lt;P = {}&amp;gt; { (props: PropsWithChildren&amp;lt;P&amp;gt;, context?: any): ReactElement&amp;lt;any, any&amp;gt; | null; propTypes?: WeakValidationMap&amp;lt;P&amp;gt; | undefined; contextTypes?: ValidationMap&amp;lt;any&amp;gt; | undefined; defaultProps?: Partial&amp;lt;P&amp;gt; | undefined; displayName?: string | undefined; } // ... type PropsWithChildren&amp;lt;P&amp;gt; = P &amp;amp; { children?: ReactNode | undefined }; FC の型パラメータ P は、上記のような PropsWithChildren 型にラップされるので、props の型定義をするときに明示的に children を含める必要はありません。 下記の ColorBox コンポーネントは、指定した背景色で子要素 (children) を表示します。</description></item><item><title>VS Code のフォーマッターで自動整形する (editor.formatOnSave)</title><link>https://maku.blog/p/qcoz9ju/</link><pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcoz9ju/</guid><description>VS Code には、標準で各種言語用のフォーマッターが搭載されており、JavaScript、TypeScript、JSON、HTML などのコードを自動整形することができます。
手動でフォーマッターを起動する ファイル全体をフォーマット (editor.action.formatDocument) コマンドパレット1 を使う場合: Format Document を選択 ショートカットキーを使う場合: (Windows) Shift + Alt + F (macOS) Shift + Option + F 選択中の行をフォーマット (editor.action.formatSelection) コマンドパレット1 を使う場合: Format Selection を選択 ショートカットキーを使う場合: (Windows) Ctrl + K → Ctrl + F (macOS) Cmd + K → Cmd + F ファイル保存時などに自動でフォーマットする 下記の設定をしておくと、ファイル保存時や、コードの編集中に自動的にフォーマッターを起動することができます。 設定ファイル (settings.json) の場所に関しては、こちらの記事 を参考にしてください。
全ての種類のファイルで自動フォーマットする場合 settings.json { // 自動フォーマット設定 &amp;#34;editor.formatOnSave&amp;#34;: true, // 保存時にフォーマット &amp;#34;editor.formatOnType&amp;#34;: true, // 入力中（改行時）にフォーマット &amp;#34;editor.formatOnPaste&amp;#34;: true, // ペースト時にフォーマット // その他.</description></item><item><title>Next.js アプリのディレクトリ構成を考える（Atomic Design と Presentational and Container Components）</title><link>https://maku.blog/p/4is2ahp/</link><pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4is2ahp/</guid><description>Web サイトを構築するにあたって、よく参照されるコンポーネントの分類手法として、Atomic Design と Presetational and Container Components があります。
Atomic Design &amp;hellip; UI の粒度と具体性によって 5 レベルに分類する Presentational and Container Components &amp;hellip; 「表示」と「振る舞い」の役割で分類する ここでは、それぞれに関して概要をざっと眺めた上で、Next.js プロジェクトにどんな形で適用していけばいいかを考えてみます。
Atomic Design とは Web デザインにおける UI コンポーネントの分割粒度の考え方として、Brad Frost 氏の Atomic Design があります。
Atomic Design - Brad Frost 氏のブログ記事 Atomic Design - 書籍版（Webで読めます） Atomic Design では、UI コンポーネントを粒度の小さい順に次のように分類します。
図: Atomic Design の 5 つのレベル（Brad Frost 氏のブログより） Atoms（原子） &amp;hellip; これ以上分割できない単位（例: ラベル、入力、ボタン） Molecules（分子） &amp;hellip; 意味のある UI パーツ単位 （例: 検索フォーム (ラベル + 入力 + ボタン)） Organisms（有機体、生物） &amp;hellip; ページの一部分を構成する。Molecules をどう組み合わせるべきかという、アプリドメインの知識が入ってくる。 Templates（テンプレート） &amp;hellip; ページ全体のレイアウト。最初はプレースホルダーだらけかもしれないが、徐々に具体的な Organisms が配置されて最終形態に近づいていく。 Pages（ページ） &amp;hellip; Templates に具体的なデータを入れたもの（特定のページ）。 よく Organisms の扱いで迷うようですが、汎用性の側面から次のような感じで分類すると、プロジェクト内でコンポーネントを整理しやすくなります。 Pages に関しては、Templates に対してデータを流し込んだものなので、ここでは省略しています。</description></item><item><title>DynamoDB 用のポリシー設定例</title><link>https://maku.blog/p/gk6jx9k/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gk6jx9k/</guid><description>あるテーブルに対するすべての操作を可能にする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;AllAPIActionsOnBooks&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: &amp;#34;dynamodb:*&amp;#34;, &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] } Action に dynamodb:* というワイルド―カードを指定することで、DynamoDB のすべての API を使った操作を可能にしています。 通常は、特定のアクションのみを許可すべきです。
あるテーブルの読み取りを行えるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;DescribeQueryScanBooksTable&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:Query&amp;#34;, &amp;#34;dynamodb:Scan&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] } このポリシーステートメントは、アカウント 123456789012 が所有する Books テーブルの読み取り（Query や Scan）が可能であることを示します。
下記は、もう少し可能な操作を増やしたバージョンです。
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;ReadOnlyAPIActionsOnBooks&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:GetItem&amp;#34;, &amp;#34;dynamodb:BatchGetItem&amp;#34;, &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:Query&amp;#34;, &amp;#34;dynamodb:Scan&amp;#34;, &amp;#34;dynamodb:ConditionCheckItem&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] }</description></item><item><title>Next.js でハッシュフラグメントを扱う（useHash カスタムフック）</title><link>https://maku.blog/p/k2ahpw5/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k2ahpw5/</guid><description>ハッシュフラグメントとは URL のハッシュフラグメントというのは、下記のような URL の末尾の # 以降の部分を指します。
https://examle.com/sample#AAA 似たようなものにクエリパラメーター（?key=val のみたいなの）もありますが、ハッシュフラグメントは HTTP リクエスト時に、その文字列（上記の例では AAA）がサーバーに送られないという違いがあります。 つまり、ハッシュフラグメントの値は、クライアントサイドで使用することが意図されています。
useHash フックの実装 下記の useHash 関数は、Next.js でハッシュフラグメントを簡単に扱えるようにするカスタムフックの例です。 useState フックと同じ感覚で使えるように、ハッシュフラグメントの現在値と、設定用の関数をペアで返します。
src/libs/useHash.ts import { useCallback } from &amp;#39;react&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; /** * URL のハッシュフラグメント部分を扱うためのフックです。 * * 次のようにすると、`hash` 変数に URL の `#` 以降の値が格納されます。 * URL の `#` 以降の値を変更したいときは、`setHash` 関数を使用します。 * * ``` * const [hash, setHash] = useHash() * ``` */ export function useHash(): [string, (newHash: string) =&amp;gt; void] { const router = useRouter() const hash = extractHash(router.</description></item><item><title>Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV)</title><link>https://maku.blog/p/gbpeyov/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gbpeyov/</guid><description>Next.js アプリ内での環境変数の振る舞い process.env の振る舞い Node.js の process.env による環境変数の参照が有効なのは、基本的には次のようなサーバーサイドで実行されるコード内のみです。
ビルド時あるいはアクセス時に呼び出される getStaticPaths や getStaticProps 必ずアクセス時に呼び出される getServerSideProps 必ずアクセス時に呼び出される API ルートのハンドラ関数 (handler) src/pages/sample.tsx export const getStaticProps: GetStaticProps&amp;lt;PageProps&amp;gt; = async context =&amp;gt; { // このコードはビルド時に実行されるので環境変数を参照できる console.log(process.env.VAR_NAME) return { props: {} } } NEXT_PUBLIC プレフィックス ただし、例外として、NEXT_PUBLIC_ で始まる環境変数を process.env.NEXT_PUBLIC_XXX のように参照すると、next build によるビルド時に変数値がインライン展開されるので、クライアントサイドで実行されるコード（コンポーネントの実装内）から参照できます。
src/pages/sample.tsx const SamplePage: FC = () =&amp;gt; { return &amp;lt;&amp;gt; &amp;lt;p&amp;gt;Public env: {process.env.NEXT_PUBLIC_ANALYTICS_ID}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Private env: {process.env.API_SECRET_KEY} （必ず空っぽ）&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; } 上記のようにすると、process.env.NEXT_PUBLIC_ANALYTICS_ID の部分には、ビルド時の環境変数 NEXT_PUBLIC_ANALYTICS_ID の値がそこに埋め込まれ、process.env.API_SECRET_KEY の方は必ず undefined になります（何も表示されない）。</description></item><item><title>Next.js のコンポーネント内でクエリ文字列を取得する (next/router, useRouter)</title><link>https://maku.blog/p/r7fou3a/</link><pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r7fou3a/</guid><description>クエリ文字列とは https://example.com/todos?sortby=title&amp;amp;order=asc URL のクエリ文字列（クエリパラメーター）というのは、上記のような URL の末尾の ? 以降の、sortby=title&amp;amp;order=asc の部分のことを指します。 この部分を参照する方法としては、主に次の 2 種類の方法があります。
クライアントサイド JS &amp;hellip; useRouter フックを使う サーバーサイド JS &amp;hellip; getServerSideProps に渡されるパラメーターを使う クライアントサイド JS からクエリパラメーターを参照する (router.query) Next.js の useRouter フック を使うと、上記のようなクエリパラメーター部分を簡単に抽出することができます。 次の例では、クエリパラメーターとして渡された sortby と order の値を取得しています。 値が省略された場合は、それぞれの値は undefined になります。
src/pages/todos.tsx import { NextPage } from &amp;#39;next&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; const TodosPage: NextPage = () =&amp;gt; { const router = useRouter() const { sortby, order } = router.query console.</description></item><item><title>TypeScript で JSON オブジェクトに型情報を付加する</title><link>https://maku.blog/p/2hr3eqx/</link><pubDate>Sat, 26 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2hr3eqx/</guid><description>何が問題か？ JSON テキストファイルの内容を JSON.parse した結果や、fetch API のレスポンスを json() 関数にかけた結果は、型情報のない any 型のオブジェクトになります。 TypeScript コードから、このオブジェクトのプロパティを参照しようとすると、「定義されていないプロパティを参照している」という感じの ESLint エラーになってしまいます。 何より、型情報がないデータをそのまま扱おうとすると、VS Code などでプロパティ名の入力補完機能が働きません。
ここでは、サンプルデータとして次のような JSON 形式の文字列を使うことにします。
const jsonText = `{ &amp;#34;games&amp;#34;: [ { &amp;#34;title&amp;#34;: &amp;#34;Title1&amp;#34;, &amp;#34;genres&amp;#34;: [&amp;#34;ACT&amp;#34;] }, { &amp;#34;title&amp;#34;: &amp;#34;Title2&amp;#34;, &amp;#34;genres&amp;#34;: [&amp;#34;ACT&amp;#34;, &amp;#34;RPG&amp;#34;] }, { &amp;#34;title&amp;#34;: &amp;#34;Title3&amp;#34;, &amp;#34;genres&amp;#34;: [&amp;#34;STG&amp;#34;], &amp;#34;note&amp;#34;: &amp;#34;Fantastic shooting game&amp;#34; } ] } ` この JSON 文字列を JSON.parse 関数でオブジェクトに変換して、そのプロパティを参照しようとすると、ESLint がエラーを出します。
// Unsafe assignment of an `any` value (@typescript-eslint/no-unsafe-assignment) const jsonObj = JSON.</description></item><item><title>React の JSX 記述のコツ</title><link>https://maku.blog/p/xjv6gqy/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjv6gqy/</guid><description>JSX の最上位要素はひとつ JSX 要素を作成するとき、トップレベルの要素は 1 つだけにする必要があります。 次のコードでは、トップレベルに 2 つの p 要素が並んでいるのでエラーになります。
ダメな例 const MyComponent: React.FC = () =&amp;gt; { return ( &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; ) } これを解決するには、例えば次のようにルート要素として div を配置します。
return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ) もちろん、これはこれで動作するのですが、ルートに余計な div 要素が作られてしまうのを防ぎたいときは、次のように &amp;lt;&amp;gt;...&amp;lt;/&amp;gt; で囲います（これは &amp;lt;React.Fragment&amp;gt; の省略記法です）。
return ( &amp;lt;&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; ) 条件を満たすときのみ出力する 次のコードは、n &amp;gt; 0 を満たしたときに、後半の p 要素を表示します。
return &amp;lt;&amp;gt; {n &amp;gt; 0 &amp;amp;&amp;amp; &amp;lt;p&amp;gt;条件を満たしたよ&amp;lt;/p&amp;gt;} &amp;lt;/&amp;gt; JSX コードの中では、if や for といった値を返さない文 (statement) を記述することができません。 なので、出力を条件分岐させたいときは、この例のように、&amp;amp;&amp;amp; や || のような演算子を駆使する必要があります。</description></item><item><title>TypeScript で undefined/null をうまく扱う (nullish coalescing (??), optional chaining (?.))</title><link>https://maku.blog/p/5oyaju5/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5oyaju5/</guid><description>Null 合体演算子 (??) ES2020 で Null 合体演算子 (Nullish Coalescing Operator) の ?? が導入されました。
☝️ nullish とは？ JavaScript において nullish とは、「undefined あるいは null」を示します。 coalescing には、「癒合、合体」という意味があります。 よって、nullish coalescing は、「null っぽかったら合体させるよ」という意味になります。 ?? 演算子を使うと、ある変数の値が undefined（あるいは null）だったときの代替となる値を指定することができます。 つまり、
A ?? B は、次のように記述するのと同等です。
A != undefined ? A : B 下記は、?? 演算子の振る舞いの一覧です。 ?? 演算子はあくまで undefined と null だけを判別するものであって、左側に偽となる値（false や空文字）をおいた場合は、その値がそのまま使われることに注意してください。
// 右側の値が（代わりに）使われるパターン const a = undefined ?? &amp;#39;default&amp;#39; //=&amp;gt; &amp;#39;default&amp;#39; const b = null ?? &amp;#39;default&amp;#39; //=&amp;gt; &amp;#39;default&amp;#39; // 左側の値が（そのまま）使われるパターン const c = &amp;#39;&amp;#39; ?</description></item><item><title>Amazon S3: 未整理・雑多メモ</title><link>https://maku.blog/p/8cygv9k/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8cygv9k/</guid><description> S3 のストレージクラスの例 汎用ストレージ &amp;hellip; S3 STANDARD アクセス頻度小 &amp;hellip; S3 STANDARD_IA 長期アーカイブ &amp;hellip; S3 Glacier S3 のバケットポリシーでは、プレフィックスとか拡張子などを指定してアクセスコントロールが可能。 S3 へのアクセスは ACL（アクセスコントロールリスト）でもコントロールできるが、古い仕組みなので非推奨。今は IAM を使う。 S3 のバージョニング設定を有効にすると、オブジェクトの複数バージョンを管理できるようになる。 S3 のバケット名は世界で一意になるように命名する。 3～63 文字で、大文字は使えない。 先頭文字は小文字の英数字。 _ 2文字目以降は、小文字の英数字、ハイフン、ドットのいずれかで構成する。ただし、ドットは通常は使わない方がよい（ドメインの区切り文字と混ざるので、HTTPS の証明書検証などに影響が出る）。</description></item><item><title>DynamoDB の未整理・雑多メモ</title><link>https://maku.blog/p/38bpqjp/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38bpqjp/</guid><description> DynamoDB のテーブルは リージョンごとに独立 して存在する。例えば、us-east-2 リージョンの People テーブルと、us-west-2 リージョンの People テーブルは別物として扱われる。 DyanmoDB のテーブル名、属性名は CamelCase にするのが公式っぽい（-、_、. といった記号も使える） プライマリキー DynamoDB の プライマリキーの型 は、文字列／数値／バイナリ、といったスカラ値のみが使える。 DynamoDB のプライマリキーは 1 つ or 2 つ 1 つの場合 &amp;hellip; パーティションキーのみ（一意な ID） 2 つの場合 &amp;hellip; パーティションキー + ソートキー（パーティションが同じであれば、同じ物理ストレージ内にソートキー値でソートされた形で項目が保持される） DynamoDB のテーブルは、プライマリキーとなる属性以外はスキーマレスなので、テーブル作成時はプライマリーキー属性のみ定義すればよい。それ以外の部分には入れ子構造のデータも自由に入れられる。 DynamoDB に項目を追加するときに バイナリ型属性 の値を渡すときは、Base64 エンコードして渡す必要がある。 RCU の消費 基本的にクエリ (Query) は合計サイズ 4KB ごとに 1RCU 消費する。 GetItem の場合は、1 件ごとに 1RCU 消費する。 100 件以上とか大量に PutItem するときは、BatchWrite の仕組みを使うとめっちゃ速くなる。複数の要求をバッファリングして通信回数を減らしてくれるぽい。具体的な使い方は、各 SDK の API ドキュメントを参照。</description></item><item><title>Azure リソースのプレフィックス名（省略名）</title><link>https://maku.blog/p/rcoz9o9/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rcoz9o9/</guid><description>Azure で何らかのリソースを作成するときは、リソース名のプレフィックス として、リソースの種類に応じた略称（cosmos- など）をつけることが多いのですが、この略称の指針が Microsoft Docs のサイトに書かれています。 リソース名をどうするかは意外と迷うところなので、こういった情報は地味に助かります。
Azure リソースの種類に推奨される省略形 - Cloud Adoption Framework | Microsoft Docs 例えば次のような感じで定義されています。
リソースの種類 プレフィックス リソースグループ rg- Cosmos DB アカウント cosmos- ストレージアカウント st- 静的 Web アプリ stapp- 関数アプリ func- また、リソース名全体の構成も次のような例で示されています。
図: Azure リソース名の構成（Microsoft Docs より） この辺りは開発チームによってルールが決められているかもしれませんが、まずはこの構成で間に合うか考えてみるとよいと思います。</description></item><item><title>MongoDB for VS Code で Azure Cosmos DB を操作する</title><link>https://maku.blog/p/dt3ahpw/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dt3ahpw/</guid><description>Cosmos DB インスタンスを MongoDB API アクセス用に作成 しておくと、さまざまな MongoDB 用のツールでデータベースにアクセスできるようになります。 ここでは、VS Code 用の拡張「MongoDB for VS Code」を使って、Cosmos DB を操作できるようにしてみます。 TypeScript を使って Web アプリを作成しているときは、エディタとして VS Code を使っていることが多いでしょうから、同じ環境上で Cosmos DB を操作できると開発が捗ります。
MongoDB for VS Code のインストール 図: MongoDB for VS Code のインストール MongoDB for VS Code は、VS Code の Extesions バー (Cmd/Ctrl + Shift + X) で MongoDB で検索すれば簡単にインストールできます。
VS Code から Cosmos DB (MongoDB) に接続する 接続文字列で簡単接続 MongoDB for VS Code をインストールすると、サイドバーに 葉っぱのアイコン が出てくるので、ここから MongoDB サーバーに接続することができます。 ちなみに、MongoDB が葉っぱアイコンを使うのは、それを使うことが「シンプルで自然であるから」らしいです（じゃあ水でもいいじゃん、とは言いますまい）。</description></item><item><title>Android Studio の IdeaVim プラグインで快適コーディング</title><link>https://maku.blog/p/f4ugxri/</link><pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/f4ugxri/</guid><description>IdeaVim プラグインのインストール Android Studio (IntelliJ IDEA) に IdeaVim プラグインを入れると、Vim 系のキーマッピングが有効になり、高速にコーディングできるようになります（もちろん Vim の操作に精通しておく必要がありますが）。 IdeaVim プラグインは Android Studio から下記のように辿って簡単にインストールできます。
File → Settings → Plugins IdeaVim で検索してインストール IdeaVim の設定 (.ideavimrc) 通常の Vim エディタの設定ファイルは ~/.vimrm ですが、IdeaVim の設定ファイルは ~/.ideavimrc です。 Windows の場合は、%USERPROFILE%\.ideavimrc です（or _ideavimrc）。
~/.ideavimrc set clipboard=unnamed nnoremap gd :action GotoDeclaration&amp;lt;CR&amp;gt; nnoremap gi :action GotoImplementation&amp;lt;CR&amp;gt; nnoremap gs :action GotoSuperMethod&amp;lt;CR&amp;gt; nnoremap gb :action Back&amp;lt;CR&amp;gt; nnoremap gf :action Forward&amp;lt;CR&amp;gt; nnoremap &amp;lt;C-Left&amp;gt; :action Back&amp;lt;CR&amp;gt; nnoremap &amp;lt;C-Right&amp;gt; :action Forward&amp;lt;CR&amp;gt; .</description></item><item><title>AWS AppSync のポリシーステートメントの記述例</title><link>https://maku.blog/p/cexcpyc/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cexcpyc/</guid><description>参考: Lambda / SSM
特定アカウントからのアクセスのみ許可する アカウント 123456789012 からのアクセスのみ許可 { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Principal&amp;#34;: { &amp;#34;Service&amp;#34;: &amp;#34;appsync.amazonaws.com&amp;#34; }, &amp;#34;Action&amp;#34;: &amp;#34;sts:AssumeRole&amp;#34;, &amp;#34;Condition&amp;#34;: { &amp;#34;StringEquals&amp;#34;: { &amp;#34;aws:SourceAccount&amp;#34;: &amp;#34;123456789012&amp;#34; } } } ] } 特定の API へのアクセスのみ許可する abcdefg API のみ許可 { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Principal&amp;#34;: { &amp;#34;Service&amp;#34;: &amp;#34;appsync.amazonaws.com&amp;#34; }, &amp;#34;Action&amp;#34;: &amp;#34;sts:AssumeRole&amp;#34;, &amp;#34;Condition&amp;#34;: { &amp;#34;ArnEquals&amp;#34;: { &amp;#34;aws:SourceArn&amp;#34;: &amp;#34;arn:aws:appsync:us-west-2:123456789012:apis/abcdefg&amp;#34; } } } ] } 特定 のリージョンからのアクセスのみ許可する us-east-1 のみ許可 { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Principal&amp;#34;: { &amp;#34;Service&amp;#34;: &amp;#34;appsync.</description></item><item><title>AWS Lambda のポリシーステートメントの記述例</title><link>https://maku.blog/p/yn7hqx8/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yn7hqx8/</guid><description>参考: AppSync / SSM
Lambda 関数の呼び出しを許可する { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;lambda:invokeFunction&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:lambda:us-west-2:123456789012:function:my-function&amp;#34;, &amp;#34;arn:aws:lambda:us-west-2:123456789012:function:my-function:*&amp;#34; ] } ] }</description></item><item><title>MUI コンポーネント (v4) に独自のスタイルを設定する (makeStyles)</title><link>https://maku.blog/p/cw9ju6f/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cw9ju6f/</guid><description>この記事では、MUI v4 以前の makeStyles() 関数を使ったカスタムスタイル設定方法を説明しています。 MUI v5 以降のカスタムスタイル設定では sx prop や styled() 関数を使用しますので、下記の記事を参照してください。
参考: MUI コンポーネントに独自のスタイルを設定する（v5 以降の sx prop、styled 関数を使う方法） Material-UI コンポーネントのスタイル設定 Material-UI が提供する各種コンポーネントには、表示スタイルを切り替えるためのプロパティが用意されています。 例えば、Button コンポーネント は variant や color プロパティで見た目を切り替えることができます。
&amp;lt;Button&amp;gt;Default&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;contained&amp;#34; color=&amp;#34;primary&amp;#34;&amp;gt;Primary&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;contained&amp;#34; color=&amp;#34;secondary&amp;#34;&amp;gt;Secondary&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;outlined&amp;#34; disabled&amp;gt;Disabled&amp;lt;/Button&amp;gt; 多くのケースでは、この仕組みで十分にスタイル設定できるのですが、デフォルトのスタイルから外れた表示をしたり、div 要素など Material-UI 以外のコンポーネントに対して独自の CSS を適用したいことがあります。 このような場合、コンポーネントの実装ファイル内に直接 CSS コードを記述してスタイルをカスタマイズできます（JavaScript 内に記述するので CSS-in-JS と呼びます）。 React の世界では色々な CSS 参照方法がありますが、Material-UI は次のような理由で CSS-in-JS な記述方法を採用しています。
現在のテーマ設定に基づいたスタイル設定を行える（例: 基準スペースの2倍のマージンを設定する） コンポーネントの props の値を使って動的にスタイル設定できる（例: &amp;lt;MyButton color=&amp;quot;vivid&amp;quot;&amp;gt; で派手な色のスタイルを設定する） フックによるスタイル設定 (makeStyle) Material-UI で、コンポーネントに独自スタイルを設定する方法としては、主に次の 3 種類の方法が用意されています。</description></item><item><title>Next.js で Material-UI を使う</title><link>https://maku.blog/p/s6djqw3/</link><pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s6djqw3/</guid><description>Material-UI は、マテリアルデザインを提供する React コンポーネントライブラリです。
Material-UI のインストール Material-UI のコアパッケージ (@material-ui/core) は、npm コマンドで簡単にインストールできます。 マテリアルデザイン系のアイコン を使いたい場合は、@material-ui/icons パッケージもインストールしておきます。
### yarn の場合 $ yarn add @material-ui/core $ yarn add @material-ui/icons ### npm の場合 $ npm install @material-ui/core $ npm install @material-ui/icons Next.js の create-next-app コマンドでプロジェクトを作成済みであれば、これだけで Material-UI コンポーネントを使う準備は完了です。 Material-UI のデフォルトテーマは Roboto フォントを使用する ので、次のようなコードを head 要素内に記述する必要がありますが、これは後述の _document.tsx で設定します。
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;amp;display=swap&amp;#34; /&amp;gt; Material-UI は font weight に 300/400/500/700 のいずれかを使用するので、上記のように読み込むデータを制限することで、ロード時間を削減できます。
Material-UI のコンポーネントを使ってみる Material-UI のインストールができたら、あとは、各コンポーネントの実装ファイルから import するだけで使用できます。 次の例では、Button コンポーネントと、ButtonGroup コンポーネントを使っています。</description></item><item><title>macOS で不要なファイルを削除してストレージ容量を確保する</title><link>https://maku.blog/p/ygpw6dk/</link><pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ygpw6dk/</guid><description>macOS のストレージ容量が足りなくなってきたときのために、各種キャッシュの削除方法などをまとめておきます。
Homebrew (brew) 関連 古いバージョンの削除 brew コマンドでいろいろコマンドをインストールしていると、古いバージョンのモジュールが /usr/local/Cellar ディレクトリの中にどんどん増えていきます。 brea cleanup コマンドで、古いモジュールを削除できます。
# ドライラン（何が削除されて、何MBくらい減らせるか確認） $ brew cleanup -n # 実際に削除 $ brew cleanup 各モジュールでどのようなバージョンがインストールされているかは、次のように確認することができます。
$ brea ls-versions ... libxext 1.3.4 libxrender 0.9.10 libyaml 0.1.6_1 0.2.5 0.1.7 ... ダウンロードキャッシュの削除 Homebrew のダウンロードキャッシュが格納されているディレクトリは次のコマンドで確認できます。
$ brew --cache /Users/maku/Library/Caches/Homebrew 次のようにしてキャッシュディレクトリごとまとめて削除できます。
$ rm -rf `brew --cache` ライブラリフォルダ内のキャッシュを削除 $ rm -rf ~/Library/Caches/* Ruby 関連 gem # インストールされている Gem のバージョン一覧 $ gem list # 古いバージョンの削除（ドライラン） $ gem cleanup --dryrun # 古いバージョンの削除（実行） $ gem cleanup</description></item><item><title>macOS のスポットライトのインデックス処理を停止・開始する</title><link>https://maku.blog/p/j5gr3dn/</link><pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j5gr3dn/</guid><description>macOS の mdutil コマンドを使用すると、スポットライトのインデックス設定を変更することができます。
インデックス処理の現在の設定を調べる $ sudo mdutil -a -s /: Indexing enabled. /System/Volumes/Data: Indexing enabled. /Volumes/SD_card: Indexing and searching disabled. インデックス処理を無効化する $ sudo mdutil -a -i off インデックス処理を有効化する $ sudo mdutil -a -i on インデックスを削除して再生成 $ sudo mdutil -a -E</description></item><item><title>TypeScript コードを Prettier で自動整形する</title><link>https://maku.blog/p/au8iu6u/</link><pubDate>Wed, 26 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/au8iu6u/</guid><description>Prettier とは？ Prettier は、TypeScript や JavaScript などのソースコードを自動フォーマットするためのツールです。 HTML や CSS など様々なファイルに対応していますが、主に TypeScript や JavaScript のフォーマッターとして使用されています。 実際にどのようにフォーマットされるかは、Playground のページ で試すことができます。
特徴と思想 Prettier の一番の特徴は、Opinionated（独断的な） コードフォーマッターであることを標榜していることです。 これは、ユーザーに自由なカスタマイズを許さず、「Prettier 自身が定義しているスタイルに強制的にフォーマットするよ」ということです（セミコロンの有無など最低限の設定はできます）。 これにより、コーディングスタイルに関する 不毛な議論を避ける ことができ、プロジェクト内のコーディングスタイルを簡単に統一することができます。
もちろん、自分がベストだと思っているスタイルでフォーマットすることはできなくなるかもしれませんが、そんな些細なことよりも、アプリケーション（成果物）を作り上げることに集中すべきだという考え方です。
Prettier がやらないこと Prettier はあくまでコードのフォーマットのみを行います。 コードの意味を解析して危険な部分（潜在的バグ）を検出してくれたりはしないので、そういったことを行いたい場合は、他の静的解析ツール（ESLint など）を使う必要があります。 ESLint にもコードフォーマット機能がありますが、フォーマッターとしては Prettier が優れており、「Prettier による整形 ＋ ESLint による静的解析」という形で組み合わせて使うのが一般的です。
あと、import 文のソートなど、一見やってくれてもよさそうなフォーマットもしてくれなかったりします。 これは、その import 順序がロジック的に意味を持っていたりする場合に、Prettier が判断できないからです。 このように、いろいろと想像と異なるフォーマット結果になることがありますが、そこにはちゃんと理由があります（参考: Rationale）。 あまり気にせずにそんなものだと考えるのがよいです。 ちなみに、ESLint の方には import 文のソートを行うプラグイン (eslint-plugin-import) があります。
Prettier をインストールする Prettier は npm で簡単にインストールすることができます。 TypeScript のプロジェクトは作成済み で、package.json がすでに存在すると想定します。
### yarn の場合 $ yarn add prettier --dev --exact ### npm の場合 $ npm install prettier --save-dev --save-exact Prettier は、パッチバージョンが上がるだけで、出力結果に微妙な差分が生まれる可能性があります。 そのため、インストール時のオプションとして --save-exact を指定することで、明確なバージョンを package.</description></item><item><title>Next.js で Bootstrap と React Bootstrap を使う</title><link>https://maku.blog/p/k8mxakw/</link><pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k8mxakw/</guid><description>何をするか？ Next.js アプリから、CSS フレームワークの Bootstrap を使えるようにする方法を説明します。
Bootstrap を導入 各コンポーネントの実装で、Bootstrap の CSS クラスを参照できるようにします React Bootstrap を導入 Bootstrap を React コンポーネントの形で使えるようにします Bootstrap を導入する bootstrap モジュールをインストールする方法 Bootstrap は npm install で簡単にインストールできます。
$ npm install bootstrap@next --save あとは、次のような pages/_app.tsx ファイルを作成して、グローバル CSS としてインポートすれば OK です。
pages/_app.tsx import type { AppProps } from &amp;#39;next/app&amp;#39; import &amp;#39;bootstrap/dist/css/bootstrap.min.css&amp;#39; export default function MyApp({ Component, pageProps }: AppProps) { return &amp;lt;Component {...pageProps} /&amp;gt; } これで、各ページコンポーネントから Bootstrap の CSS クラスを参照できるようになります。
CDN 上のファイルを参照する方法 CDN 上で公開されている Bootstrap ファイルを参照することもできます。 pages/_app.</description></item><item><title>Next.js でサーバーサイドで JSON や YAML ファイルを読み込む (fs.readFileSync)</title><link>https://maku.blog/p/iz8fnu3/</link><pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iz8fnu3/</guid><description>何をするか？ Next.js アプリのページコンポーネントの getStaticProps / getServerSideProps 関数や、API ルート (pages/api/*.ts) の handler 関数は、クライアントからのアクセス時やビルド時に、サーバーサイドで呼び出されます。 つまり、これらの関数の中では、Node.js の fs モジュールを使った（サーバー上の）ローカルファイルの読み込みが可能です。
ここでは、例として、
ページコンポーネントの getStaticProps 関数から JSON ファイルを読み込む方法 API ルートの handler 関数から YAML ファイルを読み込む方法 を紹介します。
JSON ファイルを読み込む（in getStaticProps 関数） 使用する JSON ファイル サンプルデータとして次のような JSON ファイルをプロジェクト内に配置します。
src/data/games.json [ { &amp;#34;id&amp;#34;: &amp;#34;dq1&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;dq2&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト2&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;dq3&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト3&amp;#34; } ] JSON ファイルを読み込む 次のコードでは、getStaticProps 関数の中で src/data/games.json ファイルを読み込んで、ページコンポーネントに渡す props データを作成しています。
src/pages/games.tsx import * as fs from &amp;#39;fs&amp;#39; import * as path from &amp;#39;path&amp;#39; import { GetStaticProps, NextPage } from &amp;#39;next&amp;#39; type Game = { id: string, title: string } type PageProps = { games: Game[] } export const getStaticProps: GetStaticProps&amp;lt;PageProps&amp;gt; = async (context) =&amp;gt; { // JSON ファイルを読み込む const jsonPath = path.</description></item><item><title>Next.js の Image コンポーネントで画像を表示する (next/image)</title><link>https://maku.blog/p/fw7gpx7/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fw7gpx7/</guid><description>Image コンポーネントの特徴 Next.js が提供している Image コンポーネント (next/image) を使用すると、image 要素をそのまま配置するのに比べて次のような恩恵を受けられます。
遅延ロード (Lazy loading) Web ブラウザでその画像がビューポート内（画面内）に入って来たときに初めてダウンロードされるようになります。大きなページの末尾部分に配置された画像が、無駄にダウンロードされてしまうのを防ぐことができます。 画像の最適化 アクセスしてきたクライアントに応じて画像ファイルを最適化して配信します。例えば、圧縮効率のよい WebP フォーマットなどに変換してくれます。リクエスト時にサーバーサイドでオンデマンドで最適化するため、Image コンポーネントを使うことでビルド時間が伸びてしまうことはありません。外部サーバーの画像を間接的に表示する場合も最適化できます。 レスポンシブ 画面サイズに応じたレスポンシブ表示 (CSS) がデフォルトで行われます。 画像最適化に関しては、Next.js サーバー上でホスティングしているときしか動作しないといった制約がありますが、遅延ローディングがデフォルトで有効になるのは便利です。
Image コンポーネントの基本的な使い方 次のサンプルコンポーネントでは、Image コンポーネントを使って /public/images/avatar.png ファイルを表示しています。
components/Avatar.tsx import Image from &amp;#39;next/image&amp;#39; export const Avatar: React.FC = () =&amp;gt; ( &amp;lt;Image src=&amp;#34;/images/avatar.png&amp;#34; width={64} height={64} alt=&amp;#34;My avatar&amp;#34; /&amp;gt; ) ☝️ public ディレクトリ public ディレクトリ以下に配置したファイルは、Web サイトへのアクセス時には、ルートパス (/) からの相対パスで参照できるようになります。 public ディレクトリは、必ず Next.js プロジェクトのルートディレクトリに配置する必要があります。 .ts、.tsx ファイルは src ディレクトリ以下にも配置できますが、public ディレクトリは必ずルートに置かなければいけません。 width や height プロパティを明示しておくと、画像のロード前にそのサイズの枠が確保されることになります。 これは、CLS (Cumulative Layout Shift) を発生させないために重要です。 表示サイズがあらかじめ決まっていないと、画像ロード後にレイアウトがガクッとずれたりして UX が低下します。 Google によるサイト評価でも CLS スコアは重要視されています。</description></item><item><title>Undertale やってみた</title><link>https://maku.blog/p/eu7djpv/</link><pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eu7djpv/</guid><description>インディーズゲームの世界で話題になった『Undertale』をやってみました。 斬新なシステムや、ストーリー、音楽などに定評があるゲームです。
プレイヤーによって好き嫌いがハッキリと分かれそうなゲームですが、ゲームとして非常に練りこまれていて、プレイしておいて損はないゲームだと思いました。 最初クリアしたときは、ただのパズル要素の入ったドット絵の同人 RPG みたいだなという感じでしたが、Web で情報を探してみると、下記のように特殊な進め方をする 2 回目以降のプレイからが本当のストーリーの始まりでした。
P ルート (True Pacifist Route) &amp;hellip; 誰も殺さない G ルート (Genocide Route) &amp;hellip; 皆殺し この両極端な進め方でもクリアできるようになっているところが面白く、そのプレイ方法がプレイヤーを感情移入させます。 そして登場キャラクターは、プレイヤーが何度も繰り返しプレイしていることを認識しています。 何度もクリアしなければいけないのは面倒だと思うかもしれませんが、2 回目以降は途中のパズルなどを飛ばせるようになっていて、サクサクと進められるよう工夫されています。
ただし、集団虐殺ルート（通称 G ルート）のラスボス的存在である骸骨姿の「サンズ (Sans)」は凶悪なほど強く、鬼畜ゲー と言われる理由がわかりました。 なんと、プレイヤーのコマンド入力エリアにまで攻撃を仕掛けてきて、ミリ秒単位の操作が要求されます。 ほんと寿命が縮まります。 何十回も挑戦してぎりぎりでクリアできましたが、もう少し歳を取ったら、このゲームはたぶんクリアできなくなると思います。 というかプレイ中に死ぬ と思います。 今のうちにクリアしておいてよかったです。
UNDERTALE - Switch (【永久封入特典】ストーリーブックレット 同梱) Toby Fox Nintendo Switch UNDERTALE - PS4 (【永久封入特典】ストーリーブックレット 同梱) Toby Fox PlayStation 4 UNDERTALE - PSVita (【永久封入特典】ストーリーブックレット 同梱) Toby Fox PlayStation Vita ちなみに、普通の RPG と同様に、最初にプレイヤーに名前を付けるのですが、この名前は実は、</description></item><item><title>async は「アシンク」じゃなくて「エイシンク」だよ</title><link>https://maku.blog/p/anu28ek/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/anu28ek/</guid><description>こんなことを記事にしたくもなかったのですが、ほんとうに間違った読み方をしている人が多いので書きます。
多くのモダンなプログラミング言語が async/await という非同期処理用の構文（あるいはそれに似た構文）を採用しているのですが、この「async」を「アシンク」と読んでいる日本人がすごく多いです。 感覚的には、半分くらいの人が「アシンク」って発音しているのではないかと思うくらい。。。しかし、
「async」の発音は「エイシンク」です！ もちろんこのキーワードは英語の asynchronous から来ているのですが、
アメリカ発音は eɪsíŋkrənəs イギリス発音は eɪˈsɪŋkrʌnʌs で、どちらも「エイシンクロナス」です。 英語の解説動画を見たらすぐ分かることですが、「アシンク」なんて発音している人はいません。 ちなみにちょっと古い技術ですが、「ajax」も「アジャックス」ではなく「エイジャックス」です。 「アシンクロナス」なんて発音したら、「a synchronous ~」になって全く逆の意味になってしまいます。
おそらく独学で async/await イディオムを学んだ人は最初からちゃんと正しく発音できています。 周りの人が「アシンク」って連呼しているところから学び始めた人は、間違えて覚えちゃってる人が多いのだと思います。
「アシンク」でもいいんじゃないかと言う人すらいそうですが、こんな基本的な発音すら間違っていると、この人はプログラミングをちゃんと理解しているのか？と無駄に疑われてしまいます。 こんなことでも海外のデベロッパーになめられます。 絶対にちゃんと発音した方がいいです。
この記事を読んだ人は、これ以上被害者を出さないためにも、「エイシンク」と正しく発音するようにしてください。 Youtube などで間違った読み方で解説動画を作っている人はすぐに直してください。 お願いいたします。</description></item><item><title>AWS CLI でアクセスできるのに AWS SDK で Access Denied (403) になるとき</title><link>https://maku.blog/p/7tds7bw/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7tds7bw/</guid><description>認証情報の食い違いを調べる 例えば、ローカルで AWS CLI を使って S3 の情報にアクセスできているのに、AWS SDK 使った Node.js プログラムで S3 にアクセスしたときに Access Denied (403) になるときは、異なる認証情報 (credentials) を使ってアクセスしている可能性 があります。
AWS CLI が、どのようなユーザーでアクセスしているかは、下記のようにして確認できます。
$ aws sts get-caller-identity Account: &amp;#39;123456789012&amp;#39; Arn: arn:aws:sts::123456789012:assumed-role/MyDeveloperRole/botocore-session-9876543210 UserId: A6B3EVWX58AR9AVTXAP5T:botocore-session-9876543210 次に、Node.js のプログラムなどで、AWS SDK を使って上記と同様の情報を取得します。 Node.js 用の SDK ver.2 では、AWS.STS.getCallerIdentity()、SDK ver.3 では STSClient.send() を使います。
参考: AWS.STS.getCallerIdentity() - AWS SDK v2 参考: GetCallerIdentityCommand() - AWS SDK v3 printCallerIdentity.ts（SDK ver.2 の場合） import { STS } from &amp;#39;aws-sdk&amp;#39;; async function printCallerIdentity() { try { const sts = new STS(); const result = await sts.</description></item><item><title>ドメイン管理と DNS 管理の違いを理解する</title><link>https://maku.blog/p/bwamwgp/</link><pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bwamwgp/</guid><description>ドメイン管理と DNS サーバー 「独自ドメイン＋レンタルサーバー」を契約してブログサイトなどを立ち上げようとすると、どうしてもドメイン管理や DNS 設定を行う必要が出てきます。 同じ会社で一括契約すると、まとめて設定できたりしますが、これらは本来別々のサービスなので、ここで簡単に整理しておきます。
ドメイン取得・管理は、レジストラ（およびその委託先会社）が行っており、世界で一意なドメインを運用します。 日本では、お名前.com (by GMO) などが有名ですね。 一方で、DNS サービスは、このドメイン名を具体的な IP アドレスに関連づける機能を提供します。
レジストラ（ドメイン管理会社）が提供するドメイン管理サービスは、あくまでドメイン名を管理しているだけであり、DNS の機能を提供しているわけではありません。 なので、ドメイン管理会社でドメインを取得したら、そのドメインの名前解決に使用する DNS サーバーのアドレスを教えてあげる必要があります。 上の図では、お名前.com のドメイン管理設定で、さくらインターネットの DNS サーバー (ns1/2.dns.ne.jp) のアドレスを設定する例を示しています。
この設定により、ユーザーが example.com にアクセスしようとすると、DNS サーバー (ns1.dns.ne.jp) によって IP アドレス (12.34.56.78) に変換され、そのアドレスの Web サーバーにアクセスできるという仕組みになっています。
組み合わせの例 ドメイン取得・管理 DNS サーバー Web サーバー お名前.com お名前.com お名前.com お名前.com さくらインターネット さくらインターネット お名前.com AWS (R53) AWS (EC2) 多くの場合、こんな感じで DNS サーバーと Web サーバーは同じ会社のものを使います。 レンタルサーバーのアドレスなどを自動で設定できたりして便利だからです。 DNS サーバーの使用料金はレンタルサーバーの使用料金に含まれていることが多いですが、AWS の R53 などは個別に使用料金がかかります。
一方、ドメイン取得・管理会社の方は、年ごとの更新費用などが安い「お名前.com」などを選ぶことが多いです。 Amazon (AWS) などのクラウドサービスでもドメイン取得できたりしますが、ちょっとお値段高めです。</description></item><item><title>Lambda 実装例: S3 へのアップロードを SNS で通知して Lambda から読み込む</title><link>https://maku.blog/p/f2fq2cn/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/f2fq2cn/</guid><description>何をするか？ ここでは Lambda 関数の実装例として、SNS トピックから S3 バケットの PutObject イベント通知を受けて、アップロードされたファイルを読み込む例を示します。 S3 バケット、および SNS トピックの作成と、S3 → SNS の通知設定は完了していると想定します。
参考リンク CloudFormation の設定例: S3 通知を SNS トピックに Publish する CloudFormation の設定例: SNS トピックを Lambda 関数からサブスクライブする Lambda 関数の実装 AWS SDK のインストール ここでは、Node.js 用の AWS SDK ver.2 を使っているので、先にインストールしておく必要があります。 AWS 側の Lambda 実行環境には標準でインストールされているので、--save-dev（開発用）でインストールしておけば OK です。 ついでに TypeScript 用の型定義もインストールしておくと、Lambda ハンドラのパラメータを any 型ではなく、SNSEvent 型などで参照できて便利です。
$ npm install aws-sdk --save-dev $ npm install @types/aws-lambda --save-dev Lambda ハンドラの実装 先に、S3 バケット内のオブジェクトの内容を取得するユーティリティ関数を用意しておきます（AWS SDK ver.</description></item><item><title>AWS SNS トピックから通知されるイベントデータの例</title><link>https://maku.blog/p/qcpybnx/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcpybnx/</guid><description>AWS SNS トピックからメッセージが発行されたときに、サブスクライバー（Lambda 関数など）にどのようなイベントデータが配信されるかの例です。
基本的なメッセージの構造 Lambda 関数で受け取る場合 SNS トピックに対して Lambda 関数をサブスクライブしておくと、Lambda 関数の第一引数 (event) で、次のようなオブジェクトを受信できます。 重要な情報は、Records[0].Sns の下に格納されています。
{ &amp;#34;Records&amp;#34;: [ { &amp;#34;EventSource&amp;#34;: &amp;#34;aws:sns&amp;#34;, &amp;#34;EventVersion&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;EventSubscriptionArn&amp;#34;: &amp;#34;arn:aws:sns:ap-northeast-1:123456789012:mytopic:0884-5d81c0db-4e13-829f-596f7ea9f8ad&amp;#34;, &amp;#34;Sns&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;Notification&amp;#34;, ... &amp;#34;Subject&amp;#34;: &amp;#34;Message Title&amp;#34;, &amp;#34;Message&amp;#34;: &amp;#34;Message Body&amp;#34;, ... } } ] } メールで受け取る場合 SNS トピックに「JSON 形式のメール」をサブスクライブしておくと、SNS のメッセージが発行されたときに、次のような内容のメールが届きます。
{ &amp;#34;Type&amp;#34;: &amp;#34;Notification&amp;#34;, ... &amp;#34;Subject&amp;#34;: &amp;#34;Message Title&amp;#34;, &amp;#34;Message&amp;#34;: &amp;#34;Message Body&amp;#34;, ... } Lambda 関数の第一引数で渡される event オブジェクトで表現すると、event.Records[0].Sns に相当する部分の情報がメールで送られてきます。
具体的な SNS メッセージの例 下記の例では、Records[0].Sns 以下の情報のみを示しています（JSON 形式のメールで送られる内容です）。</description></item><item><title>AWS CloudFormation の設定例: S3 通知を SNS トピックに Publish する</title><link>https://maku.blog/p/3o2dpyb/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3o2dpyb/</guid><description>何をするか？ ここでは、CloudFormation のテンプレートを使って、次のような AWS リソースを定義してみます。
S3 バケット（Logical ID: MyBucket) SNS トピック (Logical ID: MyTopic) 上記の S3 バケットへの書き込み時に、SNS トピックへ publish 動作のイメージとしてはこんな感じです。
このような構成でリソースを作っておくと、S3 バケット上のデータ更新を、SNS トピックのサブスクライブによって監視できるようになります。 例えば、Lambda 関数を SNS トピックのサブスクライバーとして登録すれば、S3 バケットへの書き込みを Lambda 関数でハンドルできます。
参考情報 CloudFormation テンプレートで S3 バケットや SNS トピックを定義する方法は、下記の記事を参考にしてください。
CloudFormation で S3 バケットの作成 CloudFormation で SNS トピックの作成 テンプレートの記述例 次の CloudFormation テンプレートでは、S3 バケットと SNS トピックのリソースを定義しています。 デフォルトの名前はそれぞれ次のようになっています。
S3 バケット名: myapp-sample-bucket-&amp;lt;AccountId&amp;gt; SNS トピック名: myapp-sample-topic S3 バケット名は世界で一意でなければいけないため、末尾に使用中のアカウント ID を付加するようにしています。
template.yml AWSTemplateFormatVersion: &amp;#39;2010-09-09&amp;#39; Parameters: BucketPrefix: Type: String Default: myapp-sample-bucket TopicName: Type: String Default: myapp-sample-topic Resources: MyTopic: Type: AWS::SNS::Topic Properties: TopicName: !</description></item><item><title>macOS のコマンドラインで ZIP ファイルを作成する</title><link>https://maku.blog/p/2it3bjs/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2it3bjs/</guid><description>ZIP ファイルを作成する（zip コマンド） macOS に標準で付属している zip コマンドを使って、ファイル群を ZIP ファイルとしてアーカイブ（圧縮）できます。
ファイルを 1 つずつ指定する $ zip sample.zip 1.txt 2.txt 3.txt 作成される ZIP ファイル sample.zip +-- 1.txt +-- 2.txt +-- 3.txt ディレクトリごとまとめて ZIP 化する $ zip -r sample.zip dir1 dir2 作成される ZIP ファイル sample.zip +-- dir1/ | +-- 1.txt | +-- 2.txt | +-- 3.txt +-- dir2/ +-- 4.txt +-- 5.txt +-- 6.txt トップディレクトリを含めずに ZIP 化する 例: src ディレクトリ以下のファイルだけ圧縮 $ (cd src &amp;amp;&amp;amp; zip -r .</description></item><item><title>AWS SDK for Node.js でプロキシ環境変数 (https_proxy) を反映させる</title><link>https://maku.blog/p/6vs27aa/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6vs27aa/</guid><description>AWS SDK for Node.js のプロキシ設定 社内のプロキシ環境下などから AWS SDK (for Node.js) を使って API 呼び出しを行うには、次のようにプロキシエージェント設定を行います。 ここでは、AWS SDK version 2 の設定例を示しています。
プロキシ設定の例 (AWS SDK v2) import * as AWS from &amp;#39;aws-sdk&amp;#39;; import { HttpsProxyAgent } from &amp;#39;https-proxy-agent&amp;#39;; AWS.config.update({ httpOptions: { agent: new HttpsProxyAgent(&amp;#39;http://proxy.example.com:8080&amp;#39;) } }); これで、それ以降の AWS サービス (AWS.S3 など）の API 呼び出しがプロキシ経由で行われるようになります。
環境変数 https_proxy の設定を使用する 次のようにすれば、環境変数 https_proxy に設定されたプロキシアドレスを、AWS SDK にも反映させることができます（といっても、process.env.https_proxy を参照しているだけです）。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; import { HttpsProxyAgent } from &amp;#39;https-proxy-agent&amp;#39;; // プロキシ設定を反映 function setupAwsProxy() { const proxy = process.</description></item><item><title>Amazon S3 バケット用のポリシー設定例</title><link>https://maku.blog/p/r9kv6gq/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r9kv6gq/</guid><description>S3 用のポリシー設定例 指定したバケット内のオブジェクト一覧を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:ListBucket&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;&amp;#34; ] } ] } 指定したバケット内のオブジェクトの内容を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:GetObject&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;/*&amp;#34; ] } ] } 指定したバケットに対していろいろできるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:DeleteObject&amp;#34;, &amp;#34;s3:GetObject&amp;#34;, &amp;#34;s3:ListBucket&amp;#34;, &amp;#34;s3:PutObject&amp;#34;, &amp;#34;s3:PutObjectAcl&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;&amp;#34;, &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;/*&amp;#34; ] } ] } すべての S3 リソースに対して何でもできるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: &amp;#34;s3:*&amp;#34;, &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } S3 で静的 Web サイトをホストするときは、バケットポリシーで s3:GetObject アクションのみを指定すればよい。ListObject や PutObject アクセス許可しなくても OK。 （おまけ）CORS 設定（JSON 形式） Web サイトの JavaScript などから S3 バケットにアクセスする場合は、バケットの設定で CORS アクセスを有効にしておく必要があります。 設定は次のように JSON 形式で行います。</description></item><item><title>AWS Lambda にデプロイするための ZIP パッケージを npm で作成する (npm-pack-zip)</title><link>https://maku.blog/p/zmydq3f/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zmydq3f/</guid><description>何をするか？ AWS Lambda で実行する関数は、ZIP ファイルの形でデプロイすることになります。 ここでは、Node.js で関数を実装しているという前提で、npm スクリプトで簡単にデプロイ用の ZIP パッケージを作成する方法を説明します。
Lambda 関数用の ZIP パッケージを作成するときは、次のようなことを考慮する必要があります。
実行時に必要な node_modules 以下のモジュールを含める（逆に devDependencies で指定したモジュールは含めない。例えば typescript とか eslint とかは含めない） AWS SDK (aws-sdk) は含めない（Lambda の実行環境にインストールされている） TypeScript を使っているのであれば、ビルド後の .js ファイルのみを含める（例えば、src/*.ts は含めず、build/*.js を含める） ☝️ AWS Lambda レイヤー Lambda の「レイヤー」という機能を使うと、関数の実行に必要な node_modules を ZIP パッケージとは別に管理して、Lambda 関数から参照するということができます。 でも設定にひと手間かかります。AWS のこういうところは嫌いです。
ここでは、レイヤーの機能は使わずに、ZIP パッケージに全部入れちゃう方法を説明しています。
npm-pack-zip で ZIP ファイルを作成する npm-pack-zip とは ここでは、npm-pack-zip パッケージを使って、Lambda 関数のデプロイ用 ZIP パッケージを作ってみます。
npm-pack-zip - npm NPM には、もともと標準で npm pack というデプロイ用の NPM パッケージを作成する仕組みが搭載されています。 Lambda 用にもこれが使えると楽なのですが、残念ながら npm pack は .</description></item><item><title>AWS Lambda をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/n9nydjc/</link><pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9nydjc/</guid><description>Lambda 関数の一覧を取得する (lambda list-functions) $ aws lambda list-functions --max-items 10 関数名だけ取り出す $ aws lambda list-functions --max-items 10 --query &amp;#34;Functions[].FunctionName&amp;#34; Node.js 10 を使ってる関数の ARN を調べる $ aws lambda list-functions --function-version ALL --output text --query &amp;#34;Functions[?Runtime==&amp;#39;nodejs10.x&amp;#39;].FunctionArn AWS から来た「Node.js 10 のサポート切れるから乗り換えてね」というメール (2021-06-04) に書かれていたやり方です。
Lambda 関数の情報を取得する (lambda get-function) $ aws lambda get-function --function-name my-function 実行結果 { &amp;#34;Configuration&amp;#34;: { &amp;#34;FunctionName&amp;#34;: &amp;#34;my-function&amp;#34;, &amp;#34;FunctionArn&amp;#34;: &amp;#34;arn:aws:lambda:ap-northeast-1:123456789012:function:my-function&amp;#34;, &amp;#34;Runtime&amp;#34;: &amp;#34;nodejs12.x&amp;#34;, &amp;#34;Role&amp;#34;: &amp;#34;arn:aws:iam::123456789012:role/lambda-ex&amp;#34;, &amp;#34;CodeSha256&amp;#34;: &amp;#34;FpFMvUhayLkOoVBpNuNiIVML/tuGv2iJQ7t0yWVTU8c=&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;$LATEST&amp;#34;, &amp;#34;TracingConfig&amp;#34;: { &amp;#34;Mode&amp;#34;: &amp;#34;PassThrough&amp;#34; }, &amp;#34;RevisionId&amp;#34;: &amp;#34;88ebe1e1-bfdf-4dc3-84de-3017268fa1ff&amp;#34;, .</description></item><item><title>Windows のコマンドプロンプトで指定した秒数だけポーズする (timeout)</title><link>https://maku.blog/p/idmg7wm/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/idmg7wm/</guid><description>Windows 7 以降のコマンドプロンプトでは、指定した秒数だけ待機する timeout コマンドを使用できます。 ユーザーのキー入力を少しだけ待ったり、Linux の sleep コマンドと同様のことを行えます。
timeout コマンドの使用例 10 秒待つ（ユーザーのキー入力があるまで待つ） C:\&amp;gt; timeout /t 10 10 秒待っています。続行するには何かキーを押してください ... 10 秒待つ（問答無用で待つ） C:\&amp;gt; timeout /t 10 /nobreak 10 秒待っています。終了するには CTRL+C を押してください ... ユーザーのキー入力があるまでずっと待つ C:\&amp;gt; timeout /t -1 続行するには何かキーを押してください ... 最後のパターンは、昔からある pause コマンドの振る舞いと同じですね（出力の行末表現が微妙に異なりますけど ^^;）。
C:\&amp;gt; pause 続行するには何かキーを押してください . . . ちなみに、「続行するには何かキーを押してください」の表示を抑制したいときは、次のように &amp;gt; nul とリダイレクトします（null じゃなくて nul なので注意）。 これは、Linux の sleep 3 と同じ振る舞いになります。
何もメッセージ表示せずに 3 秒待機 C:\&amp;gt; timeout /t 3 /nobreak &amp;gt; nul （参考）timeout コマンドのヘルプ C:\&amp;gt; timeout /?</description></item><item><title>Windows のコマンドラインで ZIP ファイルを作成する (Compress-Archive)</title><link>https://maku.blog/p/vin35f7/</link><pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vin35f7/</guid><description>Windows のコマンドプロンプト（あるいは PowerShell）から zip ファイルを作成するには、PowerShell の Compress-Archive コマンド を使用します。 特に何もインストールしなくても実行できます。
指定したディレクトリを zip 圧縮する src ディレクトリを dst.zip にアーカイブ C:\&amp;gt; powershell compress-archive src dst 作成される zip ファイル dst.zip +-- src/ +-- file1 +-- file2 +-- file3 出力ファイル名 dst.zip の .zip は省略することができます。 dst.zip を展開すると、ルートに src ディレクトリが現れる状態になります。
ディレクトリ内のファイルのみを zip 圧縮する ルートディレクトリ（この例では src）を zip ファイルに含めずに、そのディレクトリ内のファイル群だけを zip ファイルにまとめたいときは、次のように src/* と指定します。
src ディレクトリの中身だけを dst.zip にアーカイブ C:\&amp;gt; powershell compress-archive src/* dst 作成される zip ファイル dst.zip +-- file1 +-- file2 +-- file3 複数のディレクトリやファイルを zip 圧縮する 圧縮対象のディレクトリやファイルを複数指定するには、次のようにカンマ (,) で列挙します。 カンマの前後にはスペースを入れないことに注意してください。</description></item><item><title>Android アプリのテンプレートコード（空っぽのフラグメント）</title><link>https://maku.blog/p/vdnv5dm/</link><pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vdnv5dm/</guid><description>Android のアプリを作るときは、大体まっさらな Activity + Fragment の組み合わせで作り始めるんですが、そのようなクリーンなテンプレートコード（土台）を作るのが意外と大変だったりするので、ここにメモしておきます。
図: 空っぽの Android アプリ 下記は、Android TV アプリ用のテンプレートです。
maku77/Template-AndroidTv: Template of Android TV App 主なコードを抜粋。
app/src/main/java/com/example/myapp/MainActivity.kt package com.example.myapp import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import androidx.fragment.app.commit // androidx.fragment:fragment-ktx class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) showMainFragment() } private fun showMainFragment() { supportFragmentManager.commit { add(R.id.fragment_container, MainFragment.newInstance()) //addToBackStack(null) // 戻るキー用にスタック } } } app/src/main/java/com/example/myapp/MainFragment.kt package com.example.myapp import androidx.fragment.app.Fragment class MainFragment : Fragment(R.layout.fragment_main) { companion object { fun newInstance() = MainFragment() } } app/src/main/AndroidManifest.</description></item><item><title>AWS のコスト情報をコマンドライン (CLI) で取得する</title><link>https://maku.blog/p/ct4ckt3/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ct4ckt3/</guid><description>aws ce get-cost-and-usage ... 次の例では、指定した期間の AWS 利用料金を求めています。
aws ce get-cost-and-usage \ --granularity MONTHLY \ --time-period Start=2021-01-01,End=2021-02-01 \ --metrics BlendedCost 実行結果 DimensionValueAttributes: [] ResultsByTime: - Estimated: false Groups: [] TimePeriod: End: &amp;#39;2021-02-01&amp;#39; Start: &amp;#39;2021-01-01&amp;#39; Total: BlendedCost: Amount: &amp;#39;0.0900932477&amp;#39; Unit: USD 次の例では、サービスごとに料金表示しています。
aws ce get-cost-and-usage \ --granularity MONTHLY \ --time-period Start=2021-01-01,End=2021-02-01 \ --metrics BlendedCost \ --group-by Type=DIMENSION,Key=SERVICE 実行結果 DimensionValueAttributes: [] GroupDefinitions: - Key: SERVICE Type: DIMENSION ResultsByTime: - Estimated: false Groups: - Keys: - AWS CloudShell Metrics: BlendedCost: Amount: &amp;#39;0.</description></item><item><title>DynamoDB Local で DynamoDB のローカルテスト環境を作る</title><link>https://maku.blog/p/rdq4eq2/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq4eq2/</guid><description>DynamoDB Local とは DynamoDB Local を使うと、Amazon DynamoDB サービスを模倣するローカルサーバーを立ち上げることができます。 DynamoDB Local サーバーは、デフォルトでは http://localhost:8000 で起動し、ここに対して AWS CLI や AWS SDK で接続して操作します。
DynamoDB ウェブサービスで複雑なデータ処理を行うときは、あらかじめ DynamoDB Local を使ってテストを行っておくと安心です。 DynamoDB の操作のために試行錯誤しても AWS の利用料金がかかることはありません。
DynamoDB Local のインストール 実行ファイルのダウンロード DynamoDB Local には、Java の実行ファイル (JAR) や、それを含む Docker コンテナとして提供されています。 Java のインストールされた環境では、JAR ファイルをダウンロードして起動するのが手っ取り早いです。 下記から ZIP ファイルでダウンロードできます。
DynamoDB Local のダウンロード ダウンロードした ZIP ファイルを展開すると、次のような構成のディレクトリが展開されます。
アーカイブの内容 dynamodb_local_latest/ +-- DynamoDBLocal_lib/ ... 本体が使う依存ライブラリ +-- DynamoDBLocal.jar ... 本体 +-- その他のドキュメント 起動に必要なのは、DynamoDBLocal_lib ディレクトリと DynamoDBLocal.jar だけなので、この 2 つを任意のディレクトリにコピーします。 ここでは、次のようなディレクトリにコピーすることにします（Windows であれば、$HOME は %USERPROFILE% に置き換えてください）。</description></item><item><title>Linuxコマンド: date コマンドの使い方</title><link>https://maku.blog/p/ucnv5ck/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ucnv5ck/</guid><description>Linux や macOS に搭載されている date コマンドの使い方のメモです。
日時をフォーマットして出力する $ date +&amp;#39;%Y-%m-%d&amp;#39; 2021-02-23 $ date +&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39; 2021-02-23 01:08:51 Linux と macOS の date コマンドの違い Linux と macOS では、標準でインストールされている date コマンドが次のように異なります。
Linux &amp;hellip; GUN/Linux 系の date コマンド macOS &amp;hellip; BSD 系の date コマンド そのため、-d オプションと -v オプションの使い方に次のような違いがあります。
1 カ月前の日付を調べる $ date -d &amp;#39;-1 month&amp;#39; # GNU/Linux $ date -d &amp;#39;1 month ago&amp;#39; # GNU/Linux $ date -v-1m # macOS 1 日前の日付を調べる $ date -d &amp;#39;-1 day&amp;#39; # GNU/Linux $ date -v-1d # macOS</description></item><item><title>Amazon EC2 をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkx9ju6/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkx9ju6/</guid><description>EC2 で使用可能なリージョンの一覧を取得する (ec2 describe-regions) $ aws ec2 describe-regions 実行結果 (YAML形式） Regions: - Endpoint: ec2.eu-north-1.amazonaws.com OptInStatus: opt-in-not-required RegionName: eu-north-1 - Endpoint: ec2.ap-south-1.amazonaws.com OptInStatus: opt-in-not-required RegionName: ap-south-1 - Endpoint: ec2.eu-west-3.amazonaws.com OptInStatus: opt-in-not-required RegionName: eu-west-3 - Endpoint: ec2.eu-west-2.amazonaws.com OptInStatus: opt-in-not-required RegionName: eu-west-2 - Endpoint: ec2.eu-west-1.amazonaws.com OptInStatus: opt-in-not-required RegionName: eu-west-1 - Endpoint: ec2.ap-northeast-3.amazonaws.com OptInStatus: opt-in-not-required RegionName: ap-northeast-3 - Endpoint: ec2.ap-northeast-2.amazonaws.com OptInStatus: opt-in-not-required RegionName: ap-northeast-2 - Endpoint: ec2.ap-northeast-1.amazonaws.com OptInStatus: opt-in-not-required RegionName: ap-northeast-1 - Endpoint: ec2.</description></item><item><title>AWS CodeBuild をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/bwamw8i/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bwamw8i/</guid><description>CodeBuild プロジェクトの一覧を取得する (codebuild list-projects) $ aws codebuild list-projects 例: すべてのプロジェクト名を取得 $ aws codebuild list-projects projects: - app1-codebuild - app2-codebuild - app3-codebuild 出力結果をソートするには、次のオプションが使用できます。
sort-by &amp;hellip; NAME / CREATED_TIME / LAST_MODIFIED_TIME のいずれかを指定 sort-order .. ASCENDING / DESCENDING のいずれかを指定 例: 最近作られたプロジェクトを 5 件表示 $ aws codebuild list-projects --sort-by CREATED_TIME --sort-order DESCENDING --max-items 5 実行結果 NextToken: eyJuZXh0VG9rZW4iOiBudWxsLCAiYm90b190cnVuY2F0ZV9hbW91bnQiOiA1fQ== projects: - myapp25-codebuild - myapp24-codebuild - myapp23-codebuild - myapp22-codebuild - myapp21-codebuild NextToken は、続きのエントリを取得したいときに、--starting-token オプションで指定します。
☝️ 出力形式 (YAML or JSON) を変えたいとき AWS CLI の出力形式は、デフォルトでは ~/.</description></item><item><title>DynamoDB をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkzamw8/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkzamw8/</guid><description>テーブルを作成する (dynamodb create-table) aws dynamodb create-table --table-name &amp;lt;テーブル名&amp;gt; ... DynamoDB のテーブルを作成するときは、少なくともプライマリキーの設定や、課金モードの設定が必要になるので、少しだけコマンドが長くなります。
次の例では、DynamoDB に MusicCollection というテーブルを作成します。 Artist というパーティションキー (KeyType=HASH) と、Artist というソートキー (KeyType=RANGE) を定義しています。 課金体系は「プロビジョンドモード」で最小構成になるよう設定しています。
テーブル生成 (PartitionKey &amp;#43; SortKey) $ aws dynamodb create-table \ --table-name MusicCollection \ --attribute-definitions AttributeName=Artist,AttributeType=S AttributeName=SongTitle,AttributeType=S \ --key-schema AttributeName=Artist,KeyType=HASH AttributeName=SongTitle,KeyType=RANGE \ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 パーティションキーのみで良い場合（ソートキーなし）は、次のような感じになります。
テーブル生成 (PartitionKey) $ aws dynamodb create-table \ --table-name MusicCollection \ --attribute-definitions AttributeName=Artist,AttributeType=S \ --key-schema AttributeName=Artist,KeyType=HASH \ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 キャパシティモード（課金体系）をオンデマンド（本当にアクセスした分だけの支払い）にするには、--billing-mode PAY_PER_REQUEST オプションを指定し、プロビジョン設定 (--provisioned-throughput) を省略します。 一定間隔でそれなりにアクセスがある場合は、プロビジョンドモード (PROVISIONED) にして常時稼働の形にしておいた方が総合的に安くなるようですが、テスト用途で作成する場合などは PAY_PER_REQUEST にしておくのが無難かと思います。</description></item><item><title>AWS IAM の設定をコマンドライン (CLI) で行う</title><link>https://maku.blog/p/aov4bho/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aov4bho/</guid><description>AWS CLI（aws コマンド）を使うと、様々な IAM 系の操作をコマンドラインから実行できるようになります。 ただし、IAM の制御を行えるのは、AdministratorAccess ポリシーなどが割り当てられ、IAM 操作の権限が付いているユーザーに限られます。
iam &amp;ndash; AWS CLI Command Reference ユーザー関連 IAM ユーザーを作成する (iam create-user) aws iam create-user --user-name &amp;lt;ユーザー名&amp;gt; 実行例 $ aws iam create-user --user-name user-1 --output yaml User: Arn: arn:aws:iam::049957049344:user/user-1 CreateDate: &amp;#39;2021-11-01T08:41:29+00:00&amp;#39; Path: / UserId: AIDAQXINMCQAPJRMFE22H UserName: user-1 iam create-user コマンドを使うと、指定した名前の IAM ユーザーを作成できます。 作成したユーザーの情報は、iam get-user や iam list-users コマンドで取得できます。 作成したユーザー用の API アクセスキーを生成するには、ひきつづき iam create-access-key コマンドを使用します。
IAM ユーザーを削除する (iam delete-user) aws iam delete-user --user-name &amp;lt;ユーザー名&amp;gt; 指定したユーザーに何らかの設定情報（アクセスキーや SSH キー、MFA など）が設定されている場合は、先にそれらの情報を削除しておく必要があります。 例えば、アクセスキーが設定されている場合は、delete-access-key コマンドで削除してからユーザー自体を削除します。</description></item><item><title>AWS アカウント、IAM ユーザー、グループ、ポリシーの違い</title><link>https://maku.blog/p/4c7sdwg/</link><pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4c7sdwg/</guid><description> AWS を使う上で最初に理解しておくべき、「アカウント」と「ユーザー」まわりの概念についてまとめておきます。
簡単なイメージとしてはこんな感じ。 AWS アカウント &amp;hellip; 組織およびルートユーザーのこと。通称アカウント。 IAM ユーザー &amp;hellip; 組織内の個別ユーザー。通称ユーザー。 ちなみに、IAM は Identity and Access Management の略。
AWS アカウント（のルートユーザー） AWS サインアップ時に作られる、組織で 1 つだけ用意されるルートユーザーです。 AWS アカウントの ID は管理者のメールアドレスです。 AWS アカウントは、契約／支払い設定などを含むフルアクセス権限があるので、通常の業務ではこのアカウントは使わず、IAM ユーザーを使います。 IAM ユーザー AWS アカウントから作成されるユーザーで、通常の業務ではこの IAM ユーザーを使います。Linux の一般ユーザーのようなものです。 1 つの AWS アカウントから複数の IAM ユーザーを作成することができます。 IAM ユーザーに IAM ポリシーを割り当てることで、各種リソースへのアクセスが許可されます。IAM ユーザー作成直後は、何もアクセス権限がありません。ちなみに、IAM ポリシーは JSON 形式で記述されます。 IAM グループ 複数の IAM ユーザーをグルーピングするためのものです。 IAM グループに対しても IAM ポリシーを割り当てることができ、複数の IAM ユーザーにまとめて権限設定することができます。 IAM ロール 特定の AWS サービス、IAM ユーザー、IAM グループに一時的に権限を与えるために使われます。例えば、EC2 インスタンスへのアクセス権割り当てなどに使われます。 IAM ロールがどのような権限を表現するかは、IAM ロール自体に IAM ポリシーを割り当てることで制御します。 協力会社のメンバーに自社リソースの権限を与えたいときに、協力会社側で使っている IAM ユーザーに対して、自社で作成した IAM ロールを割り当てる、という使い方ができます。→ 参考: IAM ユーザーにアクセス権限を委任するロールの作成</description></item><item><title>AWS CodeBuild で Hello World（GitHub との連携）</title><link>https://maku.blog/p/xdnu3ah/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xdnu3ah/</guid><description>何をやるか？ CodeBuild は AWS が提供するビルドサービスです。 例えば、GitHub に buildspec.yml というビルド方法を記述したファイルを置いておくと、GitHub へのコードプッシュ時に、その設定通りビルドを行ってくれます。 GitHub Actions や Azure Pipelines といったサービスと同様です。
ここでは、CodeBuild 導入の第一歩として、次のような構成でセットアップしてみます。
ソースプロバイダ : GitHub（の適当なテストリポジトリ） ビルド内容 : &amp;ldquo;Hello World&amp;rdquo; と echo 表示する つまり、テスト用の GitHub リポジトリに何らかのファイルをプッシュしたときに、CodeBuild によるビルドを開始するところまでです。
ソースプロバイダとしては、GitHub だけではなく、AWS CodeCommit、Bitbucket、GitHub Enterpise といった Git リポジトリを選択できますが、おそらく GitHub が一番よく使われているので、ここでは GitHub を使うことにします。
最初の一歩はできるだけ簡単に済ませることが肝心です！
アカウントとリポジトリを準備する まず最低限の準備として、下記のアカウントは用意できているとします。
AWS アカウント GitHub アカウント 次に、GitHub にテスト用の リポジトリを作成 しておきます。 ここでは、リポジトリ名は hello-codebuild とでもしておきます。 README.md を自動生成しておくと、後のテストが楽です。
CodeBuild にビルドプロジェクトを作成する 次のようにして、CodeBuild に新規ビルドプロジェクトを作成します。
AWS CodeBuild console を開きます。 ビルド (CodeBuild) → ビルドプロジェクト → ビルドプロジェクトを作成する と選択します。 以下のような内容を入力してビルドプロジェクトを作成します。 プロジェクト名 : build-hello（名前は自由） ソースプロバイダ : GitHub → 作成しておいた hello-codebuild リポジトリを指定 ウェブフック : コードの変更がこのレポジトリにプッシュされるたびに再構築する にチェックを入れる（これで GitHub へのプッシュ時にビルドトリガがかかります） 環境イメージ : マネージド型イメージ → Amazon Linux 2 → ランタイムやイメージは適当に選択 サービスロール : 新しいサービスロール → codebuild-build-hello-service-role（デフォルト） ビルド仕様 : buildspec ファイルを使用する 以下のような感じでビルドプロジェクトが作成されれば成功です。</description></item><item><title>AWS のサービス一覧（2021年版）</title><link>https://maku.blog/p/t8fmsz5/</link><pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t8fmsz5/</guid><description>AWS のサービスを概要説明付きでリスト化したものが欲しくて作っちゃったので置いておきます。 PDF 化したもの も置いておきます。
分析 (Analytics) Amazon Athena SQL を使用した S3 でのデータクエリ Amazon CloudSearch マネージド型検索サービス Amazon Elasticsearch Service Elasticsearch クラスターを実行し、スケールする Amazon EMR ホスト型 Hadoop フレームワーク Amazon Kinesis リアルタイムストリーミングデータとの連携 Amazon Managed Streaming for Apache Kafka フルマネージド型 Apache Kafka サービス Amazon Redshift 高速かつシンプルで、費用対効果の高いデータウェアハウス Amazon QuickSight 高速ビジネス分析サービス AWS Data Exchange クラウド内サードパーティのデータを検索、購読、および使用 AWS Data Pipeline 定期的なデータ駆動型ワークフローに対するオーケストレーションサービス AWS Glue シンプルでスケーラブルなサーバーレスデータ統合 AWS Lake Formation 安全なデータレイクを数日で構築 Application Integration（アプリケーション統合） AWS Step Functions 分散アプリケーションの調整 Amazon AppFlow SaaS アプリケーションと AWS のサービス向けのコード統合が不要 Amazon EventBridge SaaS アプリと AWS のサービス向けサーバーレスイベントバス Amazon Managed Workflows for Apache Airflow 可用性に優れたセキュアなマネージドワークフローオーケストレーション Amazon MQ マネージド型メッセージブローカーサービス Amazon Simple Notification Service (SNS) Pub/sub、SMS、E メール、およびモバイルプッシュ通知 Amazon Simple Queue Service (SQS) マネージド型メッセージキュー Amazon AppSync 多くのソースから適切なデータを使用して、大規模にアプリを強化 AWS Cost Management（AWS コスト管理） AWS Cost Explorer AWS のコストと使用状況を分析する AWS 予算 カスタムコストと使用予算を設定する AWS のコストと使用状況レポート 包括的なコストと使用状況情報へのアクセス リザーブドインスタンスレポート リザーブドインスタンス (RI) の詳細を把握する Savings Plans 柔軟な料金設定でコンピューティング使用コストを最大 72% 節約 Blockchain （ブロックチェーン） Amazon Managed Blockchain スケーラブルなブロックチェーンネットワークを作成および管理 Amazon Quantum Ledger Database (QLDB) フルマネージド型台帳データベース Business Application（ビジネスアプリケーション） Alexa for Business Alexa を使って組織を強化 Amazon Chime フラストレーションフリーの会議、ビデオ電話、チャット Amazon Honeycode (ベータ) プログラミングなしでモバイルおよびウェブアプリケーションを構築 Amazon WorkDocs エンタープライズドキュメントの安全なストレージと共有 Amazon WorkMail セキュリティで保護されたマネージド型の企業向け E メールおよびカレンダー Compute（コンピューティング） Amazon EC2 クラウド内の仮想サーバー Amazon EC2 Auto Scaling 需要に合わせてコンピューティング性能をスケール Amazon Lightsail 仮想プライベートサーバーを起動および管理 AWS Batch あらゆる規模でバッチジョブを実行 AWS Elastic Beanstalk ウェブアプリの実行と管理 AWS Lambda イベント発生時にコードを実行 AWS Outposts AWS サービスをオンプレミスで実行 AWS Serverless Application Repository サーバーレスアプリケーションを検索、デプロイ、公開する AWS Snow ファミリー エッジロケーションでデータを集約および処理して AWS に転送するデバイス AWS Wavelength 5G デバイスのための超低レイテンシーアプリケーションを提供 VMware Cloud on AWS カスタムハードウェアを使用せずにハイブリッドクラウドを構築する Containers（コンテナ） Amazon Elastic Container Registry コンテナイメージを簡単に保存、管理、デプロイ Amazon Elastic Container Service (ECS) コンテナを実行するためのきわめて安全で信頼性と拡張性が高い方法 Amazon ECS Anywhere (近日公開) インフラストラクチャでの ECS Amazon Elastic Kubernetes Service (EKS) 信頼性が最も高い Kubernetes の実行方法 Amazon EKS Anywhere (近日公開) インフラストラクチャでの Kubernetes Amazon EKS Distro 一貫した Kubernetes クラスターの実行 AWS App2Container 既存のアプリケーションのコンテナ化と移行 AWS Fargate コンテナ向けサーバーレスコンピューティング AWS での Red Hat OpenShift マネージド Red Hat OpenShift クラスター Customer Engagement（カスタマーエンゲージメント） Amazon Connect クラウドベースのコンタクトセンター Amazon Pinpoint チャンネル間でのパーソナライズされたユーザーエンゲージメント Amazon Simple Email Service (SES) E メールの送受信 Database（データベース） Amazon Aurora 高性能マネージドリレーショナルデータベース Amazon Aurora Serverless v2 (プレビュー) 毎秒 100,000 件を超えるトランザクションに瞬時にスケール Amazon DynamoDB マネージド型の NoSQL データベース Amazon DocumentDB (MongoDB 互換) フルマネージド型ドキュメントデータベース Amazon ElastiCache インメモリキャッシングシステム Amazon Keyspaces (Apache Cassandra 用) マネージド型の Cassandra 対応データベース Amazon Neptune フルマネージド型グラフデータベースサービス Amazon Quantum Ledger Database (QLDB) フルマネージド型台帳データベース Amazon RDS MySQL、PostgreSQL、Oracle、SQL Server、MariaDB 向けのマネージドリレーショナルデータベースサービス Amazon RDS on VMware オンプレミスデータベースの管理を自動化 Amazon Redshift 高速、シンプル、費用対効果の高いデータウェアハウジング Amazon Timestream フルマネージド型の時系列データベース AWS Database Migration Service 最小限のダウンタイムでデータベースを移行 AWS Glue シンプルでスケーラブルなサーバーレスデータ統合 Developer Tools（デベロッパーツール） Amazon CodeGuru 最もコストがかかるコード行を見つける Amazon Corretto 本番環境に向けて OpenJDK を配信 AWS Cloud Development Kit (CDK) コードを使用してクラウドインフラストラクチャをモデル化する AWS Cloud9 Cloud IDE でコードを記述、実行、デバッグ AWS CloudShell ブラウザベースのシェル環境 AWS CodeArtifact ソフトウェア開発のためのセキュアかつスケーラブルでコスト効率性に優れたアーティファクト管理 AWS CodeBuild コードのビルドとテスト AWS CodeCommit プライベート Git リポジトリでのコードの保存 AWS CodeDeploy コードデプロイの自動化 AWS CodePipeline 継続的デリバリーを使用したソフトウェアのリリース AWS CodeStar AWS アプリケーションの開発とデプロイ AWS コマンドラインインターフェイス AWS サービスを管理するための統合ツール AWS Device Farm AWS クラウド内の実際のデバイスを使った Android、iOS、ウェブアプリケーションのテスト AWS Fault Injection Simulator 完全マネージド型のカオスエンジニアリングサービス AWS ツールと SDK AWS のためのツールと SDK AWS X-Ray アプリケーションの分析とデバッグ End User Computing（エンドユーザーコンピューティング） Amazon AppStream 2.</description></item><item><title>GraphQL クエリ仕様: フラグメント (Fragments) とインラインフラグメント (Inline Fragments)</title><link>https://maku.blog/p/wiv7it5/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wiv7it5/</guid><description>GraphQL フラグメントでクエリをパーツ化する フラグメントの基本 GraphQL クエリの中で、同じようなフィールドの指定（選択セット）を複数回使用する場合、それを フラグメント (Fragments) という再利用可能な選択セットとして切り出して定義しておくことができます。
例えば次の GraphQL クエリは、GitHub から自分のユーザー情報 (viewer) と、特定のユーザーの情報 (user) を一度に取得しています。
GraphQL クエリ query QueryTwoUsers { viewer { login # ログインID name # ユーザー名 url # ユーザーの GitHub ホームページ websiteUrl # ユーザーの Web サイト avatarUrl # ユーザーのアバター画像 } user(login: &amp;#34;ログインID&amp;#34;) { login name url websiteUrl avatarUrl } } viewer フィールドと user フィールドは、両方とも User 型 のフィールドで、しかも、上記の例では User オブジェクトの中の同じフィールドを参照しています。 明らかに冗長な書き方です。
このようなケースでは、あるオブジェクトの特定のフィールドを参照するための選択セット (selection set) を、フラグメントの形で定義することができます。 次の例では、User オブジェクトの特定のフィールドを選択するための userFragment というフラグメントを定義し、クエリ内で参照しています。</description></item><item><title>Apollo Client の useQuery 呼び出し部分をカスタムフックで分離する</title><link>https://maku.blog/p/kmj7sdv/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kmj7sdv/</guid><description>Apollo Client で GraphQL クエリを実行するときは、カスタムフックとして useQuery 関数の呼び出し部分を抽出すると、コンポーネント側のコードをシンプルにすることができます。
分離前のコード 次のサンプルコードでは、GraphQL クエリで GitHub のログインユーザー情報を取得して表示する Viewer コンポーネントを実装しています。 GraphQL のクエリ呼び出し部分や、取得したデータを ViewerData オブジェクトに詰める部分などが混在しており、あまり整理されているとは言えません。
components/Viewer.tsx import { FC } from &amp;#39;react&amp;#39; import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; import { LoadingComponent } from &amp;#39;./LoadingComponent&amp;#39; import styles from &amp;#39;./Viewer.scss&amp;#39; const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` type ViewerData = { /** ログインID */ login: string /** ホームページのURL */ url: string /** アバター画像のURL */ avatarUrl: string } /** 「ユーザー情報」を表示するコンポーネント */ export const Viewer: FC = () =&amp;gt; { const {loading, error, data} = useQuery(QUERY_VIEWER) if (loading) return &amp;lt;LoadingComponent /&amp;gt; const viewer: ViewerData = data.</description></item><item><title>読書メモ『しんがり 山一證券最後の12人』清武英利</title><link>https://maku.blog/p/wbipw4a/</link><pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wbipw4a/</guid><description>しんがり 山一證券最後の12人 清武英利 講談社 山一證券破綻の真相究明を行った「しんがり」と呼ばれる社員たちの物語。
この小説がすごいのは、ノンフィクション ということです。 著者の清武氏は記者（ジャーナリスト）であって、決して山一證券の関係者ではないのですが、あたかも社員たちと一緒にそこにいたかのようなリアルさで描かれています。 ノンフィクション賞を取るのもうなずけます。 しんがりの社員たちは破綻の真相究明のために、たくさんの社員にインタビューを行うのですが、著者のインタビュー力も半端ないですね。
最後まで会社に残った社員たちは、給料もろくにもらえない中で使命感だけで清算処理を続けるのですが、もし自分が同じような立場に立ったら、きっと逃げ出しちゃいますね。。。 ほとんどの人がそうだと思います。 でも、この本を読めば、そんな状況で最後まで頑張り抜いた先に何が待っているのかを少しだけ味わうことができます。 何か熱いものがこみ上げてきます。</description></item><item><title>ドラクエ9で終了したはずのWiFiサービスの配信クエストを受け取る</title><link>https://maku.blog/p/t8gpx6e/</link><pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t8gpx6e/</guid><description>図: DQ9 の配信クエストの受け取りできた！ 今さらですが、ニンテンドーDSのドラクエ9を楽しんでます。 こんな面白いゲームがブックオフで 200 円で買えるとはいい時代です。 ただ、エンディング後のやり込み（というかここからが本番？）をするには、ニンテンドー Wi-Fi コネクションによる配信クエストの受け取りが必要ということを知りました（エンディング迎えた後に気づいた）。
残念ながら、Wi-fi コネクションサービスは 2014 年に終了しており、配信クエストはもうあきらめていたのですが、なんと有志で立てられたサーバーに接続して受け取れることがわかりました。神か！
無線 LAN ルーターの設定で、WEP 接続できるようにしておく セキュリティ的に WEP は問題があるけど、Nintend DS は WEP 接続しか対応してない。。なので、ルーター側で MAC アドレス制限としかして繋ぐようにする。 DQ9 を起動して「Wi-Fi せっていをする」を選択。接続テストで、「エラーコード:20110 このソフトのWi-Fiコネクションサービスは終了しました。ご利用ありがとうございました。」が表示されることを確認。 「DNS自動取得」の設定を しない に変更し、プライマリDNSに 178.62.43.212、セカンダリDNSに 8.8.8.8 を設定。ちなみに、プライマリ DNS はいくつか候補があるみたい。 127.104.88.237 164.132.44.106 178.62.43.212 再び接続テストして、成功すれば OK。 あとは、セントシュタイン上のリッカの宿屋の右側にいる女性に話しかければ、すべての「配信クエスト」の受け取り、「スペシャルゲスト」、「Wi-Fiショッピング」などを行えます。
やったー！これでしばらく DQ9 楽しめる ٩(๑❛ᴗ❛๑)۶ わーぃ
図: リッカの宿屋へのスペシャルゲストもまだ来ます ちなみに、最近立て続けに DQ7、DQ8 とクリアしてきてます。 シリーズ物は順番にクリアしていきたい人なので。。。 昔のドラクエは今やってもすごくおもしろいです。
過去のドラクエの特徴まとめておこう。
DQ1 (FC) 1人旅。ロトシリーズの元祖。スマホでできる。1日でクリアできるけど十分楽しめる。 DQ2 (FC) 3人旅。復活の呪文が長くてみんな苦しめられた。 DQ3 (FC) 4人旅。ルイーダの酒場で自由にキャラ作成＆転職システムで仲間の組み合わせが楽しい。 DQ4 (FC) 8人旅。5章構成。転職ができないことで、キャラの個性が引き立った。各章の音楽が特徴的でいい。 DQ5 (SFC) 嫁にビアンカとフローラのどちらかを選ぶ旅。転職なしのストーリー重視。 DQ6 (SFC) 祝！転職システム復活。全体的にはおつかいゲーム感が強い。ハッサンが個性的すぎて、ハッサンの記憶しかない。あとバーバラとムチ。 DQ7 (PS1) 石版探しの旅。転職の職業がありすぎて大変。石版探しがストーリーを進める上で必須だけど、結構分かりにくい所にあったりして、攻略サイトないときつい。DQには珍しく、バッドエンド的な鬱なストーリーが多い。 DQ8 (PS2) 最初の街で3D酔いする。楽しいのか面倒なのか分からない錬金システム導入。キャラクターごとに個性のあるスキルシステムが導入された。スキルに割り振れるポイント数は Lv.</description></item><item><title>EditorConfig でコーディングスタイルを統一する</title><link>https://maku.blog/p/7aoa6x5/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7aoa6x5/</guid><description>EditorConfig とは EditorConfig（.editorconfig ファイル）を導入すると、各種エディタ（Visual Studio、Android Studio、Vim など）に共通のコーディングスタイルを設定することができます。
ソフトウェア開発プロジェクトでは、通常なんらかのコーディングルールが決められています。 ただ、開発者ごとに使用するエディタ、IDE が異なると、設定方法を統一できないという問題が発生します。 EditorConfig は、特定のエディタに依存しない、コーディングスタイルを記述するためのフォーマット（およびツール群） です。
EditorConfig で設定可能な項目は、エンコーディング形式や改行コード、インデントサイズといったごく基本的な項目のみですが、最低限の記述スタイルをプロジェクト全体で素早く統一することができます。
EditorConfig の導入（.editorconfig ファイルの作成） EditorConfig の導入はとても簡単で、次のような設定ファイル (.editorconfig) をプロジェクトのルートに作成するだけです。
.editorconfig # ここが最上位の設定ファイル root = true # 全種類のテキストファイルの基本設定 [*] charset = utf-8 end_of_line = lf indent_size = 4 indent_style = space insert_final_newline = true trim_trailing_whitespace = true # あとは、ファイルの種類ごとに設定を上書き [*.{js,jsx,ts,tsx}] indent_size = 2 max_line_length = 80 [*.{kt,kts}] max_line_length = 100 [*.md] trim_trailing_whitespace = false [*.py] max_line_length = 80 [*.</description></item><item><title>JavaScript で任意のテキストをクリップボードにコピーする</title><link>https://maku.blog/p/buk5i2o/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/buk5i2o/</guid><description>copyToClipboard 関数 次の copyToClipboard 関数を使うと、引数で指定したテキストを OS のクリップボードにコピーすることができます。
function copyToClipboard(text){ // テキストコピー用の一時要素を作成 const pre = document.createElement(&amp;#39;pre&amp;#39;); // テキストを選択可能にしてテキストセット pre.style.webkitUserSelect = &amp;#39;auto&amp;#39;; pre.style.userSelect = &amp;#39;auto&amp;#39;; pre.textContent = text; // 要素を追加、選択してクリップボードにコピー document.body.appendChild(pre); document.getSelection().selectAllChildren(pre); const result = document.execCommand(&amp;#39;copy&amp;#39;); // 要素を削除 document.body.removeChild(pre); return result; } JavaScript からクリップボードにテキストをコピーするときは、任意の HTML 要素のテキストを選択して、document.execCommand('copy') を実行するという流れになります。 そのため、上記の関数では、テキスト選択用の一時的な pre 要素を作成しています。
使用例 例えば次のようにすると、ボタンを押したときにクリップボードにテキストをコピーできます。
クリップボードにコピー ← 実際に動作します
sample.html &amp;lt;button id=&amp;#34;copy&amp;#34;&amp;gt;クリップボードにコピー&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; window.addEventListener(&amp;#39;DOMContentLoaded&amp;#39;, () =&amp;gt; { document.getElementById(&amp;#39;copy&amp;#39;).addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; { copyToClipboard(&amp;#39;こんにちは！\nテキストがコピーされたよ！&amp;#39;); }); }); &amp;lt;/script&amp;gt;</description></item><item><title>Apollo Client でクリック時に GraphQL クエリを実行する</title><link>https://maku.blog/p/m7ju6gr/</link><pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7ju6gr/</guid><description>図: useLazyQuery による GraphQL クエリ実行 はじめに Apollo Client の useQuery フックを使用すると、GraphQL を使って取得した情報を表示する React コンポーネントをシンプルに実装することができます。 useQuery フックによる GraphQL クエリは、React コンポーネントの表示時に実行されますが、代わりに useLazyQuery フックを使用すると、任意のタイミング、例えばボタンを押した時に GraphQL クエリを実行できるようになります。
前提として、Apollo Client の useQuery の基本的な使い方は下記の記事などで理解しているものとし、ここでは、useLazyQuery フックの使い方を説明します。
参考: Apollo Client で GitHub GraphQL API を使う (Node &amp;amp; React)&amp;quot; useQuery と useLazyQuery の違い 下記の抜粋コードは、useQuery 関数と useLazyQuery 関数の使い方の違いを表しています。
// const GET_ISSUES = gql`...`; const {loading, error, data} = useQuery(GET_ISSUES); const [getIssues, {loading, error, data}] = useLazyQuery(GET_ISSUES); useQuery 関数は呼び出し直後に GraphQL クエリが実行され、その状態や結果が直ちに loading、error、data といった戻り値に格納されます。 一方 useLazyQuery 関数の場合は、戻り値の最初の要素として、クエリ実行関数が返されます（上記の例では getIssues にしてるけど、変数名は executeQuery とか何でも OK）。 GraphQL クエリを実行するには、このクエリ実行関数を呼び出す必要があるので、例えば次のようにボタン要素の onClick で呼び出すようにしておきます。 あとは、useQuery 関数の使い方と同様です。</description></item><item><title>読書メモ『若ゲのいたり ゲームクリエイターの青春』田中圭一</title><link>https://maku.blog/p/dt5dmu3/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dt5dmu3/</guid><description>若ゲのいたり ゲームクリエイターの青春 田中圭一 KADOKAWA ゲームクリエイターたちへのインタビューを漫画にしたものです。 こういったゲーム系のインタビュー本って、なるほどーって話が多いので好きです。
女の子を育てるのは犯罪性が感じられるので、舞台をファンタジーの世界にした
─ 赤井孝美（プリンセスメーカーの作者）
ゲームの面白さの本質は「リスクを冒してリターンを得る」ということ
─ 桜井政博（大乱闘スマッシュブラザーズの作者）
ぷよぷよでカーバンクルが踊るのは、プレイヤーのためでなく、背後のギャラリーを惹きつけるため
─ 仁井谷正充（ぷよぷよの作者）
インタビュー本を読むと、紹介されている人たちに興味が出てきて、その人について調べたくなることがよくあります。 今回も本を読んでから、仁井谷さん（ぷよぷよ作ってのちに破産した人）の動向が気になって、Youtube のピョコタンチャンネルを見てしまいました。
仁井谷さんは、70歳で1人でコンパイル◯（まる）という会社を運営して、ゲームをずっと開発し続けてます。 たくさんの人が楽しめるゲームを作りたい、という情熱が伝わってきます。 ずっと情熱を持ち続けているから元気に見えるんでしょうね。
関係ないけど、ピョコタンって誰かに似てると思ったら、ヨーロッパ企画の本田力さんに似てる。。。
あと誰か、伝説のゲーム・プログラマー、ナーシャ・ジベリ氏の本を出してくれないかなぁ。今は行方が分からないらしいですけど。</description></item><item><title>読書メモ『しあわせの書』泡坂妻夫</title><link>https://maku.blog/p/8nw6dks/</link><pubDate>Sat, 17 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8nw6dks/</guid><description>しあわせの書 泡坂妻夫 新潮社 マジシャンの肩書きも持つ泡坂妻夫氏のミステリー小説です。 読み終わったときに、この本が持つ秘密に衝撃を受けます。 本の冒頭に、
読者の幸せのために
未読の人に「しあわせの書」の秘密を明かさないでください
とあるように、ここでその秘密を明かすことはできないのですが、この本には作者の巧妙なたくらみが隠されています。 話の大筋としては、ヨギ ガンジーら、3人の男女が怪しい宗教団体に紛れ込む話なのですが、その中でキーになってくるのが、読心術と『しあわせの書』です。 この本のタイトルと同じです。
Kindle や Sony Reader などの電子書籍でこの本を探しても見つかりません。 なぜなら、この物語に出てくる『しあわせの書』と同様に、この本は「文庫本」という形でしか成立しないからです。
あなたもこの本を読み通す頃には、「読心術」を身につけていることでしょう。</description></item><item><title>Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す</title><link>https://maku.blog/p/cu6eox7/</link><pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cu6eox7/</guid><description>Apollo Client の Pagination 機能 GraphQL API では柔軟なクエリ発行が可能ですが、多数の要素を取得する場合は、Pagenation 処理 により何度かに分けて API 呼び出しを行う必要があります。 例えば、GitHub の GraphQL API では一度のクエリで取得可能な要素数は 100 件までであり、それを超える情報を取得する場合に Pagination 処理が必要です。
Apollo Client には、GraphQL の Pagination 処理を簡単に扱うための仕組み（fetchMore 関数）が用意されています。
参考: Pagination - Client (React) - Apollo GraphQL Docs と言っても、そこまで簡単ではないので、ここでは GitHub の GraphQL API における Pagination 処理の具体的な実装例を紹介します。
Pagination の実装例（フィールドポリシーを使う方法） 次のサンプルコードは、GitHub の myorg/myrepo リポジトリの Issue リストを表示する IssueList コンポーネントの実装例です。 Issue の数が 100 件を超える場合は、「さらに読み込む」ボタンを表示し、このボタンが押されたときに Pagination 処理（fetchMore 関数）で次のデータを取得するようにしています。
Apollo クライアントの useQuery 関数が返す fetchMore 関数を呼び出すと、再度 GraphQL クエリを実行することができます。 このとき、オプションで variables パラメータの値（クエリ変数）を変更できるので、Issue の読み出し開始位置を示す after の値を進めていくことで、100 件を超えるデータを順番に読み出すことができます。</description></item><item><title>JUnit のテストケースを一時的に無効にする（@Ignore/@Disabledアノテーション）</title><link>https://maku.blog/p/ow3zskd/</link><pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ow3zskd/</guid><description>JUnit で特定のテストケース（クラスや関数）を一時的に無効にしておきたい場合は、次のようなアノテーションをクラスや関数に付けます。
JUnit4 の場合: @Ignore アノテーション (org.junit.Ignore) JUnit5 の場合: @Disabled アノテーション (org.junit.jupiter.api.Disabled) Java の場合 // import org.junit.Ignore; // import org.junit.Test; public class MyClassTest { @Test @Ignore public void testSomething() { // ... } } Kotlin の場合 // import org.junit.Ignore // import org.junit.Test class MyClassTest { @Test @Ignore fun testSomething() { // ... } } @Ignore (@Disabled) に文字列パラメータを渡すと、なぜそのテストを無効にしているのかを示すことができます。
@Ignore(&amp;#34;HogeHogeのパラメータを整理中&amp;#34;) @Test fun testSomething() { // ... } このメッセージは JUnit でテストを実行したときに表示されます。 下記は、Android Studio 上で JUnit によるテストを実行したときの表示例です。 16 個のテスト関数のうち 1 つが無視され、その理由が表示されています。</description></item><item><title>GitHub GraphQL クエリ例: マイルストーン情報を取得する (milestone)</title><link>https://maku.blog/p/fdnpuro/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fdnpuro/</guid><description>マイルストーン番号で Milestone オブジェクトを取得する リポジトリ名（組織名/リポジトリ名）が分かっている場合は、repository クエリ で取得した Repository オブジェクト の milestone フィールドに マイルストーン番号 を指定することで、そのマイルストーンの Milestone オブジェクト を取得することができます。 例えば、Web アプリなどでは、/milestone/123 のようなパスで指定したマイルストーンの情報を表示したいことがありますが、このようなケースで 123 という番号を使って情報を取得することができます。
記述中
GraphQL クエリ query { repository(owner: &amp;#34;myorg&amp;#34;, name: &amp;#34;myrepo&amp;#34;) { milestone(number: 123) { number title dueOn description url issues(first: 100) { nodes { number title closed url } } } } } マイルストーンが設定されていないイシューを取得する search クエリ で、Issue や PullRequest を検索するときに、query パラメータで渡す文字列に no:milestone を含めると、マイルストーンの設定されていないものだけを検索することができます。
次の例では、myorg/myrepo リポジトリにおいて、マイルストーンの設定されていない Issue の一覧を取得しています（query 引数に is:issue を含めることで、PullRequest まで取得されてしまうのを防いでいます）。</description></item><item><title>GitHub GraphQL クエリ例: PullRequest の情報を取得する (search)</title><link>https://maku.blog/p/z69a3tk/</link><pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z69a3tk/</guid><description>自分のレビュー待ちになっている PR を取得する search クエリの query パラメータで、is:pr review-requested:@me と指定すると、自分がレビューワー (reviewer) として設定されているプルリクエストを検索することができます。
GraphQL クエリ query { search(type: ISSUE, last: 100, query: &amp;#34;is:open is:pr review-requested:@me&amp;#34;) { issueCount nodes { ... on PullRequest { number title url createdAt author { login avatarUrl url } reviewRequests(first: 100) { nodes { requestedReviewer { ... on User { login avatarUrl url } } } } } } } } PullRequest オブジェクトの詳細はこちら。</description></item><item><title>GitHub GraphQL クエリ例: イシュー情報を取得する (search)</title><link>https://maku.blog/p/i5ht5ep/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i5ht5ep/</guid><description>イシュー情報の取得方法 イシュー情報を取得する方法は次のような方法があります。
ユーザーからたどる方法 &amp;ndash; viewer/user クエリ で User オブジェクト を取得し、そのユーザーに関連するイシュー（issues フィールド）を参照する方法 リポジトリからたどる方法 &amp;ndash; repository クエリ で Repository オブジェクト を取得し、そのリポジトリ内のイシュー（issues フィールド）を参照する方法 ダイレクトに検索する方法 &amp;ndash; search クエリ でもろもろの検索条件（リポジトリ名、タイプなど）を使ってダイレクトに検索する方法 search クエリによる検索はとても柔軟で、様々な条件（query パラメータ）を指定してイシューを検索することができます。 query パラメータには、GitHub の Issues ページの検索窓に入力できる is:issue is:open といった文字列で、下記のサイトに詳細仕様が記述されています。
Issue およびプルリクエストを検索する - GitHub Docs あるリポジトリのイシューの一覧を取得する 次の GraphQL クエリでは、myorg/myrepo リポジトリの最新 5 件のイシュー情報を取得しています。
GraphQL クエリ query { search(type: ISSUE, query: &amp;#34;repo:myorg/myrepo is:issue&amp;#34;, last: 100) { issueCount nodes { ... on Issue { id number title closed url author { login } assignees(first: 100) { nodes { login name email } } labels(first: 100) { nodes { name color } } } } } } search クエリはそのパラメータの意味を理解するのが重要です。</description></item><item><title>GitHub GraphQL クエリ例: リポジトリの情報を取得する (repository)</title><link>https://maku.blog/p/du6env5/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/du6env5/</guid><description>GitHub の GraphQL API を使ってリポジトリの情報を取得するには、次のような方法があります。
repository クエリ &amp;hellip; 組織名（あるいはユーザ名）とリポジトリ名が分かっている場合 organization クエリ &amp;hellip; ある組織内のリポジトリの一覧を取得する場合（こちらの記事 を参考にしてください） search クエリ &amp;hellip; 汎用的な検索用クエリ でリポジトリを検索する search クエリでリポジトリを検索する 特定の組織 (organization) 内のリポジトリを取得するには、organization クエリを使って 得られた Organization オブジェクトの repositories を参照する方法もありますが、最初から search クエリを使っていろいろな条件を指定して検索する方が早いです。
参考: リポジトリを検索する - GitHub Docs 次の例では、myorg という組織内の、product というトピックの付けられたリポジトリの一覧を取得しています。
クエリ例 query { search(type: REPOSITORY, query: &amp;#34;org:myorg topic:product&amp;#34;, last: 100) { repositoryCount nodes { ... on Repository { id url name description createdAt } } } } 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;search&amp;#34;: { &amp;#34;repositoryCount&amp;#34;: 3, &amp;#34;nodes&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;DEMwOlJlcG9zaXRvcnkzODA5MTQ0OQ==&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.</description></item><item><title>GitHub GraphQL クエリ例: 組織の情報を取得する (organization)</title><link>https://maku.blog/p/3o2doyb/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3o2doyb/</guid><description>GitHub GraphQL API で指定した組織の情報を（ここでは github organization）の情報を取得には、organization クエリ を使用します。 organization クエリには、login パラメーターで組織名を渡します。
organization クエリが返す Organization オブジェクト を参照すると、そこに所属する メンバーの一覧、チームの一覧、リポジトリの一覧 などを取得することができます。
ある組織に所属するユーザー情報を取得する (Organization.membersWithRole) Organization オブジェクトの membersWithRole フィールドは OrganizationMemberConnection オブジェクトを保持しており、この nodes を参照することで、組織に所属するメンバーの一覧を取得できます。
GraphQL クエリ query { organization(login: &amp;#34;github&amp;#34;) { name description url membersWithRole(first: 3) { nodes { login name email updatedAt } } } } 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;organization&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;GitHub&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;How people build software.&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/github&amp;#34;, &amp;#34;membersWithRole&amp;#34;: { &amp;#34;nodes&amp;#34;: [ { &amp;#34;login&amp;#34;: &amp;#34;mtodd&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Matt Todd&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;xxx@example.</description></item><item><title>Node.js で GitHub GraphQL API を使用する (@octokit/graphql)</title><link>https://maku.blog/p/h5s6ht5/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h5s6ht5/</guid><description>概要 GitHub 上の情報を扱う API として、GitHub は GraphQL API を提供しています。
GitHub GraphQL API v4 | GitHub Developer Guide Node.js で GraphQL を扱う方法としては、Apollo ライブラリを使った方法 などがありますが、GitHub の GraphQL API を呼び出したいのであれば、GitHub が提供している GraphQL パッケージ @octokit/graphql を使うのが手っ取り早いかもしれません（エンドポイントの URL などを省略できます）。
octokit/graphql.js: GitHub GraphQL API client for browsers and Node @octokit/graphql - npm ここでは、TypeScript からこの @octokit/graphql パッケージを使用する方法を紹介します。
☝️ REST API と GraphQL API GitHub API バージョン 3 は REST API でしたが、柔軟性などの観点 から、GitHub API バージョン 4 の GraphQL 版の API を使用することが推奨されています。 GraphQL API を使用することで、REST API で複数のリクエストが必要だったものを 1 度のリクエストで取得できたりします。 また、GraphQL API でしか取得できない情報もあったりします。 セットアップ まず、TypeScript のプロジェクトを作成します。</description></item><item><title>GitHub GraphQL のスキーマ情報を取得する</title><link>https://maku.blog/p/whv8it5/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whv8it5/</guid><description>GitHub API のサイトからダウンロードする方法 次のサイトから GitHub GraphQL API のスキーマ定義ファイル (schema.docs.graphql) をダウンロードすることができます。
パブリックスキーマ - GitHub Docs 例えば、このファイル内の Query オブジェクト (type Query) の定義を見ると、クエリのトップレベルにどのようなオブジェクト（フィールド）を指定できるかが分かります。
schema.docs.graphql type Query { ... organization( login: String! ): Organization ... user( login: String! ): User } 上記の場合、Query オブジェクト内に organization や user フィールドが定義されているので、クライアントアプリからクエリ要求を出すときに、次のような感じで指定できるということが分かります。
query { organization(login: &amp;#34;netflix&amp;#34;) { name description avatarUrl } user(login: &amp;#34;octocat&amp;#34;) { name company url avatarUrl } } スキーマ定義ファイル (.graphql) とクライアントアプリ側のクエリ定義 (query {...}) を組み合わせることで、TypeScript 用の型定義ファイルを自動生成することができます（クエリ要求の戻り値の型を定義できます）。 詳しくは、Apollo CLI などのコマンドラインツールを確認してください。</description></item><item><title>GitHub Pages で React Router を使った SPA サイトを動かす方法</title><link>https://maku.blog/p/9u8it5f/</link><pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9u8it5f/</guid><description>React Router などを使った SPA (Single Page Application) な Web サイトは、GitHub Pages でそのまま動作させようとしてもうまく動きません。 ここでは、その理由と、対応方法について説明します。
GitHub Pages で SPA サイトが動作しない理由 たとえば、React Router を使った Web サイトは、次のような URL を使って目的のコンテンツ (/book/123) を表示するようルーティングします。
https://yourname.github.io/repo-name/book/123 React Router を使ったアプリで、この URL を実際に処理するファイルは、
https://yourname.github.io/repo-name/index.html であり、そこに記述された JavaScript ファイル内で、URL の末尾の /book/123 という部分をルーティング用のパス文字列として処理します。 つまり、前述の URL の /book/123 という部分は、単なるアプリ用のデータであり、実際に存在するファイルを示しているわけではありません。
一方、GitHub Pages はそのような事情を知らないので、/book/123 という URL でアクセスしようとすると、/book/123/index.html というファイルを見つけようとして 404 エラー になってしまいます。
先頭ページ (/index.html) を開いた後で、JavaScript でルーティング（React の Link コンポーネントによる遷移）を行っている間はうまく動作するのですが、ページをリロードしたり、Web ブラウザのアドレスバーに URL を直接入力したりすると、やはり 404 エラーになってしまいます。 OAuth 認証を使用した Web サイトの場合は、リダイレクトによって指定された URL へのアクセスが必要になるため、これは大きな制約になります。</description></item><item><title>GitHub Pages で Jekyll による自動変換を無効化する (.nojekyll)</title><link>https://maku.blog/p/my8fmsy/</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/my8fmsy/</guid><description>GitHub プロジェクトの設定画面から、GitHub Pages を有効化すると、簡単にウェブサイトをホスティングすることができます。 デフォルトでは、リポジトリ内の Markdown ファイル (.md) が Jekyll によって HTML に変換されるのですが、直接 HTML ファイルをデプロイする場合は、この変換処理は無駄です。
そのような場合は、次のようにして Jekyll による変換を無効化できます。
リポジトリのルート（GitHub Pages のソースディレクトリ）に .nojekyll ファイルを置く これだけです。
Hugo などの静的 Web サイト生成ツールで作成したサイトをデプロイするような場合は、この設定を行っておくと、ファイルのプッシュ後に GitHub Pages に反映されるまでの時間がほんの少し早くなるかもしれません。
速度を気にしない場合はこの設定をする必要はありませんが、プッシュする Web サイトリソース内に、アンダースコア (_) で始まるファイルやディレクトリなどが含まれている場合は、この設定は必須になります。 なぜなら、Jekyll がアンダースコアで始まるファイルやディレクトリを取り除いてしまうからです。
GitHub Pages のソースブランチとして gh-pages ブランチを設定している場合は、そのブランチのルートに .nojekyll を配置しなければいけないことに注意してください。 ちなみに、GitHub Actions でデプロイするときに、peaceiris/actions-gh-pages を使っている場合は、自動的にデプロイ先のブランチ (gh-pages) に .nojekyll ファイルを作成してくれます。
- name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public</description></item><item><title>JavaScript で現在のページの URL の構成要素を取得する (window.location)</title><link>https://maku.blog/p/j6iu6gs/</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6iu6gs/</guid><description>Web サイト上で実行される JavaScript から window.location を参照すると、カレントページの URL の構成要素をパーツごとに取得することができます。
JavaScript const loc = window.location; console.log(&amp;#39;location.href = &amp;#39; + loc.href); console.log(&amp;#39;location.origin = &amp;#39; + loc.origin); console.log(&amp;#39;location.host = &amp;#39; + loc.host); console.log(&amp;#39;location.protocol = &amp;#39; + loc.protocol); console.log(&amp;#39;location.hostname = &amp;#39; + loc.hostname); console.log(&amp;#39;location.port = &amp;#39; + loc.port); console.log(&amp;#39;location.pathname = &amp;#39; + loc.pathname); console.log(&amp;#39;location.search = &amp;#39; + loc.search); console.log(&amp;#39;location.hash = &amp;#39; + loc.hash); 例えば、次のようなアドレスにアクセスした場合は、
https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose 次のような結果を取得することができます。
location.href = https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose location.origin = https://example.com:8042 location.host = example.com:8042 location.</description></item><item><title>GitHub Actions で Web サイトをビルドして GitHub Pages へ公開する</title><link>https://maku.blog/p/5q3eq2c/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q3eq2c/</guid><description>何をするか？ GitHub Actions を使うと、GitHub で管理されている Web サイト用リソースの「ビルドとデプロイ」を簡単に自動化することができます。
ここでは、
npm run build による Web サイトのビルド ビルドされたリソースの GitHub Pages へのデプロイ（gh-pages ブランチ） を行う設定を行います。 最終的に、https://yourname.github.io/project名/ という URL で Web サイトが公開されます。
前提条件として、GitHub リポジトリに npm run build でビルド可能な Web サイト用リソースがコミットされているものとします。
☝️ 他のビルド方法は？ ここでは、npm run build による Web サイトのビルドを前提としましたが、例えば、Hugo によるビルドなどもほぼ同様に行えます。 GitHub Actions の設定 GitHub プロジェクトの Actions タブから、次のように新規ワークフローを作成します。
set up a workflow yourself をクリック main.yml の編集画面になるので、次のように入力して Start commit ボタンを押す .github/workflows/main.yml name: Build and deploy website on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.</description></item><item><title>Parcel でビルドした Web サイトが GitHub Pages で動作しないとき</title><link>https://maku.blog/p/m7jw8ju/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7jw8ju/</guid><description>React アプリを Parcel でビルドして GitHub Pages で公開しようとしたら、真っ白な画面になってしまったので対応方法のメモです。 原因は、トップページの index.html から読み込んでいる JavaScript ファイルのパスが、/index.js のように、ドメインルートからの相対パスになっていることでした。
GitHub Pages で公開する Web サイトの URL が、
https://yourname.github.io/ であれば問題ないのですが、
https://yourname.github.io/project名/ になっている場合は、読み込むファイルは /project名/index.js になっていないといけません。 これを解決するには、例えば、Parcel でビルドしているときは --public-url オプションを使って、次のように指定します。
$ parcel build src/index.html -d build --public-url &amp;#34;/project名/&amp;#34; こうすることで、トップページから /index.js というパスで参照していたものが /project名/index.js に変わってうまく動作するようになります。
npm run build で Web サイトのビルドを行っているのであれば、package.json 内のスクリプト定義で次のように記述しておけばよいでしょう。
package.json { // ... &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;parcel src/index.html --open&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;rm -rf build &amp;amp;&amp;amp; parcel build src/index.html -d build --public-url &amp;#39;/project名/&amp;#39;&amp;#34; }, // .</description></item><item><title>React Router でコンポーネントの表示・非表示を切り替える</title><link>https://maku.blog/p/nfxds8n/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nfxds8n/</guid><description>React の Router 系コンポーネント (BrowserRouter / HashRouter / MemoryRouter) を使用すると、論理的なパス管理によって React コンポーネントの表示の On/Off を切り替えることができます。 例えば、/users というパスでアクセスしたときには Users コンポーネントを表示し、/projects というパスでアクセスしたときには Projects コンポーネントを表示する、といったことを実現できます。
react-router-dom のインストール Router 系のコンポーネントは react-router-dom モジュールで提供されているので、まずはこれをインストールします。 TypeScript を使用する場合は、型定義ファイルも一緒にインストールしておきます。
$ npm install --save react-router-dom $ npm install --save-dev @types/react-router-dom BrowserRouter による表示切り替え 図: Router による表示切り替え 次の App コンポーネントでは、BrowserRouter コンポーネントを使って、Page1 と Page2 コンポーネントの表示を切り替えます。 Router 系のコンポーネントには、Router というエイリアス名を付けるのが慣例なのでそれに従います。 Router コンポーネントの下には、表示切り替え用のリンク要素として Link コンポーネントを配置し、表示要素として Route コンポーネントを配置します。
components/App.tsx import * as React from &amp;#39;react&amp;#39; import { BrowserRouter as Router, Link, Route } from &amp;#39;react-router-dom&amp;#39; // 子コンポーネントを適当に用意 const Page1: React.</description></item><item><title>Azure Functions に npm install で Node モジュールを追加する</title><link>https://maku.blog/p/9t7hs4e/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9t7hs4e/</guid><description>Azure Functions への npm install Azure Functions の関数を Node.js ランタイムで動かしている場合は、通常の Node.js アプリと同様に NPM パッケージを npm コマンドでインストールして使用することができます。 簡単なのは、Azure ポータル の Function App リソースの コンソール 画面から npm install を実行する方法です。
コンソールを開くと、Function App のルートディレクトリ（通常は D:\home\site\wwwroot）がカレントディレクトリになってプロンプトが表示されます。 ここから次のように package.json の作成と、Node モジュールのインストールを行うことができます。
D:\home\site\wwwroot&amp;gt; npm init -y D:\home\site\wwwroot&amp;gt; npm install node-fetch --save これで、この Functions プロジェクト内のすべての関数から、インストールした Node モジュールを使用できるようになります。
npm install を実行するディレクトリ Functions プロジェクトのディレクトリ階層は次のように、関数ごとにディレクトリが分かれています。
D:\home\site\wwwroot +-- host.json +-- MyFunc1 | +-- function.json | +-- index.js +-- MyFunc2 +-- function.json +-- index.</description></item><item><title>Azure Static Web Apps で静的ウェブサイトを作成する</title><link>https://maku.blog/p/vgt5fqy/</link><pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgt5fqy/</guid><description>Azure Static Web Apps とは 2020年5月に Azure Static Web Apps のプレビュー版が公開されました。 これまでは、Azure 上で静的なウェブサイトを作成する場合は、BLOB ストレージを使って HTML/JS ファイルなどをホストする方法がとられていましたが、今後は Static Web Apps のサービスが主流になりそうです。
参考: Azure Storage で静的 Web サイトをホスティングする Azure Static Web Apps は、サイトのビルドやデプロイに GitHub Actions を使うことを前提としているため、Web サイトのコンテンツを GitHub 上で管理することが強制されます。
GitHub Pages でも静的な Web サイトを作成できますが、Azure Static Web Apps を使うと Azure Functions などの API サービスと統合することができます。 静的 Web サイトといいつつも、より高度な Web アプリを作成することができそうです。
Azure Static Web Apps は、ベータ版のうちは無料で使えるようです。 そのうち従量課金に切り替わると思いますが、BLOB ストレージを使った場合の利用料金はめちゃ安だったので、こちらも安価な料金が設定されることを期待しています。
GitHub リポジトリの準備 下記のような簡単な HTML ファイルを作成して、GitHub リポジトリを新規作成 してコミットしておきます。</description></item><item><title>エミュレーター: RetroArch のメモ</title><link>https://maku.blog/p/n9nybnx/</link><pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9nybnx/</guid><description>設定ファイルの場所 キーコンフィグなどの設定ファイルは下記のディレクトリに格納されています。
macOS の場合 /Users/ユーザー名/Library/Application Support/RetroArch キー設定を間違えて、にっちもさっちもいかなくなってしまった場合は、この中の
config/retroarch.cfg というファイルを削除して RetroArch を再起動すれば OK です。
スキャンした ROM のリストや、セーブファイルなどは下記のディレクトリに格納されています。
macOS の場合 /Users/ユーザー名/Documents/RetroArch おすすめ設定 スクリーンショット (F8) やセーブファイルの保存先は、Dropbox などのクラウド上に保存するようにしておくと安心です。
設定 → ディレクトリ 録画 $DROPBOX/fun-game/retro-records スクリーンショット $DROPBOX/fun-game/retro-screenshots セーブファイル $DROPBOX/fun-game/retro-saves ステートセーブファイル $DROPBOX/fun-game/retro-states スクリーンキャプチャの解像度 Nintendo - NES / Famicom の場合 → 256x224</description></item><item><title>Electron アプリで OS のプロキシ設定をメインプロセスに反映する</title><link>https://maku.blog/p/t7ekrx4/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t7ekrx4/</guid><description>Electron アプリは「メインプロセス」と「レンダラープロセス」の 2 種類を扱わないといけないので、プロキシの設定でハマりがちです。 ここでは、システム (OS) のプロキシ設定を、自動的に両プロセスに反映する方法を説明します。 この仕組みを入れておけば、ユーザーにわざわざプロキシの設定をしてもらわなくて済むようになります。
レンダラープロセスの HTTP 通信 レンダラープロセス側は、Chromium の仕組みで システムのプロキシ設定が自動的に反映される ようになっています。 例えば、Web ブラウザ上の JavaScript で使用する XMLHttpRequest 関数や fetch 関数による HTTP 通信は、自動的にプロキシ経由で実行されます。 この振る舞いで問題なければ、特に設定を行う必要はありません。
BrowserWindow で扱うプロキシを明示的に指定するには、session オブジェクトの setProxy メソッド を使用します。
メインプロセスの HTTP 通信 Electron のメインプロセスはいわゆる Node.js アプリケーションと同様の仕組みで動作するので、Web ブラウザ側のプロキシ設定が自動的に反映されるようなことはありません。 しかし、electron モジュールが提供する session オブジェクトには、Chromium 側のプロキシ設定を参照する機能が備わっています。 この情報を利用すれば、メインプロセス側のプロキシ設定も自動的に行うことができます。
下記の autoProxy() 関数をメインプロセス起動直後に呼び出しておけば、メインプロセス側で実行する HTTP 通信に対してシステムのプロキシ設定が反映されます。
import {app, session} from &amp;#39;electron&amp;#39;; import {bootstrap} from &amp;#39;global-agent&amp;#39;; /** * システムのプロキシ設定情報をメインプロセスの HTTP 通信に反映します。 */ export function autoProxy() { app.</description></item><item><title>Electron で設定情報を扱う (electron-store)</title><link>https://maku.blog/p/ev6env5/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ev6env5/</guid><description>electron-store パッケージ を使用すると、Electron アプリ用の設定を簡単にローカルファイルとして保存できます。
electron-store のインストール $ npm install --save electron-store electron-store パッケージには TypeScript 用の型定義も含まれているため、別途型定義ファイルをインストールする必要はありません。
electron-store の使い方 簡単な使い方 electron-store モジュールは、キー＆バリューの形で設定値を保存する簡単な API (get/set) を提供しています。 下記の例では、color というキーで色情報を取得・保存しています。
main.ts import ElectronStore from &amp;#39;electron-store&amp;#39;; const store = new ElectronStore(); // 設定情報を取得する（第2パラメーターはデフォルト値） const color = store.get(&amp;#39;color&amp;#39;, &amp;#39;unknown&amp;#39;); console.log(color); // 設定情報の保存する store.set(&amp;#39;color&amp;#39;, &amp;#39;blue&amp;#39;); 1度目の実行では、設定情報が保存されていないので、get メソッドは第2引数で指定した unknown を返します。 2度目の実行では、前回保存した blue という値を取得できます。
設定値の型を定義する TypeScript を使っている場合は、get() で取得した値を特定の型の変数で受け取ることになると思います。 ElectronStore はジェネリクスクラスとして定義されており、各設定キーの型をあらかじめ指定しておくことができます。 次の例では、color 設定を文字列型として宣言しています。
import ElectronStore from &amp;#39;electron-store&amp;#39;; type StoreType = { color: string; } const store = new ElectronStore&amp;lt;StoreType&amp;gt;(); const color: string = store.</description></item><item><title>Electron アプリがパッケージングされた環境 (production) で動作しているか調べる</title><link>https://maku.blog/p/5ku5dmt/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5ku5dmt/</guid><description>Electron の app モジュールの isPackaged プロパティ を参照すると、アプリが electron-builder などでパッケージングされた状態で動作しているかどうかを調べることができます。 一般的に、app.isPackaged が true となる場合、production モードで動作していると考えられます。
次の例では、アプリが開発中の場合のみ Chromium の DevTools を開くようにしています。
// const win = new BrowserWindow(this.options); // 開発中のみ起動時に DevTools を開く if (!app.isPackaged) { win.webContents.openDevTools() }</description></item><item><title>GitHub GraphQL API の呼び出し回数制限 (rate limit) の情報を取得する</title><link>https://maku.blog/p/bqz7emt/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bqz7emt/</guid><description>GitHub API を使ったアプリケーションを作成するときは、API の呼び出し回数制限を意識した設計を行う必要があります。 GitHub API バージョン3 の REST API には、1 時間に 5000 リクエストまでという明確な呼び出し回数制限がありましたが、API バージョン4 の GraphQL API はそのクエリの性質上、ちょっと異なるコスト計算方法が採用されています。
GraphQL resource limitations | GitHub Developer Guide 正確な計算方法は上記のサイトに記述されていますが、簡単にいうと、GraphQL クエリの入れ子階層が深くなり、複雑になるほどコストがかかるという計算になっています。
ある GraphQL クエリが実際にどれだけのコストがかかるかは、下記のように rateLimit 情報を取得することで調べることができます。
query { rateLimit { limit cost remaining resetAt } search(query: &amp;#34;repo:electron/electron is:issue&amp;#34;, type: ISSUE, first: 5) { issueCount nodes { ... on Issue { title labels(first: 10) { nodes { name }} } } } } 上記のクエリを実行すると、次のような感じの JSON レスポンスが返ってきます。</description></item><item><title>React でモーダルダイアログを表示する (react-modal)</title><link>https://maku.blog/p/q6fnu29/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q6fnu29/</guid><description>react-modal パッケージが提供する ReactModal コンポーネントを使用すると、React アプリ内で簡単にモーダルダイアログを実現することができます。
上記は、設定 ボタンを押してモーダルな設定ダイアログを開いたときの表示例です。
react-modal のインストール ReactModal コンポーネントを使うために、react-modal パッケージと TypeScript の型定義ファイルをインストールします。
$ npm install --save react-modal $ npm install --save-dev @types/react-modal ReactModal コンポーネントを使用する ReactModal の使い方 ReactModal コンポーネントは、isOpen プロパティでダイアログの表示・非表示を制御するようになっています。
// import ReactModal from &amp;#39;react-modal&amp;#39;; &amp;lt;ReactModal isOpen={this.props.isOpen} onAfterOpen={this.handleOpen} onRequestClose={this.handleClose} style={this.customStyles} contentLabel=&amp;#34;Settings&amp;#34; &amp;gt; // ... フォームの内容などをここに記述 ... &amp;lt;/ReactModal&amp;gt; onAfterOpen でオープン時、onRequestClose でクローズ時のイベントをハンドルすることができます。 ReactModal は自分自身のダイアログを自動で閉じたりしないので、onRequestClose に設定したハンドラ内で、isOpen プロパティに渡す値を false に設定してダイアログを閉じる必要があります。 onRequestClose ハンドラは、Esc キーを押したときや、ダイアログ外の領域をクリックしたときなどに呼び出されます。
コンポーネントの作成 下記のサンプルコードは ReactModal を使ったコンポーネントの作成例です。 ここでは、ユーザー名を入力可能な設定ダイアログを想定しています。 React を使ったフォームの作成方法などは次の記事を参照してください。
参考: React コンポーネントでフォームの入力を処理する components/settingsDialog.</description></item><item><title>GitHub GraphQL API のクエリ例: ユーザー情報を取得する (viewer, user)</title><link>https://maku.blog/p/9bku4cj/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9bku4cj/</guid><description>サインイン済みのユーザー情報を取得する (viewer) viewer クエリを使用すると、現在アクセスしているユーザー（サインイン中のユーザー）のユーザー情報（User オブジェクト）を取得することができます。
Queries - viewer GraphQL クエリ query { viewer { login # ログインID name # ユーザー名 email # メールアドレス（ユーザーが公開していれば） url # ユーザーの GitHub ホームページ websiteUrl # ユーザーの Web サイト avatarUrl # ユーザーのアバター画像 } } 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;viewer&amp;#34;: { &amp;#34;login&amp;#34;: &amp;#34;maku77&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Maku Maku&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;maku@example.com&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/maku77&amp;#34;, &amp;#34;websiteUrl&amp;#34;: &amp;#34;https://maku77.github.io/&amp;#34;, &amp;#34;avatarUrl&amp;#34;: &amp;#34;https://avatars2.githubusercontent.com/u/5519503?v=4&amp;#34; } } } 指定したログイン ID のユーザー情報を取得する (user) user クエリを使用すると、指定したユーザー名のユーザー情報を取得することができます。
Queries - user GraphQL クエリ query { user(login:&amp;#34;maku77&amp;#34;) { login # ログインID name # ユーザー名 email # メールアドレス（ユーザーが公開していれば） url # ユーザーの GitHub ホームページ websiteUrl # ユーザーの Web サイト avatarUrl # ユーザーのアバター画像 } } 取得できるオブジェクトは、viewer クエリの場合と同様に User オブジェクト です。</description></item><item><title>Azure Pipelinesメモ: azure-pipelines.yml から別の Yaml をインクルードする (template)</title><link>https://maku.blog/p/36h9xj9/</link><pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/36h9xj9/</guid><description>Template 機能 Azure Pipelines の Template 機能を使用すると、別の Yaml ファイルに記述したビルド設定をインクルードすることができます。
Templates - Azure Pipelines | Microsoft Docs 変数を渡して、部分的に内容を置き換えることができるので、「インクルード」ではなく「テンプレート」と呼んでいるみたいです。
単純に共通の steps を読み込んで使うこともできるし、逆にテンプレートファイルに対してパラメータで stepList を渡すということもできます。
使用例（steps の共通化） 例えば、別の Yaml ファイル（テンプレート）に記述した steps 定義を、azure-pipelines.yml から読み込むとします。 テンプレートファイルには次のような感じで、ルートに steps 要素を記述します。
common-steps.yml（テンプレート） steps: - task: NodeTool@0 inputs: versionSpec: &amp;#39;10.x&amp;#39; displayName: &amp;#39;Install Node.js&amp;#39; - task: Npm@1 inputs: command: &amp;#39;ci&amp;#39; displayName: &amp;#39;npm ci&amp;#39; - task: Npm@1 inputs: command: &amp;#39;custom&amp;#39; customCommand: &amp;#39;run lint&amp;#39; displayName: &amp;#39;npm run lint&amp;#39; # ... azure-pipelines.yml の steps 以下で、上記のテンプレートファイルを読み込むには、template というキーワードを使用します。</description></item><item><title>VS Code で行末の空白（半角スペース）を自動で削除する (files.trimTrailingWhitespace)</title><link>https://maku.blog/p/j6jv7it/</link><pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6jv7it/</guid><description>Visual Studio Code で次のように設定しておくと、ファイル保存時に、行末の余計なスペースを自動で削除してくれます。
settings.json で設定する方法 settings.json { &amp;#34;files.trimTrailingWhitespace&amp;#34;: true, // ... } Markdown ファイル (.md) は、行末の 2 つのスペースが改行の意味を持っていたりします。 そのような場合はスペースが削除されてしまうと都合が悪いので、次のように言語別設定で markdown の場合のみ無効化しておきます。
{ &amp;#34;files.trimTrailingWhitespace&amp;#34;: true, &amp;#34;[markdown]&amp;#34;: { &amp;#34;files.trimTrailingWhitespace&amp;#34;: false }, // ... } 参考: settings.json について 設定画面で設定する方法 Ctrl + , で設定画面を開く（macOS の場合は Cmd + ,） trim で検索して Trim Trailing Whitespace にチェックを入れる</description></item><item><title>Android開発: ContraintLayout で配置されたビューの実際のサイズを取得する</title><link>https://maku.blog/p/khqpnjf/</link><pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/khqpnjf/</guid><description>ConstraintLayout で配置したビューは、周囲のビューとの位置関係で位置やサイズなどが決まるため、実際に内部的なレイアウトが終了するまでは、ビューのサイズ情報などが取得できなかったりします（0 になります）。
View.doOnLayout() などで、レイアウト完了するのを待ってからサイズを取得すればうまくいきます。 これは、TransitionManager などでレイアウトを切り替えた直後なども同様です。
// レイアウト変更＆アニメーション開始 TransitionManager.beginDelayedTransition(constraintLayout) constraintSet.applyTo(constraintLayout) // この直後にレイアウト情報取得してもうまく取得できない val w = myView.width val h = myView.height myView.doOnLayout { // このタイミングであればうまく取得できる val w = it.width val h = it.height }</description></item><item><title>Electron アプリ内のリンクをOSのデフォルトブラウザで開く</title><link>https://maku.blog/p/7yhwcr7/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7yhwcr7/</guid><description>BrowserWindow 内で表示した HTML のリンクをクリックすると、デフォルトではそのウィンドウ内でリンク先のページへ遷移します。 リンククリック時に発生する will-navigate イベント と new-window イベント をハンドルすることで、OS のデフォルトブラウザでリンクを開くことができます。 リンククリック時には通常 will-navigate イベントが発生するのですが、&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt; のように別ウィンドウで開くようなリンクをクリックした場合は new-window イベントが発生するので、両方のイベントをハンドルする必要があります。
// リンククリック時に OS のデフォルトブラウザで開く const handleUrlOpen = (event: Event, url: string) =&amp;gt; { event.preventDefault(); shell.openExternal(url); }; // リンククリック時のイベントハンドラを登録 win.webContents.on(&amp;#39;will-navigate&amp;#39;, handleUrlOpen); win.webContents.on(&amp;#39;new-window&amp;#39;, handleUrlOpen); 下記はメインプロセス全体のコードです。
main.ts import { app, BrowserWindow, shell } from &amp;#39;electron&amp;#39;; class MainWindow { private options: Electron.BrowserWindowConstructorOptions = { width: 800, height: 400, webPreferences: { nodeIntegration: true } } // リンククリック時に OS のデフォルトブラウザで開く private handleUrlOpen = (event: Event, url: string) =&amp;gt; { event.</description></item><item><title>Azure Pipelines トラブル: npm タスクを実行できないとき</title><link>https://maku.blog/p/7c2kdub/</link><pubDate>Wed, 22 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7c2kdub/</guid><description>Azure Pipelines の設定で、次のような感じで Npm タスクを追加したとき、
azure-pipelines.yml steps: - task: Npm@1 inputs: command: &amp;#39;ci&amp;#39; displayName: &amp;#39;npm ci&amp;#39; - task: Npm@1 inputs: command: &amp;#39;custom&amp;#39; customCommand: &amp;#39;run lint&amp;#39; displayName: &amp;#39;npm run lint&amp;#39; Node.js 系のコマンドが認識されていないと、エラーが出て Npm タスクを実行できません。
No agent found in pool Default which satisfies the specified demands: npm, Agent.Version -gtVersion 2.163.1 そのような場合は、steps の先頭で、次のように NodeTool (Node.js Tool Installer) タスクを実行しておくと、うまく動作するようになります 。
azure-pipelines.yml steps: # これで npm コマンドを認識するようになる - task: NodeTool@0 inputs: versionSpec: &amp;#39;10.x&amp;#39; displayName: &amp;#39;Install Node.</description></item><item><title>フレックスボックス (Flexbox) レイアウトでサイドバーと本文を別々にスクロールできるようにする</title><link>https://maku.blog/p/zgqz8gp/</link><pubDate>Sun, 19 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zgqz8gp/</guid><description>CSS のフレックスボックスの登場により、サイドバーなどの2段組レイアウトを簡単に実現できるようになりました。 アプリによっては、サイドバーと本文部分を別々にスクロールできるようになっていると便利です。 次の例では、フレックスボックスのアイテムとして配置した 2 つの div 要素 (left と right) を、別々に縦スクロールできるようにしています。
HTML &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt; Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt; Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt; Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt;Left&amp;lt;br&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt; Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt; Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt;Right&amp;lt;br&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; CSS body { margin: 0; height: 100vh; } .container { display: flex; height: 100%; } .left { width: 100px; background: #f9c; overflow-y: auto; } .right { flex: 1; background: #9cf; overflow-y: auto; } ポイントは次の通りです。
親要素 (container) の height で高さを指定する 子要素 (left/right) の overflow-y に auto を指定する これらの設定により、子要素の内容が表示領域 (height) に収まらないときに、自動的にスクロールバーが表示されるようになります。</description></item><item><title>Electron アプリのレイアウトにはフレックスボックスなど新しいスタイルを使用する</title><link>https://maku.blog/p/awamxak/</link><pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/awamxak/</guid><description>Electron アプリのレンダリングには、最新の Chromium を使用できるため、比較的新しい CSS 機能を安心して使用することができます。 Web ブラウザで動作するわけではないので、ベンダープレフィックスなどのケアをする必要もありません。
例えば、次の例では、サイドバーと領域の広がる本文部分に別れるレイアウトを、CSS のフレックスボックス (Flexbox) で実現しています（ここでは React を使用しています）。
app.tsx import * as React from &amp;#39;react&amp;#39;; const styles: {[key: string]: React.CSSProperties} = { container: { display: &amp;#39;flex&amp;#39;, minHeight: &amp;#39;100vh&amp;#39;, }, sidebar: { background: &amp;#39;lightgray&amp;#39;, width: &amp;#39;150px&amp;#39;, }, body: { background: &amp;#39;#ddd&amp;#39;, flex: 1, } }; export class App extends React.Component { public render(): React.ReactNode { return ( &amp;lt;div style={styles.container}&amp;gt; &amp;lt;div style={styles.sidebar}&amp;gt;Sidebar&amp;lt;/div&amp;gt; &amp;lt;div style={styles.body}&amp;gt;Body&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ); } } フレックスボックスはとても柔軟で、画面上端で左右に広がるメニュー など、いろいろな用途に使用することができます。</description></item><item><title>React コンポーネントに CSS スタイルを設定する</title><link>https://maku.blog/p/eu4cksy/</link><pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eu4cksy/</guid><description>React は Web サイトの View レイヤのコンポーネントを作るためのライブラリですが、CSS ファイルの扱い方は特に決められておらず、今でも多くの人が試行錯誤しています。 ここでは、React アプリにおける CSS の扱い方を、下記のように分類して順番に説明していきます。
従来通り HTML 起点でスタイルを読み込む方法 インラインスタイル CSS Modules CSS in JS ライブラリ HTML ファイルで読み込んだ CSS ファイルを参照する これは React を使わない従来の HTML/CSS のやり方に近い方法です。 HTML ファイル内の style 要素で定義した CSS クラスや、HTML から読み込んだ CSS ファイル内で定義した CSS クラスを React コンポーネントから使用します。
例えば、HTML ファイル内で次のようにスタイル定義されているとします。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;MyApp&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;style&amp;gt; .hello { color: blue; background: #aaccff; padding: 0.5em; font-weight: bolder; border-radius: 0.5em; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;index.</description></item><item><title>webpack と TypeScript を組み合わせて使用する</title><link>https://maku.blog/p/ucnv6en/</link><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ucnv6en/</guid><description>はじめに TypeScript は JavaScript コードに型付けすることができる優れたトランスパイラですが、変換後の .js ファイル群をまとめる（バンドルする）機能は備えていません。 また、モダンな Web サイトを構築するときは、CSS Modules や Sass/Less/Stylus といった仕組みを使用するのが常套手段となっています。
そのため、Web サイト用の .js ファイルを TypeScript を使って作成する場合、webpack などのバンドルツールを組み合わせて使用する必要があります。
TypeScript &amp;hellip; .ts ファイルから .js ファイルへの変換 webpack &amp;hellip; Web サイト用の各種リソースをバンドルする バンドルツールには様々なものがありますが、大きなシェアを占めているのは webpack なので（2020年現在）、ここでは TypeScript と webpack を組み合わせて使用する方法を説明します。
☝️ webpack は必要なくなる？ ES Module の仕組みにより、Web ブラウザからモジュール化された .js ファイルをインポートすることが可能になりつつあります。 しかし、Web サイトの最終的なデプロイ時には、各種リソースを最適化（minify など）する必要があるため、まだまだ webpack などのバンドルツールが必要です。 関連パッケージのインストール TypeScript のインストール プロジェクト用のディレクトリと package.json を作成し、TypeScript をインストールします。
$ mkdir myapp &amp;amp;&amp;amp; cd $_ $ npm init -y $ npm install --save-dev typescript webpack のインストール webpack 関連のパッケージをインストールします。</description></item><item><title>Electron のメインプロセスとレンダラープロセスの関係</title><link>https://maku.blog/p/mkisgqb/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mkisgqb/</guid><description>メインプロセスとレンダラープロセス Electron アプリを作成するときは、メインプロセスとレンダラープロセスを意識して使い分ける必要があります。
レンダラープロセス側で呼び出し可能な Electron モジュール（他の Node モジュールも含む）は制限されていて、実行できる JavaScript ライブラリは、Web ブラウザ上で実行可能な JavaScript に毛が生えたものくらいものと考えておくのがよいです。
ipcRenderer モジュールは例外的にレンダラープロセスから使ってもよいとされているモジュールのひとつで、これ経由でメインプロセスに対して要求（メッセージ）を送ることができます。 逆にメインプロセスからのメッセージをハンドルすることもできます。
通知先のレンダラープロセスの指定 メインプロセスに対して、レンダラープロセスは複数存在することがあるので、メインプロセスからメッセージを送るときは、どのレンダラープロセスへのメッセージなのかを意識する必要があります。
レンダラープロセスからのメッセージに応答する レンダラープロセスからのイベントを ipcMain.on() でハンドルする場合、コールバック関数の第1パラメータとして渡される event: Electron.IpcMainEvent オブジェクトから送信元のレンダラープロセス (sender: Electron.WebContents) を参照することができます。
下記のメインプロセスは、my-add イベントとしてレンダラープロセスから 2 つの数値を受け取り、IpcMainEvent.reply() を使って送信元のレンダラープロセスに応答メッセージ（数値を足した結果）を返しています。
main.ts（メインプロセス） // レンダラープロセスからメッセージを受信して、応答メッセージを返す ipcMain.on(&amp;#39;my-add&amp;#39;, (evt: Electron.IpcMainEvent, num1: number, num2: number) =&amp;gt; { evt.reply(&amp;#39;my-add-reply&amp;#39;, num1 + num2); //evt.sender.send(&amp;#39;my-add-reply&amp;#39;, num1 + num2); }); レンダラープロセス側では、ipcRenderer.send() でメインプロセスにメッセージを送り、その応答を ipcRenderer.on() でハンドルするように実装します。
renderer.ts（レンダラープロセス） import { ipcRenderer } from &amp;#39;electron&amp;#39;; // メインプロセスへメッセージを送信 ipcRenderer.send(&amp;#39;my-add&amp;#39;, 100, 200); // メインプロセスからメッセージを受信 ipcRenderer.</description></item><item><title>Electron アプリの配布パッケージを作る (electron-builder)</title><link>https://maku.blog/p/2tcs8n2/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2tcs8n2/</guid><description>概要 electron-builder を使用すると、Electron アプリを Windows、macOS、Linux 用の配布用バイナリとしてパッケージングすることができます。 各 OS 用のインストーラはもちろん、ポータブルな zip パッケージを作成することもできます。
electron-builder 公式サイトのドメイン名が electron.build っていうのがかっこいいですね。
electron-builder のインストール Node.js のパッケージ管理ツールとして、npm よりも yarn を使うことが strongly recommended されているので、まず yarn をインストールしてから yarn で electron-builder をインストールすることにします。
$ npm install -g yarn $ yarn add electron-builder --dev 下記のように実行して、ヘルプを表示できればインストール完了です。
$ npx electron-builder --help ビルド設定 electron-builder 用の設定は、package.json の build プロパティで行うことができます。 ポイントは、files の指定で、パッケージングする html ファイルや js ファイル、画像ファイルなどをすべてカバーするように指定しておく必要があります。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;build/main.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;tsc &amp;amp;&amp;amp; electron .</description></item><item><title>Electron の app.getData() で取得できる特殊ディレクトリパスの一覧</title><link>https://maku.blog/p/77sas8m/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/77sas8m/</guid><description>app.getPath について electron モジュールの app.getPath(name) 関数を使用すると、OS 固有の特殊フォルダパスを取得することができます。 例えば、getPath('userData') とすると、ユーザーの設定ファイルなどを格納するディレクトリを取得することができます。
下記は、いろんな特殊フォルダのパスを取得するテストコードです。
import { app } from &amp;#39;electron&amp;#39;; export function showSpecialDirs() { console.log(`app.getAppPath() = ${app.getAppPath()}`); console.log(&amp;#39;\n==== Application data&amp;#39;); console.log(`app.getPath(&amp;#39;home&amp;#39;) = ${app.getPath(&amp;#39;home&amp;#39;)}`); console.log(`app.getPath(&amp;#39;temp&amp;#39;) = ${app.getPath(&amp;#39;temp&amp;#39;)}`); console.log(`app.getPath(&amp;#39;appData&amp;#39;) = ${app.getPath(&amp;#39;appData&amp;#39;)}`); console.log(`app.getPath(&amp;#39;cache&amp;#39;) = ${app.getPath(&amp;#39;cache&amp;#39;)}`); console.log(`app.getPath(&amp;#39;userData&amp;#39;) = ${app.getPath(&amp;#39;userData&amp;#39;)}`); console.log(`app.getPath(&amp;#39;logs&amp;#39;) = ${app.getPath(&amp;#39;logs&amp;#39;)}`); console.log(`app.getPath(&amp;#39;crashDumps&amp;#39;) = ${app.getPath(&amp;#39;crashDumps&amp;#39;)}`); console.log(&amp;#39;\n==== OS multimedia&amp;#39;) console.log(`app.getPath(&amp;#39;desktop&amp;#39;) = ${app.getPath(&amp;#39;desktop&amp;#39;)}`); console.log(`app.getPath(&amp;#39;documents&amp;#39;) = ${app.getPath(&amp;#39;documents&amp;#39;)}`); console.log(`app.getPath(&amp;#39;downloads&amp;#39;) = ${app.getPath(&amp;#39;downloads&amp;#39;)}`); console.log(`app.getPath(&amp;#39;music&amp;#39;) = ${app.getPath(&amp;#39;music&amp;#39;)}`); console.log(`app.getPath(&amp;#39;pictures&amp;#39;) = ${app.getPath(&amp;#39;pictures&amp;#39;)}`); console.log(`app.getPath(&amp;#39;videos&amp;#39;) = ${app.getPath(&amp;#39;videos&amp;#39;)}`); console.log(&amp;#39;\n==== Executables&amp;#39;) console.</description></item><item><title>Electron: レンダラーからの要求でメインプロセスでファイルを読み込んで返す</title><link>https://maku.blog/p/aq2airz/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aq2airz/</guid><description>Electron アプリのメインプロセスで使用できる ipcMain.handle を使うと、レンダラーから呼び出せる関数のようなものを定義できます。 正確には、特定の名前のチャネル (channel) へのメッセージをハンドルするコールバック関数を設定します。 次の例では、メインプロセスで read-textfile メッセージを受診したときに、指定されたファイルを読み込んでその内容を返すように実装しています。
main.js（メインプロセス） import { app, ipcMain, BrowserWindow } from &amp;#39;electron&amp;#39;; import * as fs from &amp;#39;fs&amp;#39;; // ... // 指定されたテキストファイルを読みこんで、その内容を返します。 ipcMain.handle(&amp;#39;read-textfile&amp;#39;, async (event, filename) =&amp;gt; { const buf = await fs.promises.readFile(filename); return buf.toString(); }); 一方、レンダラー側では ipcRenderer.invoke を使って、あたかも関数呼び出しのようにメインプロセス側の処理を呼び出すことができます。 次の例では、画面上のボタンを押した時にメインプロセスに read-textfile メッセージを送り、その戻り値を表示しています。
renderer.js import { ipcRenderer } from &amp;#39;electron&amp;#39;; const btn = document.querySelector(&amp;#39;#btn&amp;#39;)!; const output = document.querySelector(&amp;#39;#output&amp;#39;)!; btn.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; { ipcRenderer.invoke(&amp;#39;read-textfile&amp;#39;, &amp;#39;./hoge.txt&amp;#39;) .</description></item><item><title>Electron: 処理が終わるまでボタンを無効状態 (disabled) にする</title><link>https://maku.blog/p/xkxbnza/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xkxbnza/</guid><description>button 要素の disabled プロパティ JavaScript で button 要素の disabled プロパティを true に設定すると、ボタンを無効状態 (disabled) にすることができます。 TypeScript を使っている場合は、document.querySelector() の戻り値を HTMLButtonElement にキャストすることで disabled プロパティを参照できるようになります。
button 要素を disabled にする const btn = document.querySelector(&amp;#39;#btn&amp;#39;) as HTMLButtonElement; btn.disabled = true; ボタンを押したときに重い処理（データ取得など）を実行する場合、処理中にボタンを無効化することで、ユーザーによるボタンの連打を防ぐことができます。
より実践的なサンプル 下記は Electron アプリの実装サンプル（レンダラープロセスの抜粋）です。 ボタンを押したときにボタンを無効化すると同時に Web からデータ取得します。 そして、データ取得が完了するか、エラーが発生したときにボタンを有効化します。
ここでは、HTTP GET リクエストを送るために superagent モジュールを使用しています。
superagent のインストール $ npm install --save superagent $ npm install --save @types/superagent renderer.ts import * as superagent from &amp;#39;superagent&amp;#39;; const btn = document.</description></item><item><title>Electron で各種ダイアログを表示する (dialog)</title><link>https://maku.blog/p/ihwanyc/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ihwanyc/</guid><description>electron モジュールが提供する dialog を使用すると、いろいろなダイアログを表示することができます。 ダイアログの表示は、メインプロセスからしか行えません。
参考: Electron Documentation - dialog エラーボックス (showErrorBox) 一番簡単に使えそうなエラーボックスから。 ダイアログのタイトルと、メッセージの内容を指定するだけで表示できます。
dialog.showErrorBox(title, content) import { dialog } from &amp;#39;electron&amp;#39;; dialog.showErrorBox(&amp;#39;File Not Found&amp;#39;,&amp;#39;指定されたファイルが見つかりませんでした。&amp;#39;); このエラーボックスが表示されている間は、他の全てのウィンドウが操作できなくなるようです（つまり、モーダルダイアログとして振る舞います）。
ドキュメントによると、この dialog.showErrorBox は、「app モジュールが ready イベントを emit する前に呼び出すことができる」とされています。 つまり、アプリケーションの起動時に行うエラーチェックなどで使用できるということです（メインウィンドウ表示前に設定ファイルの内容が正しいか調べたり）。
レンダラープロセス側では alert() を使っちゃうことが多いかもしれません。
メッセージボックス (showMessageBox, showMessageBoxSync) メッセージボックスを表示するには、次のような関数を使用します。
dialog.showMessageBox(options) dialog.showMessageBox(browserWindow, options) dialog.showMessageBoxSync(options) dialog.showMessageBoxSync(browserWindow, options) 表示内容を options パラメータでいろいろ制御できます（下記に例を示します）。
メッセージボックスが表示されている間は、基本的には他のウィンドウを操作できなくなります。 browserWindow パラメーターで、親ウィンドウとなる BrowserWindow インスタンスを指定すると、その親ウィンドウのモーダレスダイアログとなり、その親ウィンドウだけ操作できなくなります。
☝️ ワンポイント showMessageBoxSync() にも親ウィンドウを指定するバージョンがありますが、この関数を呼び出すと結局他のウィンドウも操作できなくなります。 いまいち使いどころが分かりませんが、親ウィンドウを指定することで、親ウィンドウの表示位置に近いところにダイアログが表示されるという効果は得られます。 例: OK ボタンだけあるダイアログ const options: Electron.MessageBoxOptions = { type: &amp;#39;info&amp;#39;, // none/info/error/quetion/warning title: &amp;#39;タイトル&amp;#39;, message: &amp;#39;メッセージ&amp;#39;, detail: &amp;#39;説明文&amp;#39; }; dialog.</description></item><item><title>Node.js で GitHub REST API を使用する (@octokit/rest)</title><link>https://maku.blog/p/7r6gr3d/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7r6gr3d/</guid><description>概要 Octokit は、様々な言語から GitHub API を使用するためのライブラリを提供しています。 ここでは、TypeScript (JavaScript) 用の GitHub API v3 (REST API) ライブラリである、@octokit/rest を使用する方法を紹介します。
インストール @octokit/rest は次のようにインストールします（npm init で package.json を作成済みだと想定します）。
$ npm install @octokit/rest --save 実装（基本） 基本的には下記の API ドキュメントを参照しながら実装していくことになります。
octokit/rest.js API ドキュメント Octokit インスタンスを生成する main.ts import { Octokit } from &amp;#39;@octokit/rest&amp;#39;; const octokit = new Octokit(); このように生成した Octokit インスタンスを使って、様々な REST API を呼び出します。
リポジトリの一覧を取得する (repos.listForOrg) API ドキュメント (Repos - Get a repository)
次の例では、組織名 sony のパブリックなリポジトリを 5 件分取得しています。
octokit .</description></item><item><title>textlint で表記揺れをチェックする (proofread-helper, prh)</title><link>https://maku.blog/p/m4cks29/</link><pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4cks29/</guid><description>prh と textlint-rule-prh テキストファイルの表記揺れをチェックする Node.js 製ツールに、proofread-helper (prh) というものがあります。 これを使うと、例えば、テキストファイル内の javascript という文字列を JavaScript に自動的に修正できたりします（大文字・小文字の構成）。
textlint の作者の azu さんが、この prh を textlint から使えるようにするルール定義 textlint-rule-prh を作成してくれています。 prh を直接使うよりも、Markdown ファイルの構文をうまく扱ってくれるみたいです（リンク内のテキストは対象外にするなど）。
インストール ルールのインストール textlint 用のルールモジュールである textlint-rule-prh は、次のようにインストールします（textlint 自体はインストール済みであるとします）。 proofread-helper を別途インストールする必要はありません。
$ npm install --save-dev textlint-rule-prh 設定ファイルの作成 proofread-helper (prh) の設定ファイル（表記揺れチェックルール）は、下記のような感じで Yaml ファイルで作成します。
rules.yml version: 1 rules: # 大文字小文字全角半角の統一 - expected: JavaScript - expected: jQuery textlint の設定ファイルで textlint-rule-prh を有効にし、上記のルールファイルのパスを指定します。
.textlintrc { &amp;#34;rules&amp;#34;: { &amp;#34;prh&amp;#34;: { &amp;#34;rulePaths&amp;#34;: [ &amp;#34;.</description></item><item><title>こたつ布団おうちで洗ってみた</title><link>https://maku.blog/p/zit5eow/</link><pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zit5eow/</guid><description>長年使い続けてたコタツ布団がなんだか臭ってきた気がするのでおうちで洗濯してみました。 洗濯機に入れるには大きすぎるので、おふろで足踏み洗い。
なんか水がすごい黒い。。。 見た目はあまり汚れてるように見えなかったんですけど、汗とかいろいろ染み込んでたんでしょうね。
洗ったあとはよくすすいで物干し竿に干したんですが、水を吸いまくっててめっちゃ重かった。。。 でもこれでスッキリです。 もし中の綿がおかしくなっちゃったら、あきらめて捨てるつもりでしたけど、なんか大丈夫っぽいです。</description></item><item><title>Azure Table Stroage を使ってみる: TableService を Promise 化して使いやすくする</title><link>https://maku.blog/p/4m96s2r/</link><pubDate>Thu, 04 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4m96s2r/</guid><description>PromiseTableService クラスの概要 Node.js から Azure Table Storage を操作する場合は、azure-storage パッケージの TableService クラス を使用するのですが、このクラスは残念ながら Promise 対応 対応されておらず、旧式のコールバック形式での呼び出しが強制されます。
下記の azure-table-promise パッケージが提供している PromiseTableService クラスを使用すると、TableService を Promise 化して使用することができます。
azure-table-promise - npm パッケージ ちなみに、下記の Issue で公式パッケージの Promise 化の議論がされているのですが、TableService クラスはいまだに対応されてませんね（2020年6月現在）。
参考: Promise support · Issue #110 · Azure/azure-storage-node こういった対応は本家の方でサクッとやってくれれば 3rd パーティライブラリの乱立が防げるんですけどね。。。
PromiseTableService を使ってみる まず必要なモジュールをインストールします。 azure-storage は本家 Microsoft の TableService クラスを使うためのモジュールで、azure-table-promise がそれを Promise ラップするためのモジュールです。 ここでは TypeScript を使うので、Node.js 型定義もインストールしておきます。
npm モジュールのインストール $ npm install --save-dev @types/node $ npm install --save azure-storage $ npm install --save azure-table-promise 次の MyTableStorage クラスは、PromiseTableService を使って TableStroage から情報を取得するサンプルです。 コンストラクタで PromiseTableService インスタンスを生成し、getRandomMessage() メソッドで、randommessage テーブルの値をランダムに取得しています。</description></item><item><title>TypeScript: 2つの変数の値をスワップする</title><link>https://maku.blog/p/k8kw8it/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k8kw8it/</guid><description>TypeScript 独自の構文ではありませんが、ECMAScript 2015 (ES6) で導入された 分割代入 (Destructuring assignment) 構文 を使用すると、2 つ以上の変数を簡単に入れ替えることができます。
let a = 1; let b = 2; [a, b] = [b, a]; 参考: 配列の分割代入で複数の値を同時に代入する (Array destructuring) ｜ まくまくJavaScriptノート</description></item><item><title>npm run スクリプト実行時の ERR! 出力を抑制する (npm run --silent)</title><link>https://maku.blog/p/epm9ipy/</link><pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/epm9ipy/</guid><description>npm run コマンドを使うと、package.json に定義されているスクリプトを実行することができるのですが、そこで実行したコマンドがエラー終了（exit 1 など）すると、npm run の実行自体もエラー扱いとなり、下記のようにエラー情報がたくさん出力されます。
$ npm run test &amp;gt; myapp@1.0.0 test C:\myapp &amp;gt; echo &amp;#34;Error: no test specified&amp;#34; &amp;amp;&amp;amp; exit 1 &amp;#34;Error: no test specified&amp;#34; npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! myapp@1.0.0 test: `echo &amp;#34;Error: no test specified&amp;#34; &amp;amp;&amp;amp; exit 1` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the myapp@1.0.0 test script. npm ERR! This is probably not a problem with npm.</description></item><item><title>npm でインストール済みのモジュールを簡潔にリスト表示する</title><link>https://maku.blog/p/nuvbg6k/</link><pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nuvbg6k/</guid><description>npm list (ls) コマンドは NPM (Node Package Manager) でインストールしたパッケージの一覧を表示するコマンドですが、デフォルトでは依存モジュールをすべてツリー構造で表示するので、出力が大量になります。
インストールパッケージの一覧を表示 $ npm ls myapp@1.0.0 D:\y\gitwork\myapp +-- textlint@11.6.3 | +-- @textlint/ast-node-types@4.2.5 | +-- @textlint/ast-traverse@2.1.7 | | `-- @textlint/ast-node-types@4.2.5 deduped | +-- @textlint/feature-flag@3.1.6 | | `-- map-like@2.0.0 deduped | +-- @textlint/fixer-formatter@3.1.13 | | +-- @textlint/module-interop@1.0.2 deduped | | +-- @textlint/types@1.3.1 deduped ... なが～い出力 ... 次のように --depth オプションを付けると、トップレベルのモジュール名だけを簡潔に表示することができます。
$ npm ls --depth=0 myapp@1.0.0 D:\y\gitwork\myapp +-- textlint@11.6.3 +-- textlint-rule-preset-ja-technical-writing@3.1.3 `-- textlint-rule-web-plus-db@1.1.5 グローバルにインストールしたモジュールを表示するときも同様です。
$ npm ls -g --depth=0</description></item><item><title>見やすいグラフを小さなスペースに描く方法</title><link>https://maku.blog/p/d6n3hwb/</link><pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d6n3hwb/</guid><description>The Economist さんの描くチャートって何かとっても見やすいです。 こんな感じのとか。
昔から The Economist のチャートの見せ方には定評があり、小さいスペースでもわかりやすいチャートにするために、いろいろな工夫がされているようです。
What software package does The Economist group use to create charts and graphs for the magazine? - Quora 簡単にまとめるとこんな感じでしょうか。
短い キャッチーなタイトル （具体的なタイトルはサブタイトルとして記述） データラベルは線のすぐ近く に記述する（凡例ボックスはスペースを食う） 水平ラインは薄く入れ、 垂直ラインは入れない （右端の垂直ラインも入れない） グラフ内に 軸の単位を記述しない （サブタイトルで示せばよい） 軸のラベル名は 最初の値以外は省略名 で記述（例: 2011 → 12 → 13） 色数は少なく （基本は青系ラインのみ、メイン以外は薄く、必要があれば赤系も） 煩雑なブランドロゴを毎回貼らない（The Economist は代わりに赤い矩形でアピール） 次のような入り組んだラインチャートも、部分的にサブチャート化するとか、とても参考になる描き方がされています。 色使いなども、目立たせる部分だけ濃くするなど工夫されてます。
原色の赤を使うのは、本当に目立たせるところだけ。
仕事の資料だけでなく、Web サイトに載せるチャートをシンプルにきれいに描くときの参考になりそうです。</description></item><item><title>ISO 639-2 (alpha-3) 言語コードから Java の Locale オブジェクトを生成する</title><link>https://maku.blog/p/jbs8o3h/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jbs8o3h/</guid><description>Locale クラスは ISO 639-2（3桁）の言語コードを受け付けるのか？ ISO 639-2 (alpha-3) では、言語を 3 桁のアルファベットで識別できるよう定義しています（例: 日本語は jpn）。 この言語識別子を使って、Java の Locale オブジェクトを生成できるのでしょうか？
Java の Locale クラス の説明には、次のように記載されています。
言語に alpha-2 コードと alpha-3 コードの両方がある場合は、alpha-2 コードを使用する必要があります。
また、Locale クラスのコンストラクタ の第 1 引数の説明には、次のように書かれています。
language - ISO 639 alpha-2 または alpha-3 言語コード、または最高 8 文字の言語のサブタグ。
実際に試してみると、alpha-2 コード（2桁）はほぼすべて対応しているのに対し、alpha-3 コード（3桁）は対応がいまいちのようです。
sample.kt fun main() { // alpha-2 で指定 println(Locale(&amp;#34;ja&amp;#34;).displayLanguage) // 日本語 (OK) println(Locale(&amp;#34;en&amp;#34;).displayLanguage) // 英語 (OK) println(Locale(&amp;#34;fr&amp;#34;).displayLanguage) // フランス語 (OK) println(Locale(&amp;#34;zh&amp;#34;).displayLanguage) // 中国語 (OK) // alpha-3 で指定 println(Locale(&amp;#34;jpn&amp;#34;).</description></item><item><title>Java/Kotlin で ISO 3166 国コードの一覧を取得する</title><link>https://maku.blog/p/5weufam/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5weufam/</guid><description>Locale クラスで国コードのリストを取得する Locale クラスの getISOCountries() メソッド を使用すると、ISO 3166 で定義されている国コードの一覧を取得することができます。
String[] Locale.getISOCountries() ISO3166-1 alpha-2（2桁のアルファベット） Set&amp;lt;String&amp;gt; Locale.getISOCountries(Locale.IsoCountryCode.PART1_ALPHA2) ISO3166-1 alpha-2（2桁のアルファベット） Set&amp;lt;String&amp;gt; Locale.getISOCountries(Locale.IsoCountryCode.PART1_ALPHA3) ISO3166-1 alpha-3（3桁のアルファベット） Set&amp;lt;String&amp;gt; Locale.getISOCountries(Locale.IsoCountryCode.PART3) ISO3166-3（4桁のアルファベット） サンプルコード 次の Kotlin コードでは、Locale.getISOCountries() で ISO3166-1 alpha-2 の国コードをすべて取得し、それぞれについて、2桁の国コード、3桁の国コード、国名を表示しています。 Try Kotlin のサイトにコピペして実行できます。
import java.util.Locale fun main() { for (alpha2 in Locale.getISOCountries()) { val loc = Locale(&amp;#34;dummylang&amp;#34;, alpha2) val alpha3 = loc.getISO3Country() val name = loc.getDisplayCountry() println(&amp;#34;$alpha2 $alpha3 $name&amp;#34;) } } 実行結果 AD AND Andorra AE ARE United Arab Emirates AF AFG Afghanistan AG ATG Antigua and Barbuda AI AIA Anguilla AL ALB Albania .</description></item><item><title>Java/Kotlin で ISO 639 言語コードの一覧を取得する</title><link>https://maku.blog/p/wjxanza/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wjxanza/</guid><description>Locale クラスで言語識別子のリストを取得する Locale クラスの getISOLanguages() メソッド を使用すると、ISO 639-1 alpha2 で定義されている 2 桁の言語識別子の一覧を取得することができます。
String[] Locale.getISOLanguages() サンプルコード 次の Kotlin コードでは、Locale.getISOLanguages() で ISO 639-1 alpha-2 の言語識別子をすべて取得し、それぞれについて、2桁の言語識別子、3桁の言語識別子 (ISO 639-2/T)、言語名を表示しています。 Try Kotlin のサイトにコピペして実行できます。
langcodes.kt import java.util.Locale fun main() { for (alpha2 in Locale.getISOLanguages()) { val loc = Locale(alpha2) val alpha3 = loc.getISO3Language() val name = loc.getDisplayLanguage() println(&amp;#34;$alpha2 $alpha3 $name&amp;#34;) } } 実行結果 aa aar Afar ab abk Abkhazian ae ave Avestan af afr Afrikaans ak aka Akan am amh Amharic .</description></item><item><title>国コードや言語コードのまとめ (ISO 3166, ISO 639)</title><link>https://maku.blog/p/tfs5gr3/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tfs5gr3/</guid><description>国コード ISO 3166-1 (country codes) ISO 3166-1 は、国を示すコードとして、短いアルファベットや数値を割り当てています。 日本では JIS X 0304 として標準化されています。
ISO 3166-1 alpha-2 : ラテン大文字 2 桁で国を表す（例: JP、US） ISO 3166-1 alpha-3 : ラテン大文字 3 桁で国を表す（例: JPN、USA） ISO 3166-1 numeric : 数字 3 桁で国を表す（例: 392、840） 下記は、これらの国コードの例です（ISO - Country Codes Collection より）。
Short name Alpha-2 code Alpha-3 code Numeric code JAPAN JP JPN 392 UNITED STATES OF AMERICA US USA 840 UNITED KINGDOM OF GREAT BRITAIN AND NORTHERN IRELAND GB GBR 826 CHINA CN CHN 156 ISO 3166-2 (country subdivision code) ISO 3166-2 では、国より細かい行政区画名（県や州）のコードを定義しています。</description></item><item><title>TypeScriptの環境/設定: 厳格な型チェックを有効にする (strict)</title><link>https://maku.blog/p/7b9432m/</link><pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7b9432m/</guid><description>厳格モードに関するオプション TypeScript の設定ファイル (tsconfig.json) には、厳格な型チェックを有効にするための strict オプションが用意されています。
プロパティ名 デフォルト値 説明 strict false Enable all strict type checking options. コンパイル時の様々な厳格な型チェック機能を有効にします。 tsconfig.json の記述例 { &amp;#34;include&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;ES2015&amp;#34;, &amp;#34;module&amp;#34;: &amp;#34;commonjs&amp;#34;, &amp;#34;allowJs&amp;#34;: true, &amp;#34;outDir&amp;#34;: &amp;#34;./build&amp;#34;, &amp;#34;strict&amp;#34;: true /* Enable all strict type-checking options. */ } } 上記の例では、tsconfig.json で strict オプションを有効にしていますが、tsc コマンドのオプションで --strict と直接指定する方法もあります。
$ tsc --strict 実は、strict オプションは、下記のようなオプション群をまとめて true にするためのオプションです。
プロパティ名 デフォルト値 説明 noImplicitAny false Raise error on expressions and declarations with an implied any type.</description></item><item><title>WSL (Windows Subsystem for Linux) をインストールする</title><link>https://maku.blog/p/sorrvcb/</link><pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sorrvcb/</guid><description> WSL 本体のインストール まず、コントロールパネルから Windows の機能の有効化または無効化 を起動し、Windows Subsystem for Linux にチェックを入れて WSL 本体をインストールします。
Linux ディストリビューションのインストール Microsoft ストアからのインストール WSL 本体のインストールができたら、 Microsoft ストア から Ubuntu や Debian などのディストリビューションをインストールします。 ここでは、Ubuntu よりもサイズの小さい、Debian GNU Linux をインストールしてみました（Debian も apt で各種コマンドを追加インストールしていくことができます）。
インストールが完了すると、Windows メニューから Debian などのターミナルを起動できるようになります。
マニュアルインストール 会社の PC などで、Windows ストアの利用が制限されている場合は、下記サイトからディストリビューションをダウンロードして手動インストールすることができます。
Linux 用 Windows サブシステム (WSL) ディストリビューションを手動でダウンロードする | Microsoft Docs</description></item><item><title>Teams や Slack で PC 画面の一部のキャプチャ画像を簡単に共有する方法</title><link>https://maku.blog/p/92jyhx7/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/92jyhx7/</guid><description>コロナウィルスの影響でテレワークする人が急増し、コミュニケーションツールとして多くの人が Microsoft Teams や Slack を利用するようになってきています。 Teams のチャットで、何かの説明の際に、 自分のデスクトップ画面の一部をキャプチャして共有したい ことがあると思います。 そんなときは、下記のようにすると一瞬で部分的なキャプチャを共有できます。
Windows 10 の場合 Windows + Shift + S で画面の一部分を矩形選択 そのまま Teams や Slack のメッセージ欄で Ctrl + V で貼り付け macOS の場合 Cmd + Ctrl + Shift + 4 で画面の一部分を矩形選択 そのまま Teams や Slack のメッセージ欄で Ctrl + V で貼り付け 上記のようなショートカットキーを使用すると、選択範囲のイメージを直接クリップボードに格納してくれるので、わざわざ画像ファイルに保存したりする必要がなくなります。 慣れると、画面キャプチャをバンバン共有できるようになって、ものすごく意思疎通が捗ります。</description></item><item><title>読書メモ『WORK SHIFT ワークシフト』リンダ・グラットン</title><link>https://maku.blog/p/sj2gu9n/</link><pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sj2gu9n/</guid><description>ワーク・シフト ― 孤独と貧困から自由になる働き方の未来図〈2025〉 リンダ・グラットン プレジデント社 朝 7 時に人工知能エージェントが立ち上がり、壁に 300 件のメールが映し出される。。。
ようこそ！いつも仕事に追われ続ける未来へ！ 『WORK SHIFT』は、『LIFE SHIFT』 でも有名なリンダ・グラットンさんの著書で、人生 100 年時代の働き方改革について考えている人にとってバイブルとされている本です。
私にとっても、これから 何に重点をおいて仕事と向き合っていくべきか という考え方に、少なからず影響を与えてくれた本です。 中でも、 産業革命以前の職人仕事の時代へ回帰していく という表現にはとても共感を覚え、決して専門技術を日々追求しない管理職人間（その企業でしか通用しない人間）にはならないぞと誓いました。
ここ数十年間の「常識的な働き方」とはどんなものでしょうか？
朝 9 時から夕方 5 時まで勤務する 月曜から金曜日まで働いて週末に休む 学校を卒業してから引退するまで 1 つの会社で働きあげる 親や兄弟と同じ国で暮らす いつも同じ顔ぶれの同僚と仕事をする おそらく多くの人が感じているように、こういった従来の働き方・生き方は通用しなくなりつつあります。 そのような未来において、リンダ氏は、次のような 3 つのシフト が必要だと述べています。
広く浅い知識しか持たないゼネラリストから、高度な専門技能を備えたスペシャリストへのシフト ゼネラリスト的な技能を尊ぶ常識は問い直すべきである。 孤独に競い合う生き方から、他の人と関わり協力し合う生き方へのシフト 職業生活とキャリアを成功させる土台が個人主義と競争原理であるという常識は問い直すべきである。 大量消費を志向するライフスタイルから、意義と経験を重んじるバランスの取れたライフスタイルへのシフト どういう職業人生が幸せかという常識を問い直し、消費をひたすら追求する人生から脱却し、情熱的に何かを生み出す人生に転換すべきである。 以下、上記の 3 つのシフトについてメモメモ。
第一のシフト（ゼネラリストから「連続スペシャリスト」へ） 未来の世界では、その他大勢から自分を差別化することがますます重要になる。 そのために、時間と労力を費やして専門分野の知識と技能を高めなくてはならない。 未来の世界では、広く浅い知識を持つのではなく、いくつかの専門技能を連続的に習得していかなくてはならない。
第1のシフトに必要な資質
専門技能の連続的習得 &amp;hellip; 将来ニーズが高まりそうなジャンルの高度な専門知識と技能を身につけ続ける セルフマーケティング &amp;hellip; 自分の能力を取引相手に納得させる材料を確立する 専門性の低い ゼネラリスト的なマネジメント技能（管理職）は、特定の企業以外で通用しない。大企業では、その代わりにそこで働き続けられるという暗黙の契約があったが、そうした契約は徐々に崩れ始めている。しかも専門性の低い技能は、Wikipedia や Google Analytics のようなオンラインサービスによって急速に取って代わられつつある。
長い時間をかけて築いた人脈も、昔ほどの価値を持たない。SNS を利用すれば、誰でも世界中に人的ネットワークを広げられる時代になっている。ゼネラリストからの脱却は、ある意味で産業革命以前の 職人仕事の時代への回帰 でもある。</description></item><item><title>PowerShell で環境変数を扱う</title><link>https://maku.blog/p/jodtbr8/</link><pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jodtbr8/</guid><description>環境変数の値を参照する PowerShell スクリプトの中から環境変数の値を取得するには、$env:変数名 を参照します。
sample.ps1 echo $env:USERPROFILE 環境変数が設定されているかどうかを調べる 環境変数が定義されているかどうかを調べるには、以下のような条件分岐を使用します。
sample.ps1 if ($env:HOME -eq $null) { Write-Host &amp;#39;HOME is not set&amp;#39; } if ($env:HOME -ne $null) { Write-Host &amp;#39;HOME is set&amp;#39; } 値が空である場合も「定義されていない」とみなしたいのであれば、IsNullOrEmpty() でチェックします。
if ([string]::IsNullOrEmpty($env:HOME)) { Write-Host &amp;#39;HOME is not set&amp;#39; exit }</description></item><item><title>PowerShell: 現在の日時を ISO 8601 (YYYY-MM-DD) フォーマットで取得する (Get-Date)</title><link>https://maku.blog/p/9a9n6se/</link><pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9a9n6se/</guid><description>PowerShell の Get-Date コマンドレットを使用すると、現在の日時を表す文字列を取得することができます。
Format、UFormat パラメータで日時の書式を指定する Format Get-Date の Format パラメータを指定することで、任意の書式で日時文字列を取得することができます。
PS&amp;gt; Get-Date -Format &amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34; 2020-03-19 15:23:09 PS&amp;gt; Get-Date -Format &amp;#34;yyyy-MM-ddTHH:mm:ssK&amp;#34; # ISO 8601 2020-03-19T15:23:09+09:00 UFormat UFormat パラメータを使うと、もう少しシンプルに記述できたりします（指定できる記号の一覧はこちら）。
PS&amp;gt; Get-Date -UFormat &amp;#34;%F %T&amp;#34; 2020-03-19 15:26:42 PS&amp;gt; Get-Date -UFormat &amp;#34;%Y-%m-%d %H:%M:%S&amp;#34; # 同上 2020-03-19 15:26:42 PS&amp;gt; Get-Date -UFormat &amp;#34;%FT%T%Z&amp;#34; # ISO 8601 2020-03-19T15:26:42+09 DateTime オブジェクトの ToString メソッドを使用する Get-Date で先に DateTime オブジェクトを取得しておいて、ToString 関数で日時を表す文字列に変換するという方法もあります。
PS&amp;gt; (Get-Date).ToString(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;) 2020-03-19 15:11:37 この方法を使うと、DateTime オブジェクトで日時データを編集してから文字列に変換することができます。 例えば、次の例では、現在から 10 日後の日時を取得しています。</description></item><item><title>PowerShell: バッチファイルから PowerShell を呼び出して結果を変数に格納する</title><link>https://maku.blog/p/372dx46/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/372dx46/</guid><description>Linux や mac では、外部コマンドをバッククォート () で囲んでやるだけで実行結果を取得できますが、バッチファイルで同じようなことをするには FOR /F` コマンドを使用します。 本来は、コマンドの出力結果を一行ずつ処理するためのコマンドですが、次のようにすれば、コマンドの実行結果を一行だけ変数に格納できます。
FOR /F &amp;#34;usebackq delims=&amp;#34; %%A IN (`外部コマンド`) DO set 変数名=%%A FOR ループのパラメータの意味 /F: コマンドの出力結果をループ処理する usebackq: バッククォートで囲まれた文字列全体を外部コマンドとみなす delims=: コマンド実行結果にスペースが含まれていても分割せずに取得（ここではデリミタ文字をなくしている） 上記の 外部コマンド のところで、powershell コマンドを実行すれば、PowerShell で実行した結果をバッチファイル内の変数で受け取ることができます。
例えば、次のバッチファイル (next-month.bat) では、1か月後の日時を PowerShell で求めて、その結果をバッチファイル内の next_month 変数に取得しています。
next-month.bat @echo off setlocal FOR /F &amp;#34;usebackq delims=&amp;#34; %%A IN (`powershell &amp;#34;(Get-Date).AddMonths(1).ToString(&amp;#39;yyyy-MM-dd&amp;#39;)&amp;#34;`) DO set next_month=%%A echo %next_month% 次のように PowerShell で実行するコマンドを分離しておくと見やすいかもしれません。 ps_command 変数の内容を置き換えるだけで、別のコマンドに対応できます。
set ps_command=`powershell &amp;#34;(Get-Date).AddMonths(1).ToString(&amp;#39;yyyy-MM-dd&amp;#39;)&amp;#34;` FOR /F &amp;#34;usebackq delims=&amp;#34; %%A IN (%ps_command%) DO set result=%%A echo %result% 実行結果 C:\&amp;gt; next-month 2020-04-19</description></item><item><title>VS Code の Vim プラグインで OS のクリップボードと同期する (vim.useSystemClipboard)</title><link>https://maku.blog/p/tb6s2ck/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tb6s2ck/</guid><description>Vim エディタ使いにとって、Visual Studio Code の Vim プラグイン はほぼ必須の機能になっています。
Vim - Visual Studio Marketplace デフォルトでは、y キーによるヤンクバッファ（Vim 用語では unnamed register）のコピーが、OS のクリップボードと同期されません。 次のように Vim プラグインの設定を行っておく、OS のクリップボードと同期してくれるようになります。
settings.json で設定する方法 settings.json { &amp;#34;vim.useSystemClipboard&amp;#34;: true, // OS のクリップボードと同期 // ... } 参考: settings.json について 設定画面で設定する方法 Cmd + ,（Windows では Ctrl + ,）で設定メニューを開く Vim: Use System Clipboard の項目にチェックを入れる これで、アプリ間をまたいだコピー＆ペーストを行うことができるようになります。</description></item><item><title>Facebook や Twitter でシェアするときに画像や説明文が表示されるようにする (OGP: Open Graph Protocol)</title><link>https://maku.blog/p/awakw8i/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/awakw8i/</guid><description>OGP とは Web ページ内に、OGP: Open Graph Protocol に基づいた HTML タグを含めておくと、Facebook や Twitter などの SNS アプリで URL 共有したときに、サイト画像や説明文を表示することができます。 下記は、https://www.yahoo.co.jp/ を Facebook で共有したときの表示例です。
図: Yahoo! Japan の例 何も指定しなくても、ある程度はコンテンツから推測して表示してくれますが、想定外の画像が表示されてしまったりするので、ちゃんと指定しておいた方がよいです。
Web サイトに OGP メタ情報を付加する Open Graph タグを使ってメタ情報を付加するときは、主に次のような情報を記述します。
og:site_name : サイト名（og:title の方は個々のページの名前） og:title : ページのタイトル（サイト名は含まれないようにします） og:type : コンテンツの種類（website で OK。ブログ記事の場合は article を使うことも） og:url : ページの URL（絶対パスで指定） og:image : サムネイル画像の URL（絶対パスで指定）。さらに下記を指定することで、ページを最初にシェアするユーザーが画像を表示できるようになります。 og:image:width : サムネイル画像の幅（ピクセル値） og:image:height : サムネイル画像の高さ（ピクセル値） og:description : コンテンツの内容を示す説明文 og:locale : コンテンツのロケール（ja_JP で OK） これらのメタ情報は、HTML の meta 要素として、head 要素内に記述します。</description></item><item><title>Android開発: ダイアログ表示時の背景の暗転（ディミング）を防ぐ</title><link>https://maku.blog/p/voanw2h/</link><pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/voanw2h/</guid><description>Android でダイアログを表示するときに DialogFragment クラスなどを使用すると、デフォルトではダイアログの後ろは暗くなって、下の UI がうっすらと見える状態になります。 このような効果を抑制して、背景が明るいままにするには、ウィンドウから FLAG_DIM_BEHIND フラグをクリアします。
class MyDialogFragment : DialogFragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // ダイアログの中身を独自レイアウトにする return inflater.inflate(R.layout.my_dialog, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) disableBackgroundDimming() } /** ダイアログの背景が暗くなるのを防ぐ */ private fun disableBackgroundDimming() { dialog?.window?.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND) } }</description></item><item><title>新型コロナに便乗してマスクがぼったくり価格に・・・</title><link>https://maku.blog/p/g8o3gu9/</link><pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/g8o3gu9/</guid><description>マスク2万円超えはちょっと高いなぁ・・・。 こんな出品をする人もする人だけど、こーゆーのを野放しにする Amazon も企業としてのあり方が問われますね。</description></item><item><title>TypeScriptサンプル: ジェネリッククラスの定義例（MyStackクラス）</title><link>https://maku.blog/p/tkwj6bw/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tkwj6bw/</guid><description>TypeScript で型パラメータを使用したジェネリッククラスの定義サンプルとして、簡単なスタッククラスの実装例です。 TypeScript の配列がスタックの代わりになるので、スタッククラスなど作る必要はありませんが、Generics の使用例ということで。
myStack.ts export class MyStack&amp;lt;T&amp;gt; { private items: T[] = []; push(item: T): void { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } } 使用例 (main.ts) import { MyStack } from &amp;#39;./myStack&amp;#39;; const stack = new MyStack&amp;lt;number&amp;gt;(); stack.push(1); stack.push(2); stack.push(3); console.log(stack.pop()); //=&amp;gt; 3 console.log(stack.pop()); //=&amp;gt; 2 console.log(stack.pop()); //=&amp;gt; 1 console.log(stack.pop()); //=&amp;gt; undefined</description></item><item><title>Unityスクリプト: 加速度センサー／ジャイロスコープの値を取得する</title><link>https://maku.blog/p/m6hs3dn/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m6hs3dn/</guid><description>加速度センサ (Input.acceleration) 加速度センサからの入力を取得するには、Input.acceleration プロパティを参照します。 Vector3 型で、X/Y/Z 軸の加速度を -1.0 〜 +1.0 の範囲で取得できます。
Vector3 accel = Input.acceleration; 次の例では、Update() のタイミングで加速度を読み取り、画面上のテキストで X, Y, Z 各軸の加速度を表示しています。
Sample.cs using UnityEngine; public class Sample : MonoBehaviour { private Vector3 m_accel; void Update() { m_accel = Input.acceleration; } private void OnGUI() { var rect = new Rect(30, 30, 500, 50); GUI.skin.label.fontSize = 30; GUI.Label(rect, string.Format(&amp;#34;X={0:F2}, Y={1:F2}, Z={2:F2}&amp;#34;, m_accel.x, m_accel.y, m_accel.z)); } } ジャイロスコープ (Input.gyro) ジャイロスコープからの入力を取得するには、Input.gyro プロパティを参照し、Gyroscope オブジェクトを取得します。
Gyroscope gyro = Input.</description></item><item><title>Bot Framework: Web チャットの表示をカスタマイズする</title><link>https://maku.blog/p/oitn3a3/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oitn3a3/</guid><description>Microsoft Bot Framework を使ってウェブサイト上にチャットボットを配置したときの表示のカスタマイズ方法です。 次のように、ボットやユーザーのアイコンを設定することができます。
このようなカスタマイズ表示を行うには、Azure portal 上の Web App Bot リソースの Channels タブから選択できる、Direct Line チャネルを使う必要があります。 Web Chat というチャネルを使うと、iframe タグで簡単にチャットウィンドウを埋め込むことができるのですが、そちらではあまりカスタマイズができないようです。
図: Direct Line チャネルのキーを確認 下記はチャットウィンドウをカスタマイズして表示するサンプルコードです。 Bot Framework が提供している WebChat.renderWebChat() 関数を呼び出すと、実際にチャットウィンドウが表示されるのですが、このときに styleOptions パラメータを指定することで表示方法をカスタマイズすることができます。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.botframework.com/botframework-webchat/latest/webchat.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; * { margin: 0; } #webchat { height: 100vh; width: 100vw; background: gray; border: solid 5px #f37; box-sizing: border-box; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;webchat&amp;#34; role=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const TOKEN = &amp;#39;HpJB2ofxzsA.</description></item><item><title>正規表現: ひらがなとカタカナを正規表現で表す</title><link>https://maku.blog/p/kkaq7q5/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kkaq7q5/</guid><description>ひらがな・カタカナの正規表現 ひらがなの 1 文字、カタカナの 1 文字を正規表現で表すと次のようになります。
ひらがな [\u3041-\u3096] [\x{3041}-\x{3096}] \p{Hiragana} （Unicode 文字プロパティが使える場合） カタカナ [\u30A1-\u30FA] [\x{30A1}-\x{30FA}] \p{Katakana} （Unicode 文字プロパティが使える場合） 参考 Wikipedia: Hiragana (Unicode block) より
Wikipedia: Katakana (Unicode block) より
参考リンク TypeScriptサンプル: 文字列内のひらがなとカタカナを変換する</description></item><item><title>TypeScriptサンプル: 文字列内のひらがなとカタカナを変換する (hiraToKana, kanaToHira)</title><link>https://maku.blog/p/tzjvcad/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tzjvcad/</guid><description> util.ts export class Util { /** * 文字列に含まれているすべてのひらがなをカタカナに変換した文字列を作成します。 * ただし、半角文字は変換しません。 * @param str ひらがなを含む文字列 */ static hiraToKata(str: string): string { return str.replace(/[\u3041-\u3096]/g, ch =&amp;gt; String.fromCharCode(ch.charCodeAt(0) + 0x60) ); } /** * 文字列に含まれているすべてのカタカナをひらがなに変換した文字列を作成します。 * ただし、半角文字は変換しません。 * @param str カタカナを含む文字列 */ static kataToHira(str: string): string { return str.replace(/[\u30A1-\u30FA]/g, ch =&amp;gt; String.fromCharCode(ch.charCodeAt(0) - 0x60) ); } } 使用例 import { Util } from &amp;#39;./util&amp;#39;; console.log(Util.hiraToKata(&amp;#39;あいうアイウ&amp;#39;)); //=&amp;gt; アイウアイウ console.log(Util.kataToHira(&amp;#39;あいうアイウ&amp;#39;)); //=&amp;gt; あいうあいう 参考リンク ひらがなとカタカナを正規表現で表す</description></item><item><title>Azure: デプロイスロットでリリース時のダウンタイムをなくす（Blue-Green デプロイメント）</title><link>https://maku.blog/p/bog7iq8/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bog7iq8/</guid><description>なぜデプロイスロットが必要か？ App Service を作成すると、デフォルトでは運用スロット (production slot) がひとつだけ作成され、Azure Repos や GitHub からのアプリケーションのデプロイ先として使用されます。
アクセスの少ないアプリケーションであればこれでも問題ありませんが、デプロイ後にサーバー上でのビルド処理（ウォームアップ）が走るようなケースでは、少なからずダウンタイムが発生してしまいます。
このようなダウンタイムの発生を防ぐために、ステージング用のスロット (staging slot) を用意し、そこでのウォームアップが完了した後で運用スロット (production slot) と入れ替えるという方法を取ります。
GitHub or AzureRepos ─デプロイ→ staging スロット ↑ (スワップ) ↓ production スロット このようにサーバーインスタンス（ここではスロット）を 2 つ用意して、内容をスワップ（実際はアドレスをスワップ）することで運用環境を瞬間的に入れ替える手法を Blue-Green デプロイメント とか、A/B アップデートと呼びます。
Azure の App Service は、 デプロイスロット (Deployment slots) という機能名で、Blue-Green デプロイメントをサポートしています。
図: App Service の Deployments slots 設定 デプロイスロットを使ったスワップ運用には次のような利点があります。
ステージング環境 (staging slot) で事前に動作検証できる 運用環境 (production slot) のダウンタイムをほぼゼロにできる 運用環境 (production slot) で問題が発生したら、再度スワップして前のバージョンに戻すことができる App Service にステージング環境用のデプロイスロットを追加する デプロイスロットの作成 まず、App Service に新しくステージング環境用のデプロイスロット (Deployment slots) を作成します。 対象となる App Service のリソースを選択し、次のように選択するとデプロイスロットの追加ダイアログが開きます。</description></item><item><title>Unityスクリプト: キー入力を取得する (UnityEngine.GetKey)</title><link>https://maku.blog/p/xitjt3c/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xitjt3c/</guid><description>キーが押されているか調べる (GetKey) UnityEngine.GetKey() 関数を使用すると、指定したキーが現在押されているかどうかを調べることができます。 次の例では、Update メソッド内で上カーソルキーと下カーソルキーが押されているかどうかを調べ、入力状態によって Cube オブジェクトを上下に動かしています。
using UnityEngine; public class Sample : MonoBehaviour { private GameObject _cube; private void Start() { _cube = GameObject.CreatePrimitive(PrimitiveType.Cube); } private void Update() { float amount = 0; if (Input.GetKey(KeyCode.UpArrow)) { amount = 3; } else if (Input.GetKey(KeyCode.DownArrow)) { amount = -3; } _cube.transform.Translate(0, amount * Time.deltaTime, 0); } } 継続的にオブジェクトの位置を動かす場合、上記のように移動量に Time.deltaTime をかけることで、1 秒あたりの移動量を示すことができます。
単発のキー入力 (GetKeyDown/ GetKeyUp) UnityEngine.GetKey() 関数の代わりに、GetKeyDown() や GetKeyUp() 関数を使うと、指定したキーが押された瞬間、あるいは離された瞬間を調べることができます。</description></item><item><title>チコちゃん財布がいい感じ</title><link>https://maku.blog/p/vrfv4zw/</link><pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vrfv4zw/</guid><description>チコちゃんに叱られる！のチコちゃんにはまっているので、『チコちゃんがまぐちポーチ』 をげっちゅ。
小さめなので基本は小銭入れ用途かな。お札も折りたためばギリギリ入ります。
ふわふわだし、この顔見てるだけで癒されるよ～。 財布だけど飾っておきたい。 けど飾っておいたら盗まれちゃうな（笑）
やっぱりキャラクターグッズはいいですね。</description></item><item><title>Androidメモ: RecyclerView にアニメーションを追加する方法</title><link>https://maku.blog/p/8avcr5h/</link><pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8avcr5h/</guid><description>Android の RecyclerView にリスト表示する各要素を、左や右からスライドインさせながら表示する方法を説明します。
RecyclerView へのアニメーション追加方法 RecyclerView の各要素をアニメーションさせるには、下記のような方法があります。
カスタム ItemAnimator を作成してセットする方法 LayoutAnimation をセットする方法（RecyclerView だけでなく、すべての ViewGroup に適用できます） 1 の方法を使うと、アイテムの追加・削除に応じたアニメ―ションを定義できるので、柔軟なカスタマイズが可能になりますが、2 の方法であれば、アニメーションの定義だけを行えばよいので簡単です。 ここでは、シンプルな 2 の方法を説明します。
アニメーションの定義は、XML 形式のリソースファイルで行います。 ディレクトリ名やファイル名は任意ですが、通常は res/anim/xxx.xml のような名前にし、コードの中から R.anim.xxx と参照できるようにします。
要素を左からスライドインさせる 下記の res/anim/slide_from_left.xml リソースでは、画面内の要素をどのように表示するかを定義しています。
res/anim/slide_from_left.xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layoutAnimation xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; android:animation=&amp;#34;@android:anim/slide_in_left&amp;#34; android:delay=&amp;#34;10%&amp;#34; android:animationOrder=&amp;#34;normal&amp;#34; /&amp;gt; 各属性の説明です。
android:animation=&amp;quot;@android:anim/slide_in_left&amp;quot; 個々の要素がどのようにアニメーションするかを指定します。ここでは、Android にあらかじめ定義されている slide_in_left を指定しています。 android:delay=&amp;quot;10%&amp;quot; 1 つ前の要素のアニメーションが何％まで完了してから、次の要素のアニメーションを開始するかを指定します。100% と指定すると、各要素のアニメーションが完全に終了してから次の要素のアニメーションが開始されるため、すべての要素が表示されるまでに非常に時間がかかります。 android:animationOrder=&amp;quot;normal&amp;quot; 要素がどのような順番で表示されていくかを指定します。normal、reverse、random などを指定できます。 ここでは、個々の要素のアニメーション方法として、Android 付属の @android:anim/slide_in_left を使っていますが、これは次のように定義されています。
@android/anim/slide_in_left（抜粋） &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;set xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; &amp;lt;translate android:fromXDelta=&amp;#34;-50%p&amp;#34; android:toXDelta=&amp;#34;0&amp;#34; android:duration=&amp;#34;@android:integer/config_mediumAnimTime&amp;#34;/&amp;gt; &amp;lt;alpha android:fromAlpha=&amp;#34;0.</description></item><item><title>読書メモ『アンドロメディア』渡辺浩弐</title><link>https://maku.blog/p/fycnw8h/</link><pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fycnw8h/</guid><description>アンドロメディア 渡辺浩弐 幻冬舎文庫 『中野ブロードウェイ脱出ゲーム』の中に、アンドロメディアというワードが出てきたので、その元ネタになっている小説も読んでみました。 同じコージィ先生の著作です。 アンドロメディアは映画化 (1998) もされてるみたいですね。 しかも SPEED 主演ですか。。。 原作と全然内容が違うらしいですけど今度見てみよう。
小説の方は、自分とまったく同じように振舞うバーチャルアイドル (AI) を作られてしまったアイドル「人見舞（ひとみマイ）」のお話です。
バーチャルアイドルの AI（アイ）は、自分（マイ）とは違う存在のはずなのに、だんだん自分の記憶と現実が曖昧になっていきます。 章ごとに一人称となる人物が変わっていて、人見舞とバーチャルな AI の話が別々の視点で進んでいきます。
1章は舞 2章はAI 3章はユウ 4章はAI/舞/ユウ これって、ドラクエ4と同じような構成ですね。 最初は各人物ごとにストーリーを進めておいて、最終章で合流という。
ちなみに、メインキャラの名前は、I / My / You となっていて覚えやすいです。 これは『中野ブロードウェイ脱出ゲーム』の登場人物と同じです。
I / My / You のそれぞれ異なる視点でストーリーを追っていくと、それまでの各人物の奇妙な振る舞いの謎が少しずつ解けていきます。
もともと AI には、ロボットの三原則ならぬ「AI 三原則」が設定されていました。
第1条、AI は人間に危害を加えてはならない 第2条、AI は人間に与えられた命令に服従しなくてはならない 第3条、AI は第1条、第2条に反する恐れのない限り、自己を守らなくてはならない あるときユウは、この AI 三原則の順番を書き換えてしまいます。 するとどうなってしまうのか。。。 それは読んでからのお楽しみということで。
AI はコピー元となった舞の記憶にはかなわないということで悲しみを覚えます。 そんな AI に対して、ユウがかけた言葉が印象的でした。
記憶はデータとしてコピーできる。でも、思い出は自分自身で体験しなければ得られない。
思い出は、自分自身 (AI) だけが作っていけるものなんだよと。 とても素敵な言葉ですね。
近い将来、このお話と同じような世界が訪れるかもしれません。 わたしもいつか AI に出会ったら、ユウと同じような言葉をかけてあげようと思います。
ちなみに、この小説のジャンルは SF ホラーとなっており、結末はちょっと怖いです。 伏線はところどころのセリフに出てきます。</description></item><item><title>読書メモ『君がオヤジになる前に』堀江貴文</title><link>https://maku.blog/p/br3bjs2/</link><pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/br3bjs2/</guid><description>君がオヤジになる前に 堀江貴文 徳間書店 若者たちの会話には、不満や不安があふれている。 仕事が大好きというホリエモンが、そんな不安の正体を明らかにし、どういう考え方をしていれば思考の停止した「オヤジ」にならずに済むかを語ります。
表紙の青年は福本伸行先生の漫画『天』の主人公なんですね。 いざという時に守りに入ってしまい、いまいち突き抜けることができない若者の象徴なのだとか。 巻末には福本伸行とホリエモンの対談も載ってます。
以下、メモメモ。
25 歳の君へ、
安定を求めようとする努力のプロセスの中で、人は不安定になっていく。 ─ 不安さの中でうまく生きていくスタイルを取るべきなのだ。 週末起業はお勧めしない。独立を一度でも経験しておくと、ビジネススキルが飛躍的にアップする。 ─ 財務管理能力が身に付く。 食習慣の均質化は、思考を停止させる可能性をはらんでいる。 流行歌を聴けば、時代を象徴している言葉に触れることができる。 様々な場面で法律をもっと勉強した方がいい。 ─ 上司に可愛がられるより、法に詳しくなる方がよほどセーフティだ。 社員を大勢雇うのはリスキーすぎる。 刻一刻と人生の最盛期は過ぎている。上司への媚びを捨て、独立を真剣に考えろ。 ハタチの子たちを面白がらせる話題を持っている 70 歳なんて素敵じゃないか。そのためには、やはり色々なことに興味を持っておきたい。 最近は、リスクを減らしつつ起業する方法として週末起業を勧める人が増えていますが、ホリエモンはもっとリスクを取れという立場を貫いていますね。 中途半端では身につくものも身につかないし、本当に好きなことがあるのであれば、そこに限られた人生の時間を注ぎ込むべきだという意見はもっともです。 頭のいい人は、うまくいかなかったときの将来を想像できてしまうから一歩が踏み出せない。 何事も、一歩を踏み出すには、一時的にでもバカにならなきゃですね。
32 歳の君へ、
これだけネットが普及すると、アイディアに価値はない。 アイディアよりも、圧倒的に大事なのは実行力だ。 知らない。面倒臭い。やり方を変えたくない。こういう人たちを、僕は「情報弱者」と呼ぶ。 どうやって仕事の幅を広げればいいのか。ひと言、仕事先に 「お客さんを紹介してください」と言えばいい。 ─ 「お客さんが欲しい」という言葉は、意外と効率的だ。 異業種交流会には、そもそもビジネスチャンスは存在しないので行く必要はない。 まっとうなビジネスマンなら、売るのは顔じゃなく仕事だろう。 英語をアドバンテージだと感じているならオヤジ化が始まっている。 会社で育つ人間は勝手に育つし、育たない人間を切る方が実利的だ。 もし収入が減ったとしても、月収 100 万円でつまらない仕事を続けるとの、好きなことだけやって得られる 30 万円とでは、幸福度がまったく違うだろう。 人間の恐怖の大半は、情報不足が原因だ。 ホリエモン自身は、自分について来れない友人や仕事仲間はどんどん切り捨てていくことで成長してきたと言います。 友人や家族をバッサリと切り捨てられるほど打ち込めることがあるのは幸せなのでしょう。 最適な人脈は、成長した自分のレベルに合った人たちで新しく作っていく。 言われてみれば、それが効率という面ではもっとも優れた人脈の作り方なんでしょうけど、多くの人はそこまでは踏み切れない。。。
35 歳の君へ、
もっと会社の経費に対してうるさく言った方がいい。それが結果的に、思考力のある社員を育てることに繋がる。 タクシー代も出せないような仕事をしているのなら、その仕事には何の価値もない。 どんなに忙しくても、 絶対に 8 時間ほどの睡眠時間 はとっている。 ─ ショートスリーパーの多くは記憶力が悪い。 包容力も、これからのビジネスには必要なのかもしれない。もっと言うなら、他人への無償の愛は、効果的なトレードオフのひとつということだろう。 偉大な経営者やバンドなどの考え方に触れるうちに、「包容力」というもの可能性も感じてきているようです。 包容力とか、あまり論理的には語ってほしくはないところですけどねｗ
引き寄せの法則じゃないですが、まわりへの配慮が結局自分のためになるというのは絶対にあると思います。 そこに気づいている人と気づいていない人では、生き方に大きな差がありそう。</description></item><item><title>Unityスクリプト: デバッグログを表示する (Debug.Log)</title><link>https://maku.blog/p/bxcp2dp/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bxcp2dp/</guid><description>デバッグログの基本 Debug.Log() 系の関数を使用すると、Unity の Console ビュー内にデバッグ用ログを出力することができます。
Debug クラス public static void Log(object message); public static void LogWarning(object message); public static void LogError(object message); デフォルトのレイアウトでは、Conosle ビューは画面の下の方に配置されています。
Debug.Log() の代わりに、Debug.LogWarning() で警告レベルのログ、Debu.LogError() でエラーレベルのログを出力できます。 Console ビュー上に表示されるアイコンも変化します。
Debug.Log() の使用例 using UnityEngine; public class Sample : MonoBehaviour { void Start() { Debug.Log(&amp;#34;Normal Log&amp;#34;); Debug.LogWarning(&amp;#34;Warning Log&amp;#34;); Debug.LogError(&amp;#34;Error Log&amp;#34;); } } デバッグログをゲームオブジェクトに関連づける Debug クラス public static void Log(object message, Object context); public static void LogWarning(object message, Object context); public static void LogError(object message, Object context); Debug.</description></item><item><title>Unityスクリプト: 空のゲームオブジェクトを作成する (GameObject)</title><link>https://maku.blog/p/j4fqyaj/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j4fqyaj/</guid><description>GameObject クラス public GameObject(); public GameObject(string name); public GameObject(string name, params Type[] components); Unity のシーンは、様々なゲームオブジェクトを配置することで構築していきます。 GameObject クラスのコンストラクタ を使用して、空の GameObject インスタンスを生成することができます。
GameObject インスタンスを生成した後は、そこにコンポーネントを追加することで、オブジェクトの性質を付け加えていくことができます。
次の例では、MyGameObject という名前を付けて空のゲームオブジェクトを作成しています。 作成した GameObject インスタンスはフィールドで保持していませんが、明示的に削除するまではシーン上に残ります。
using UnityEngine; public class Sample : MonoBehaviour { void Start() { var obj = new GameObject(&amp;#34;MyGameObject&amp;#34;); } } 動的に作成されたゲームオブジェクトは、Hierarchy ビュー上で確認することができます。
空のゲームオブジェクトであっても、Transform コンポーネントだけはデフォルトで設定されているため、座標を移動するための矢印が画面上に表示されます。</description></item><item><title>読書メモ『中野ブロードウェイ脱出ゲーム』渡辺浩弐</title><link>https://maku.blog/p/kexfxfv/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kexfxfv/</guid><description>中野ブロードウェイ脱出ゲーム 渡辺浩弐 KADOKAWA 中野ブロードウェイに住んでいるという噂（自称）の渡辺浩弐氏による、中野ブロードウェイ物の長編小説です。 そういえば、PC エンジンミニがもうすぐ発売ということもあって、渡辺さんまた元気になってきましたね。
YouTube - PCエンジン mini / 全収録タイトル渡辺浩弐氏解説付トレーラー 大竹まことのただいま!PCランドで大活躍されていたころの記憶が蘇りました。 ほんといい番組でした。 渡辺さんのゲーム紹介の調子、全然変わってないｗ
と話がそれましたが、肝心の小説の内容はというと、屋上で少女と2人で裸になって戯れていたら、突然中野ブロードウェイが恐ろしい世界に変化して人が死に始める、、、というちょっと不思議で怖いお話です。 著者の、中野ブロードウェイへの愛が伝わってくる感じで、中野ブロードウェイを探索したことのある人であれば、これはあの辺のことを言っているのだなと想像しながら楽しめます。
前半は人間ドラマっぽい話が続いていくのですが、後半（400ページくらい）から渡辺節が始まって、科学的な裏付けが始まります。 口コミなんかを見ると、前半で読むのを止めちゃった人が多そうなのですけど、後半から違う話なので（笑）、読み続けて欲しいですね。 現在のコンピュータ技術を超える◯◯コンピュータや、昔、日本が実際に作ったという風船爆弾の話などが出てきます。 同名の小説もある『アンドロメディア』なども出てきます。
個人的には結構楽しめました。 最後まで読んで、何か似てる情景があったなぁと思ったら、『天気の子』でした。 渡辺先生、だいぶ先取りしましたね。
渡辺浩弐さんの小説といえば 『ゲーム・キッズ』 シリーズだと勝手に思っていますが、長編ものも読んでみようと思って読んでみました。 でもやっぱり700ページはちょっと長かったな。。。</description></item><item><title>プログラムでレインボーカラー（虹色）のグラデーションを作成するには</title><link>https://maku.blog/p/4cbbh6o/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4cbbh6o/</guid><description>とあるコーディングにおいて、色を滑らかに変化させる必要があったのでメモメモ。
RGB ではなく HSV で考える 何らかのプログラミング言語から虹色のグラデーションを作る必要がある場合、RGB の色空間で色調整を行うのは大変ですが、HSV の色空間で考えると簡単に表現することができます。
図: HSV 色空間 参考: HSV 色空間 - Wikipedia HSV はそれぞれ下記のような情報を表しており、
色相 (Hue): 0～360 彩度 (Saturation・Chroma): 0～1 明度 (Value・Brightness): 0～1 このうち、色相 (Hue) の値を 0～360 の間で変化させてやることでレインボーカラーを表現することができます。
プログラムのサンプル 図: 虹色グラデーションの描画 例えば、Android では、android.graphics.Color.HSVToColor() という関数を使用すると、HSV 色空間における値を、描画に使用するカラーデータに変換することができます。
下記の ColorGenerator クラスの nextColor() メソッドを連続して呼び出すと、徐々に変わっていく色をひとつずつ取り出すことができます。 やっていることは、メソッドの呼び出しごとに、色相 (Hue) の値を少しずつ変化させているだけです。 色相 (Hue) が、何度の nextColor() 呼び出しで一周するかは、コンストラクタの steps パラメータで指定できるようにしています。
ColorGenerator.kt class ColorGenerator(val steps: Int, initialHue: Float = 0.0F) { private val hueStep: Float = 360F / steps private var currentHue = initialHue fun nextColor(): Int { val hsv = floatArrayOf(currentHue, 1.</description></item><item><title>読書メモ『起業家』藤田晋</title><link>https://maku.blog/p/cr83qcw/</link><pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cr83qcw/</guid><description>起業家 藤田晋 幻冬舎 Abema TV で大躍進を続けている（今年 1000万 WAU を突破！）サイバーエージェントが、かつてメディア事業にかじを切った経緯などが述べられています。
2006 年の当時、サイバーエージェントには CAJJ 制度というものがあり、赤字の上限を超えた事業は撤退しなければいけませんでした。 でも、メディア事業であるアメーバだけは例外として進めました。 現在、先行投資を続けている Abema TV も同じ方針なのでしょう。
メディア事業では最初は売り上げを見ずに、ページビューだけを追求する。 そうした会社の方向転換には、みんな簡単にはついてきてくれなかった。
これまでにない収益構造で赤字を出しながら事業を進めていくには、大変な勇気がいると思います。 藤田氏はどのような決断を下していったのか・・・
ネット業界で大きくなっていくためには、何よりも強いメディアを持つことが必要不可欠な条件だった。
アメーバを含むメディア事業で、身をもってこういった経験をしてきたからこそ、今 Abema TV で視聴率を上げることに力を入れ続けているのでしょう。 社長がこういった強い意志を持っている会社は強いですね。 この方針は意地でも貫き通すと気持ちが伝わってきます。 社員も目標を持って働きやすいと思います。
当時のサイバーエージェントの上層部にはエンジニアは一人も存在していませんでした。 だから、ユーザー向けに面白いサイトを作り上げることが、どれだけ難しいことか、理解すらしていなかった。 また、買収は時間を買うという意味がありますが、ネット業界において、先行するメリットが、1年早いことが金額に換算してどれほど大きなことなのか、本当の意味では分かっていなかった。
今でこそ会社の上層部には技術的志向の強い人が必要だというのは常識になっていますが、インターネット系の事業がどうあるべきかを模索していた時代にはいろいろと失敗があったようです。 サイバーエージェントも2000年のマザーズ上場後、4年連続で営業赤字を出していましたが、優秀なエンジニアの大切さ、メディアを持つことの大切さに気付いてからは黒字で成長を続けています。 ネットメディアの場合、ページビューを伸ばすのに必要なのは、コンテンツの力が3割、残りの7割は技術力、と言っています。 Abema TV が驚くべき選局スピードを達成できているのは、技術に力を入れてきた成果なのでしょう。
新卒採用位に優秀な人材を獲得しておかないと、中途採用だけで人材を揃えるのは困難です。 優秀な人材は新卒で大企業に入ってしまうと、簡単には辞めず中途市場に出てこないからです。
サイバーエージェントでは、終身雇用を目指し、長く働く人を奨励するというメッセージを打ち出しています。 終身雇用というと時代の流れに逆行しているようにも感じてしまいますが、藤田氏は社員を大切にする会社になるという意思を持って会社を育てています。 このようなメッセージを打ち出したことで、社員が元気な姿を取り戻していきました。 福利厚生に力を入れるのも、「社員を新たに採用するのにかけるコストよりも、長く働いてもらうためにお金を使った方が安くて効果的」という合理的な判断のもとに行っています。
会社が「社員を大事にするよ」と呼びかければ、社員も「会社を大事にしよう」と応えてくれる。 外から採用した人を最初から上層部に登用することはない。中で頑張っている人がしらけるようなことはしない。 こういった考え方って、ほとんどの企業ができていないと思います。 大企業の天下りのような人を雇ってきて、いきなり経営陣に組み入れるというやり方が横行しています。
新規事業に投資する際の基準となるルール（CAJJ制度）を作った。 このルールに則ってさえいれば、いくらでも新規事業の立ち上げ数を増やすことができる。
先行投資は、
1年半で黒字化しないと撤退 赤字に下限を設ける という2つの柱のもとに進めており、「小さく生んで大きく育てる」ためのベースになっているようです。 確かにこのやり方であれば、先行投資にかかる費用も見積もりやすいです。 サイバーエージェントが連結業績で黒字を出し続けていることも納得できます。 ただ、1年半で黒字化というのはなかなか厳しいですよね。 事業も限られそうですが、このあたり何かコツがあるのか聞いてみたいです。
メディア事業を育てるために社長がやったこと インターネットメディアの力に皆が気付いていないころ、藤田氏は、自分がメディア事業に力を入れていることを社員に伝えるため、自分自身が変わらないといけないことに気付きました。 下記は、そんな藤田氏が具体的にやってきたことですが、経営者が社員に意思を伝えるためのよい見本になると思います。
7年過ごしたマークシティ21階の社長室を離れ、アメーバ事業部が入るビルに社長室ごと移動した。 自分のスケジュールをアメーバ関連の予定で全て埋め尽くした。 スーツを着るのをやめた（話しかけにくいイメージを作らない）。 期限までにページビューが〇億超えたら熱海旅行、△億超えたら沖縄旅行というインセンティブを設定した。目指すのはページビュー1本であることを伝えた。30億ページビューを目指す！という目標が浸透し、組織が一つになっていった。 自分にも正しいかどうか分からないが、ブレる姿だけは決して見せないようにした。 2007年にプロデューサー組織を初めて作った。彼らの目標は「ページビュー数」ただ一つ。とにかくページビュー数を伸ばせば評価されるという組織にした。 一番重要なのは、サーバーのレスポンスを上げること。快適なレスポンスが最もページビューに影響する。 ユーザー視点からブレたサービスは、世に出さないと決めていた。どんなに時間をかけて開発したサービスでも、私がOKを出さない限り、絶対にリリースさせない。知らない広告枠が勝手に追加されていたら、「誰がやったんだ！」とスタッフが硬直するほど怒った。 社外の方との会食を極力減らし、アメーバの社員、特に技術者と食事に行く回数を増やした。 成功を重ねるたびに孤独の度合いは増していきます。それでもなぜ前に進もうとしているのか──</description></item><item><title>文房具: ペリカンの万年筆スーベレーンのペン先は外せる</title><link>https://maku.blog/p/4ku4ckt/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4ku4ckt/</guid><description>文房具が好きです。
万年筆を使うと字が綺麗になる（気がする）ので、使える場面ではなるべく万年筆を使うようにしています。 最近はお手軽なスケルトン万年筆の 『PILOT プレラ』 をよく使っています。 キャップがねじ式じゃないのでサッと外して、すぐに書けるのがすばらしいです。
社会人になってから初めて奮発して買ったのが 『ペリカンのスーベレーン M400』 でした。 もう何年も使っているのですが、今日、インクの入れ替えのためにペンを洗浄していたら、ペン先を外せることに初めて気がつきました。
ペン先をティッシュでくいっとひねるだけで外れます。 きっと長年使っているうちにすこしずつ緩んできて外れやすくなってたんでしょう。 こんな風に外せるなら、このペン先だけを水につけ置き洗いできますね。 他の万年筆のペン先も同じように外れるかもしれないので、万年筆を持っている人は洗浄時に試してみるといいかもしれません。
ちなみに、ペン先だけを購入することもできるようですが、スーベレーンはペン先だけで1万5000円以上しますね。。。 まぁ、一番大切なところなので、この値段で交換できるのは安いのかもしれません。</description></item><item><title>本は汚く読んだ方がいい</title><link>https://maku.blog/p/cr2hrvx/</link><pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cr2hrvx/</guid><description>自分の本の読み方が、昔と比べてどんどん変わってきている気がするのでちょっとだけ紹介。 どんなことを考えて読むかというより、物理的な本の扱い方の話です^^)
本の自炊はしない 本を裁断してスキャンする通称「自炊」は昔流行りましたよね（今もやっている人はたくさんいますが）。 10 年以上前だと思いますが、わたしも Scansnap を買って、本をスキャンしまくりました。
本を電子化してしまえば、重い本を持ち歩かなくて済むし、家のスペースも取りません。 そんなメリットに惹かれて、いろいろスキャンしていましたが、しかし、しばらくして気が付きました。
電子化するとその本は読まなくなる！ PDF ファイルになった時点でいつでも読めると安心してしまうのか、全然読まないのです。 読む機会が増えると思っていたのですが、タブレットなどでファイルを開くのが逆に面倒くさい。。。
やっぱり読むべき本は、物理的な積読（つんどく）状態にしておいた方がいいことに気が付きました。 それに、自炊している時間があったら、数十ページくらいは読めてしまうので、自炊する暇があったら本を読む時間に使った方がいいということにもやってみて気付きました。
というわけで、我が家の Scansnap は年賀状のスキャンとか、重要な書類のスキャンなどにしか使っていません。
本には書き込みまくる あなたは本を読むとき、線を引いたり、書き込んだりしますか？ わたしはめっちゃ書き込みます。 それこそ消耗品のノートのように。。。 ただ単純に読んでいるところを鉛筆でなぞりながら読み進めることもあります。
後から本の内容をまとめたりする場合は、この書き込みが参考になります。 そのとき思ったことをその場で書き込んでおけば、内容を思い出しやすくなります。 だから、書き込みの内容は、なるべくまとめるときのことを考えて書くようにします。 まとめやすいように自分なりに番号を振るだけのこともあります。
本に何も書き込まないという人は、あとからその本をブックオフに売ったり、友人にあげたりすることを想定しているのかもしれません。あるいはコレクション目的かもしれません。 でも本当にそういったことをしている人はどれだけいるのでしょう？ もし、自分のために残しておくだけの本であれば、その本がきれいなまま残っていることに本質的な価値はないはずです。 自分が死ぬときのことを思い浮かべてみてください。 本がそこにきれいに残っていることに意味はなく、それまでにどれだけ自分の血肉になったかが大切なはずです。
お風呂で読むときはパワータンク or 鉛筆 そんなわけで、長く保存しそうな本以外はお風呂に持ち込んで読んだりもします。 濡れてシワシワになろうが気にしません。 大切なのは本の内容をどれだけ吸収できたかなので。
お風呂読書するときに役に立つのが、『パワータンク』 というボールペンです。 このペンはお風呂の中に落とそうが、上向きに書こうが平気で書き続けることができます。
鉛筆でもいいのですが、鉛筆は木でできているので、濡らすのは若干抵抗があります。 アンケートやゴルフのときによく使われるペグシル（クリップペンシル）のようなプラスチック製の鉛筆はよいかもしれません。 ソニックのクリップペンシルはちょっとオシャレでかわいい。
ソニック クリップペンシル 本を読み進めた達成感を味わう たくさんの本を並行して読み進めているとき、どの本をどこまで読んだかを覚えておくのは大変です。 しおりや付箋で解決できることもありますが、ページを飛ばしながら読んでいるときは、付箋だらけになっちゃいます。 こんな場合は、読んだページの端っこを切っていく という方法をとったりします。 読んだことのあるページと、まだ読んでいないページが、ページ単位で一目瞭然になります。
あと最近、コクヨの 『静音シュレッダー』 を導入したのですが、読み終わったページをこれにどんどんかけていくと爽快です。 読めば読むほど本が薄くなっていくので、読み進めているんだという達成感を味わえます（もう一度読み返したいページは残しておいた方がよいですが）。
このシュレッダーはとても静かで、真夜中に動かしても全然気にならないのでオススメです（会社に置いてあるようなシュレッダーってものすごくうるさい…）。 シュレッダーの問題点は、ゴミの嵩が増えるところですね。 でもやみつきになります。
電子書籍 電子書籍はソニーの Reader Store と、アマゾンの Kindle Store を愛用しています。 『Kindle 本体』 は防水モデルが出たので、お風呂で読めていいですよね。</description></item><item><title>全ページをパーマリンク化しました</title><link>https://maku.blog/p/7yhxet9/</link><pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7yhxet9/</guid><description>本サイトのすべての記事が、https://maku.blog/p/XXXXXXX という 7 桁の ID をベースにした URL でアクセスできるようになりました。 これまではサイトの構造が変わると URL が変わってしまいましたが、今後は URL は固定化されるのでリンク切れの心配はありません。
安心して個々のページにリンクを張ってください ٩(๑❛ᴗ❛๑)۶
ちなみにこのページのリンクは https://maku.blog/p/7yhxet9 です。</description></item><item><title>メガドライブミニを買ったよ！完成度高い！</title><link>https://maku.blog/p/7zgwds7/</link><pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7zgwds7/</guid><description>ひさびさにいい買い物をしたよー。 『メガドラミニ』 です！
迷っていたけど、我慢できなくなってポチりました。 あースッキリしたw やっと届いたので開封の儀です。
こちらがパッケージ。わくわく。
ゲームはよりすぐりのものが 40本以上 も入っているのですが、 2 人同時プレイできるものも半分くらい入ってます。 だから、コントローラーは当然 2 個セットをチョイス。 6 ボタンだから、スト2ダッシュプラスの操作性もバッチリです。
箱はとってもコンパクトで、左側にコントローラー2個、右側に本体とケーブルがみっちり詰まってます。
ジャーン。 どうでもいいけど、HDMI ケーブルと USB ケーブルってガジェット買ってるとどんどん溜まってくよね。。。みんなどうしてるんだろう。 あと、本体はともかく、ケーブルや説明書を全部ビニル袋に入れるのは過剰包装ですよね。改善して欲しい。
テレビとは HDMI ケーブルでつないで、電源は USB からの給電です。 うちはソニーの BRAVIA (Android TV) ですが、テレビの USB コネクタから給電できました。AC アダプタとか使わないでいいので配線はとてもスッキリします。 ケーブルは 2 本ともテレビにつなぐので、写真のようにケーブルを束ねちゃいました。 使ったのはコントローラーのケーブルとか束ねてあったやつ。ゴミは出さずに活用♪
電源スイッチをカチッとスライドすると、すぐにゲーム選択画面になります（^O^) いいっ。 発売日順、ジャンル別、1〜2人用などソート方法もサクッと切り替えられます。
こちらが発売前から話題となっていた、メガドラミニでの新作のダライアス（3画面アーケードを1画面に移植）。 発売日表示も 2019 年になってますね。 PC のエミュレータではこのダライアスは楽しめません。
シューティング好きな人にとっては、このダライアスだけでもメガドラミニを買う価値があるとか。。。 処理落ちもないしスピード速くて難しいけど、とってもシンプルで硬派なシューティングなので、初心者にもオススメです。 コントローラー右上の拡張ボタンか、本体のリセットボタンを押せば、いつでもセーブできる（1ゲームにつき4スロット）ので、これを使ってズルすれば誰でもクリアできます。
こちらは今や不朽の名作となった『ぷよぷよ』の原点である『魔導物語』。 アルルが卒園試験として、塔の中でテストを行います。 オリジナルは MSX というパソコンの雑誌付録（MSXマガジンだったかな？）でしたが、後にメガドライブに移植されました。 戦闘に入ったときに、コマンド選択がないから操作方法がわからなくて困りました。 こんなときは、Web サイトにあるマニュアルを読みます。 メガドライブミニに収録されているゲームソフトの取扱説明書（マニュアル）は こちら から全部見れるようになってます。 マニュアルを見てるだけでおもしろいです。
答えは、A 押しながら魔導コマンド入力でした。 初期の攻撃方法である「ふぁいやー」は、↑←↓→ です。
3D ダンジョンもののゲームは『ウィザードリィ』が有名ですけど、やっぱりちょっと難しい。 でも、この魔導物語はとってもやさしくて誰でも楽しめます。 なんてったって 操作するキャラが園児 ですからね。 ちなみに HP 表示もなく、体力が減るとアルルの表情が眠そうになっていきます。</description></item><item><title>TypeScriptの環境: tsc-watch で ts ファイルの変更監視＆アプリの再起動を自動化する</title><link>https://maku.blog/p/nxzsnkf/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nxzsnkf/</guid><description>TypeScript の監視と JavaScript の監視の両立 tsc --watch コマンドを使うと、TypeScript (.ts) ファイルの変更を監視して自動的に tsc （トランスパイル）を実行してくれるようになります。 nodemon コマンドを使うと、JavaScript (.js) ファイルの変更を監視して自動的に node コマンドを再起動してくれるようになります。
これらを組みあわせれば、TypeScript (.ts) ファイルの変更時に、自動的に Node.js アプリを再起動できそうな気がしますが、一連のコマンドとしてこれら 2 つを組み合わせて実行するのにはみんな苦労しているようです（もちろんコマンドシェルを 2 つ立ち上げればできますが）。
そこで便利なのが tsc-watch コマンド です。
tsc-watch パッケージでまるごと解決 tsc-watch という NPM パッケージ（コマンド）を使用すると、TypeScript の変更監視と Node アプリの再起動の連動を簡単に行えるようになります。 まず、必要なパッケージを下記のようにインストールします。 nodemon は使わなくて済むので、ここでは依存パッケージとして typescript と tsc-watch をインストールしておきます。 --save-dev オプションを付加して、package.json の devDependencies に登録するのを忘れないようにしましょう。
$ npm install --save-dev typescript $ npm install --save-dev tsc-watch tsc-watch コマンドはほとんど tsc --watch のラッパーなので、そのまま実行すると、TypeScript ファイルの変更を監視してトランスパイルを実行するという動作になります。 これだけの用途であれば tsc コマンドで十分なのですが、tsc-watch コマンドに追加されている --onSuccess オプションを使うと、トランスパイル後に任意の追加コマンドを実行することができます。 この追加コマンドとして npm start などを実行するように設定しておけば、TypeScript のトランスパイル後に Node.</description></item><item><title>読書メモ『完全ひとりビジネスを始めるための本』右田正彦</title><link>https://maku.blog/p/5wdt9n3/</link><pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5wdt9n3/</guid><description> 完全ひとりビジネスを始めるための本 右田正彦 秀和システム 自宅にひきこもりつつも、いかに安定して稼いでいくかについて述べた本です。 ブログのアフィリエイトでの稼ぎ方の話は参考になるのでメモメモ。
テーマを決めて、10 記事中 7 記事はそのテーマで書くとよい 3 ヶ月間は広告を貼らずに記事を書き溜める Wordpress が SEO 対策されていてオススメ（と著者は言ってますが、個人的には Wordpress はいろいろ無駄に苦労することが多いのでオススメしません。本気でやるなら Hugo などの静的な Web サイトジェネレータがオススメ） 毎日 1 記事のペースを保つ（それ以下でもそれ以上でもダメ） 無料のブログサービスは使っちゃダメ 稼ぎやすい 2 つのテーマ コンプレックスの解消 ノウハウの指南 記事は 800 文字程度はあると、Google にも表示されやすくなる タイトルは具体的に 記述する Google で検索するときに表示される サジェストキーワード を参考にタイトルを決める 見せたいキーワードは タイトルの最初の方 に入れる（Google は最初の 32 文字を表示するため） 商品を売るなら、タイトルに商品名を入れる 2 ヶ月目からは過去の記事を見直して リライトする 特定のネタの記事が 4 〜 5 記事くらい溜まったら、まとめ記事 を作る Google アナリティクスでどんな検索ワードで集まって来ているか調べて、タイトルを変更する ブログの理想系は全ての記事がまんべんなく多くの人に読まれている状態になること</description></item><item><title>Azure: Node.js アプリを App Service へデプロイする（Kudu ビルド編）</title><link>https://maku.blog/p/wx3fvib/</link><pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wx3fvib/</guid><description>Azure App Service には、デプロイセンター という仕組みがあり、そこからソースコードのビルドからデプロイまでの自動化の設定を行うことができます。 簡単に言うと、Azure Repos や GitHub のリポジトリに最新の JavaScript コードをコミットするだけで、最新の Node.js アプリが自動で立ち上がるようになります。
ビルドの仕組みとしては、クラウド上の Azure Pipelines を使ったり、ローカルでビルドしてしまってからデプロイする方法があります。 App Service には Kudu エンジン が組み込まれており、デプロイ時に自動で実行されるスクリプトを使って簡易的なビルド処理を行うこともできます。
はじめに（用語定義） Azure ではデプロイ処理を構成するコンポーネントを下記のような名前で呼んでいます。
デプロイソース GitHub や Azure Repos など。 ソースコードが置いてある場所（リポジトリ）のこと。 Azure App Service は手軽なデプロイソースとして OneDrive や Dropbox などのフォルダ共有サービスを設定することもできますが、本格的な運用で使用することは推奨されていません。 ビルドパイプライン（ビルドプロバイダー） Azure Pipelines など。デプロイソースからソースコードを取得し、一連のビルド処理を行う仕組み。 App Service には組み込みで Kudu エンジンが搭載されており、デフォルトではデプロイ時にこの Kudu エンジンによって npm install などが実行されるようになっています。 また、デプロイ時に実行する カスタムスクリプトを .deployment ファイルで定義する こともできます。 これらの仕組みだけで十分であれば、Azure Pipelines を使う必要はありません。 デプロイメカニズム ビルドしたアプリを Azure App Service などに配置するためのアクション。Kudu エンジンや FTP (SFTP)、WebDeploy などのデプロイメカニズムが提供されています。 リポジトリの準備 (Azure Repos) ここでは、Azure Repos に Git リポジトリを作成し、そこに Node.</description></item><item><title>Azure: App Service の Node.js アプリのエントリポイントはどこで定義されているか？</title><link>https://maku.blog/p/3u4hj7h/</link><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3u4hj7h/</guid><description>Node.js アプリのエントリポイントの指定 Azure App Service で Node.js アプリをテンプレートから作成すると、うまいことルートに配置された index.js が起動してくれます。 この仕組みがブラックボックスな感じで気持ち悪いので調べてみたところ、このエントリポイントの指定は web.config ファイルにあるようです。
web.config（抜粋） &amp;lt;add name=&amp;#34;iisnode&amp;#34; path=&amp;#34;index.js&amp;#34; verb=&amp;#34;*&amp;#34; modules=&amp;#34;iisnode&amp;#34;/&amp;gt; Windows ベースの App Service で Node.js アプリを動作させる場合、Windows の Web サーバーである IIS 上で動作する iisnode という Node.js 実装が使用されます。 IIS が起動するときに設定ファイルである web.config が読み込まれ、上記の設定により iisnode がエントリポイント index.js を使って起動するという流れになります。 なので、作成している Node.js アプリのエントリポイント（メインの JS ファイル）が変わった場合は、この web.config ファイルを修正する必要があります。
あと、このような仕組みのため、web.config ファイルは必ずアプリを構成する JS ファイルと一緒にデプロイしないといけないということも分かります。 上記の設定のままであれば、デプロイ先のルートディレクトリに、少なくとも下記の 2 ファイルが配置されていなければいけません。
web.config （IIS の設定ファイル） index.js （上記ファイルで指定されたエントリポイント） なぜ紛らわしいのか？ Node.js アプリを開発するとき、通常は package.json の start スクリプトとしてエントリポイントを指定します。
package.json（抜粋） { &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;node index.</description></item><item><title>TypeScriptの環境: 既存の JavaScript プロジェクトを TypeScript に乗り換える</title><link>https://maku.blog/p/3eccb2t/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3eccb2t/</guid><description>TypeScript プロジェクトへの移行は簡単！ TypeScript の構文は、JavaScript のコードとの互換性を考慮して仕様が決められているため、既存の JavaScript プロジェクトを簡単に TypeScript プロジェクトに移行することができます。 後述するように設定をうまく行えば、JavaScript ファイルの拡張子を .ts に変える必要すらありません。
TypeScript の構文を使わないと意味がないのでは？と思うかもしれませんが、TypeScript のトランスパイラ (tsc) には、強力な静的解析の仕組みが備わっているため、この機能を既存の JavaScript ファイルに適用するだけでも TypeScript を導入する価値があります。
ここでは、tsc コマンドは下記のようにグローバルにインストールしてあることを前提とします。
$ npm install -g typescript おすすめのディレクトリ構成 既存の JavaScript コードを TypeScript トランスパイラ (tsc) の変換対象にする場合は、入力ファイルとなる .js ファイルと、生成される .js ファイルのディレクトリを明確に区別しておくべきです。 そうしておかないと、どのファイルが自分が作成したファイルで、どのファイルが自動生成されたファイルなのか分かりにくくなってしまいます。
ここでは、既存の JavaScript プロジェクトのソースコード (.js) を、下記のように src ディレクトリに格納します。 このディレクトリには、最終的に .js ファイルと .ts ファイルが混在していても構いません。
project/ +-- tsconfig.js （設定ファイル） +-- build/ （出力用ディレクトリ） +-- src/ （入力用ディレクトリ） +-- main.js +-- module1.js +-- module2.js 上記では、src ディレクトリの直下に .</description></item><item><title>GitHub Pages は早く Jekyll から Hugo に乗り換えるべき</title><link>https://maku.blog/p/xwfwdy6/</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xwfwdy6/</guid><description>GitHub Pages は HTML ジェネレーターとして昔から Jekyll を採用しているのですが、Jekyll ははっきり言って遅すぎるし、ある程度のサイト規模になると使い物になりません。 セットアップもいろいろなライブラリの依存があって複雑です。 バージョンアップのたびにストレスが溜まります。
世の中には爆速なサイトジェネレーターの Hugo があります。
Jekyll では Web サイトが数千ページ規模になってくると、1 つの記事を 1 文字変更しただけで再ビルドに何分もかかります。 一方、Hugo であれば少なくとも数秒で終わります。
Hugo は爆速なだけでなく、実行環境も 1 バイナリだけ（Windows であれば hugo.exe のみ）で、導入もバージョンアップもストレスフリーです。 開発者の Bjørn Erik Pedersen 氏がめちゃくちゃやる気があるので、常に進化を続けていて、テンプレートファイルも柔軟にカスタマイズできます。
GitHub Pages は一刻も早く Jekyll から Hugo に乗り換えるべきだと思います。 移行にはある程度痛みを伴うかもしれませんが、ユーザーも GitHub 社（Microsoft により買収済み）も幸せになれるはずです。
（2022-08-17: 追記）Jekyll から Hugo への乗り換えを始めました</description></item><item><title>Jekyll (GitHub Pages) でページの最終更新日を表示する</title><link>https://maku.blog/p/6ez7nuf/</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6ez7nuf/</guid><description>Jekyll では、HTML ファイルを生成するために Markdown 形式で記事を作成するのですが、先頭のフロントマターと呼ばれる部分に任意の変数を定義することができます。
下記の例には、記事の作成日 (date) と、最終更新日 (lastmod) を入れてあります。
sample.md --- title: &amp;#34;ページタイトル&amp;#34; date: &amp;#34;2015-01-01&amp;#34; lastmod: &amp;#34;2019-09-12&amp;#34; --- 本文... これらの情報をレイアウトファイルから参照するには、下記のようにします。 ここでは、最終更新日 (lastmod) の情報があればそちらを、なければ作成日 (date) を表示するようにしています。 フロントマターでの lastmod の指定はオプショナル扱いということです。
{% if page.lastmod %} {% assign lastmod = page.lastmod %} {% else %} {% assign lastmod = page.date %} {% endif %} &amp;lt;span class=&amp;#34;date&amp;#34;&amp;gt;{{ lastmod }}&amp;lt;/span&amp;gt; HTML5 の time 要素や、schema.org の構造化データマークアップを使ってちゃんと SEO 対策するのであれば、下記のような感じでテンプレートを作成するのがよいでしょう。
default.html（抜粋） {% if page.lastmod %} {% assign lastmod = page.</description></item><item><title>WebGL で使う Typed Array</title><link>https://maku.blog/p/twmzpfj/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/twmzpfj/</guid><description>Typed Array とは JavaScript の配列型には、汎用型の Array の他にも、Int32Array のような、特定の型の値だけしか格納できない配列型が用意されています。 このような配列型のことを Typed Array と呼びます。 イメージとしては、C 言語の int 配列や float 配列に近いです。
例えば、WebGL で頂点属性（座標や色）の配列を用意するようなケースでは、その中の要素の型はすべて float 型に統一されていたりするので、汎用型の Array ではなく、Float32Array を使用することでメモリ効率がよくなります。
Typed Array には下記のようなものが用意されています。
型名 バイト数 値の範囲 説明（対応するC言語の型） Int8Array 1 -128 ～ 127 8-bit sined integer (int8_t) Uint8Array 1 0 ～ 255 8-bit unsigned integer (uint8_t) Int16Array 2 -32768 ～ 32767 16-bit signed integer (int16_t) Uint16Array 2 0 ～ 65535 16-bit unsigned integer (uint16_t) Int32Array 4 -2147483648 ～ 2147483647 32-bit signed integer (int32_t) Uint32Array 4 0 ～ 4294967295 32-bit unsinged integer (uint32_t) Float32Array 4 1.</description></item><item><title>読書メモ『ヴァーチャリアン嘘つかない』渡辺浩弐</title><link>https://maku.blog/p/3w27afe/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3w27afe/</guid><description>ヴァーチャリアン嘘つかない ― マルチメディアの正体を暴く 渡辺浩弐 メディアワークス 渡辺コージィさんの 25 年前の本。 ちょうどバブル崩壊の頃ですね。 最近発売された 『令和元年のゲーム・キッズ』 とか、コージィさんのゲームキッズシリーズは面白いので、別の著書も読んでみようと思ってブックオフでげっちゅして読んでみました。
マルチメディアやゲームの目指すべき方向性みたいなことを書いた本なのですが、思ったよりすごい内容ですね。 先見性がすごい。。。じゃなくて、下品さがすごい（笑）。 まさに昭和時代の下品さ。 コージィさんといえば、「大竹まことのただいま！PCランド」のイメージが強いんですけど、大竹さんの影響かなｗ
でも、ゲームってどうあるべきか、っていう意見はまともです。
「気持ち良さ」だけを残して「辛さ」や「難しさ」は省いてやることが大切 画面の中のものを自分の手で押して引いてみたときの純粋な気持ち良さが、ゲーム的な快楽の原点だ ゲームとは現実を超える擬似現実を作り出すもの 企画書を書くべきではない！体面やお行儀を気にした試作品を作らず、いきなり商品を作ることが大事 Netflix で電脳社会をテーマにしたブラックミラーという一話完結型のドラマをやっていますが、ゲームキッズが原点ですよね（´・ω・｀)</description></item><item><title>WebGL で シェーダーコードを分離する方法</title><link>https://maku.blog/p/itkdix9/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/itkdix9/</guid><description>解決したいこと WebGL で使用する頂点シェーダーとフラグメントシェーダーの GLSL ES コードは単純な文字列データであればよいので、下記のように JavaScript のコードに埋め込んでしまう方法が最初に思いつきます。
const VSHADER_CODE = ` void main() { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); gl_PointSize = 10.0; }`; const FSHADER_CODE = ` void main() { gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); }`; しかし、これだとアプリ側のコードとシェーダーのコードが混ざってしまうので美しくありません。 ここでは、シェーダーコードを分離するいくつかの方法を示します。
script 要素内にシェーダーコードを埋め込む方法 下記のような感じで、頂点シェーダーとフラグメントシェーダー用の script 要素を用意して、そこにコードを埋め込んでしまう方法です。
HTML 抜粋 &amp;lt;script id=&amp;#34;vshader&amp;#34; type=&amp;#34;x-shader/x-vertex&amp;#34;&amp;gt; void main() { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); gl_PointSize = 10.0; } &amp;lt;/script&amp;gt; &amp;lt;script id=&amp;#34;fshader&amp;#34; type=&amp;#34;x-shader/x-fragment&amp;#34;&amp;gt; void main() { gl_FragColor = vec4(0.</description></item><item><title>Python で OpenGL (1) pyGLFW のインストール</title><link>https://maku.blog/p/sfpwow9/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sfpwow9/</guid><description>Python で簡単に Open GL のプログラムを開発できるように、GLFW (pyGLFW) というライブラリを使用するための環境構築をしてみます。
GLFW とは Khronos グループが作成している OpenGL や OpenGL ES、Vulkan などの API を使用すると、クラスプラットフォームな 3D プログラムを作成することができます。 ただし、OS ごとにウィンドウの作成方法やキーハンドリングの方法は異なっているため、その部分は個別に作成する必要があります。
GLFW は、そのあたりの OS 依存の処理を抽象化するためラッパーライブラリで、Windows、macOS、Linux などのデスクトップ環境に対応しています。 GLFW 本家は C 言語用のライブラリとして作成していますが、Python 用のラッパーライブラリ (pyGLFW) も公開されています。
昔は GLUT というライブラリがよく使われていましたが、今はもうメンテナンスされていないので、GLFW を使います。
pyGLFW (glfw) のインストール ここでは、Python 用の GLFW ラッパーライブラリである、pyGLFW (glfw) パッケージ をインストールします。
Python 用ライブラリ glfw のインストール Python 用の glfw パッケージは pip コマンドで簡単にインストールできます。 システム全体の環境に影響しないようにするには、virtualenv を使って仮想環境を構築 してからインストールするのがよいでしょう。
virtualenv で仮想環境に切り替える場合 $ mkdir sample $ virtualenv ENV $ source ENV/bin/activate glfw のインストール $ pip install glfw ランタイムライブラリのインストール glfw を使用したプログラムを実行するには、各 OS ごとに用意されたランタイムライブラリ (Shared library) もインストールしておく必要があります。</description></item><item><title>Python で OpenGL (2) PyOpenGL のインストール</title><link>https://maku.blog/p/665rua3/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/665rua3/</guid><description>PyOpenGL とは 前回の記事 では、pyGLFW を使ってウィンドウを表示するところまで行きました。 ただし、pyGLFW がやってくれるのは、ウィンドウの作成や、そのサーフェスに描画するための OpenGL コンテキストを生成するところまでです。 実際に OpenGL コンテキストを使ってレンダリングするには、OpenGL の API が必要です。
そのためのライブラリが PyOpenGL パッケージ です。
PyOpenGL のインストール PyOpenGL パッケージも pyGLFW と同様、pip コマンドで簡単にインストールすることができます。
$ pip install PyOpenGL PyOpenGL で Hello World 下記のサンプルコードは、pyGLFW (glfw) パッケージを使ってウィンドウの初期化を行い（main()）、PyOpenGL (OpenGL) パッケージを使って OpenGL の API を呼び出しています（render()）。
main.py import glfw from OpenGL.GL import * def render(): glClearColor(0, 0, 0.5, 1.0) glClear(GL_COLOR_BUFFER_BIT) def main(): if not glfw.init(): raise RuntimeError(&amp;#39;Could not initialize GLFW3&amp;#39;) glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, 3) glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, 3) glfw.</description></item><item><title>Azure Speech Service を使って音声をテキストに変換する (STT)</title><link>https://maku.blog/p/5zx3ozz/</link><pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5zx3ozz/</guid><description>Microsoft の Cognitive Services のひとつとして提供されている Speech Service を使用すると、音声をテキストに変換したり、逆にテキストを音声に変換したりすることができます。
ここでは、Python から Speech Service の機能を利用してみます（Windows 10 で動作確認済）。 実行するにはマイクのついた PC が必要です マイクのついていない PC で実行すると SPXERR_MIC_NOT_AVAILABLE エラーが発生します。
準備 Speech Service の準備 Azure Portal から Speech のリソースを作成し、Subscription Key を取得しておいてください。
Speech SDK のインストール Python の azure-cognitiveservices-speech パッケージをインストールします。
$ pip install azure-cognitiveservices-speech Visual Studio C++ Redistributable のインストール 必要があれば、Visual Studio C++ の再頒布可能パッケージをインストールします。
Visual C++ 再頒布可能パッケージ (vc_redist.x64.exe) Python コード 一回だけ変換して終わるバージョン stt.py import azure.cognitiveservices.speech as speechsdk # この設定は適宜変更してください subscription = &amp;#34;e1b5f0964ab743133b7de4f892741c7a&amp;#34; region = &amp;#34;japaneast&amp;#34; language = &amp;#34;ja-JP&amp;#34; # proxy = (&amp;#34;proxy.</description></item><item><title>Blender で猫とたわむれる</title><link>https://maku.blog/p/7qer4dw/</link><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7qer4dw/</guid><description>うちは賃貸でネコが飼えないので、Unity のアセットとして販売されている Cu Cat を Blender に取り込んで遊ぶ。 きゃわいー。 なでれないけど。
これをうまく動かせるようになりたいなぁ。 3D は難しいけど面白いです。 これからは 3D の技術が重要になってくる予感。</description></item><item><title>直木賞の受賞作品リスト</title><link>https://maku.blog/p/yhuuddz/</link><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yhuuddz/</guid><description>直木賞は、無名・新人または中堅作家による、短編および長編の大衆小説に与えられる文学賞です。 新聞、雑誌（同人雑誌を含む）に掲載されたものも対象になります。
下記は 2000 年から現在までの直木賞の一覧（新しい順）です。 文庫版が出ているものは、なるべく文庫版へのリンクを張るようにしています（リーズナブルなので）。
たまには文学もたしなまなきゃね(๑･㉨･๑)
回 受賞年 作品名 受賞者 160 2018年下期 『宝島』 真藤順丈 159 2018年上期 『ファーストラヴ』 島本理生 158 2017年下期 『銀河鉄道の父』 門井慶喜 157 2017年上期 『月の満ち欠け』 佐藤正午 156 2016年下期 『蜜蜂と遠雷』 恩田陸 155 2016年上期 『海の見える理髪店』 荻原浩 154 2015年下期 『つまをめとらば』 青山文平 153 2015年上期 『流』 東山彰良 152 2014年下期 『サラバ！(上)』 『サラバ！(中)』 『サラバ！(下)』 西加奈子 151 2014年上期 『破門』 黒川博行 150 2013年下期 『恋歌（れんか）』 朝井まかて 『昭和の犬』 姫野カオルコ 149 2013年上期 『ホテルローヤル』 桜木紫乃 148 2012年下期 『何者』 朝井リョウ 『等伯(上)』 『等伯(下)』 安部龍太郎 147 2012年上期 『鍵のない夢を見る』 辻村深月 146 2011年下期 『蜩ノ記（ひぐらしのき）』 葉室麟 145 2011年上期 『下町ロケット』 池井戸潤 144 2010年下期 『漂砂（ひょうさ）のうたう』 木内昇 『月と蟹』 道尾秀介 143 2010年上期 『小さいおうち』 中島京子 142 2009年下期 『ほかならぬ人へ』 白石一文 『廃墟に乞う』 佐々木譲 141 2009年上期 『鷺と雪』 北村薫 140 2008年下期 『悼む人(上)』 『悼む人(下)』 天童荒太 『利休にたずねよ』 山本兼一 139 2008年上期 『切羽（きりは）へ』 井上荒野 138 2007年下期 『私の男』 桜庭一樹 137 2007年上期 『吉原手引草』 松井今朝子 136 2006年下期 なし 135 2006年上期 『まほろ駅前多田便利軒』 三浦しをん 『風に舞いあがるビニールシート』 森絵都 134 2005年下期 『容疑者Ｘの献身』 東野圭吾 133 2005年上期 『花まんま』 朱川湊人 132 2004年下期 『対岸の彼女』 角田光代 131 2004年上期 『空中ブランコ』 奥田英朗 『邂逅の森』 熊谷達也 130 2003年下期 『号泣する準備はできていた』 江國香織 『後巷説百物語』 京極夏彦 129 2003年上期 『4TEEN フォーティーン』 石田衣良 『星々の舟』 村山由佳 128 2002年下期 なし 127 2002年上期 『生きる』 乙川優三郎 126 2001年下期 『あかね空』 山本一力 『肩ごしの恋人』 唯川恵 125 2001年上期 『愛の領分』 藤田宜永 124 2000年下期 『ビタミンF』 重松清 『プラナリア』 山本文緒 123 2000年上期 『GO』 金城一紀 『虹の谷の五月(上)』 『虹の谷の五月(下)』 船戸与一 芥川賞のリストはこちら</description></item><item><title>芥川賞の受賞作品リスト</title><link>https://maku.blog/p/89d6c4p/</link><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/89d6c4p/</guid><description>芥川賞は、優れた純文学を書いた新人に与えられる文学賞です。 新人作家による発表済みの短編・中編作品が対象です。 大衆文学を対象にした直木賞に比べると、芥川賞は純文学を対象としているので、より芸術性を考慮して受賞作が決定されています。
下記は 2000 年から現在までの芥川賞の一覧（新しい順）です。 文庫版が出ているものは、なるべく文庫版へのリンクを張るようにしています（リーズナブルなので）。
たまには文学もたしなまなきゃね(๑･㉨･๑)
回 受賞年 作品名 受賞者 160 2018年下期 『ニムロッド』 上田岳弘 『1R（いちらうんど）1分34秒』 町屋良平 159 2018年上期 『送り火』 高橋弘希 158 2017年下期 『百年泥』 石井遊佳 『おらおらでひとりいぐも』 若竹千佐子 157 2017年上期 『影裏（えいり）』 沼田真佑 156 2016年下期 『しんせかい』 山下澄人 155 2016年上期 『コンビニ人間』 村田沙耶香 154 2015年下期 『異類婚姻譚（いるいこんいんたん）』 本谷有希子 『死んでいない者』 滝口悠生 153 2015年上期 『火花』 又吉直樹 『スクラップ・アンド・ビルド』 羽田圭介 152 2014年下期 『九年前の祈り』 小野正嗣 151 2014年上期 『春の庭』 柴崎友香 150 2013年下期 『穴』 小山田浩子 149 2013年上期 『爪と目』 藤野可織 148 2012年下期 『ａｂさんご』 黒田夏子 147 2012年上期 『冥土めぐり』 鹿島田真希 146 2011年下期 『共喰い』 田中慎弥 『道化師の蝶』 円城塔 145 2011年上期 なし 144 2010年下期 『苦役列車』 西村賢太 『きことわ』 朝吹真理子 143 2010年上期 『乙女の密告』 赤染晶子 142 2009年下期 なし 141 2009年上期 『終の住処』 磯崎憲一郎 140 2008年下期 『ポトスライムの舟』 津村記久子 139 2008年上期 『時が滲む朝』 楊逸 138 2007年下期 『乳と卵』 川上未映子 137 2007年上期 『アサッテの人』 諏訪哲史 136 2006年下期 『ひとり日和』 青山七恵 135 2006年上期 『八月の路上に捨てる』 伊藤たかみ 134 2005年下期 『沖で待つ』 絲山秋子 133 2005年上期 『土の中の子供』 中村文則 132 2004年下期 『グランド･フィナーレ』 阿部和重 131 2004年上期 『介護入門』 モブ・ノリオ 130 2003年下期 『蹴りたい背中』 綿矢りさ 『蛇にピアス』 金原ひとみ 129 2003年上期 『ハリガネムシ』 吉村萬壱 128 2002年下期 『しょっぱいドライブ』 大道珠貴 127 2002年上期 『パーク・ライフ』 吉田修一 126 2001年下期 『猛スピードで母は』 長嶋有 125 2001年上期 『中陰の花』 玄侑宗久 124 2000年下期 『熊の敷石』 堀江敏幸 『聖水』 青来有一 123 2000年上期 『花腐し』 松浦寿輝 『きれぎれ』 町田康 直木賞のリストはこちら</description></item><item><title>読書メモ『嶋浩一郎のアイデアのつくり方』</title><link>https://maku.blog/p/8o74agi/</link><pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8o74agi/</guid><description>嶋浩一郎のアイデアのつくり方 嶋浩一郎 ディスカヴァー・トゥエンティワン ジェームス・ウェブ・ヤングの『アイデアのつくり方』 とは別の本です。
こちらは、博報堂ケトルというクリエイティブ・エージェンシーで働いている嶋浩一郎さんがアイデアの生み出し方についてまとめた本です。
情報はまとめずに、手書きの手帳に書いていくのがよい、と主張されています。 情報は分類せずに放牧する、という表現も使っています。
情報は分類すると死んでしまう。情報を放牧するとアイデアが生まれる。 手帳ならページをめくりながら情報と情報を交配させていくことができる。 だから、情報は分類せずに、ぐちゃぐちゃに目の前に羅列しておく方がよい。
10 年前のメモを読み返したりもするので、丈夫なモールスキン（モレスキン）を使っているのだとか。 という私もなんだかんだ言って、10 年分以上の手帳はたまってたりします。。。
嶋さんはアイデアの作り方を 3 ステップにまとめています。
情報収集 放牧 化学変化 下記はそれぞれのステップのまとめです。
ステップ1: 情報収集 情報はとにかく集める！ 本で読んだこと 人から聞いた話 テレビやラジオで耳にしたこと レストランで隣のカップルが話していたこと 会議中の雑談 映画や街の風景 集める情報には 5 つの方向性がある 事実 (FACT) &amp;hellip; あなたの知らなかった事実。 意見 (OPINION) &amp;hellip; 新聞の投稿欄、会議、立ち話、他人の会話など、斬新な意見だと思ったネタ。 分析 (ANALYSIS) &amp;hellip; 今まで見聞きしなかったユニークな分析。 示唆・疑問 &amp;hellip; 意見や分析ほど定かではないが、何か示唆を感じさせる情報。「〜かもしれない」といった推測を含ませるもの。 表現 &amp;hellip; これは使える！と思える文章表現や、たとえ、比喩、名言、格言、広告のキャッチコピー。 情報源を明記する 集める情報が 5 つのうちにどれに当たるのかはいちいち考えなくてもいい。 ただし、情報源はしっかり記録しておく。 最終的にその情報を使うときに検証するため。
情報は差別しない 情報には一流も三流もなく、すべて等価。 無差別に集めればよい。 芸能ゴシップ、考古学の発見、同人誌、どの情報も同様に扱ってよい。
二軍ノートを用意する まず、第一ステップとして「二軍ノート」に時系列にどんどん書き込んでいく。 無駄だと思ってもとにかくメモしておく。
ステップ2: 放牧 3ヶ月前に書いたネタと、今日書いたネタ、まったく関係ない話が突然つながることが多々ある。 ステップ 1 で二軍ノートに書いたネタの中から、これは面白い、興味深いと思ったものをセレクトし、「一軍ノート」にデビューさせる。 このときも分類したりせず、順番に書いていくだけ。 単純にナンバーだけ振っておけばよい。</description></item><item><title>2019-06-10 今日のボドゲー部</title><link>https://maku.blog/p/fsm6uh8/</link><pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fsm6uh8/</guid><description>今日のボドゲー部は 『街コロ』 と 『キングドミノ』 。
街コロ サイコロを振って出た目に応じてお金をもらえるゲームです。 カードには 1〜12 の数字が書いてあって、出た目のカードを持っていると恩恵を得られます。 カードはお金を払って増やしていくことができるのですが、強いカードはその分高くなってます。
序盤は 1 つのサイコロしか振れないようになっていて、1〜6 の出目での勝負が続きます。 2 つサイコロが振れるようになったら一気に場が盛り上がるんだろうなぁと思っていると、いつもすぐに終わってしまいます。 もうちょっと勝負が長引くようにアレンジすると面白いかもしれないです。 先に 50 コインのお城を購入した人が勝利するとか。
とりあえず、サイコロを使うゲームは運の要素が強めで盛り上がりやすいので好きです。
キングドミノ キングドミノは 『カルカソンヌ』 に似たゲームです。
カルカソンヌはみんなで 1 つのマップを育てていきますが、キングドミノは各プレイヤーが 5x5 マスの土地を完成させます。 地形パネルを順番に置いていき、最後に「つながった地形の数 x 王冠の数」が得点になるというシンプルなルールです。
どうやったら土地を繋げられるかというパズル的なセンスが問われるゲームですね。 キングドミノもカルカソンヌも、最後の得点計算がちょっと地味です。 最後にドーンと盛り上がって終われないっていう。。。</description></item><item><title>2019-05-26 ゲームマーケット2019春に行ってきた</title><link>https://maku.blog/p/k6m6tdm/</link><pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k6m6tdm/</guid><description>今日はアナログゲームの祭典、ゲームマーケット。 会場には東京テレポート駅から徒歩10秒で到着です。
日曜日の午後からぶらりと行ってきたんですが、思ったより空いてました。 初日はたぶん混んでたんでしょうね。
ほとんどのお店（サークル）には試遊台があるので、いろいろ遊んでいたらたぶん一日あっても足りないですが、ざーっと見て回るだけなら2、3時間あれば大丈夫。
参加者は年々うなぎのぼりみたいですが、このブームいつまで続くんでしょうか。 ゲームつくろーっと。</description></item><item><title>理学療法士さんの肩こりのお話</title><link>https://maku.blog/p/x2zrq7f/</link><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x2zrq7f/</guid><description>とある理学療法士さんに肩こりについてのお話を聞いたのでメモメモ。
肩こりの原因 長時間の同一姿勢 → 筋肉が固まる 血管の圧迫 → 筋肉が過緊張 発痛物質 → 酸素や栄養の不足 ブルーライト → 自律神経の乱れ 筋肉は 30 秒伸ばすと緩むという性質を持っているので、首などのストレッチは 30 秒間続ける 猫背になる → 口呼吸になる → 口が渇く → 食事中に唾液で消化しにくくなる → 胃腸が悪くなる 寝る前に横隔膜呼吸をすると、副交感神経が優位になって良い睡眠をとれる 最近の流行で、タンパク質の取りすぎが起きている アンモニアが生成されるので体が臭くなるよ 肝臓に負担がかかるので、タンパク質摂るならお酒は飲んじゃダメ 肝臓のためにマグネシウムも一緒に摂る（マグネシウムを摂れる入浴剤もあるよ） 炎症物質に注意 赤身肉、砂糖 → ヒスタミンのもと → アトピーになったり、肌が汚くなったり</description></item><item><title>読書メモ『トム・ピーターズのサラリーマン大逆襲作戦〈2〉セクシープロジェクトで差をつけろ！』トム・ピーターズ</title><link>https://maku.blog/p/9sh9ycn/</link><pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9sh9ycn/</guid><description>トム・ピーターズのサラリーマン大逆襲作戦〈2〉セクシープロジェクトで差をつけろ！ トム・ピーターズ CCCメディアハウス つまらない仕事を「すごい仕事」に変えるヒントが詰め込まれています。 「プロジェクト」って何だろう？ 何が大切なことなのだろう？ ということを原点に戻って考えさせてくれます。
才能のない人は、最初からおもしろいことがないかを探してしまう。 大切なのは、工夫すること自体が楽しいから工夫するという考え方。
今やっている仕事がつまらないと思ってしまったら、この本を開いてみると何かが変わるかもしれません。
はじめに プロジェクトって？ 普通の人が理解できないことをやらなければいけない。やる価値があるものは、それ以外にないのだから
&amp;mdash; アンディ・ウォーホール
プロジェクト内には、ガント図、PERT、CPM など、素人を煙に巻く道具がたくさんあり、多くの人たちは、
そのプロジェクトの一体どこがすごいのか？ どこが人の記憶に残るものなのか？ という肝心なことを忘れてしまう。
すごいプロジェクトとは、
目にも止まらぬ速さで突っ走るもの はじめ馬鹿にしていた人に「私が間違っていた」と言わせるもの たちどころに試作品が出来上がるもの あらゆる官僚的手続きをせせら笑うもの である。 ウェイン・ワン監督の映画『スモーク』では、生き様を示すのがプロジェクトだと言っている。
充実した人生を送るには 実現できない夢はある。 しかし、夢を描き、その夢を実現するために、持てる限りの智力、体力、気力を振り絞らない限り、人間が鍛えられず、絶望の味も歓喜の味も知らず、心も生活も豊かにならぬまま人生を終えることになる。
充実した人生を送るには、すごいプロジェクトをやるしかない。
プロジェクトの 4 段階 創造 (30%): プロジェクトの企画。カッコいいか？やる価値があるか？ 売り込み (30%): お客さんを集める。 実行 (30%): 舞台の幕を開ける。紙の上のプランよりも、試行錯誤を重視する。 退場 (10%): バトンタッチ。これをいい加減にやると、跡形もなく消えてしまう。 ほとんどのプロジェクトでは、「実行」以外のプロセスが忘れられている。 実際には、「実行」は「売り込み」の延長であることが多い。
第一段階『創造』 言われた通りに仕事をやっているだけでは、いつまでたってもプロジェクトは創造できない。
「トイレを直して」と頼まれたらどう考えるべきか？ バスルームの位置が悪いのかもしれない。 家全体の設計の問題では？ 本格的な改築工事が必要かもしれない。 「返品規定を見直して」と頼まれたらどう考えるべきか？ 会社が官僚的でもろもろの手続きが複雑なのでは？ 対処する現場の人間を信用していないのでは？ 社風刷新計画への突破口になるかもしれない。 戦略的に欠陥を是正する絶好のチャンスかもしれない。 枠を取っ払う あなたの本当の仕事は、一見つまらない業務や雑用を、カッコいいもの、忘れられないもの、すごいものに変えることだ。 憂鬱な仕事を、自分たちの価値観を体現する一大プロジェクトに変えてはいけない理由はない。 平凡な成功をまたひとつ積み重ねるだけの仕事はやめよう。
バカはメモをとらない まずは「観察ノート」を作ってみよう。(1) ムカつくことに出くわしたら、(2) すごいものに出くわしたら、何でも書き留める。 ポイントは、ものを見る眼を養い、小さなことに感動できる感性を磨くことにある。 シンプルなスパイラルノートの表紙に「しびれる」、裏表紙に「むかつく」と書き、今日から始めよう。 プロジェクトごとに専用の日記を用意し、そこに何でも書いていく。 思いついたらすぐに書き留めること。</description></item><item><title>クリスタのメモ: 別のレイヤーのオブジェクトが選択されてしまうのを防ぐ</title><link>https://maku.blog/p/drsjj6t/</link><pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/drsjj6t/</guid><description>操作ツールを使ってオブジェクトを選択するときに、別のレイヤーのオブジェクト（ベクター線など）が選択されてしまい、思ったような操作ができないことがあります。 このような場合は、下記のように設定することで、操作対象になっているレイヤー上のオブジェクトのみを選択することができます。
図: 別レイヤーへの選択切り替えをオフ ツールパレットから 操作 ツールを選択 ツールプロパティパレットを開き、透明箇所の操作 のプルダウンを開く 別レイヤーへの選択切り替え のチェックボックスをオフにする</description></item><item><title>クリスタのメモ: ワークスペースのレイアウトをリセットする</title><link>https://maku.blog/p/od3ojpe/</link><pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/od3ojpe/</guid><description>Clip Studio Paint のパレットのレイアウトは自由に変更できるため、うまく配置すれば効率的に作業できるようになります。 ただ、慣れないうちに適当に配置を変えていると、デフォルトの配置からかけ離れたものになってしまい、かえって使いにくくなってしまうこともあります。 マニュアル本との対応付けもしにくくなっていまいます。
このような場合は、メニューから下記のように選択するだけで、初期のレイアウト（基本レイアウト）に戻すことができます。
ウィンドウ → ワークスペース → 基本レイアウトに戻す</description></item><item><title>クリスタのメモ: 画像ファイルをレイヤーとして取り込む</title><link>https://maku.blog/p/bycbpyn/</link><pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bycbpyn/</guid><description>画像ファイルを新規レイヤーに取り込む メニューから次のようにした画像ファイルを読み込むことができます。 取り込んだ画像は、新しいレイヤーに配置されます。
ファイル → 読み込み → フォトライブラリから&amp;hellip; iPad 版の場合は最後の フォトライブラリから&amp;hellip; の代わりに、カメラ撮影&amp;hellip; を選択して、カメラ撮影した写真を直接キャンバスに取り込めます。
画像を取り込んだレイヤーを編集できるようにする 取り込み メニューから画像を取り込むと、作成されるレイヤーは 画像素材レイヤー になっています。
このレイヤーに直接描画を行いたい場合は、レイヤー メニューから ラスタライズ を実行してラスターレイヤーに変更しておく必要があります。
ラスターレイヤーになったら、ペンツールなどで直接編集できるようになります。
キャンバスサイズを画像サイズに合わせる 取り込み メニューから画像ファイルを取り込んでも、キャンバスサイズは変更されません。
画像サイズに合わせてキャンバスサイズを変更したいときは、メニューから下記のように実行します。
レイヤー → レイヤーから選択範囲 → 選択範囲を作成 編集 → キャンバスサイズを選択範囲に合わせる</description></item><item><title>クリスタのメモ: 選択範囲外を削除する</title><link>https://maku.blog/p/pa7qtf9/</link><pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pa7qtf9/</guid><description>例えば下記のような絵が 1 つのレイヤーで絵が描かれているとして、アザラシ以外の部分をまとめて削除したいとします。
選択範囲ツールの、投げなわ選択 などを使って、残したい部分をぐるっと囲みます。
図: 選択範囲→投げなわ選択 選択範囲ランチャーの、選択範囲外を消去 のボタンを押します（上部のコマンドバーにも同じボタンがあります）。 あるいは、メニューから 編集 → 選択範囲外を消去 を選択します。
図: 選択範囲外を消去 すると、アザラシ以外の部分が削除されます。
ちなみに、選択範囲を解除したいときは、選択範囲ランチャーの左端にある 選択を解除 のボタンを押してください。
図: 選択を解除</description></item><item><title>HTML5 の time 要素の正しい使い方</title><link>https://maku.blog/p/ukama8m/</link><pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ukama8m/</guid><description>time 要素とは HTML5 には、機械（コンピュータ）の読み取りのための要素として data 要素が定義されています。 中でも時刻はよく使用する情報なので、特別に time 要素として定義されています。
この要素を記事内に含めておくことで、article 要素の作成日時や、ページ自体の作成日時を表現することができます。 正しいフォーマットで記述しておけば、検索エンジンの検索結果に日付を表示してもらえるかもしれません。 SEO 対策のためにも、time 要素を正しく記述できるようにしておきましょう。
time 要素の記述方法 &amp;lt;time datetime=&amp;#34;日時情報&amp;#34;&amp;gt;表示される日時&amp;lt;/time&amp;gt; time 要素のフォーマットは上記のようになっており、datetime はオプショナルな属性です。 datetime を省略する場合は、表示される日時 の部分が、RFC 3339 - Date and Time on the Internet で定義された形式で記述されている必要があります。 典型的な書き方は下記のような感じ。
書式 意味 2019-04-27 日付（UTC あるいは日本時間） 2019-04-27T21:30Z 日付＆時刻（UTC） 2019-04-27T21:30+0900 日付＆時刻（日本時間） 逆に、datetime オプションに上記のような日時情報を含めておけば、表示される日時 の部分には任意のテキストを指定することができます。 なので、下記の 2 つの time 要素はどちらも正しい記述です。
正しい書き方 &amp;lt;time&amp;gt;2019-01-01&amp;lt;/time&amp;gt; &amp;lt;time datetime=&amp;#34;2019-01-01&amp;#34;&amp;gt;2019年の元日&amp;lt;/time&amp;gt; datetime 属性を省略している場合は、表示される日時 の部分を独自形式で記述してはいけません。
間違った書き方 &amp;lt;time&amp;gt;2019年の元日&amp;lt;/time&amp;gt; 正しく time 要素を使って、人にも機械にもやさしい Web サイトを作成したいですね！
schema.org の構造化データマークアップ HTML データに、より明確な意味を持たせるための schema.</description></item><item><title>読書メモ『るるいえびぎなーず - クトゥルフ神話TRPG入門』内山靖二郎</title><link>https://maku.blog/p/67uziuj/</link><pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/67uziuj/</guid><description>るるいえびぎなーず - クトゥルフ神話TRPG入門 内山靖二郎、アーカム・メンバーズ エンターブレイン 女子高生の睦（むつみ）と、いっしょにクトゥルフ神話 TRPG を学んでいくお話です。 題材はクトゥルフ神話ですが、どんな TRPG にも言える一般的な心構えや、シナリオの作り方のコツなども載っているので、クトゥルフ神話以外の TRPG をやってみたいという人にもオススメできる本です。 なお、クトゥルフ神話 TRPG では、ゲームマスター (GM) のことをキーパーと呼びます。
ここでは、プレイヤーの心得、キーパーの心得、シナリオの作り方のコツなどをまとめておきます。
プレイヤーの心得 プレイヤーは、謎を解き明かし事件を解決しようとするキャラクター “探索者” の役を引き受ける ルールブックのこの一文に、探索者としての心得は集約されている。 何か怖そうなことが起こったときに、ただ引き籠っていたら話が進まない。 事件には好奇心を持って臨むこと。
キーパーは敵ではない キーパーはプレイヤーの邪魔をするかもしれないけど、困らせようとしているのではなく、楽しませようとしてやっていることを理解してプレイしよう。
自由は断るためのものではない プレイヤーが自由に行動できるというのが TRPG のウリだけど、NPC からお願いされたことをむげに断るというのが自由ではない。 断ることよりも協力することを考えよう。 どういう状況であれば探索者が協力するのか考え、ストーリーをみんなで楽しみながら作っていくのがよい。
命は大切に クトゥルフ神話 TRPG は死にやすい。 事件に対して積極的になるべきといっても、何にでも突っ込んでいけばいいというわけではない。 「事件や謎の解明」と「命を大切にすること」はバランスよく考えてプレイしないといけない。 不幸にも探索者が死んでしまった場合はネガティブにとらえず、死にゆくときを精一杯楽しむのがよい。
探索のノウハウ（便利な行動集） 図書館で調べる。図書館に行って事件について調べるという行動は、プレイヤーにとっても、キーパーにとっても便利な行動。ただし、＜図書館＞の技能ロールは、4 時間程度かかる行動であることに注意。 新聞社に行く。交渉力があれば、記者に話を聞いた方が、図書館で調べるよりも早い。ファンタジー RPG でいうところの酒場。 日記を読む。クトゥルフ神話では、登場人物の日記がよく登場する。誰かの部屋を調べるときは、まずは「日記を読む」と宣言するという冗談がある。プレイヤーと敵対する NPC の情報を提供するには、日記という手段はもってこい。 魔道書を読む。日記と並んでよく出てくる情報源。クトゥルフ神話に関する禁断の知識が記されている。読むと正気度が下がったりするが、引き換えに呪文を覚えられたりする。 現場を調べる。事件に遭遇したら、まずは現場を調べることから入って間違いない。この辺りのノウハウは、刑事ドラマや推理小説が参考になる。 聞き込みをする。自分のセリフに NPC がダイレクトに反応してくれるのは TRPG ならではの魅力。クトゥルフ神話 TRPG では、聞き込みに必要な ＜言いくるめ＞＜説得＞＜信用＞＜心理学＞ といった技能が充実している。 探索者の設定／知識 探索者は知り合い同士にしておいた方が、すぐに協力体制をとることができてゲームの展開が早くなる。 探索者とプレイヤーの知識は別物として扱わなければならないが、何も知らないはずの探索者に、どうやってプレイヤーの知識に基づいた行動をさせるのか考えるのもこのゲームの面白さのひとつ。
狂気に陥ったとき これまで正常だった仲間が、狂気に陥った途端に人が変わってしまうという恐怖をプレイヤーの方から演出できるのはクトゥルフ神話 TRPG の大きな魅力。 ただ、狂気に陥ったからといって何をしてもいいというわけではない。 いきなり銃を乱射するような周りに迷惑をかけるような行動はダメ。 あくまで周りを楽しませるようなロールプレイをしよう。</description></item><item><title>読書メモ『伝説の社員になれ！』土井英司</title><link>https://maku.blog/p/p68t83i/</link><pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p68t83i/</guid><description> 「伝説の社員」になれ！ 成功する5％になる秘密とセオリー 土井英司 草思社 出世することではなく、自分の価値を高めることが大切なんだよと教えてくれる本です。 会社の中で働いていると、どうしても地位というものを感じてしまいます。 人生100年時代に入り、「出世＝勝ち組」のように考える人はさすがに少なくなりましたが、平社員という低い立場を逆に利用して自分の価値を高めていくという考え方は、多くの人に希望を与えてくれると思います。
伝説の社員 自分をトコトン安く売り、その引きかえに、経験と実験の場を手に入れる。 会社という舞台で「タダの社員」という立場をフルに活用し、「伝説」を作る。 自分に付加価値をつけるとは、上司にゴマをすることでも、外国語を流暢に話すことでもない。 伝説の社員になってしまえば、いつでもその能力を「キャッシュに換える」ことができる。 ソコソコ出世するスーパーエリートは能力に秀でている。とんでもなく成功する「伝説の社員」と呼ばれる人は、情熱なら誰にも負けない。 どう働くか、職場をどう捉えるか 自分が成長するために必要なのは、出世したり、高い給料を追い求めることではない。一生を通じて自分がケアをし、それによって自分も成長できる、そんな対象を見つけること。 職場は授業料を払ってでも行きたい、興味深い人間の悲喜劇に満ちている場所である。複雑な人間関係やトラブルの処理は、専門学校や通信教育では学べない。 お金はためるより、自分の価値を高めるために使った方が、あとで何倍にもなって戻ってくるのではるかにトク。 24時間使える、そう思ったとき、それまでは「ない」と思っていたものが「ある」に変わる。 自分一人のために働いていると、どんどん煮詰まっていくが、会社のため、人のために働いていると、人との繋がりはどんどん広がっていく。 会社の経費に自腹という投資分を上乗せして成果を出そうという発想があってもよい。 一億円あろうがなかろうが、遊びは人生のメインにはならない。金を抱えてリタイアするより、一生面白い仕事をする方が、よほど生き甲斐がある。 学び方 高価な本を買う Bad: ベストセラーを読んで皆と同じ情報を共有する安心感を得る。 Good: 多少痛い自腹を切ってでも、特化した情報を手に入れる。自分の血肉になるものにお金を使う。 成功の方法を学ぶよりも、失敗しない方法を学ぶ 成功する方法は明日にも陳腐化するが、失敗の要因はいくつかにまとめることができる。 「私のミスです」と、はっきり言えるような「原因も失敗も明らかな失敗」は、正確なデータがとれるのでかけがえのない財産になる。 失敗した人が身近にいたら、話をトコトン聞こう。 ダメ上司がいるのなら絶好のチャンスと考える。失敗している人のそばにいる人は、失敗を観察できぶん有利な立場にいる。 異業種交流会やセミナーでは、講師に近づこうとするのではなく、目の前の参加者と話し、名刺交換をするのがよい。その中には必ず自分と一緒に伸びていく人がいる。 自分マーケティング 自分はどんなことを褒められたら嬉しいのか？それがわかれば自分の才能は開花する。 会社ではなく◯◯さんにお願いしたい、という取引先や客を多く掴んだときが独立のタイミング。伝説の社員は、取引先や顧客など、社外にファンを持っている。 一緒に仕事をしている人を誰かに紹介するときは、「◯◯さんは△△の分野でとても優秀なんです」と具体的な褒め言葉を添えて強い印象を残す。その人の価値を伝えることができるし、そんな素晴らしい人を紹介してくれたあなたにも感謝してくれる。 寒いときに寒そうな顔をすることは誰でもできる。寒いときに暖かそうな顔をすること、そういうことができる人が貴重。それは価値であり、人を惹きつける。 人脈を広げたければ、好かれるより、信用されることを目指す。いい人だけでは意味がない。 自分を売るためには、自分にわかりやすいキャッチコピーをつける。 「女性下着を売っているスケベオヤジです」塚本幸一（ワコール創業者） 「書評に関しては毒舌で辛口の◯◯です」土井英司（出版コンサルタント） 「営業成績ナンバーワンを目指す◯◯です」 「ユーザーの立場が第一と考える◯◯です」</description></item><item><title>雑誌、本の読み終わったページをひと目で分かるようにする</title><link>https://maku.blog/p/zvwesen/</link><pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zvwesen/</guid><description>みなさん、本をどこまで読んだかってどのようにマーキングしてますか？
わたしは読み終わったページの隅っこのところ（ページ番号が印刷されているあたり）を切り取っています。 こうすると、読み終わったページと、読んでいないページがすぐに分かるようになります。 さらに、まだ読んでいないページをさっと開くことができるようになります。
前から順番に読んでいく場合は付箋を貼っておくのもよいですが、この方法なら、飛ばし読みしたりする場合でも、一度以上読んだページと一度も読んでないページをすぐに区別できます。 付箋がなくても、ハサミだけで OK ですしね（笑）。
かれこれ 10 年以上この方法を続けていますが、何割くらい読み終わったかが一目で分かるので、本を読み切るというモチベーションにも繋がっている気がします。 大切な本に切り込みを入れることには抵抗があるかもしれませんが、本は読んでこそ価値が出るもの。 コレクションとして 10 年後まで本を綺麗な状態で保つことを目的としていないのなら、時間を有効に使うことを徹底した方がよいと思います。</description></item><item><title>読書メモ『孫社長にたたきこまれた すごい「数値化」仕事術』三木雄信 (1/5)</title><link>https://maku.blog/p/yuhqrdx/</link><pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yuhqrdx/</guid><description>孫社長にたたきこまれた すごい「数値化」仕事術 三木雄信 PHP研究所 若い時からソフトバンクの孫さんの右腕として働いていた三木さんの著書です。 「数値化」というタイトルなので、よくある KPI、KPI とうるさい内容なのかと思ったら全然そんなことはなく、本当に企業の生産性を上げられそうな考え方や方法がギュッと詰まった本でした。 長年培ってきた知識を一冊の本にまとめてくれたことに感謝です。
なぜ「数値化」すると生産性が劇的にアップするのか 問題が多すぎて、どこから手をつけていいかわからない → 数値化すれば、「どの問題から着手すればいいか」優先順位が明確になる。
例: コールセンターへのクレームを分類したら、2種類の問題が全体の80％を占めていた。 数値化しないと、立場が上の人や、声が大きい人の意見ばかりが通ってしまう → 数字が正しければ、どの立場の人も動かせる。
例: モデムのクレームを減らせば、コール発生率を5％から4％に減らます。1％減ると、毎月4000万円のコスト削減になります。 数値化の 7 つのコツ (1) 数字は「与えられるもの」ではなく、自分で「取りにいくもの」 会社から与えられた数字で、自分の問題が解決しないなら、それは取るべき数値が間違っているということ。「自分の問題」を解決するには、本当に必要な数字を計測し、分析して、「数値」という道具に仕立て上げなくてはいけない。
(2) 数値化の目的は「どうだったか」ではなく「どうするか」 未来（＝次のアクション）に繋がらない数値化には意味がない。
(3) 数値化のファーストステップは「分ける」こと。数える前にまず分けろ！ 分け方の例
「種類別」、「業界別」、「ジャンル別」に分ける 始点と終点を決め、「プロセス」、「工程」で分ける 分け方にルールはないので、自分で決めればいい。 チームで問題解決に当たる場合は、メンバー全員でグループ分けの作業をするとよい。全員にポストイットに5枚ずつ「思いつく理由」を書いてもらってグループ分けしてみる。
(4) 問題のありかが見えてきたら、さらに細かく分けて計測 計測ポイントの例
「1日」ごと 「場所」ごと 「人」ごと 迷ったら、とにかく手を動かしてみて、事実を見る。
(5) 数値化のゴールは、現実の問題を「数式で表す」こと 「データ」それ自体は意味のない数字である。大事なのは、データを「構造化」して、情報やナレッジにすること。 情報: データを整理し、解釈や意味を持たせたもの ナレッジ: 情報を体系化し、まとめたもの ビジネスの現象をモデル化することが重要。 数式は必ず解くことができる。だから、数値化すれば、問題を解決することができる。 例: 小売業の売上 ＝ 1平方メートル当たりの売上 × 店舗面積 × 営業日数 例: 営業部の売上 ＝ 営業マン1人あたりの1日の売上 × 営業の人数 × 営業日数 例: 1日にどれだけモデムを配れるか ＝ 立地（通行料） × アルバイトの習熟度 (6) 数値化したら、あとはPDCAを高速で回し続ける 実行した結果、得られる数値ほど正確なものはない。 日本企業は失敗を恐れて、計画に時間をかけすぎる。 実行 (Do) と計画 (Plan) は順序通りやる必要はなく、セットで迅速に回す。 (7) 問題解決後も数字でチェックを続け、環境変化にいち早く気づく 数字を日々チェックしていれば、「予測値と実測値が急にズレるようになった」ということが分かり、環境の変化に気づくことができる。</description></item><item><title>Let's Encrypt certificate expiration notice が来たら</title><link>https://maku.blog/p/cniq5vr/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cniq5vr/</guid><description>Let&amp;rsquo;s Encrypt Expiry Bot からの証明書期限切れメール 2 ヶ月ほど前に、Sakura VPS レンタルサーバーを Let&amp;rsquo;s Encrypt で SSL 対応していたら、こんなメールが来ました。
Your certificate (or certificates) for the names listed below will expire in 20 days (on 10 Apr 19 07:02 +0000). Please make sure to renew your certificate before then, or visitors to your website will encounter errors.
We recommend renewing certificates automatically when they have a third of their total lifetime left. For Let&amp;rsquo;s Encrypt&amp;rsquo;s current 90-day certificates, that means renewing 30 days before expiration.</description></item><item><title>クリスタのメモ: 下のレイヤの描画領域だけに描画する（クリッピング）</title><link>https://maku.blog/p/f2kkmnw/</link><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/f2kkmnw/</guid><description>ある絵の上に影を追加したいときなどは、レイヤを 1 枚上に追加して、下のレイヤでクリッピングして色を上乗せしていくとよいです。
ここでは、図のような単純な矩形が描画されているレイヤが 1 枚あるとします。 まず、この上に重ねる形で 新規レイヤを作成 します。
新規作成したレイヤ（上にあるレイヤ）が選択された状態で、下のレイヤでクリッピング のボタンを ON にします。
すると、上のレイヤに赤いバーが表示された状態になります。
この状態で、上のレイヤに描画すると、下のレイヤの描画領域に重なる部分だけが見えます。 これが、下のレイヤでクリッピング の機能です。
実際に描画されている部分はもっと広いのですが、この機能によって、見た目だけがクリッピングされて見えるようになっています。 クリッピングのボタンをもう一度押して OFF にすると、実際に描画されている部分すべてが見えるようになります。 あまりに広い範囲が無駄に塗られているようでしたら、この状態で消しゴムツールで消してしまうとよいでしょう。</description></item><item><title>読書メモ『プラットフォーム革命』アレックス・モザド、ニコラス・L・ジョンソン</title><link>https://maku.blog/p/g4mr3g7/</link><pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/g4mr3g7/</guid><description>プラットフォーム革命 アレックス・モザド、ニコラス・L・ジョンソン 英治出版 Amazon や Google、Facebook に代表されるように、今や「プラットフォーム」を浸透させた企業＝勝ち組といった構図になっています。 この『プラットフォーム革命』では、プラットフォームって何なのか、どのようなプラットフォームが勝ち残るのか、といったことをたくさんの会社の事例をもとに学ぶことができます。
中でも、下記のプラットフォームの 4 つのコア機能に関する説明は参考になります。 何か新しいプラットフォームを作成するときには、これらのコア機能をどう達成しているのかが重要になってきます。
(1) オーディエンス機能 消費者とプロデューサ（提供者）を集める機能のこと。
Airbnb などは他のサービスと勝手に連携させて顧客を奪うみたいなことまでやっている。そのようなやり方の是非はともかく、プラットフォームとして成立するには、消費者とプロデューサの量を確保して、取引を成立しやすくするという流動性が必要になる。
消費者とプロデューサをやみくもに集めると、その人数のアンバランスの問題も出てくる。Uber などは、価格を動的に変更させる仕組みを導入して、この需要と供給のバランスをうまく解決するようにしている。
(2) マッチメイキング 消費者とプロデューサを結びつける機能のこと。
消費者とプロデューサの量を確保できたら、今度は両者をいかにマッチングさせるか（取引成立させるか）が課題となる。
うまくいっているプラットフォームは、ユーザの数が増えても自動的にスケールするような仕組みができている。Uber は巡回セールスマン問題的な問題を自動で解き、非常に早く車が到着するようになっている。アマゾンは協調フィルタリングの仕組みで膨大な商品の中からオススメできている。Youtube は視聴時間に基づいたおすすめ機能がうまく働いている。
(3) 中核となるツールとサービス コアとなる取引を円滑化するためのツールやサービスのこと。
設計者はとにかくいろんな機能を詰め込みすぎてしまう。 まずは シンプルで効率的 なツールやサービスを提供することが大切。 と、Facebook のマーク・ザッカーバーグも言っている。
Twitter はシンプルなテキスト送信機能から始めた。 Google はシンプルな検索機能から始めた。 Amazon は本だけの販売から始めた。
こういった今でも成長しているプラットフォームは、シンプルで使いやすい機能から始めてうまくいっている。
(4) ルールと基準 ユーザが安心して使えるような仕組みが必要。
一度はユーザを集めたのに廃れてしまったプラットフォームは、ユーザの安心感を満たせなかったりしてユーザが離れていってしまったものが多い。
ユーザ数が膨大になってくると、プラットフォームの提供者がユーザの行動を監視することは不可能になってくる。 そこで、Airbnb などは、消費者とプロデューサの間で評価をつける仕組みを導入して、自動的に評価の低いユーザは淘汰されていくようになっている。
ただ、この評価という仕組みは後付けなので、できればユーザには最初からよい振る舞いをしてもらいたい。 そのためには、ちゃんと「ルールと基準」をプラットフォーマーが定めて提示する必要がある。 法的な強制力がない場合でも、ほとんどのユーザはそれに従ってくれる。</description></item><item><title>コルク代表 佐渡島庸平さんのお話</title><link>https://maku.blog/p/urdve7g/</link><pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/urdve7g/</guid><description>『インベスターZ』 や 『宇宙兄弟』 を担当されていた佐渡島さんのお話を聞いたのでメモメモ。
コミュニティを作ると強い 宇宙兄弟のコミュニティを作って、今は 35,000 人くらいいる。 そこで商品を紹介すると、10% 以上の人が買ってくれるというすごいコンバージョンレートを達成できる。 がんばっていろんな店に商品を並べるより、圧倒的に効率がよく、すぐ売り切れる。 インターネットでつながった世の中では、このようなビジネスモデルが今後主流になっていくだろう。
ボットとのコミュニケーション チャットボットとチャットしているとき、相手が機械だと分かっていても褒められるとうれしいと感じる。 それはきっと、何がよいことなのか、褒めるべきことなのかという設定を、裏側で人間がやっていることを知っているからだと思う。
コンテンツの値段はタダになる コンテンツはすべて無料になるだろうという前提で活動している。 少なくとも中国はもうそうなっている。 一方で、他の人よりも早くコンテンツ（情報）を手に入れられるということに対してはお金を払う人はたくさんいる。
▽インベスターZなどがタダ同然の値段で売ってたりしたのは佐渡島さんの仕業なのかな。</description></item><item><title>読書メモ『20円で世界をつなぐ仕事』小暮真久</title><link>https://maku.blog/p/vsw6doh/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vsw6doh/</guid><description>20円で世界をつなぐ仕事 小暮真久 ダイヤモンド社 TABLE FOR TWO という仕組みを世の中に広げる NPO 法人をやっている小暮さんの本。 主に会社の食堂に導入するように活動していて、カロリーの低いヘルシーメニューを頼むと、その代金のうち 20 円がアフリカに寄付され、子供の食費1人分に当てられるという仕組みです。 従業員の多い会社に勤めている方は、食堂に導入されているのを見たことがあるかもしれません。
ヘルシーメニューを頼むことで、自分はカロリーオフできて、さらにアフリカの子供を救うことができる。 一粒で二度美味しいとてもよい仕組みなのだけど、「寄付」という仕組みがベースである都合上、企業に導入してもらうのにはいつも苦労しているようです。 NPO 法人はボランティア的なものだと思われることが多く、そういった活動から給料を得ているということ自体に難色を示す人がまだまだいる。
それでも、アフリカの子供たちを直接笑顔にできるという仕事にとても生きがいを感じているようです。 そんな天職に巡り逢えるのってとても幸せなことだと思います。 この本を読んだ人が NPO 法人の活動というものを理解し、世界中の人を幸せにする仕組みがもっともっと広まっていくとよいですね。</description></item><item><title>2019-01-14 大室山からの景色は壮観！</title><link>https://maku.blog/p/g2d9uzk/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/g2d9uzk/</guid><description>伊東にある大室山（おおむろやま）に登ってみました。 といっても、歩いて登山するわけではなくて、こんなリフトで登っていきます。 往復500円。 このリフトはすごい低空で、ときどき地面に足が着いたりして面白いです。
頂上に着くと、火口を一周できます。
360度景色を見渡せるのですごく景色がいいです。 近くに来たときはぜひ登ってみるとよいです。 ちなみに隣にはシャボテン公園があります。カピバラさんがいます。
風が強くて、この季節はちょっと寒かったです。 ニット帽が必須かな。
車でちょっと移動すると、世界遺産の韮山反射炉（にらやまはんしゃろ）があります。 残存する唯一の反射炉らしいです。 説明員の人が丁寧に歴史を教えてくれます。
この反射炉は、銑鉄を熱で溶かして大砲を作る設備です。 熱を壁に反射させながら温度を上げて金属を溶かすので反射炉と言います。
ここで作った大砲はペリー来航に備えて東京の品川に設置されました。 砲台を設置する場所なので「台場」と呼んでいます。 台場は 8 つ作られたのですが、今では台場公園として第三台場だけ入ることができます。 もうひとつ第六台場も残っているのですが、陸路がなくて入ることはできません。
お台場に行くことがあったら、買い物だけじゃなくて、砲台跡も見てみるとおもしろいです。</description></item><item><title>お名前.com の共用サーバーを Let's Encrypt で SSL 対応</title><link>https://maku.blog/p/s46j9sq/</link><pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s46j9sq/</guid><description>Chrome で https に対応していない Web サイトにアクセスすると、アドレスバーに「保護されていない通信」という警告が出るようになりました。 Web サーバーの管理者は、https (SSL) への対応がほぼ必須になっています。 ここでは、お名前.com の共用サーバー（SD-11、SD-12 プランなど）で、SSL を有効にし、http によるアクセスがあったときに https なアドレスにリダイレクトする設定方法を説明します。
Let&amp;rsquo;s Encrypt による SSL 対応 お名前.com の共用サーバーで Web サイトを運用している場合は、下記のコントロールパネルからポチポチやるだけで、簡単に SSL (https) によるアクセスを有効にすることができます。
共用サーバーSD コントロールパネル https://cp.rentalserver.jp/ 自前の Web サーバで SSL 設定を行おうとすると、証明書の発行手続きや設定などが結構面倒ですが、このコンパネからポチポチやれば 1 分で設定完了です。 無料証明書で有名な Let&amp;rsquo;s Encrypt のサービスに対応しているので、無料で SSL 対応することができます。
http アクセスを https にリダイレクトする 数時間待って、無事 SSL の設定が反映されると、https:// によるウェブサイトへのアクセスが可能になります。 ただし、そのままだと古い http:// のサイトも残ったままです。
ここでは、Web サーバー (Apache) の設定ファイルである .htaccess を修正（なければ新規作成）することで http から https へのリダイレクト設定を行います。 ここでは、下記のような手順で修正することにしましょう。
sftp コマンドでサーバ上の .htaccess を取得（存在する場合のみ） ローカルで .</description></item><item><title>Nginx で 403 Forbidden エラーが出るときのチェック項目</title><link>https://maku.blog/p/ew5zmmw/</link><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ew5zmmw/</guid><description>nginx サーバを起動して Web ブラウザでアクセスしたときに、ブラウザ上に 403 Forbidden エラーが表示されるときは、パーミッション系のエラーが発生しています。
サーバ自体は稼働していますので、下記のあたりを確認すれば無事表示されるようになります。
ファイルに読み取り権限、ディレクトリに実行権限を付ける html ファイルなどのコンテンツファイル自身には読み取り権限、ディレクトリには実行権限が必要です。
$ chmod 0755 -R /home/maku/website ドキュメントルートまでのディレクトリに実行権限 (x) を付ける 例えば、ドキュメントルートを /home/maku/website としている場合は、/、/home、/home/maku、/home/maku/website のディレクトリに実行権限が必要です。
$ chmod +x /home/maku 特定のディレクトリのパーミッションは下記のように確認できます。
$ ls -ld /home/maku drwx--x--x 5 maku maku 156 1月 10 17:32 /home/maku nginx の設定を再読み込み ファイル群のパーミッションを変更しただけでは nginx の再起動は必要になりませんが、nginx の設定ファイルを変更した場合は、設定ファイルを反映する必要があります。
$ sudo service nginx reload</description></item><item><title>Nginx の設定: http でアクセスされた場合に https にリダイレクトする</title><link>https://maku.blog/p/jowgstm/</link><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jowgstm/</guid><description>nginx サーバの SSL 対応（https 有効化）が終わった後は、http プロトコルによるアクセスは避けてもらいたいですね。 そのような場合は、下記のように設定しておけば、http でアクセスされた場合に、https で再度アクセスしてもらうようにクライアントに応答することができます（301 という値は、Moved Permanently を示す HTTP レスポンスコードです）。
/etc/nginx/conf.d/xxx.conf server { listen 80; server_name example.com; return 301 https://$host$request_uri; } server { listen 443 ssl http2; server_name example.com; # ... } 結果として、Web ブラウザから http://example.com/ にアクセスすると、Web ブラウザは自動的に https://example.com/ という URL でアクセスし直すことになります。</description></item><item><title>Sakura VPS レンタルサーバーを Let's Encrypt で SSL 対応</title><link>https://maku.blog/p/xkpjfcf/</link><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xkpjfcf/</guid><description>今更ですが、さくらインターネットでレンタルしている Sakura VPS の Web サーバーを SSL (https) に対応しました。 とりあえず今回は無料の Let&amp;rsquo;s Encrypt の証明書を、nginx サーバに設定します。
使っている OS が CentOS6 だったので、ついでに CentOS7 をクリーンインストールすることにしました。 といっても、さくらインターネットの VPS の設定画面でポチポチとやっていくだけ。 ここで、[public] CentOS_LetsEncrypt というスタートアップスクリプトを選んだら、自動的に SSL の証明書などの対応が完了します。 入力するパラメータはドメイン（example.com など）と連絡用のメールアドレスだけ。
Web サーバの nginx も自動的にインストールされて、Web サーバにアクセスできる状態で起動するのですが、nginx の設定は少しだけ調整する必要があります（ドキュメントルートなど）。
数分で OS の再インストールが完了し、下記のような nginx の設定ファイルが自動生成されていました（ドメイン名は example.com に置換してあります）。 SSL の設定も完了した状態になっています。
/etc/nginx/conf.d/https.conf map $http_upgrade $connection_upgrade { default upgrade; &amp;#39;&amp;#39; close; } server { listen 443 ssl http2; server_name example.com; location / { root /usr/share/nginx/html; index index.</description></item><item><title>好きな映画、ドラマ、TV番組、マンガ</title><link>https://maku.blog/p/z97ysqu/</link><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z97ysqu/</guid><description>いやぁ、映画ってほんっとうにいいもんですね。 貧乏モノ、病気モノ、音楽モノの映画とかは鉄板で感動してしまいます。
好きな映画 『小説家を見つけたら』 : ショーンコネリー主演。 とってもほんわかできる映画で、すべての人におすすめできる映画です。 16歳の高校生ジャマールは、自分が書いていた小説のメモを落としてしまいます。 そのメモは戻ってくるのですが、そこには細かい批評がびっしりと書き込まれていました。 ジャマールは最初、「落書きしやがってと」思って読んでいましたが、その的確な指摘にのめり込んでいきます。 それは、行方の分からなくなっていた幻の大作家フォレスターによる仕業だったのです。
『カンフーハッスル』
チャウシンチー主演。 少林サッカーもよいのだけど、こっちの方が好きかな。 無駄に派手なところがわざとらしくて好きです。
『セッション』 : J・K・シモンズが熱い、熱すぎる。プロのジャズ演奏者を育てるために徹底的にしごき倒します。それが嫌がらせなのか、本気で育てたいのかわからない。それでも必死にがんばる主人公。この映画を見ると、必死になるというのはこういうことなんだってことがわかります。それにしても最後のシーンはイイ。ラストは 5 回くらい見ました笑。そして師弟愛の行く末がモヤッとしたまま終わるのがまたイイ。
『ザ・ハッカー』 : ハッカー題材にした映画って適当な描写が多いのですけど、初めて本格的だって思えたハッカー映画です。ドラマだと『ブラッディ・マンデイ』もハッカーものとしてはよくできてますね。
『ビューティフルマインド』 : 狂ってしまった数学者ジョン・ナッシュの話。 ゴールのわからない問題に対してずっと向かい合っている人って、少なからずおかしくなってしまう危険性があるのだと思う。 ちょっと悲しくも暖かい気持ちになれる映画です。
『雀鬼シリーズ 1〜5』 : Vシネマですけど。。Vシネマ史上初めてオリコントップを独占し続けた伝説の麻雀映画です。 伝説の雀鬼、桜井章一さんが監修してます。 今でもこの映画を凌ぐ麻雀映画はないし、今後も出ないでしょうね。
『プレステージ』 : 究極の発明により、究極のマジックが生み出されました。 ただ、その裏にはとんでもない犠牲が隠されていました。 印象に残る映画だけど、2 回見る気にはならないかもしれない。
好きな俳優 チャウ・シン・チー: ハッスルハッスル！ ショーン・コネリー: 「小説家を見つけたら」を見てからはまりました。 ロバート・ネッパー: プリズン・ブレイクのセオドア（ティーバッグ）が最高。トランスポーター３の悪役とかやってます。 ブレンダン・フレイザー: 「センター・オブ・ジ・アース」を見て、他の作品も見てみたくなりました。 好きなドラマ 僕と彼女と彼女の生きる道: ハーモニカの練習をしている娘からハーモニカを取り上げて投げつけ、「うるさいんだよ！」と怒鳴るような父親（草なぎ剛）が心を開いていく物語。草なぎ君ドラマには名作が多いけど、その中でも一番好きかも。 銭の戦争: 草なぎ剛さん主演。登場人物の本心がなかなか読めないところが面白いです。復習心から行動していた主人公が、だんだんとお金に取り憑かれていくように見えるけど、実はそうではないと思わせたり、でも最後の最後で・・・といった感じで飽きさせません。 銭ゲバ: 貧乏でセコイ主人公（松山ケンイチ）とその父親（椎名桔平）とのやりとりが最高です。「銭ズラ〜〜〜」っていうセリフは残念ながら流行りませんでした。椎名桔平の「おーこわいこわい」っていう人をおちょくるようなセリフが好き。 プリズンブレイク: セオドア・&amp;ldquo;ティーバッグ&amp;rdquo;・バッグウェルが最高です！毎シーズン、「こんな状況抜け出せるわけない！」ってところから脱出してしまう展開がたまらなくおもしろいです。 TRICK: 謎解き的なストーリーも面白いですが、仲間由紀恵と阿部寛のドジ＆ドジのかけあいが好きです。ほんわか系。 セトウツミ: セト＆ウツミのくだらない会話だけで進んでいくドラマなんですが、絶妙なツッコミが心地よいです。ほんわか系。 節約ロック: 松本タカオ（上田竜也さん）の頭のわるすぎる節約術が毎回笑わせてくれます。悪巧みしてるときの顔がおもしろすぎるｗ 下町ロケット: 阿部寛さんのクサい演技に毎回感動してしまいます。最後には真面目に仕事に取り組んできた人たちが報われる正義感に溢れるドラマです。 僕の初恋をキミに捧ぐ: 学園おちゃらけラブストーリーかと思ったら感動モノでした。原作はフラワーコミックスなんですね。 ノーコンキッド: 田中圭主演のゲームセンターのお話。昔のゲームセンターを知ってるので、すごく懐かしい感じがする。 おいしい給食: そこまで美味しそうでもない給食のおかずをハイテンションで美味しそうに食べるのがサイコー。おいしいっおいしいっおいしーよっ♪ 草なぎ剛さん、阿部寛さんのドラマが好きな傾向があるみたいです。</description></item><item><title>ポリシー、座右の銘、モットー</title><link>https://maku.blog/p/3tog8xc/</link><pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3tog8xc/</guid><description>行動の選択基準 何かの選択や行動で迷ったとき、こんな感じで判断するようにしています。
まわりが笑顔になる方を選ぶ 楽しい方、楽しくなりそうな方を選ぶ 体によい方を選ぶ 例えば、料理のメニューを見て迷ったら、健康そうな料理を選びます。
また、落ち込んだときに気分良く過ごすにはこう考えます。
気にしない、気にしない、まいっか 別に死ぬわけじゃない 時間の使い方 趣味 → 仕事 → 勉強 → 趣味や仕事は「今」のため。 勉強は「将来」のため。 これらをバランスよくやらなきゃだめ。
日々やるべきことは、それを行うタイミングに注目すると、3 種類に分類できる。 TODO を書き出すときは、これらを分けて管理するとよい。
Routine: 定期的にやること（日課としての学習など） ToDo: 必ず終わらせなければいけないこと（終わったらリストから削除できる重要なタスク） Whim: 時間があるときにやればよいこと（趣味の読書など） 学びについて 真の学びとは 学びの真の目的は、スキルの学習ではなく「発達」。「覚える」のではなく、「察知する」力を付けていくべき。 苦労して手に入れたものの方が長く楽しめる 「仕組み」を学ぶ 何事に関しても、「仕組み」を知る・学ぶことを怠らないようにしたい。 特に技術的な事柄に関しては。
書籍『HACK PROOFING YOUR NETWORK』の中に、次のような言葉があります。
ハッキングのスキルを学ぶために費やす時間は、重要です。 ある目的を達成するだけの人は、時間をかけずに、スクリプトキディになりやすくなります。 そうなると、できることには限界があります。
どんなことに対しても「仕組み」を学ぼうという姿勢を持つことは重要だと思います。 例えば、ある仕事を片付けるための方法を聞いて、サクッと仕事を終わらせるだけの人と、その方法がどんな仕組みで成り立っているのかを同時に学ぼうとする人では、技術力や発想力の向上に差が出てきます。 ある物事に関して改善点を探すためには「仕組み」を知らないといけないし、まったく別の新しいアイデアを生み出すための知識として活用するためにも、「仕組み」を知ることは重要です。
「仕組み」を学ぶ姿勢なくして技術力の向上なし！
人間関係 コネを作ることを目的にして奔走しない。 自分の魅力（知識、能力、実績、人間性）を高める ことで、人が向こうからやってくる状態が理想。
人を疑うのではなく、まずは信じる こと。 何事にも疑いやすくなっているこのご時世、無条件に信じるくらいでちょうどいい。 こちらから信じなければ、信頼関係は生まれない。何も始まらない。
下記は、PRESIDENT『ハーバード式仕事の道具箱 「怒りの感情」をコントロールする法』より。 誰かに不快なことや受け入れ難い条件を突きつけられた時は、逆に 相手の視点を理解して、賞賛する のがよい。 賞賛すれば、相手にもこちらの協力をしようという感情が芽生えやすい。 相手の地位の分野を見極めて敬意を払う ことで、信頼感や相互協力を高めることができる。
モノを増やさない ものを使わずにたくさん溜め込むと、宝の持ち腐れになったり、なくした時にショックが大きい。 理想的には、仮に家が火事になって、身の回りの物が全部なくなった場合にものほほんとしていられるくらい 身軽になる こと。
使い捨てのものはどんどん使って捨てる。 読んで捨てられる資料はどんどん読んで捨てる。 使わないものは人にあげる。 増やすべきはモノではなく、自分の知識や能力 であることを忘れない。</description></item><item><title>好きな顔文字</title><link>https://maku.blog/p/afwfp22/</link><pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/afwfp22/</guid><description>わーぃ ٩(๑❛ᴗ❛๑)۶ わーぃ (｡╹ω╹｡) キュピーン (ฅ&amp;rsquo;ω&amp;rsquo;ฅ) エッ？ ∑(ﾟДﾟ；) （゜Д゜） (゜O゜; (　ﾟдﾟ) (つд⊂)ｺﾞｼｺﾞｼ (；ﾟдﾟ) (つд⊂)ｺﾞｼｺﾞｼ _, ._ （；ﾟ Дﾟ） その他 φ(･ｪ･o)~メモメモ ミ(・ 。・)彡 ウーパールーパー o(・・)oヾ(￣▽￣ ) ヨチヨチ (´･∀･`)ﾍｰ (∩ω・。)ﾉｼ ヨシヨシ( ^・ェ・^)/(; ; )グシュ (..､)ヾ(^^ )いいこいいこ |ω・`）チラ _ ∩ (　ﾟ∀ﾟ)彡　バイソン！バイソン！ ⊂彡</description></item><item><title>読書メモ『ザ・シークレット』ロンダ・バーン</title><link>https://maku.blog/p/mcshm5f/</link><pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mcshm5f/</guid><description>ザ・シークレット ロンダ・バーン 角川書店 自分の望む姿をイメージすることでそれが叶うという、引き寄せの話の集大成のような本です。 1ページ1ページのデザインがきれいで、思わず買ってしまった本です。これも引き寄せ。
引き寄せ的な考え方には否定的な人が多いのでしょうけど、幸せだと考えるのは自分自身なのだから、考え方から変えていくというのは実は本質を突いているのではないかと思います。 プラシーボ効果による治癒現象など、思い込みによって身体に影響が現れるということも実証されています。 まずは信じるところから始めてみよう。
ちなみに、ザ・シークレットは映像化もされていて、Netflix で見ることができます。 映像の方は宗教勧誘みたいな感じがしてしまうので、個人的には書籍の方が好きです。
良い思考をしているときに気分が悪くなることはない。もしも気分が悪いようなら、それはあなたが自分の感情を害するような思考をしているからだ。気分が悪くなったら、そのもとになっている思考を変えるか、気分転換をしよう。 あなたが欲しいと思ったものを、既に手に入れたと信じなければいけません。まだ受け取っていないと思えば、それをまだ持っていない状況を引き寄せてしまいます。 車が欲しければ、まずその車に試乗してみなさい。家が欲しければ、その家で使うものを買いなさい。そして、その家に実際に入ってみてください。その気分になれることはなんでもしてみると、それが引き寄せを実現するのです。 チャンスが到来し、衝動が起き、直感的なひらめきが浮かんだらすぐ行動を起こしなさい。それがあなたのなすべき事です。それだけでよいのです。 自分自身を愛と尊敬をもって扱ってください。そうすれば、あなたを愛し、尊敬してくれる人々を引き寄せます。 人生を好転させるために、真っ先にできることは、心から感謝できることの一覧表を作ることです。感謝することこそ、あなたの人生により豊かさをもたらす方法です。もし『ザ・シークレット』の中の知識をただ1つだけ選ぶとしたら、それは感謝です。 その人の長所を認め、感謝することに焦点を合わせ始めると、良いものをもっともっと引き寄せ、いつの間にか、問題は消えていきます。 愛の感情を作り出すあなたの能力は無限です。愛することができる全ての物を愛してください。愛することができる全ての人を愛してください。 （白紙の）小切手に、あなたの名前、金額などを書き入れて、目立つところに置いてください。その小切手を見て、今、その額を手にした気持ちになってください。そして、そのお金を使い、買いたいもの、やりたい事を全て実現している自分の姿を想像してください。それがどれだけ素晴らしい気持ちか実際に感じてください。 「お金が足りない」という思いから、「お金は充分にある」というように考え方を変えなくてはなりません。 「お金を稼ぐにはたくさん働いて苦労しなければならない」という考えを持っているようでしたら、それをすぐに捨ててください。その思いを「お金は容易に、かつ、頻繁に入ってくる」に変えましょう。 ノーマンは不治の病と診断されていました。医者は彼にあと数ヶ月の命だと宣告しました。そこで、ノーマンは自分の力で治すことに決めました。彼がしたことは、三ヶ月の間、喜劇映画を見て、ひたすら笑い続けることだけでした。すると、その三ヶ月の間に彼の体内から病気が消え、医者たちはその回復を奇跡だと驚嘆したのです。─ 笑いは本当に最高の薬なのです。 もしも、あなたがあまり気分がよくないときでも、誰かが、「ご機嫌はいかがですか」と尋ねてきたら、その人が気分転換するように言ってくれたと思い感謝してください。あなたの望むものについてだけ話してください。 私は「はっきりと見えます。はっきりと見えます」と繰り返し唱えました。三日後、私の視力は回復しました。 この法則の真髄は、あなたは豊かさを考え、豊かさを見、豊かさを感じ、豊かさを信じなければならないということです。あなたの頭に有限という概念をいれないようにしましょう。 あらゆるものが、全ての人々、全員に十分にあります。 「あらゆるものが豊かにある」「供給は無限にある」「宇宙はすばらしく気前が良い」ことを選び、知ってください。 思い通りにうまくいっていないことがあっても、不満を言ったり、とがめたりして、エネルギーを使ってはいけません。望むものを抱きしめてあげてください。 あなたの周りにあるものを祝福し、賞賛しましょう。 誰かを賞賛している時にはあなたは愛を与え、偉大な波動を放射しているのです。すると、それが100倍にもなってあなたに返ってきます。 あなたの敵でも賞賛し祝福しましょう。敵を賞賛し祝福すると、賞賛と祝福があなたに返ってきます。 世界の「問題」に焦点を合わせるのではなく、あなたの注意とエネルギーを「信頼」「愛」「豊かさ」「教育」「平和」などに向けてください。 あなたの夢やあなたのビジョンだけに焦点を合わせて、あなたの環境から全ての競争を取り払ってください。 あなたは創造主です。そして、この地球上で、あなた自身を創造しているのです。 「私は〜である」という言葉に威力がある（アファーメーション）。 私は全ての素晴らしいものを受け取っています。 私は幸福です。 私は豊かです。 私は健康です。 私は愛です。 私はいつも時間に間に合います。 私は永遠に若いです。 私は毎日エネルギーに満ち溢れています。 私たちはみんな繋がっていて、全ては一つです。 あなたがしなければならないことは、今、心地よい気持ちになることだけです。 感謝するクセをつけるために、毎日の終わりに感謝の気持ちを書き出していくのがいいかもしれませんね。
富ではなく、多くの人が幸せ、感動を味わえるようなことをしよう。富を得ることだけを目的にすると、争いや不幸を生む。幸せを与えること、味わうことは無限なのだから。</description></item><item><title>「ふたりザードリィ」やってみた</title><link>https://maku.blog/p/x7kd593/</link><pubDate>Sun, 23 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x7kd593/</guid><description>RPG アツマールで公開されている「ふたりザードリィ」やりました。
パーティーが2人しかいない簡単なウィザードリィ風ゲームです。 レベルアップの概念もなくて、お金でスキルアップしていくだけ。
すごいシンプルなのにゲームバランスは結構良くておもしろいです。 ウィザードリィは気になっているけど敷居がちょっと高いという人にもおすすめです。 基本的にはウィザードリィをベースにしてますが、アイテム名とかはドラクエをパロっていたりします。 「ほしふるゆびわ」とか。
1週目でボスを倒すと、2週目が始まって裏ボスが出てきます。 裏ボスは若干の謎解きあり。
裏ボスを倒すと最強アイテムが手に入って3週目に入るのだけど、3週目は特にゴールなしかな・・・？</description></item><item><title>読書メモ『会社を辞めずに年収を倍にする！ノーリスクな副業・起業・独立のためのパーフェクトガイド』藤井孝一</title><link>https://maku.blog/p/hq62imj/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hq62imj/</guid><description> 会社を辞めずに年収を倍にする！ノーリスクな副業・起業・独立のためのパーフェクトガイド 藤井孝一 講談社 最初は会社勤めをしながら、週末起業するのがよい。「給与所得」と「事業所得」を確保しながら、自分で稼ぐ力を身に着けることができる。 会社にいながらできないものは、会社を辞めてもできない。 大切なのは辞めたくなった時に辞められること。いざというときにはこっちで行くという仕事があれば、本業でも大胆になれる。 1円稼ぐところから始める。フリマで不要になった衣類やCDを売ることから始めるのでもよい。 会社に売り上げについて探りを入れられたら「お小遣い程度です」と言っておくのが良い。 銀行では原則として副業は認められない。公務員も、公務員法によって禁じられている。 何でも屋ではダメで（中小企業診断士とかは何でも屋の典型）、ここだったら絶対に勝てるという土俵を持つこと。ありきたりのビジネスであっても、誰もやっていない分野を見つけて自分をポジショニングしていく。 「あのお客さんにとっての専門家になろう」と意識すること。私がお願いしている税理士は、お願いしなくても税法の改正などがあったときに教えてくれる。 給与所得を失っても、家族が暮らせるだけのキャシュフローを確保しておくのがよい。 8歳くらいのときに「やりたい」と思っていた夢は、その人の本質に根ざしている。 4つの条件に当てはまる仕事から始め、時間に拘束されずに稼ぐ仕組みを作る。 自分の趣味や好きな仕事 元手のかからない仕事 スキルアップにつながる仕事 粗利が大きい商品を扱う仕事 ポータルサイトの運営もよい。特定の分野であらゆることを取り扱うサイトを作って、利用者の利便性を高める。 週末起業で飲食店のオーナーになった人でも、仕組みを作って最後に人に任せられるようになった人もいる。 ベンチャー企業が出資を募る際にも、事業計画だけでなく、テストマーケットの結果があると有利。人気のブログやメルマガが本になるのは、事前にテストマーケットが済んでいる点が大きい。 人が作った仕組みを利用すれば失敗のリスクを下げられる。 粗利が小さく、固定費がかかるビジネスはダメ。 中小企業診断士の資格が直接役立つということはなかったが、資格を取らなかったら、どんな分野でビジネスをするのか気持ちが固まらなかった。 専門性の高くない分野の資格で食べていきたいのなら、他の資格を取得して、もう一つの専門分野を持って差別化する。 土日の勉強で取れる資格や検定は、即戦力になるものがある。 福祉住環境コーディネーター eco 検定 国際会計検定 (BATIC) ビジネス実務法務検定 カラーコーディネーター ゲームやスマホの音楽を作曲して売る方法がある。音楽の素材を作ってネット販売し、月100万円売り上げている人もいる。画像の販売はよくあるが、音楽でやるという発想。 ネット販売で成功している人の多くは、実店舗を持っていて、販路の一つとしてネットを利用している。その他は、セミナーをビデオにしたり、ノウハウをPDF化して商材にして売っているケースが大半。 オークションサイトでは、一般的に不用品を販売しているイメージがあるが、稼いでいる人はきちんと仕入れをして売っている。 ネット古書店を始めるときは、ネットークションで中古品を売るときと同じように古物商許可申請が必要。 農業は比較的実働時間が短いので、週末起業で農業をするのもよい。農業が初めての人は、農業高校の教科書で基礎を学び、農家のアルバイトをしておくのがよい。 農地は転用するのが難しく、宅地にすると税金が上がるため、レンタル農園にして貸し出しているところが結構ある。農機や農具も、農協からレンタルできる場合がある。 独立するときはサラリーマンのうちに、**「会計」「マーケティング」「法律」**を学んでおく。個人情報保護法、著作権法、訪問販売法、特許法（特定商取引に関する法律）について基本的なことは知っておいた方がよい。 「誰に」「何を」「どう売るか」を考えることを習慣にする。 地元の商工会議所や、地方自治体の創業担当の窓口を尋ねれば、いろいろと相談に乗ってくれる。 あなたが会社勤めをしている場合、開業届が受理されるかどうかは、税務署員次第。**事業とは「対価を得て継続的に行われるもの」**である。 わざと事業収益を赤字にして給与の税金を取り戻そうとする人がいるので、週末起業の開業届が受理されないことがある。 開業届が受理されると、決算が赤字であれ、売り上げがゼロであれ、毎年必ず申告をしなければならない。 サラリーマンが給与所得以外に副収入を得ている場合は、通常は「雑所得」となり、年間20万円までは税務申告の必要はない。 銀行口座は事業用と家計用で分け、事業の投資効果を管理できるようにする。口座名義が個人名より、屋号になっていた方がはるかに信用度が高くなる。 自分が日々どのようにすごしているかを一週間記録してみると、結構無駄な時間を過ごしていることに気づく。 資格を取るときに学校に通うのはいい選択。学校では誰もが資格取得を目指しているので、取って当然という気になる。何か行動を起こそうというときは、まず居場所をそのような環境に変えること。 自分のオリジナルの商材やサービスでなければ、5万円の壁を超えることは難しい。 ライターや英文翻訳の仕組みでも、自分が働かなくていい仕組みは作ることができる。翻訳家やライターの登録バンクを作って、自分は仲介に特化するか、仲介さえもアルバイトに任せてしまえばいい。ただし、自分がこなし切れないほどの仕事の依頼があり、自分がその道で専門家になっていることが前提。 投資と借金 広告宣伝するのも投資。「売り上げの10％を広告に回す」などと決めておくとよい。 事務所を借りて家賃を払うという行為はムダに思えるが、事務所があると来客が増え、新しいビジネスチャンスが手に入る。それが次の売り上げにつながる。つまり、これも投資である。 借金をして投資して、その儲けから金利を払った残りが預金の金利よりも大きければ、預金よりも投資をした方が得である。これが起業家の借金に対する考え方。サラリーマンは借金を悪と考える。 法人化 ビジネスの世界は、原則として「法人」対「法人」で仕組みができている。「個人」とは契約を結ばないという方針の企業もある。 法人化すると、帳簿を複式簿記で作成して税務申告しなければならない。 個人のときは税務署に申告するだけでよかったのが、法人になると、都道府県や市町村にも申告しなければならない。 法人住民税というものがあり、都道府県や市町村に年間7万円程度を必ず支払わなければならない（赤字であっても）。 パソコンや備品、様々な会費などが、法人価格とされて多少割高になることがある。 企業の経営資源は「ヒト」「モノ」「カネ」と言われるが、個人が企業する場合も同様。この3つの資源を使ってお金を生み出していく仕組み（ビジネスモデル）を作れば、事業を立ち上げることができる。 事業の成長性や発展性が見込めない場合は、独立すべきではない。稼ぎが徐々に上がっていくかどうかがポイント。 独立の年齢は30代半ばが一つの節目だが、40代、50代のサラリーマンは、定年後の仕事を見据えて週末起業を始めておくのがオススメ。 会社を辞めたら、税金や保険料を自分で支払わなければならない。前年の所得から計算されるので、事業を始めた直後に数十万円単位の請求書が届くことになる。 友人と一緒に事業を始めたとしても、ずっと一緒に事業を続けるケースはまれ。揉めるのは大概お金のことなので、友人を部下として雇う場合も、給与は同じにしておいた方がいい。友人と上司部下の関係になるのは避けた方がいい。 多くの経営者が不動産投資をして、事業のリスクをヘッジしている。 株でも外為でも不動産でも、実際の取引で稼ぐだけでなく、ノウハウを公開して稼いでいる人もいる。 稼ぐ人は商品だけでなく、広告のノウハウを学ぶことにも熱心。通販のカタログを読み込んだり、通販のCMを見て日夜研究している。 ネット販売 ドロップシッピングは品揃えから値付けまで自分で決められる（アフィリエイトは、他の人の商品を告知代行するだけ）。 ドロップシンッピングで稼げるかどうかは、どの商品を扱うかによってほぼ決まる。 楽天などでショップを出店すると固定費がかかるが、オークションなら手数料は発生ベースの数百円で済む。 大企業が真面目に扱おうとしない物を売る。 中古品を扱う場合には、古物商の免許が必要。警察に行って手続きすれば簡単に取得できる。 ネットオークションに出品して稼いでいる人の多くは、ネットオークションで競り落として仕入れている。 ユーザーから仕入れるという方法もある。古本屋のように個人向けに販売する一方で、利用者から不用品の買取を行う。 海外の物を売って成功している人は、日本語のマニュアルを自作して添付していたりする。</description></item><item><title>読書メモ『統計学が最強の学問である』西内啓</title><link>https://maku.blog/p/qwbowke/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwbowke/</guid><description> ビジネス領域における統計学を応用したソリューションのことをビジネスインテリジェンスと呼ぶ。 統計学が最強の武器になるワケ ─ どんな分野の議論においても、データを集めて分析することで最速で最前の答えを出すことができるからだ。 原因不明の疫病を防止するための学問を「疫学」と呼ぶ。 現代の医療で最も重要な考え方として EBM (Evidence-Based Medicine)、日本語にすると「科学的根拠に基づく医療」というものがある。この科学的根拠のうち最も重視されるものの1つが、妥当な方法によって得られた統計データとその分析結果というわけである。 統計リテラシーさえあれば、自分の経験と勘以上の何かを自分の人生に活かすことがずいぶんと簡単になる。 心臓病だろうがコレラだろうが、原因不明なのであれば、その原因を明らかにするために行うべきことは、慎重かつ大規模なデータの収集であり、その適切な統計解析以外にはあり得ないのである。 データ分析において重要なのは、「果たしてその解析はかけたコスト以上の利益を自社にもたらすような判断につながるのだろうか？」という視点だ。 ★データの集計結果をビジネスに使うには、次の3つに答えられるものでないといけない。 何かの要因が変化すれば利益は向上するのか？ そうした変化を起こすような行動は実際に可能なのか？ 変化を起こす行動が可能だとしてそのコストは利益を上回るのか？ フィッシャーたちの時代とそれ以前の統計学の大きな違いは、誤差の取り扱い方にある。 統計学においてはこうしたデータの取り方のことを「A/Bテスト」とは言わずランダム化比較実験と呼ぶ（なおAパターンとBパターンの条件の変え方にランダムさが含まれていない実験は準実験と呼ぶ）。 クロス集計表について「意味のある偏り」なのか、それとも「誤差でもこれくらいの差は生じるのか」といったことを確かめる解析手法に「カイ二乗検定」というものがある。 「実際には何の差もないのに誤差や偶然によってたまたまデータのような差（正確にはそれ以上に極端な差を含む）が生じる確率」のことを統計学の専門用語でp値という。このp値が小さければ（慣例的には5％以下）、それに基づいて科学者たちは「この結果は偶然得られたとは考えにくい」と判断する。 統計学をある程度マスターすれば「どのようにデータを解析するか」ということはわかる。だが、実際に研究や調査をしようとすれば、「どのようなデータを収集し解析するか」という点のほうが重要になる。 重要になるのは「ここから何かわからないか」という漠然とした問いではなく、そのようなデータのうち何が、どのような関係で利益と繋がっているのかである。 ランダム化比較実験がどれだけ強力か、その最も大きな理由は、「人間の制御しうる何者についても、その因果関係を分析できるから」である。 統計学が「最強の学問」となったのはその汎用性の高さ、すなわち、政治だろうが教育だろうが経営だろうがスポーツだろうが、最速で最善の答えを導けるところにある。 フィッシャーが打ち立てたランダム化比較実験で、「誤差のある現象」を科学的に扱えるようになった。 「無制限にデータを得ればわかるはずの真に知りたい値」を真値とよび、たまたまえられたデータから計算された統計量がどの程度の誤差で真値を推定しているかを数学的に整理することで、無限にデータを集めることなく適切な判断が下せるという考え方を示した。 ランダム化してしまえば、比較したい両グループの諸条件が平均的にはほぼ揃う。そして揃っていない最後の条件は実験で制御しようとした肥料だけであり、その状態で両グループの収穫量に「誤差とは考え難い差」が生じたのであれば、それはすなわち「肥料が原因で収穫量に差が出る結果になった」という因果関係がほぼ実証できたと言える。 人件費を浪費して終わりのない会議を繰り返すよりは、比較的安価な媒体で小規模なランダム化比較実験を行ったほうが、早く、安く、確実な答えを得られる可能性が高い。 「正解のない意識決定」について、正解がないのであればとりあえずランダムに決めてしまう、という選択肢の価値はもっと認められるべきだ。 わざわざデータの取り方を工夫しなくても、より高度な手法を用いれば可能な限り条件を揃えた「フェアな比較」が可能になる。そのための最も重要な枠組みの1つが回帰分析だ。 回帰係数の誤差や信頼区間といった値を読み解けるようになれば、あなたの統計リテラシーはぐっとレベルアップする。 ありとあらゆる分野の研究結果が、先ほどの図表と同様に、回帰係数とその信頼区間やp値といった（あるいはこの一部を述べる）形で記述されている。 現代における統計手法の王道「重回帰分析」は、「フェアな比較」を行ううえで重要な役割を果たす統計解析手法である。政府のレポートにおいても学者の論文においても、重回帰分析やその拡張であるロジスティック回帰の結果が示されている。 バスケット分析よりも統計学的なカイ二乗検定による相関分析のほうがいい。 予測モデルから今後何をすべきかを議論したいのであれば、（シンプルな）回帰モデルの方が役に立つ。</description></item><item><title>テスト駆動開発の過去・現在・未来（和田卓人さん）</title><link>https://maku.blog/p/cxk6nn3/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cxk6nn3/</guid><description>タワーズ・クエストの和田卓人さん (t-wada) のお話を聞いたのでメモメモ。 Kent Beck の TDD 本の翻訳本『テスト駆動開発』を書いてる人です。 和田さんによる追記もあるので、正確には翻訳＋αですね。
テスト駆動開発 Kent Beck、和田卓人 オーム社 TDD の歴史は、バイブル的な本の出版歴を見ていくとわかりやすいみたいですね。
2002年: Kent Beck の TDD 本が出版される 2003年: TDD 本の翻訳『テスト駆動開発入門』がピアソンから出版される。しかし、ピアソンの技術部門の撤退で廃版となる 2017年: 和田氏によって TDD 本の再翻訳『テスト駆動開発』がオーム社から出版される TDD は &amp;ldquo;Test Driven Development&amp;rdquo; ではなく、&amp;quot;Test-Driven Development&amp;quot; と書くのが正解みたいです（ハイフンがいる）。
xUnit Test Patterns by Gerard Meszaros xUnit Test Patterns: Refactoring Test Code Gerard Meszaros Addison-Wesley Professional 書籍 『xUnit Test Patterns』 では、2007 年の時点でテストコードのメンテナンス性の課題について言及しています。
重複の多いテストコードがあると、メンテナンスコストがどんどん上がっていく。 プロダクトコードだけでなく、テストコードもメンテ対象であり、日常的なリファクタリングが必要であるという認識が必要。 「テストコードを追加するとメンテナンスコストが上がるので、テストコードはあまり追加したくない」という意見はそもそもテストコードに対する認識が間違っている。プロダクトコードと同じレベルのものと考えないといけない。 だから、書籍のサブタイトルでも「Refactoring Test Code」と訴えている。 ちなみに和田さんは、こーゆー分厚い本はぶった切って持ち運びやすいサイズにして読むみたいですね。 私も本は読んで知識にしてナンボだと思ってますので、そのやり方には賛成です。 本には書き込みまくって自分の知識になったと思ったら捨てる。その繰り返し。
Mock オブジェクトについて Mock オブジェクトの登場により、Inside-Out な開発から、Outside-In な開発に変えられることが分かった。簡単に言うと、ユーザーに近い UI の部分から Mock を利用して作り始めるという考え方。Mock オブジェクトが、ただのユニットテストの道具ではなく、受け入れテストに近いところから開発するというプロセス改善のために使えるということが示された。 早い段階でリリースして、フィードバックを受けながら作り込んでいくというプロセスが現在ではよいとされている。 「動作するきれないコードはあらゆる意味で価値がある」by Kent Beck Mock 系のライブラリは強力になりすぎて弊害にもなっている。もともとは、テストを書いているときに「Mock に置き換えにくいので設計を改善しなきゃ」という設計改善の原動力となる部分があったのに、今は Mock ライブラリが強すぎて、汚い設計でも Mock を導入できてしまう。テストには「設計を改善する」という目的があるのに、これでは本末転倒だ。 TDD の T は「テスト」なの？ TDD の T は「テスト」の一部に過ぎない ─ 『Agile Testing: A Practical Guide for Testers and Agile Teams』</description></item><item><title>2018-11-22 中島聡さん (UIEvolution、元Microsoft) のお話</title><link>https://maku.blog/p/zrz3ggy/</link><pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zrz3ggy/</guid><description>Windows95 を作った男と言われている中島聡さんのお話を聞いて来たのでメモメモ。 『なぜ、あなたの仕事は終わらないのか スピードは最強の武器である』 はかなり売れたみたいですね。
今は Singularity Society という NPO もやってる。会社としての利益とかではなくて、もっと大きな問題に幅広く関わっていきたいと思って社団法人として設立した。 経団連に PC が入ったとか、そういう人たちが日本を回していたりする。みんな危機感を持たなきゃいけないよ。 「これを作りたい！」という気持ちが少しでもあったら、その気持ちを大きくして、どんどん外に出していくべき（起業家精神みたいなの）。上司とかマネージャー陣は守りに入って反対することが多いかもしれないけど、どんどん訴えていくべき。 「ものは作ったもん勝ち」。Windows 95 のときも、最初に Smalltalk でハリボテみたいなプロトを作って見せたら、結局それが Windows 95 のベースになって、自分が Windows 95 を作った男と呼ばれるようになった。その頃 Smalltalk でガッツリ実装しているのは自分くらいしかいなかった。 今もプログラムはバリバリやってる。最近は自動運転とか。自動運転自体のプログラムを作っているわけではないが、自動運転の社会になったときに必要になってくるであろうルーティングのプログラムなどを、先を見越して作っている。 Uber や Google が自動運転社会のトップになって幸せな世界になるとは思えない。例えば、地方で運転できずに病院にもいけない老人を救うといったニーズは必ずある。そういった幅広いニーズに応えていくということがこれからの世の中には必要だ。 自動運転は法の整備がポイントなので、そのあたりに強みを持っている中国がまずは抜け出すだろう。先を行かれる可能性が高く、ピンチだ。 テスラは iPhone が出たときと同じくらいワクワクして買った。テスラは買った後にどんどん進化していく。3週間ごとにソフトウェア更新されて車自体が性能向上していくのはほんとすごい（アップデートの頻度とかも）。日本の大企業とかはできないんだろうなぁ（リスクが大きいことはやらないから）。 自動運転社会が来れば必ず新しいビジネスが生まれる。今のうちにどのようなビジネスがヒットするのかを考えておくのが大切。例えば、信号や駐車場がなくなったりして、大きな変化が出てくるだろう。 エンジニアへのアドバイスもいくつか。
自分がどこで勝負するのかは意識していた方がいい。 会社のやり方と合わないと感じたら、辞める前に思いっきり暴れてみよう（物理的にではなくて）。 これからはマネージャよりエンジニアの方が給与が高いという時代になっていく（日本は遅れている）。逆にそうなっていない会社は廃れていくだろう。いつも言ってるが、スキルの高い人がプログラミングせずに、スキルのない下請けに受注するという構造は最低だ（日本の大企業はほとんどそう）。 クラウドができて、ハードウェアもできて、クライアントもできる、みたいなオールマイティな人は強い。IoT な時代は、ある処理をどの部分でやればベストなパフォーマンスを出せるのかということを答えられる人が強い。</description></item><item><title>2018-11-07 iPad Pro キター！おえかきおえかき</title><link>https://maku.blog/p/y66a3ji/</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/y66a3ji/</guid><description>今日発売の新型 iPad Pro 2018 年版が来ましたので、早速開封の儀。
外装。
上のフタをパカっと開けると、縁までぴったり本体が収まってました。 思ったより大きい（それがよいのだけど）。
本体の下には簡易マニュアルと、充電アダプタと USB type-C のケーブルが一本。 相変わらずシンプルです。
標準で付属しているメモアプリでちょっとだけお絵描き。 Apple Pencil は筆圧検知はもちろん、傾けて太い線を引くこともできます。 ほんと、普通のペンを使って書いているような感じ！
新しい Apple Pencil は、ペンの横のところをダブルタップすると簡単に消しゴムに切り替えることができます（ペンのダブルタップを何に割り当てるかはアプリによります）。 これで快適なお絵描きライフを送れそうです(^o^)
画面大きいから Sony Reader アプリや Kindle アプリを入れれば、漫画を見開きで読めるなぁ。。。</description></item><item><title>『嫌われる勇気』岸見一郎さん講演会</title><link>https://maku.blog/p/i5kosb6/</link><pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i5kosb6/</guid><description> 嫌われる勇気 岸見一郎、古賀史健 ダイヤモンド社 『嫌われる勇気』で有名な岸見さんの講演を聞いてきました。 思ってたよりおもしろい人でした。 まぁよく考えてみれば、カウンセリングやるような人はユーモアがないと心開いてもらうのは難しいですからね。
お話の内容はほぼ本に書かれているようなことでしたけど、メモメモ。
人から嫌われることを恐れて八方美人に振る舞っていると、「自分の人生」を生きることができない。本当に言いたいことを言えない。本当にやりたいことができない。 「人の評価」と「自分の評価」は違うものなのだということを認識する必要がある。 アドラーは、「自分に価値があると思えるときだけ勇気を持て」と言っている。 仕事に取り組む勇気 対人関係（人の輪）に入っていく勇気 自分に価値を見出すには… 自分の特徴を長所として捉える ×飽きっぽい → ○新しいことを始める決断力や行動力がある。 ×性格が暗い → ○人を傷つけるようなことを言わない優しさを持っている。 他人に貢献しているのだと考える ×生活のために働いている → ○人々に時間を提供している（コンビニのレジ係の例） 教師は、授業では学生に間違えて欲しいと思っている。それによって、その学生に伝わっていないことが何なのかを把握できるので、効率的に教えることができるようになる。質問されて答えられないのは、間違えることで人にどう評価されるかということを恐れてしまっている典型的な例。 すべての悩みは対人関係から生まれるが、生きる喜びや幸せもそこから生まれる。そこに飛び込んでいく勇気を持たなければ、幸せになることはできない。 ちなみに、著書の『嫌われる勇気』っていうタイトルの由来は、自分の子供に「あなた本当に嫌われるのがイヤなんだね」って言われたことらしい。 「あなた」って呼ばれてることの方がおもしろいんですけどｗ
幸せになる勇気 岸見一郎、古賀史健 ダイヤモンド社</description></item><item><title>読書メモ『バカの壁』『超バカの壁』養老孟司</title><link>https://maku.blog/p/2685wd6/</link><pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2685wd6/</guid><description>バカの壁 養老孟司 新潮社 一元論に陥ってしまうことの怖さを説いています。 教育しかり、経済しかり、宗教しかり。 やっぱりわかりやすいのは宗教で、原理主義に走ってしまうと「他の考え方は悪」だと決めつけてしまう怖さがある。 しかも決めつけてしまう方が楽だから始末が悪い。
孟司氏は、「人生は崖を登るようなものだ」と言っています。 いろんな考え方を理解していくのはとても大変だけれど、そこを乗り越えることで視界が開けるんだと。
原理主義的な宗教も決して悪いところばかりじゃないと思いますが、もっと柔軟にやっていけないのですかね？ 宗教って一度入信してしまうと、一生貫きとおさなければいけないという風潮がある。
「オレ、先月までイスラム教だったけど、今はプロテスタントやってんねん」 みたいに、いろんな考え方を取り入れられるようになると、宗教間の争いも減りそうなんですけどね。
著者は他にもいろいろ厳しい意見を述べられています。
今の教師には、反面教師になってもいい、嫌われてもいいという信念がない。サラリーマンになってしまっている。給料の出所に忠実な人であって、仕事に忠実なのではない。逆に、職人というのは、仕事に忠実じゃないと食えない。自分の作る作品に対して責任を持たなくてはいけない。 個性なんてものは初めから与えられていて、それ以上のものではない。薄っぺらな個性しかない人が、子供に「個性を伸ばせ」なんて教育をするのではなく、他の人の気持ちがわかるかと伝える方がよっぽどよい。 人生は無意味だ、病気の苦しみには意味はない、と考えるのは楽に思えるがそれは結局自分自身の不幸を招く。苦しみには意味があると考えるべき。苦しいうえにその状況に意味がないと考えてしまうのは二重の苦しみを味わっていることになる。 虚の経済、実の経済という考え方も面白いですね。 国が出している指標は虚の経済であって、お金のやり取りだけが計算されている。 でもその裏では環境破壊が進んでいる。 実の経済というのは資源、エネルギーを一基本貨幣単位としてモデリングされていなければならない。 世界一貧しい大統領ホセ・ムヒカが伝えようとしていることも本質は同じですね。 富よりも大切なことがあるのだと。
知るということは、自分がガラッと変わること。世界がまったく変わってしまう。それが昨日までとほとんど同じ世界であっても。 その世界は、自分がよりよく生きられる世界だ。 だから我々は学び続けなければいけない。 それが生きる意味だ。
超バカの壁 養老孟司 新潮社 『バカの壁』の続編の『超バカの壁』でも、養老孟司氏がものの考え方について述べています。 中でも、「人生の価値」を次のように考えるというのは素敵な考え方だなと思いました。
世の中の穴を埋めること 人生の価値を、「何かに大成功することだ」とか、「他人との競争に勝つことだ」とか考えていると疲れてしまいます。 そうじゃなくて、世の中にポコポコ開いた穴を、みんながそれぞれ埋め合うことで世の中がうまくいく。 こんな考え方で生きていけたら幸せになれそうだし、世界は平和になりそう。</description></item><item><title>読書メモ『180日でグローバル人材になる方法』天野雅晴</title><link>https://maku.blog/p/hdcgy8y/</link><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hdcgy8y/</guid><description>180日でグローバル人材になる方法 天野雅晴 東洋経済新報社 日本と米国 日本は、会社や組織が個人の居場所を定義する。米国では、会社や組織の枠を越えて「個人のレベル」で繋がっている。 日本では会社や組織の比重が大きいため、個人の比重が大きい米国のネットワークとは、ある意味で「水と油」のような関係にある。 米国企業は、最初は最低予測金額の3倍くらいの価格で交渉をスタートさせる。多くの日本企業はほとんど最初の金額か、それに近い額で応じる。 日本人は習慣ですぐに名刺を出す人がいるが、米国では特にそういう習慣はない。しばらく話をしてお互いに興味を持った時点で初めて名刺を交換する。 モチベーション 経済学や社会行動学の分野では、「3番目のモチベーション」に注目が集まっている。 第1のモチベーション: 生物としてもっている食べることや生殖に対するもの。 第2のモチベーション: それにつながるお金や地位などに対するもの。 第3のモチベーション: 得意分野や単純に生きがいを感じることをしたいという思う気持ち。 → 『モチベーション3.0─持続する「やる気！」をいかに引き出すか』 ダニエル・ピンク、大前研一 金銭的な利益の追求より、社会貢献や環境維持などに関する「ベネフィット」の追求を選ぶ人や企業が増えている。これに対応するために For benefit（For profitではなく）という会社形式が、米国の会社法として認められた。 第3のモチベーションが原動力になるような何かを社員に持たせることが、企業の成功にとても重要なファクターである。 コミュニケーション グローバル社会のあらゆる場面に対応するコミュニケーションは、英語の問題というよりは、そういう場で何度も実戦訓練をして初めて得られるスキルだと言える。 技術者などの日本人の現場スタッフには、説明だけして肝心の結論を言わない人が多い。「それでどうしたいのか？」と聞くと、特にそれに対しては何も言わない。 海外では自分の考えていることをストレートに相手に伝えることが重要。まずは「YES」なのか「NO」なのかをはっきりと言う。ただし、強い口調で主張するのではなく、落ち着いた口調で言う。 音読、発音矯正 英会話を習得するのに効果がある方法として「音読」がある。ただ読むのではなく、実際に声に出して読むだけのことだが、これでも頭の中だけで読むよりはずっと効果があることが実証されている。 ただ頭の中で言っても自分のものにはならない。本当に何かがわかったときに、実際に &amp;ldquo;I got it!&amp;rdquo; と声に出すことが重要。 出身地によっていろいろなアクセントがあり、「日本人アクセント」があってもそれだけで問題にはならない。しかし、発音矯正には画期的な効果がある。発音矯正のレッスンは、日本でもいろいろな英会話学校のオプションとして受けることができる。 カランメソッド カランメソッド (Callan Method) という「簡単な英文を何度も何度も繰り返し、即座に反応しなければならない」という「英語脳トレーニング」がある。 カランメソッドの大きな特徴は、教室で生徒がしゃべる英語はすべて「教科書に指定された英文のみ」で、それに従って一字一句間違いなくしゃべるということ。いちいち日本語に訳さないということ。 日本でよくある英会話習得法は、外国人教師を相手に自由におしゃべりをするというものだが、これでは自分のしゃべれる英語に限られてしまうので、英語力はつかない。英語学校が楽な方法をとっているだけである。逆に、カランメソッドでは、トレーニング中は自分勝手な英語のおしゃべりをしないことが大切。 カランメソッドでは、しゃべるべき英文はあらかじめぎっしり教科書の中に用意されており、授業ではその英文を先生が質問して生徒が答えるという形式を取る。例えば、&amp;ldquo;express&amp;rdquo; というキーワードに対して、&amp;ldquo;Can you express your idea in English?&amp;rdquo; という質問と &amp;ldquo;Yes, I can express my idea in English.&amp;rdquo; （あるいは &amp;ldquo;No, I can&amp;rsquo;t &amp;hellip;&amp;quot;）という答えが書かれており、先生と生徒はほぼそのままそれを繰り返すだけ。ただし、先生が質問する英語のスピードはかなり早く、日本語で考える余裕はない。 カランメソッドのもう一つの特徴は、一定の時間ごとに先生が入れ替わるということ。その結果、違う先生の英語の発音やしゃべり方に対して、同じやり取りを何度も繰り返すことになる。同じ英文を違う人がしゃべると、同じものを別の角度から見るように情報量が増加する。 カランメソッドは個人や企業でも応用することができる。ポイントは使用する英文。企業なら、特定の業種や業務に合わせたフレーズを集めるのがよい。こうして用意した「オリジナル英文」を使って、外国人教師や友達とひたすら英文のやり取りを繰り返す。大切なのはスピード。やり取りのタイミングを早くして、頭の中で日本語にしないようにする。 ひたすら決められた英文を「訳すことなく」何度も何度も繰り返すことで、英語脳の育成に集中する。本当に英語脳を作るには、このような作業をかならい長く続ける必要がある。毎日のように英文を繰り返さないと効果は出ない。 単刀直入訓練 単刀直入に、&amp;ldquo;I disagree!</description></item><item><title>UML ダイアグラムの一覧と分類</title><link>https://maku.blog/p/yzs49gv/</link><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yzs49gv/</guid><description>構造図 (structual diagrams) クラス図: クラス、特性、関係 コンポーネント図: コンポーネントの構造と接続 コンポジット構造図（複合構造図）: クラスのランタイム分割 配置図: ノードへの成果物の配置 オブジェクト図: インスタンスの接続の基本例 パッケージ図: コンパイル時の階層構造 振る舞い図 (behavioral diagrams) アクティビティ図: 手続き的なまたは並行な振る舞い ユースケース図: ユーザーがシステムとどう対話（相互作用）するか ステートマシン図（状態マシン図）: オブジェクトの存続期間にイベントがオブジェクトに加える変更の内容 相互作用図 シーケンス図: オブジェクト間の相互作用（シーケンスを重視） コミュニケーション図: オブジェクト間の相互作用（リンクを重視）UML1ではコラボレーション図と呼ばれていた タイミング図: オブジェクト間の相互作用（タイミングを重視）(UML2) 相互作用概要図: シーケンス図とアクティビティ図を合わせたもの (UML2)</description></item><item><title>読書メモ『UMLモデリングのエッセンス第3版』マーチン・ファウラー</title><link>https://maku.blog/p/tc73ttt/</link><pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tc73ttt/</guid><description>UMLモデリングのエッセンス第3版 マーチン・ファウラー 翔泳社 大きな仕様である UML の中で重要なポイントを簡潔にまとめた UML のバイブル的書籍です。 マーチンファウラーの名前は、『リファクタリング』や『アナリシスパターン』といった書籍で目にした人も多いでしょう。 長年オブジェクト指向に携わってきたファウラー氏のまとめたエッセンスに振れれば、UML の重要なポイントを効率よく一気に学ぶことができます。 本書は、UML を創ったスリーアミーゴ（Grady Booch、Ivar Jacobson、James Rumbaugh）の推薦図書でもあります。
第1章: UMLの概要 UML の使い方に関する面倒な論争に対するアプローチとして、Steve Mellow と Martin Fowler は、UML の使い方を 3 種類のモードに分類している。
スケッチ（もっとも一般的な使われ方） フォワードエンジニアリング: コードを記述する前に UML ダイアグラムを作成する。 リバースエンジニアリング: 既存のコードを理解する補助手段としてコードから UML ダイアグラムを作成する。 設計図面（blueprint。実装のため完全性を重視） プログラミング言語（Executable UML など。うまくいかず、流行らなかった） UML のユーザーは UML の本質はダイアグラムだと考えている人がほとんだが、UML の作成者は UML の本質はメタモデルであると考えている。ダイアグラムはメタモデルの表現にすぎない。
細部までフォワードエンジニアリングされた設計図面はうまく扱うのが難しく、開発作業の遅れに繋がる。 サブシステムのインタフェースレベルで設計図面を作成するのは合理的だが、実装するのに合わせてインタフェースが変わることを想定しておく必要がある。 このような考えから、著者のマーチン・ファウラーは、UML をスケッチとして使用することを重視している。
UMLダイアグラム一覧と分類 UMLダイアグラムが使用目的に適さない場合は、非UMLダイアグラムを積極的に使うべき。デシジョンテーブルや画面フロー図などは役に立つ。 まずクラス図とシーケンス図の基本形態に集中することをお勧めする。これらは最も一般的であり、最も便利なダイアグラムである。 第2章: 開発プロセス モデリング技術は、それがプロセスにどのように適合するかを理解しなければ、意味を成さない。UMLの使い方は、使用するプロセスのスタイルによってかなり異なる。 ウォーターフォール型プロセスでは、プロジェクトをアクティビティに基づいて分解する。要求分析、設計、コーディング、テストを順番に実行する。 反復型プロセスは、プロジェクトを機能のサブセットで分解する。1年間のプロジェクトでは、3ヵ月ごとの反復に分解することが考えられる。3ヵ月が終わるごとに、必要な機能の1/4がシステムに実装される。 Steve McConnell は、『ラピッドデベロップメント』 の中で、プロセスを組み合わせて使用する方法を説明している。最初の4ヵ月で要求分析と設計をウォーターフォール的に行い、コーディングとテストは2ヵ月の反復を4回繰り返す。 テストと統合は予測の難しいアクティビティであり、このような終了時期の見えにくいアクティビティをプロジェクトの最後に置かないことが重要。 経験から言うと、単体テストのコードは製品本体のコードと同程度の量が必要。 RUP (Rational Unified Process) RUP はプロセスと呼ばれているが、実際にはプロセスのフレームワークである。RUP はプロセスを説明するための語彙と柔軟な構造を提供する。 RUP は本質的に反復型プロセスであり、ウォーターフォール型は RUP の考え方に適合しない。 RUP は UP (Unified Process) に基づいた Rational 社の製品であると考えることができる。また、RUP と UP を同じものと考えることもできる。どちらも正しい。 反復型開発の最大の利点のひとつは、プロセスを頻繁に改良できること。 反復の最後に、チームでその反復を振り返り、次の3つのリスト (KPT) を作成するのがよい。 K: Keep（継続）: 有効に機能していて、今後も継続して行う事項 P: Problem（問題）: 有効に機能していない事項 T: Try（試み）: プロセスを改良するための変更 プロジェクトの最後、または主要なリリース時には、本格的にプロジェクトを振り返るのもよい。参考: https://en.</description></item><item><title>デザインパターン: MVC パターンのメモ</title><link>https://maku.blog/p/cps3nt8/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cps3nt8/</guid><description>MVC パターンの構造 オブジェクト図 ≪生成コード&amp;#x1F4D6;≫ シーケンス図 図: シーケンス図 ≪生成コード&amp;#x1F4D6;≫ M (Model) 処理。ビジネス・ロジック。
アプリケーションが使用するデータを保持し、アプリケーション固有の処理を実行する。 外部のストレージ（データベース）に保存するためのインタフェースなどを備えていてもよい。
特に、保持するデータを参照するための public インタフェースだけを備えているものを Model ということもある。J2EE デザインパターンでは、純粋にデータのみを保持するものを Value Object と呼んでいる。
View、Controller とは関連性を持たないのが望ましい。 Model オブジェクトは、自分自身がどのように表示されるかを知らない。
特定の実行環境に依存しないのが望ましい。 例えば、特定のフレームワーク上に構築されたアプリケーションであっても、Model クラスだけは別のフレームワークでも使用できるようにするべき。つまり、フレームワークに特化したインタフェースを備えてはいけない。
V (View) 表示。プレゼンテーション・ロジック。
データを目に見える形で表示するためのコード。ウィンドウアプリケーションでは、ウィンドウ内に表示するウィジット等の表示、Web アプリケーションでは、HTML の出力などが View に当たる。
C (Controller) 入力。インタラクション・ロジック。
ユーザやシステムからのイベントを受けとり、Model や View の作成、更新、相互作用を管理する。
MVC パターンの Pros and Cons 利点 (Pros.) UI コードにビジネスロジックが入るのを防ぐことができる。 ユニットテストしやすい。 欠点 (Cons.) スケールしない（UI は個々に作成できるが、モデルを分離しにくい） Contoller が肥大化しやすい（View からの処理がすべて Controller 経由になる） SOLID 原則の S (Single responsibility principle) と I (Interface segregation principle) に違反してしまう。 View と Controller の関連 多くの GUI toolkit では、V (View) と C (Controller) は複雑に絡み合っている。なぜなら、C (Controller) は、それ自体が画面上に表示される widget であることが多いから。</description></item><item><title>デザインパターン: MVP パターンのメモ</title><link>https://maku.blog/p/5wu6fbv/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5wu6fbv/</guid><description>MVP (Model-View-Presenter) パターンでは、MVC (Model-View-Controller) パターンと異なり、View と Model が直接やり取りせず、すべて Presenter 経由でのやり取りになります（亜種としてデータバインディングを使用するケースもあります）。
MVP パターンの構造 オブジェクト図 ≪生成コード&amp;#x1F4D6;≫ シーケンス図 ≪生成コード&amp;#x1F4D6;≫ MVP の構成要素 View: 描画ロジックを持つ。自分自身が能動的に描画処理を行うことはなく、Presenter からの要求で描画処理を行うため、Passive View と呼ばれる。Presenter に言われたとおりに、渡されたデータを描画するだけ。ユーザの入力を受け、Presenter へ通知する。 Presenter: ユーザイベントをハンドルし、具体的なアクションを実行する (Proxy)。データを Model から取得し、View が扱える形に加工して描画情報として渡す。 Model: ビジネスロジックとデータ保持（およびデータ取得処理）を担う。DB や Web サービスと通信してデータを取得する役割を持つ。必要に応じて Presenter へ変更通知を送る。 MVP の Pros and Cons Pros. 複雑なタスクをシンプルなタスクに分割できる。 クラスが小さくなり、不具合が入りにくくデバッグしやすくなる。 ユニットテストできる。 Cons. 各レイヤを繋ぐ退屈な作業が必要。 Model が特定のユースケースに結びついてしまい再利用しにくい。 View と Presenter が特定のデータ形式により結び付けられてしまう（Model の提供するデータを Presenter 経由で View に渡すときにデータの依存ができる）。 MVP の各コンポーネントの生成過程 MVP パターンを導入しようとするときに、最初に迷うのがオブジェクトの所有関係をどうするかだと思います。 下記は MVP の一般的なオブジェクトの生成過程です。
アプリを起動すると View が生成される。 View は自分自身を制御してもらうための Presenter を生成する。Presenter に自分自身の参照を渡しておく（これは、Presenter から View を制御してもらう必要があるため）。 Presenter はビジネスロジックを実行するための Model を生成する。 Presenter は、View や Model の参照を持つ必要があるわけですが、このとき View の具象クラスの参照を保持するのではなく、インタフェース型の参照（IView的な）として保持するのがポイントです。 こうすることにより、Presenter の単体テストが可能になります（View のモックを作成する）。</description></item><item><title>読書メモ『マンガを読んで小説家になろう！』大内明日香・若桜木虔</title><link>https://maku.blog/p/38w985m/</link><pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38w985m/</guid><description>マンガを読んで小説家になろう！ 大内明日香・若桜木虔 アスペクト 「物語はパターンとバリエーションからできてる」という考え方を一冊まるまる解説しています。 漫画や小説のヒットするパターンというのは決まっているのだから、そこにはほとんど工夫の余地はないと言い切っています。 だからと言って、物語がつまらなくというわけではなく、バリエーションを持たせることによっていくらでもヒット作は生み出せる。
文章の書き方的な教本ではないので、そこだけは注意ですが、ストーリーのパターンというものを学べる良書かと思います。 以下、個人的に大事そうなところをまとめ。
ストーリーを作るコツは、「すべての物語はパターンとバリエーションからできている」と割り切ること。 多作な作家が生き残る。著名な小説家やマンガ家は多作である。専業作家で食べていくには、年に6冊の新作を書かないといけない。オリジナル、オリジナル、って考えている人には絶対に無理。 多作になるためには、ストーリーをシステマティックに作らなければならない。必要なのは情報のインプット。ストーリー作りはなにからでも学べる。小説だけでなく、マンガをどんどん読もう！アニメを観よう！特撮を見よう！ 新聞にはネタがたくさんあるが、テレビ欄の裏（39面）の社会面のメインは大きな事件を扱うところで、皆がこの事件をネタにしようとするので、その情報は捨てた方がいい。38面の下の、B級、C級な隅っこの記事が実は面白く狙い目。 自分は天才だと思っている人は、「勝たなくてもいい。わかる人にだけわかれば」と思っているから勝つことはできない。「なにがなんでも小説家になる！」と強く思っている人が小説家になれる。 小説家の人はナチュラルに嘘をつく。これもサービス精神の表れ。とにかくみんな話を大きく大きくしようとする。これは職業病みたいなもので、常に人を喜ばせたいと思うのが小説家。 長続きするマンガで大事なのは「読者の期待を裏切らないこと」。こち亀の両さんは必ず最後に大目玉を食らう。ドラゴンボールの悟空は戦うたびに強くなって相手を倒す。ゴルゴの弾は必ず命中する。ワンパターンは決して悪いことではない。「待ってました！」は褒め言葉です。 逆に完全なオリジナルは売れない。個性的だから、先がわからない。わからないから、期待も持てない。期待できないから、わくわくできない。だから売れない。本当のオリジナルを書いた作家は、たいてい死んでから売れる。画家のゴッホだってそう。ギャグマンガ家が長続きしないのは、ギャグに使い回しがきかず、常にオリジナルを必要とされるから。 「元ネタはありません。オリジナルです。」という作品は罵られるが、「このマンガには元ネタがある。さぁ探してみろ！」とほのめかされているとみんな喜んで元ネタを探す。ケロロ軍曹がよい例。 同じ作者の複数の作品に、同じキャラクターや名前だけ変えたキャラクターが登場する「スター・システム」はもともと映画業界用語だが、マンガ業界でも有名。手塚治虫氏はマンガのスター・システムの創始者と言われている。みんなスター・システムが大好き。あっちのマンガで出ているキャラが、別のマンガで出ていると大喜びする。同じようなキャラを登場させることを堂々と宣言するのがよい。小説でも、売れっ子の人は、キャラに関してワンパターンであることが多い。 自分の得意なストーリーの「パターン」を早く見つけて、それを自分の「スタイル」と言うのがよい。ワンパターンと言われると腹が立つけど、スタイルと言われるとカッコいい。さらに、人気作家になると「◯◯ワールド」と言われるようになる。 不思議なことに、他の作品や意見を参考にしないで作ろうとすればするほど似てしまう。他の作品のパターンを組み合わせて自分の世界を作ってしまった方がよい。 大事なのは「書きたいもの」ではなく、「それを書きたいという気持ち」。その気持ちの源泉は何でもいい。有名になりたい、モテたい、あっと言わせたい、即売会に間に合わせたい。モチベーションに貴賎はない。書こうという気持ちが薄らぐ日が来たときのために、モチベーションの源泉、自分なりのモチベーションの素をストックしておくことはとても大切。 小説を書く手順 パターン決め バリエーション決め あらすじ作り 原稿執筆 1. パターン決め 下記の4つのパターンが物語の王道。
主人公成長・破滅もの 長編は書きやすいが、短いストーリーが求められる新人賞などは取りにくい。だから、最初にこのパターンを使うのはオススメできない。 旅もの 一話完結でバリエーションをつけやすい。格闘マンガもコレに分類できる。 最初から英雄・天才もの 初心者向け。短編が書きやすい。分野を絞るのがコツだが、マイナーすぎるネタではよくないので、組み合わせを考えるとよい。 特殊なキャラ日常ひっかきまわしもの キャラの魅力がすべて。アニメ化しやすい。友人、知人と相談して決めていくのがよい。オリジナリティが一番必要。キャラの職業設定に困ったら「居候」がおすすめ。 この4つのうち1つでも習得できれば、一生食うには困らない。 逆にコロコロ変えると「ワールド」が作れなくて困ったことになる。
2. バリエーション決め パターンは「ケーキ台」で、バリエーションは「クリーム」。 バリエーションで決めることは下記の4つ。
超目的（テーマ） ストーリー上における、主人公の目的および目標。格闘ものなら「主人公が世界で一番強い男になる」で、探偵ものなら「主人公が真犯人を見つける」。 キャラ 登場人物。 ウリ（特徴） その作品で最も特徴的な事柄で、その作品にしかない魅力的な部分。ドラえもんであれば「道具を出すロボット」で、DEATH NOTE であれば「人を殺せるノート」。このウリの良し悪しで作品の人気が決まる。 世界観 物語の世界の時代と場所と様子。 パターンはすぐに決まるが、このバリエーション決めには時間をかけなければいけない。 バリエーションは小説の命であって、逆に言うと考えるところはここしかない。 パターンで期待させ、バリエーションでハラハラドキドキさせる。先が見えるのは OK だが、過程は秘密にしておくということ。
パターンとこの4つが決まると、話が固まってくる。 例えば「桃太郎」だと、超目的は「勧善懲悪」、キャラは「桃太郎、犬、猿、キジ、おじいさん、おばあさん、鬼」、ウリは「主人公が桃から生まれている、家来が動物である」、世界観は「中世日本」。
「世界観」に関しては、小説の執筆依頼時に編集者が決めてくることが多い。例えば、「架空戦記」だったら「第二次世界大戦中の日本」など。「キャラ」の制約までつけられることもある。制約のない仕事などどこの世にもないのだから、がんばれるところでがんばるしかない。 たくさんマンガを読んで、バリエーションの蓄積を作るべし。
3. あらすじ作り あらすじの字数は短ければ短い方がよく、できれば100文字以内、上限300文字以内におさまる内容にする。 本の裏表紙に書けるスペースは限られているし、読者に魅力を簡潔に伝えられなければいけない。 素晴らしいあらすじができたら、もうその作品は素晴らしい作品になることが決まったようなもの。
4. 原稿執筆 書けない人の訓練方法（3ステップ）</description></item><item><title>読書メモ『シェアリングエコノミー』アルン・スンドララジャン</title><link>https://maku.blog/p/syzny8w/</link><pubDate>Thu, 04 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/syzny8w/</guid><description>シェアリングエコノミー アルン・スンドララジャン 日経BP社 Uber や Airbnb といった「シェア」をベースにする企業が勢いをつけ、急速に社会のあり方が変わりつつあります。
シェアリングエコノミーとは何なのか？ なぜここまで浸透してきたのか？ これまでとは何が違うのか？ 今後どうなっていくのか？ といったことを、シェアリングエコノミーの第一人者であるアルン・スンドララジャンが包括的にまとめています。
これまでの社会はサービスや財が流通する世界でしたが、シェアリングエコノミーの世界では、人に対する感情、信用といった評価が重要になってきます。 典型的なのがトレイティーのサービスで、自分の献血経験やボランティア活動経歴など、信用の向上につながる情報は何でもデジタル化されて管理されるようになっています。 Airbnb などのうまくいっているプラットフォームには「信頼性」が付随しており、皆がよりよいサービスを提供したいと思わせる仕組みができています。 逆に、このあたりを理解せずに新しいシェアサービスを立ち上げてもうまくいかないでしょう。
P2P ビジネスの法律的な解釈についても述べられています。 例えば、Uber のプラットフォームを使用して働いているドライバーは、Uber の従業員の一種なのか、それとも独立請負人として扱うべきなのか？ 雇用保険のあり方や、裁判になったときの責任の所在などが変わってくるのでこれは大きな課題です。 このような論点での裁判は昔から多く行われており、決して新しい問題ではないと著者は述べていますが、訴訟社会であるアメリカが中心になって法的な整備が今後一気に進んでいくでしょう。
スンドララジャンは研究者らしく多くのサービスを取り上げて特徴をまとめています。 中でも、「プラットフォームのヒエラルキー性、市場性、ハイブリッド性」についてまとめた表は、今後登場するサービスの特徴を調べるときや、新しいサービスを作る際のよい指標になるでしょう。</description></item><item><title>読書メモ『21世紀ファミコン』恋パラ支部長</title><link>https://maku.blog/p/cnjd43a/</link><pubDate>Sun, 30 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cnjd43a/</guid><description>21世紀ファミコン 恋パラ支部長、波多野ユウスケ マイクロマガジン社 世界でただ一人ファミプロを自称している恋パラ支部長さんの本。 有名どころのファミコンソフトを、普通とは違った遊び方で楽しむ方法が書かれています。 例えば、
「スーパーマリオ」を1つのコントローラーを2人で持って対戦プレイ。十字キー担当はマリオを死なせたら勝ち、ABボタン担当はマリオを死なせないようにジャンプで逃げる。 「チャレンジャー」も同じように対戦プレイ。 「ディグダグ」で地面を全部掘る。 「大航海時代」を一切航海せずにクリアする。 「魔界村」でレッドアリーマーをボスまで連れていく。 「アストロロボSASA」をコントローラー逆さまに持ってプレイ。 「バルーンファイト」の2人用をひとりでプレイ。 「デビルワールド」の画面上半分を隠してプレイ。 「ソロモンの鍵」で画面全てを石で埋め尽くす。5面でやるとよい。4の倍数面から行ける隠し部屋だとやや簡単。 「本将棋 内藤九段将棋秘伝」を2人でプレイ。相手の手番の後にCPUがプレイヤーを詰めれば勝ち。 「三国志」で CPU に天下統一させる。 「ロイヤルブラッド」で同上。 「テトリス」のブロックで文字を描く。 「ウィザードリィ」のパーティ全員を魔法使いにしてプレイ。 「半熟英雄」で攻撃は将軍のタマゴのみに限定。 「舛添要一 朝までファミコン」を本当に深夜から朝までプレイ。 「ギャラガ」を居合撃ちのみでプレイ（目の前で敵を撃つ）。一発でも外したらリセット。 「高橋名人の冒険島」でフルーツを1つも取らずにクリア。 「ナッツ＆ミルク」で敵のナッツを水中に落とさないようにプレイ。 などなど。 プレイ方法に制限を加えるものと、別の目標を作るものに大別できそうです。 やり尽くしたと思ったゲームでも楽しみ方は無限ですね。
著者の言う、ファミプロの掟の中に次のようなものがあります。
ゲームを遊ばず、ゲームで遊ぶ これはいい考え方だなぁ。 既存の枠組みに捉われず、何でも遊びに変えてしまえば、常に楽しく暮らせますね。</description></item><item><title>WinSCP をコマンドラインから利用して2つのディレクトリを同期する</title><link>https://maku.blog/p/eqrmt6x/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eqrmt6x/</guid><description>WinSCP のインストール WinSCP の本体は下記のサイトからダウンロードできます。
WinSCP :: Official Site :: Download ここでは、コマンドラインから winscp.exe を使用しますので、インストーラを使ってインストールするときに、カスタムインストールを選択し、インストールディレクトリを環境変数(%PATH%)に追加を選択してください。
winscp コマンドでリモートホストへディレクトリをコピーする ローカルディレクトリの内容を、リモートにあるディレクトリへ同期させるには、次のように winscp.exe の /synchronize オプションを使用します。
winscp [mysession] /synchronize [local_directory] [remote_directory] 例えば、example.com というホストに、ユーザ名 user で接続してローカルの website ディレクトリ内のファイルを user のホームディレクトリの public_html ディレクトリに同期させるには次のようにします。
例: ローカルの website をリモートの public_html へ winscp user@example.com /synchronize &amp;#34;C:\Users\maku\website&amp;#34; &amp;#34;/user/maku/public_html&amp;#34; 参考 WinSCP のドキュメント (Command-line Options)</description></item><item><title>ボードゲームではダブリングキューブをもっと利用したらいい</title><link>https://maku.blog/p/cy3f9xj/</link><pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cy3f9xj/</guid><description> みなさんバックギャモンはやったことありますか？ ボードゲーム界ではプレイヤー数はチェスと並んで世界最大とも言われるバックギャモンですが、日本ではあまりプレイされていないんですよね。 ルールも簡単で、見た目もおしゃれなのでもっと流行ってもよいんですけどね。 というわたしも最近ルール覚えたばかりですけど(^^;
実はバックギャモンの世界チャンピオンは日本の矢澤亜希子さんです。 これを期に、日本でもプレイヤー数増えていくといいですね。
【特報】第43回世界選手権　矢澤亜希子選手が優勝 と前置きはこのくらいにしておいて、バックギャモンの中に「ダブリングキューブ」というものがあります。 写真の真ん中にあるサイコロです。 よくある 6 面体のサイコロですが、描いてある数字は 2、4、8、16、32、64 と、倍々になってます。 だから、ダブリング。
このダブリングキューブはころころっと転がして使うのではなくて、現在の勝負の得点を 2 倍にする ダブル宣言（倍プッシュ！）をするときに使います。 ダブル宣言を突きつけられたプレイヤーの取れる選択肢は 2 つです。
テイク: ダブルを受けて 2 倍になった得点でゲーム続行する パス: 現在の得点（1点）を相手に与えてゲーム終了する つまり、ダブル宣言とは、
もうオレの勝ちだからオリて得点よこせよ！ と、オリを強制しているわけです。 ただし、ダブルされた方は、もし自分の方が勝っていると思えば倍付けの勝負を続行できるので、ダブル宣言する方は慎重に行わないといけません。 しかも、次のダブル宣言はダブルを受けた側のみが権利を持つことになり、逆に 4 倍の勝負を突きつけられるリスクを追うことになります。
これって得点が倍々になっていくのでギャンブル要素の強いルールですが、その考え方はとても理にかなっていて、消化試合的なゲームがダラダラと続いてしまうのを防ぐ効果 があります。 だから、このダブリングキューブは、もっといろんなゲームで利用してもよいと思うんですよね。 特に二人用のボードゲームなどで、ポイント制をとっているものであれば、このダブリングキューブがひとつあればドキドキハラハラな展開を楽しめます（ダブリングキューブがなくてもできますけど、雰囲気大切！）。 もちろん、最後まで逆転要素があるゲームであればそれがベストですが、どうしても最後には消化試合になってしまうようなゲームでも、ダブリングキューブがあればもっと楽しめます！
2018-10-20 追記
ライナー・クニツィア氏の『ダイスゲーム百科』にダブリングキューブを使うゲームが載ってました。 イースト・ウェストというポーカー系のゲームのバリエーションとして紹介されています。 ダブリングキューブの仕組みはいろいろなゲームで利用されているみたいですね。
ダイスゲーム百科 ライナー・クニツィア スモール出版</description></item><item><title>『人身売買デスゲーム』やった</title><link>https://maku.blog/p/h5j77zj/</link><pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h5j77zj/</guid><description>RPG アツマールというサイトで公開されてる『人身売買デスゲーム』ってのをずっとやってました。 試しにやってみたら、数時間かけて結局最後までやってしまった。
人身売買デスゲーム - RPGアツマール GANTZ みたいに数人が部屋に閉じ込められたところから始まって、逆転裁判のように推理を進めながらステージごとに一人ずつ脱落していく（投資家に人が売られていく）ゲームです。 逆転裁判好きだから、こーゆーの好き。
特殊能力を使える人が出てくるストーリー物は、「変身できる能力」、「能力をコピーできる能力」ってのが入ってくると途端に複雑になりますね。 人身売買デスゲームには両方ともでてくるからややこしい。 でもゲーム自体は簡単に進んでいくので（逆転裁判よりかなりイージー）、どちらかというとノベル読んでるみたいな感じです。
ちなみに、ゲームの中では、上下する人の価値に対して投資をして株のように稼ぐシステムがあるのですけど、これでがんばって稼いだお金はほとんど使う場面がありません。ここだけ拍子抜け。</description></item><item><title>読書メモ『ラクして速いが一番すごい』松本利明</title><link>https://maku.blog/p/2454mic/</link><pubDate>Fri, 17 Aug 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2454mic/</guid><description>ラクして速いが一番すごい 松本利明 ダイヤモンド社 若干コンサルタントよりの内容になっていますが、会社のなかで要領よく仕事をすすめていくコツがたくさん書いてあります。 若いうちに読んで実践すると早く出世できそうですね。
メモ 報告・説得 何かを伝えたいときは、報連相（ホウレンソウ）ではなく、**空雨傘（ソラ・アメ・カサ）**を使う。マッキンゼーの日本オフィスが考えた思考のフレームワーク。
空（ソラ）を見ると曇ってきた（事実）。 雨（アメ）が降りそうだから（洞察）、 傘（カサ）を持って行こう（打ち手）。 差が出やすいのは 2 つ目の洞察部分で、「どうしてそうなった（過去）」ではなく、「どうなりそうなのか（未来）」を伝えることがポイント。
上司を説得するには、自分の価値観ではなく、会社の価値観を利用する。「我が社の価値観の『◯◯』に沿って判断するとこうなります」と言えばいい。個人の見解では上司にひっくり返される。下記は会社の価値観・判断基準の例。
ディズニーランド: ◯夢の国、×現実 アップル: ◯シンプル、×細かなたくさんの機能 サウスウエスト航空: ◯格安、×費用 話を始めるときは、相手の「欲」をダイレクトに刺激するひと言を最初に言う。最初に大した話ではないと思われたら、結論がどれだけすばらしくても話半分にしか聞いてもらえない。
資料 50名を超える講演やセミナーなどの場合、黒地に白で文字を見せたほうが、遠くからはハッキリ見える。最後の資料として「サマリ」を付け、最低限持って帰ってほしいことを 3 つ、多くても 5 つにまとめて伝える。 外資系コンサルタントは、入社時に「パワポの配色ルール」を教わる。色の3属性は「色相」「明度」「彩度」だが、重要なのは色相。 2色の場合: 色相環上の反対色を使う。橙系と青系がオススメ。 3色の場合: 色相環上で正三角形を意識して使う。赤系、青系、黄系の3つがオススメ。 4色の場合: 反対色を2つ組み合わせて使う。橙系、青系、赤系、緑系の4つがオススメ。 パンチラ（パンチライン）など、遠くからでもハッキリとメッセージをアピールしたいときは、明朝体ではなくゴシック体を使う。標準のMSPゴシックは太字にすると投影時や印刷時の相性問題でレイアウトがズレやすいので、「HGP創英角ゴシックUB」がオススメ。 早く確実に文章のミスをチェックするには、音読して文章をチェックする。 用語集は「OK/NG方式」で作成し、更新日と更新者名を入れておく。Excel の場合は、一番左に「Read me」のタブを作り、そこに用語集を入れておく。 下記はOK/NG方式の一例。 OK:「ドラフト」、NG:「草稿」「メモ」「たたき台」 OK:「ギャランティ」、NG:「報酬」「フィー」「契約料」 OK:「報告書」、NG:「調査書」「レポート」 断る Yes/But 法でいく。ひと呼吸おいてから「わかりました」と言い、受け入れながらも自分の意見を主張する。No というだけでは嫌われるだけだが、どうすればその仕事が早く進むかを一緒に考えると逆に感謝される。 多部署からの依頼は、他の人に回すときは「◯◯さんがいいと思います」と名前を伝えるだけでは不十分。「できるか聞いてみますね」、「私からも彼にメールを入れておきます」というつなぎのひと手間をかける。 アピール 自分のことを伝えるには、過去→現在→未来の3点セットで伝えるのがコツ。 評判を上げる近道は、常にまわりに感謝すること。「うまくいったのは◯◯さんのおかげです。ありがとうございます」と声に出して言う。具体的に何のどこがどうよかったのかをハッキリと言葉にして伝える。メールで感謝を伝えるコツは、事実をベースに、短文で「ありがとう」を伝えること。追伸の形で「いつも◯◯してくれてありがとう」と書くのもよい。 嫉妬されずに、うまく自分の手柄をアピールするには**「みんなでやった」と言う**。まわりの100人に感謝すれば、その同じ100人分の感謝が自分1人に集まる。 スケジューリング／タスクの処理 「みなさん、ご都合はいかがでしょうか」と聞いてしまうと相手の都合に振り回される。「次回のミーティングは、◯月△日13時でいかがでしょう？」と先に自分の都合で提示する。 1日は8時間ではなく、6時間でスケジューリングしておく。イレギュラーなことが発生したり、チャンスが舞い込んだときに手をあげる余裕が生まれる。 TODO は「緊急度ｘ重要度」の軸ではなく、「成果が出るｘ自分に向いている」の軸で考えると他人の緊急度によって振り回されずに済む。 自分一人の仕事より、相手がいる仕事から着手する。 最終的に手元に残すのは「あなたが得意で、かつ、あなたにしかできない仕事」だけ。得意な仕事を洗い出し、その具体的なノウハウを他人でも使えるようにツールやフォーマットに落とし込んでみる。落とし込めるものは他の人でもできる。 優秀で本当に忙しい人ほどビックリするくらい返信やお礼のリアクションが早い。逆に忙しいフリをしている人は返事が遅い。一行だけでもいいのですぐ返信する。 打ち合わせ 「議事録を文書で起こす」という社内ルールがないのであれば、ホワイトボードの内容をスマホで撮り、関係者に一斉メールすることで議事録作成の手間を省く。グーグルや外資系コンサルティング会社などはこの方法をとっている。 持論を繰り返す人は、自分の意見を大事に扱ってくれないことや、無視されることに腹をたてるので、ホワイトボードにその意見を書いてあげるだけで満足してくれる。 独演会を始める人の対策としては、ホワイトボードに終了時間を書いておき、「お話の途中ですみません。重要な話の内容ですが、あと15分で結論を出すことになっています。一番のポイントを先に教えていただけますか？」と切り出す。 キーマンとのランチで話す内容は、事実ベースの内容にする。(1)現部署でどんなことがおきているか、(2)どんなことで悩んでいるか、(3)どんな人が実は活躍しているか、という現場の一次情報を伝えると喜ばれる。告げ口、悪口、おべっかは言わない。事実のみを伝えるので、解釈はあなたに任せます、というスタンスが正解。 会議やセミナーの Q&amp;amp;A では、真っ先に発言するだけで「できる人だ」と評価されるようになる。優秀な人は「最初に発言」することで評価されている。 姿勢を正し、ハッキリとした声を出す。 コンサルタントは厳しいことを言うが、お辞儀が一番深く、長い。壇上では堂々と力強い姿を見せるのに、実際お会いして見ると腰が低くていねい。このギャップが魅力につながる。 仕事ができない人への対処 仕事ができない人の特徴は、「プライドが高いが、自分に自身がなく、ガラスのハートを持っている」ことなので、仕事のできない人を責めるのは逆効果。</description></item><item><title>読書メモ『J2EE パターン』 Deepak Alur、John Crupi、Dan Malks</title><link>https://maku.blog/p/saanpfh/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/saanpfh/</guid><description>J2EE のパターンコレクションを示した本です。 有名な GoF のデザインパターンとは異なる、21 のパターンが紹介されています。 既存のプロジェクトにパターンを適用するにはリファクタリングが必要になりますが、その方法も示されています。
Grady Booch（Rational Software Corporation 主任研究員）のまえがき パターンに名前を付けることによって、新たな語彙を手に入れ、それまでは気付かなかったであろう方法でパターンを適用できるようになる。
慢性的に時間に余裕がないところでは、美しいソフトウェアはなかなか書けない。 しかし、適切なパターンを選んで適用すれば、システムにある程度の優雅さをもたらすことができる。
マイクロアーキテクチャとは マイクロアーキテクチャは、アプリケーションおよびシステムの構築に利用できるビルディングブロック。個々のパターンよりも抽象度が高く、複数のパターンをリンクさせ組み合わせて表現することができる。
第1章: パターンとJ2EE パターンの定義 パターンとは、特定の文脈、問題、および解決策の相関関係を表した、3要素から成る規則である。
─Christopher Alexander 『A Pattern Language』 パターンとは、「特定の文脈」、「その文脈において繰り返し発生する問題」、および「これらの問題を解決する特定のソフトウェア構造」の3要素の相関関係を表した規則である。
─Richard Gabriel『A Timeless Way of Hacking』 パターンとは、ある現実の文脈の中で有用であって、他の文脈の中でもおそらく有用であろうと思われるアイデアである。
─Martin Fowler『Analysis Patterns』 繰り返し発生する問題と、その解決策に関する知識を表現して伝えるには、パターンが理想的なツールである。 考慮事項、アイデア、メモなどの知識を公式に文書化して伝えることができるようになる。
第2章: プレゼンテーション層における設計上の考慮事項とバッドプラクティス この章では、ユーザセッションやクライアントアクセスの制限に関しての概要が述べられている。 プレゼンテーション層におけるバッドプラクティスがざっと羅列してあるが、特に目新しさは感じられない（コントローラーが肥大化したら他のオブジェクトに処理を委譲する、といった程度のことしか書いてない）。 第6章以降のパターンカタログの方を見ていくのがよい。
第3章: ビジネス層における設計上の考慮事項とバッドプラクティス ステートレスなセッションBeanであれば、Beanをプールしておいて、複数のクライアントで使いまわせる。 スケーラビリティの問題のほとんどは、ステートフルセッションBeanや、ステートレスセッションBeanの誤用によるものである。 スケーラビリティが必要なシステムでは、ステートレスセッションBeanを使用することがより実用的な設計戦略となり得る。 1回のメソッド呼び出しでサービスが完了するビジネスプロセス（非対話型ビジネスプロセス）を実装するには、ステートレスセッションBeanを使うとよい。
スケーラビリティの向上を狙って、どのようなケースでもステートレスセッションBeanを選択する設計者もいる。 しかし、こうした設計を行ったために、ネットワークトラフィックのオーバーヘッド、再構築時間、アクセス時間などが絡んできて、かえってスケーラビリティが低下してしまっては本末転倒である。</description></item><item><title>『オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて』スコット・W・アンブラー</title><link>https://maku.blog/p/9kuptdn/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9kuptdn/</guid><description>オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて スコット・W・アンブラー 日経BP社 原題は『The Object Primer』。 スコット・アンブラーのフルライフサイクルオブジェクト指向テスト (FLOOT: Full Lifecycle Object-Oriented Testing) から、アジャイルな要求やアーキテクチャまでが、1 つにまとめられています。 実践 eXtreme プログラミングの共著者である Granville Miller は、「アジャイルになるとは、チームや自分自身に対する制約を取り払うこと」だと述べています。 本書ではその方法の神髄を学ぶことができます。
下記、重要そうなところや、個人的にビビッと来たところのメモです。
第1章: 最先端のソフトウェア開発 下記がアジャイルアライアンスのマニフェストであり、そこに集まった異なる方法論者全員に受け入れられたものである。 Individuals and interactions over processes and tools
プロセスやツールよりも個人や相互作用 すばらしいプロセスやツールは重要だが、結局は人の協力関係がすべて。 Working software over comprehensive documentation
わかりやすいドキュメントよりも動作するソフトウェア ドキュメントはシステムがなぜ、どのように構築されたか、どう使えばよいかを理解するためには重要。 Customer collaboration over contract negotiation
契約上の駆け引きよりも顧客との協調 契約は重要だが、契約を結んだからといってコミュニケーションが必要なくなるわけではない。 Responding to change over following a plan
計画を硬直的に守ることよりも変化への対応 プロジェクト計画は必要だが、柔軟でなければならない。ガントチャートを何枚も作成する必要はなく、非常に単純なものでよい。 自己組織化されたチームとは、チームのリーダーが開発メンバーの各自の役割や作業範囲を決めるのではなく、目標を共有するメンバーが共同作業を行う過程でチームの能力が最大限発揮されるようにメンバーの役割が自然に決まっていくようなチーム形態のこと。 成功を収めている組織は、大抵アジャイルなソフトウェア開発アプローチをとっているか、RUP または EUP を採用しているかのどちらかだ。RUP をアジャイルに使おうとしても現実には非常に困難（素材が多すぎてアジャイルなレベルまで切り詰められない）。アジャイルプロセスを取り入れたいなら、XP や FDD などを採用すべき。 MDA よりも、アジャイルモデル駆動開発 (AMDD: Agile Model-Driven Development) アプローチの方が、お絵かき式のモデリング方法に近く、現実的に大多数の開発者が採用できるアプローチである。 第2章: オブジェクト指向概念の基本 この章にはオブジェクト指向を知らない人のために、その概念について書かれています。</description></item><item><title>読書メモ『ワークブック形式で学ぶ UML オブジェクトモデリング─ユースケース駆動でソフトウェアを開発する』ダグ・ローゼンバーグ、ケンドール・スコット</title><link>https://maku.blog/p/d3ehztz/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d3ehztz/</guid><description>ワークブック形式で学ぶ UML オブジェクトモデリング ダグ・ローゼンバーグ、ケンドール・スコット ソフトバンククリエイティブ 「ユースケースと UML モデリングの例題がもっと必要だ」という声がきっかけになり書かれた本です。 ユースケースという抽象的な表現から、どのようなステップで具体的なコードにまで落とし込んでいくかが説明されています。 このような開発をユースケース駆動と呼んでおり、提唱者の Ivar Jacobson によると、ユースケース駆動は下記のように説明されています。
システム機能を変更する場合は、適切なアクタとユースケースを再モデル化します。 システムアーキテクチャ全体は、ユーザの要求にそって構築されます。 すべてのモデルはトレースできるようにしておくと、新しい要求仕様が発生した際にもシステムの修正が可能になります。 ユーザに対し、変更したい部分（もしくは変更したいユースケース）の内容を確認し、ほかのモデルの中でどの部分を変更するかを見極めます。
本書の著者、ダグ・ローゼンバーグはこれを以下のように簡単に解釈しています。
ユーザマニュアルを書けば、コードも書ける。
第1章: はじめに ここで用いる ICONIX プロセスは、重量級の RUP（ラショナル統一プロセス）と、軽量級の XP (eXtreme Programming) の間に位置する。具体的で理解しやすいユースケースが作成できるという点で、Ivar Jacobson が構想した「ユースケース駆動」の意味に一致している。 ソフトウェアプロジェクトの進捗はどれだけのコードを書いたかによって測定されることが多いので、プロジェクトはコーディングに移行しようとする。そして、モデリングが十分にできていない段階でコーディングが始まってしまう。 本書の目的は、ソフトウェアプロジェクトにおいて、よい仕事をするために通常必要と思われる UML（およびモデリング全般）の、最小限ではあるが、十分なサブセットを定義すること。 what（要求）と how（詳細）のギャップを埋めることが ICONIX プロセスの中心課題である。ロバストネス図を使って、あいまいで漠然としたユースケース（要求レベルのビュー）と、詳細で正確なシーケンス図（設計レベルのビュー）のギャップを解消する。ロバストネス図を使用せずにユースケースからシーケンス図を作成することは非常に難しい。ロバストネス分析は、要求と設計のギャップを解消するのにとても役に立つ。 ギャップの解消するためには、ロバストネス分析の中で、下記のような作業を並行して行っていく。 見落としていたオブジェクトを見つける。 データフローをトレースする際に、クラスに属性を追加する。 ロバストネス図を描きながら、ユースケース記述を更新し洗練する。 ドメインモデルで定義した「用語」を使ってロバストネス図を描く。 ユースケースモデル ⇔ ロバストネス図 ⇒ シーケンス図 図: ICONIX プロセス全体像 ICONIX プロセス: プロトタイプを作る（おそらく画面の簡単な描画）。 クライアントに誤りがないかを確認してもらう。 ユースケース図のユースケースを識別する。 ユースケース記述を書く。 ロバストネス分析でユースケース記述を洗練する。 第2章: ドメインモデリング ドメインモデリングでは、UML モデルの静的な部分の基礎を形成する。 ドメインモデルは実世界の問題空間オブジェクトを中心に構成するので、ソフトウェアの要求ほど頻繁には変化しない。 ドメインモデルは、ユースケースを記述する作業の初期段階で使用できる「用語集」の役割を果たす。 ドメインモデリングでは、属性と操作の把握には時間を費やさない。後の作業で明らかになった属性と操作を追加していけばよい。 ドメインモデリングでは、オブジェクト間の関係（汎化や集約）を識別することに焦点を当てる。 ソフトウェアが再利用できるかどうかは、このドメインモデリング作業にかかっている。 ドメインモデリングの誤りトップ10 ドメインモデリングのコツはすばやく作ること。ブラッシュアップは後のロバスト分析などの過程で行っていけばよい。</description></item><item><title>障害者向けの製品アイデア</title><link>https://maku.blog/p/rx89f98/</link><pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rx89f98/</guid><description> 聴覚障害 自分が喋っている言葉の発音がきれいになるようにサポートする（表示 or 振動） 音声を振動に変えて伝える（自分の名前が呼ばれたらリストバンドを特定のパターンで震わせるなど） 発話障害 ジェスチャーをリアルタイムに会話音声に変換（首かけ型のガジェットから、カメラで判別＆音声出力）</description></item><item><title>読書メモ『雀鬼流。桜井章一の極意と心得』桜井章一</title><link>https://maku.blog/p/w9j69xb/</link><pubDate>Mon, 09 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w9j69xb/</guid><description> 雀鬼流。桜井章一の極意と心得 桜井章一 三五館 裏プロの世界で20年間無敗だった桜井章一氏が、初めて雀鬼流について記述したものです。 雀鬼流は麻雀の技術ではなく、生き方について教えています。 教育の世界に身を置く人や武道家、スポーツ選手など、桜井氏の考え方は多くの人が参考にしています。
知識の中には、実体験で得たものと、そうでないものがある。実体験で得たものを尊重したい。 外面的なことに身を任せるのではなく、自分という内面に身を任せるなら、自分という存在に確信を持つことができるはずなのだ。 我が道を生きるとは、われを見捨てず、われを人任せにせず、自分の内面を、心を、思いを大切にし、われを知ることにある。楽しい人生というのはそんなところにある。 かかわりを深くしていると、楽しかったり、いいなあと思えることが沢山増えるのです。 雀鬼会では、もっともっと心を開け、行動を惜しむな、と教えている。そうしていかないと、いつまでたっても、本当の自分というものに気づかない。 おもしろいこと、楽しみは、外に求めるべきものではなく、楽しみを作る人間にならなければいけない。 人のことをわかろう、わかろうとするのではなく、自分のほうをきれいに掃除して、無駄な要素を省いていけば、相手のことが見えてくる。 多くの人たちは、自分に価値を見出せないから、真の価値を見出せないから「数」に価値を見出して、「数」を追うほかなくなる。 相手に鳴かれるかもしれぬ、手の内に残ったどちらかの牌が当たり牌だ、というスレスレのところまでやってみないと、読めているのか、ズレているのかの見極めがつかないし、流れを自分のものとすることはできない。 自分である程度納得ずくで振る、という振りを「勝負振り」というんですが、納得感のある振り込みを心掛けなければ勝負運、勝負強さというものは身につかない。 勝とうという意識が先にきてはいけないのです。低いレベルで勝っても、それは価値のある勝利ではないのです。政治もビジネスも同様です。 他人を欺くことだけが、嘘をつくことではない。自分で自分に約束したことを破ることも、嘘をついたことになる。 「東の二局に絶対和了るんだ」「南の三局は絶対何が何でも和了るんだ」と、勝負が始まる前に、前もって決めてしまう。いい手悪い手なんて関係ない。どんな配牌でも、その一局では一歩も下がらないで和了きることです。点棒上では負けであっても、前もって決めておいた東場と南場の二回を和了れば、その勝負は勝ちなのです。こういう強い意思を育む訓練によって、オーラスという状況を迎えたときに、いとも簡単に和了れるようになってくる。 不真面目に生きることも良くないですし、真面目くさって生きることもよくないのです。真面目とユーモアがくっついてこそ、本当のあったかさが生まれるんです。そうすることで、理不尽なことは決して許せないといった真面目な側面とのバランスをとっているのです。 ふんぞり返ってもいない、意気消沈してうなだれてもいない、真ん中にいて背筋を伸ばしている人は崩れない。真ん中にすっくと立っている人が一番強いということなんです。自分の手の内を全部さらけ出している人が一番強いのです。 麻雀は人と人との戦いですが、私は他者には惑わされません。麻雀だけを見つめていればいい。「アイツ強いからなあ」と、人を見てしまうと、麻雀との戦いではなく、人との戦いになってしまう。誰が相手であろうが、人が見ていようがいまいが、己の姿勢を崩さない心をふだんから持ち続けなければならないのです。 ヒクソン・グレイシーの言葉「見ただけで相手をジャッジしないようにしている。目に見えるものにとらわれない、信じるものは、心に感じられたものだけだ。」 人生をお金の動きだけで捉えようとすることに意味がないように、勝負の行方をはっきりと決定づけるのは、点棒の動きではなく、打ち手の心の動きです。 自分の手牌はもちろんですが、敵の三人の表情、河（ホー）の捨て牌など、あらゆることに気をくばって、それでいてどこか一箇所に気をとられてしまってはいけない。つまり、部分的なものに目を奪われることは避けて、勝負全体を、流れを見ることが大切なのです。 自分のために麻雀を打つのではなく、一緒に打ってくれる三人のために打つ気持ちをまず大切にしなさい。そうすれば、潔さとか、犠打とか、思いやりとかがわかってくる。自分のためだけを考えて打っているのであれば、自分以外の人の心の動きなど見えてくるはずもない。私を捨てて公で打て。 いいライバルがいるということは、喜ぶべきことなのです。日々自分で自分を叱咤激励することはとても困難。ですから、雀鬼会では、いいライバル作りを心掛けているのです。ただ己を向上させることだけではなく、真剣に戦いあうために、己の、そしてライバルの雀力をアップさせなければいけない。 二日間の戦いで、２時間くらいしか寝てないときがけっこうありました。そんなとき、大抵の人は、体のせいにしてしまう。私は逆です。「あ、チャンスだな」と思う。いわゆる不運を、与えられた手だ、テーマだと思うのです。人がリーチをかけてくると、私はうれしくなる。条件が厳しくなればなるほど、緊張感が高まって気持ちいい。相手のリーチは、川の流れの中の岩であり、障害物です。水や魚はぜんぜんそれを気にしません。岩をこわがり逃げるのは人間心理。それを水や魚になって、すき間を見つけたり、迂回するのが、流れにそうと言うことです。 求めるべきなのは、安住ではなく、試練なんです。試練が、人を鍛え上げてくれるんです。つねに公の精神を忘れないで、不安定や危険に飛び込んでいく姿勢を持っていないと、低いレベルからはなかなか脱し切れないんです。 育児／恋愛 世間の言ういい子というのは、自分自身を小さい頃から売ってしまっている子です。いい子になりなさいと洗脳されてきた子で、いいなりになりやすい人間に育ってしまっているといえませんか。すべて親のいうことを聞いているということは、親に魂を売ってるということです。 本当の素直というのは、良い悪いをきちんとわきまえて、悪いことは悪いと、自分の気持ちに忠実にはねつけられることです。両親のいうこと、先生のいうことを半分聞いて、半分は聞かないほうが、良い子であり、素直な子だと私は思う。堂々と、「お父さんには、こんな駄目なところがあるんだよ」といえばいい。 私の育児観はこうです。子供たちが小学校を終えるまでは私は子供の奴隷、ということです。中学からは立場は逆転して、私がトップになる。それも、二十歳になる間だけです。二十歳になってからは、対等の関係なんです。十分に与えてもらって来た子は、欲求不満に陥っていないので、思ったより簡単に甘えから自らを解放し、自立できるようになるものなんです。 子供のほうでは、十分に悪いことをやってしまったと自覚してて、相談にきている。そういうときは、私は絶対に怒りません。本人が、悪いことをやっているのにもかかわらず、悪いことをやったということに気づいていないときは、コラッと怒る。 愛し合うときは、じゅうぶんに愛しあって、それ以外のわかりあえない部分があっても、それはそれでいいわけです。このズレを埋めようとしてしまうからいけない。</description></item><item><title>読書メモ『シンギュラリティは近い』レイ・カーツワイル</title><link>https://maku.blog/p/57uv9oa/</link><pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/57uv9oa/</guid><description> シンギュラリティは近い レイ・カーツワイル NHK出版 人工知能 (AI) が人類を上回り、この世のあり方が一変するシンギュラリティ（技術的特異点）。 人工知能の世界的権威であり、Google で AI 開発の先頭に立つレイ・カーツワイルが、シンギュラリティはなぜ間近だと断言できるのか、シンギュラリティに到達すると何が起こるのかを解説しています。
シンギュラリティとは何か？ テクノロジーが急速に変化し、それにより甚大な影響がもたらされ、人間の生活が後戻りできないほどに変容してしまうような、来るべき未来。 人生の意味を考えるうえでよりどころとしている概念が、このとき、すっかり変容してしまう。 数学者は「特異点（シンギュラリティ）」という言葉を、有限の限界を超える値を表すものとしてこの言葉を用いた。 シンギュラリティ以降の世界では、人間と機械、物理的な現実と拡張現実（VR) との間には区別が存在しない。 生物の進化と人間のテクノロジーの進化は継続的に加速している。 ほとんどの人は未来を線形的に見ている。短期的に達成できることは必要以上に高く見積もるのに（細部の必要条件を見落とす）、長期的に達成されることを必要以上に低く見積もってしまう（指数関数的な成長に気づかない）。 将来的にはナノテクノロジーを用いてナノボットを設計することができる。これにより、加齢を逆行させることも可能になる。脳の毛細血管に数十億個のナノボットを送り込み、人間の知能を大幅に高めることができる。ナノボットは、過去の工業社会が引き起こした汚染を逆転させ、環境を改善する。フォグレットと呼ばれるナノボットは、モーフィング技術を使って作成した VR を現実世界に出現させる。 最後には、宇宙全体にわれわれの知能が飽和する。これが宇宙の運命なのだ。 五感すべてを組み込んだ完全没入型の VR 環境は、2020年代の終わりには実際に手に入ることになる。 スーパーコンピュータが人間の脳の性能に達し、2020年頃までにパソコンもそこに達する。▼著者のこの予想はさすがに外れそう。ちなみに、原書は13年以上も前の2005年に書かれています。 ムーアの法則をはじめとする個別のパラダイムは、最終的に、指数関数的成長がそれ以上不可能な水準に必ず到達する。ところが、コンピュータの伸びは、基盤となるパラダイムを次々と取り替え、当面のところ、現行の指数関数的成長が持続する。パラダイムシフトによって、あらゆる個別のパラダイムの S 字曲線は、次なる指数関数曲線へと変わっていく。 ナノコンピューティングによって強力な水準の知能が生まれるので、もしもピコやフェムトのコンピューティングが可能だとしたら、将来の知能がそのために必要なプロセスを見出してくれるだろう。 人間の脳は、超並列処理を用いて、微妙なパターンをすばやく認識する。だが、人間の思考速度は非常に遅い。基本的なニューロン処理は、現在の電子回路よりも、数百万倍も遅い。 人間のニューロンはすばらしい創造物だが、これと同じ遅い手法を用いてコンピューティング回路を設計したりはしない。自然淘汰を通じて進化してきた設計は確かに精巧だが、われわれの技術で作り出せるものよりも、何桁もの規模で能力が劣る。 人間のニューロンにある複雑さのほとんどは、情報処理ではなく、生命維持機能を支えるために使われている。 非生物的なコンピューティングを利用して、人間の知能を拡大し利用することで、われわれは最終的に知能のパワーを増大させることになる。よって、コンピューティングの最終的な限界について考えることは、実際には、われわれの文明はどういう運命をたどるのか、と問うているのと同じことなのだ。 シンギュラリティ─人間の能力が根底から覆り変容するとき─は、2045年に到来すると考えている。 デジタルのコンピューティングはアナログのコンピューティングと機能的に同等だということを、念頭に置いておかねばならない。つまり、デジタルとアナログが混じり合ったネットワークの機能のすべてを、デジタルだけのコンピュータで実行することができるのだ。この逆は真ではない。デジタルコンピュータの機能のすべてをアナログコンピュータでシミュレートすることはできない。 脳が従来のコンピュータと異なる重要な点がたくさんある。 脳の回路はとても遅い。 それでも脳は超並列処理ができる。 脳はアナログとデジタルの現象を併用する。脳のほとんどの昨日はアナログで、非線形性にあふれている（出力が突然切り替わる）。 脳は自身で配線し直す。 脳の細部のほとんどはランダムだ。 脳は創発的な特性を用いる。 脳は不完全である。 われわれは、矛盾している。 脳は進化を利用する。 パターンが大切だ。 脳はホログラフィ的だ。 脳は深く絡み合っている。 脳には、各領域をまとめるアーキテクチャがある。 脳の各領域の設計は、ニューロンの設計よりも単純だ。 われわれの思考プロセスは、われわれ自身を理解することが本質的に可能なのかどうか、と疑いをもつ者がたくさんいた。精神科医のピーター・D・クレイマーは「精神が、われわれに理解できるほど単純だとすれば、われわれはあまりにも単純すぎて、精神を理解することはかなわないことになる」と書いている。 人間の知能は、「自己理解」に必要とされる閾値より上なのか下なのか、というダグラス・ホフスタッターの疑問に答えて言うならば、脳のリバースエンジニアリングが加速度的に進展する中で、われわれが自分自身を理解する能力には限界などない。 バージョン 1.0 の虚弱な人体は、はるかに丈夫で有能なバージョン 2.0 へと変化するだろう。何十億ものナノボットが血流に乗って体内や脳内をかけめぐるようになる。体内で、それらは病原体を破壊し、DNA エラーを修復し、毒素を排除し、他にも健康増進につながる多くの仕事をやってのける。その結果、われわれは老化することなく永遠に生きられるようになるはずだ。 人体2.0: 2030年代の初頭、われわれはどうなっているだろう。心臓、肺、赤血球、白血球、血小板、膵臓、甲状腺他すべての内分泌器官、腎臓、膀胱、肝臓、食道下部、胃、小腸、大腸などはすでに取り除かれている。この時点で残っているのは、骨格、皮膚、生殖器、感覚器官、口と食道上部、そして脳だ。 人体3.0: 2030年代から2040年代。MNT（マイクロ・ナノテクノロジー）ベースの構造を体内に組み入れることによって、身体的特徴を好きなようにすぐ変えられるようになる。 「VR 環境デザイナー」という新しい職種が生まれ、新しい芸術の形となる。2020年までに、完全没入型の視聴覚ヴァーチャル環境の中で体をすばやく変化させられるようになるだろう。そして2020年代にはあらゆる感覚と結びついた完全没入型のVR環境の中で変身できるようになる。そして2040年代には現実世界でそれが可能になる。 人間の平均寿命は今後もどんどん伸びていく。 クロマニョン人: 18歳 古代エジプト: 25歳 1400年ヨーロッパ: 30歳 1800年ヨーロッパおよびアメリカ合衆国: 37歳 1900年アメリカ合衆国: 48歳 2002年アメリカ合衆国: 78歳 病気の50％を予防すれば: 150歳 病気の90％を予防すれば: 500歳 病気の99％を予防すれば: 1000歳 そもそも種とは生物学の概念であり、われわれがしようとしているのは、生物学を超越することなのだ。シンギュラリティの根底にある転換は、生物進化の歩みを一歩進めるだけのものではない。 未来の機械は、感情や精神を宿すことができるのだろうか？─もっとも説得力のあるシナリオは、人間そのものが徐々に、しかし確実に、生体から非生物的な存在へと変わっていくと言うものだ。 意識の実在を決定的に裏づける客観的な検証法は、ひとつとして存在しない。</description></item><item><title>読書メモ『夢をかなえるゾウ』水野敬也</title><link>https://maku.blog/p/mebz3uq/</link><pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mebz3uq/</guid><description>夢をかなえるゾウ 水野敬也 飛鳥新社 ゾウの神様ガネーシャが夢をかなえるための課題を毎日ひとつずつ出してくれるお話です。 神様なのにパチンコでお金をなくしたり、涙もろかったり、なんだか親しみが湧いてきます。
頭の中で夢を想像しているだけでは駄目で、小さいことでもいいから実際に行動することでしか夢は叶えられない、体感することでしか自分を変えていくことはできない、というのがガネーシャの教えです。 ガネーシャが出した課題は以下の通り。
靴をみがく コンビニでお釣りを募金する 食事を腹八分におさえる 人が欲しがっているものを先取りする 会った人を笑わせる トイレ掃除をする まっすぐ帰宅する その日頑張れた自分をホメる 一日何かをやめてみる 決めたことを続けるための環境を作る 毎朝、全身鏡を見て身なりを整える 自分が一番得意なことを人に聞く 自分の苦手なことを人に聞く 夢を楽しく想像する 運が良いと口に出して言う ただでもらう 明日の準備をする 身近にいる一番大事な人を喜ばせる 誰か一人のいいところを見つけてホメる 人の長所を盗む 求人情報誌を見る お参りに行く 人気店に入り、人気の理由を観察する プレゼントをして驚かせる ガネーシャからの最後の課題:
やらずに後悔していることを今日から始める サービスとして夢を語る 人の成功をサポートする 応募する 毎日、感謝する 成功したり、有名になったり、お金持ちになるためのガネーシャの理論は以下の通り。 お金は人を喜ばせることでもらうもの。 人は好きなことしかできない。 だとしたら、人を喜ばせることが何より楽しいと思えるように自分自身を変えていくしかない。</description></item><item><title>読書メモ『パターン指向リファクタリング入門』ジョシュア・ケリーエブスキー</title><link>https://maku.blog/p/2j4w6nn/</link><pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2j4w6nn/</guid><description>パターン指向リファクタリング入門 ジョシュア・ケリーエブスキー 日経BP社 マーチン・ファウラーの『リファクタリング』の続編のような本で、デザインパターンを活用しながら、どのようにソフトウェアの設計を改善しけばよいかを示しています。 パターンの知識を付けるだけでなく、パターンの賢い使い方を知ることをテーマとしています。
この本の特徴として、現実のコード、あるいは実際に使用したコードを元にしたコードが使用されている点が挙げられます。 実際のプロジェクトにはリファクタリングに関して多くの制約があり、それは作り物のコードでは体験できないものです。
以下は全11章のメモです。
第1章: 本書を執筆した理由 コードを必要以上に柔軟にしたり洗練させることは、作り込みすぎ (over-engineering) である。チームのプログラマたち（特に新しく参加した人たち）は、無意味に大きく複雑なコードベースを扱わなければならなくなる。作り込みすぎは生産性を低下させる。作り込みすぎな設計を引き継ぐ場合、拡張や保守を行うのに多大な時間がかかる。 とはいうものの、作り込み不足 (under-engineering) は作り込みすぎよりずっと多い。 TDD と継続的なリファクタリングのリズムを身に着けるには経験と時間が必要だが、この開発スタイルに慣れてしまえば、別の方法で実稼働するコードを作成することは奇妙で、不安で、プロフェッショナルらしくないと感じるようになる。 優れた設計を行いたいなら、設計そのものを調べるよりも、その設計がどのように進化してきたかを知らべる方が有益だ。真の知恵は進化の中に存在する。 第2章: リファクタリング コードが明確でない臭いの元は、リファクタリングで取り除くべきであって、コメントで脱臭するべきではない。そのようなコードをリファクタリングをするときは、そのコードをよく理解している人に立ち会ってもらうのが一番である。 実際にリファクタリングを促すものは感情だ。私はコーディングの不快感を少しでも減らすためだけにリファクタリングを行うことがよくある。 マーチンファウラーの言葉「コンパイラが理解できるコードは誰にでも書ける。すぐれたプログラマは、人間にとってわかりやすいコードを書く。」 小さい単純なステップに分けることで、大きなステップよりも間違いなく早く目標にたどり着くことができる。 アプリチームとフレームワークチームを1つのチームにしておけば、それらがちぐはぐになることがない。フレームワークはアプリのニーズにもとづいて作られるので、価値のあるフレームワークのコードだけが作成される。ただし、このプロセスには継続的なリファクタリングが必須である。それによって、フレームワークとアプリを分けておくことができる。 第3章: パターン パターン魔 (patterns happy) は、パターンに魅了され、コードでパターンを使わずにいられなくなった人。誰しもがパターンを学ぶ過程でパターン魔になる。リファクタリングによってパターンを徐々にシステムに組み込んでいくようにすれば、パターンによって作り込みすぎる可能性は低くなる。 残念なことに多くプログラマは、デザインパターン本に例示されている各パターンの構造の図が、そのパターンを実装する唯一の方法だと間違えて捉えている。『デザインパターン』の共著者の一人であるジョン・ブリシデスも、「実際のコードにはいろいろなニーズや制約があり、示されている構造の図とは大きく異なってくる」と述べている。例示されている構造をそのまま実装するのではなく、パターンの実装を必要最小限に抑えることは、進化的設計のプラクティスである。目的は設計をよりよくすることであって、パターンを実装することではないことを忘れないこと。 一般的には、パターンを実装することで、コードの重複を取り除き、ロジックを単純化し、意図を伝えやすくし、柔軟性を高めることができるはずである。しかし、パターンに慣れていない人がコードを読むと、わかりにくい、複雑すぎると感じることがある。このような意見の食い違いが発生した場合は、パターンの使用をやめるより、チームがパターンを学ぶ方がよい。 第4章: コードの臭い もっともよくある設計の問題は、次のようなコードが原因である。 重複している 不明確である 複雑である メソッドの適した行数はどのくらいであろうか？ほとんどのメソッドが1～5行のコードからできているものが適切だと私は考えている。小さなメソッドを連鎖させても、性能はほとんど低下しない。プロファイラを使えば明らかである。 第5章: パターンを取り入れるリファクタリングのカタログ この章では、この本の読み進め方が述べられています。
第6章: 生成 Creation Method によるコンストラクタの置き換え (Replace Constructors with Creation Methods) 問題: 1つのクラスに複数のコンストラクタがあると、開発時にどのコンストラクタを使うかの判断が難しくなる。 対策: コンストラクタの代わりに、意図がわかりやすい Creation Method を作成し、それがオブジェクトのインスタンスを返すようにする。 利点: どのような種類のインスタンスが返されるかがコンストラクトよりもよく伝わる。 引数の数と型が同じであるコンストラクタを2つ作成できないといった、コンストラクタの制限事項を回避できる。 使われていない生成コードを見つけるのが簡単になる。 欠点: 生成方法が標準に準拠しなくなる。new によってインスタンスを生成するクラスと「Creation Method」を使うクラスとが混在する。 Factory による生成処理の置き換え (Move Creation Knowledge to Factory) 問題: クラスのインスタンス化に使うデータやコードが数多くのクラスに散在している。 対策: 生成に関する知識を1つの Factory クラスに移動する。 利点: 生成ロジックとインスタンス化／設定のための情報をまとめられる。 クライアントを生成ロジックから切り離すことができる。 欠点: 直接のインスタンス化に比べて設計が複雑になる。 Factory によるクラス群の隠蔽 (Encapsulate Classes with Factory) 問題: 1つのパッケージ内に存在して共通のインタフェースを実装しているクラス群を、クライアントが直接インスタンス化している。 対策: クラスのコンストラクタをパブリックでなくし、クライアントには Factory 経由でインスタンスを生成させる。 利点: さまざまな種類のインスタンスの生成を、意図が明確なメソッド経由で行うことで、単純化できる。 公開する必要のないクラスが隠蔽されるため、パッケージの「概念的重み」(by Bloch) を減らすことができる。 「インタフェースに対してプログラミングするのであって、実装に対してプログラミングするのではない」（書籍『デザインパターン』より）という原理を厳しく適用できる。 欠点 新しい種類のインスタンスを生成しなければならない場合には、Creation Method の新規作成や変更が必要になる。 Factory のソースコードではなくバイナリコードにしかアクセスできない場合には、カスタマイズが制限される。 Factory Method によるポリモーフィックな生成の導入 (Introduce Polymorphic Creation with Factory Method) 問題: 階層内のクラスが、オブジェクトの生成ステップを除いて同じようにメソッドを実装している。 対策: そういったメソッドをスーパークラスで1つにまとめ、そこで Factory Method を呼び出してインスタンス化の処理を行う。 利点: オブジェクトを生成するステップが異なることが原因で生じている重複が減る。 どこで生成が行われているか、どのようにオーバーライドされているかが効果的に伝えられる。 Factory Method で使うためにクラスがどの型を実装しなければならないのかが明確になる。 欠点: Factory Method を実装するクラスに不必要な引数を渡さなければならないことがある。 Builder による Composite の隠蔽 (Encapsulate Composite with Builder) 問題: Composite の構築処理が何度も出現したり、複雑であったり、あるいはエラーを起こしやすいものになっている。 対策: 詳細部分を Builder に任せることで、構築を単純化する。 利点: Composite を構築するクライアントコードを単純化できる。 Compsoite の生成にまつわる繰り返しやエラーを軽減できる。 クライアントと Composite の間の結合度が低くなる。 カプセル化された Composite や複合オブジェクトを異なった形式で表現できる。 欠点: インタフェースの意図が伝わりにくくなる可能性がある。 Singleton のインライン化 問題: コードからあるオブジェクトにアクセスしなければならないが、グローバルなアクセス方法は必要でない。 対策: Singleton の機能を1つのクラスに移し、そのクラスにオブジェクトを格納してアクセス手段を提供する。Singleton は削除する。 利点: オブジェクトの協調関係がより見えやすく明示的になる。 唯一のインスタンスを保護するための特別なコードを必要としない。 欠点: いくつもの層を経由してオブジェクトインスタンスを渡すのが面倒だったり困難だったりする場合には、設計が複雑になる。 第7章: 単純化 メソッドの構造化 (Compose Method) 問題: メソッドのロジックをすぐに理解できない。 対策: 意図の伝わりやすい、詳細レベルが揃った小さなステップ群にロジックを変換する。 利点: メソッドが何をし、それをどのように行うかが効果的に伝わる。 詳細レベルが揃った、わかりやすい名前がついた振る舞いに分割することで、メソッドを単純化できる。 欠点: 小さなメソッドが増えすぎることがある。 多数の小さなメソッドにロジックが分散するため、デバッグが困難になることがある。 Strategy による条件判断の置き換え (Replace Conditional Logic with Strategy) 問題: いくつかの計算方法のうちどれを実行するかを、メソッド内の条件ロジックで制御している。 対策: 計算方法ごとに Strategy を作成し、元のメソッドは計算処理を Strategy のインスタンスに委譲する。 利点: 条件ロジックが減る、あるいは取り除かれるため、アルゴリズムが明白になる。 アルゴリズムのバリエーションをクラス階層に移すため、個々のクラスが単純になる。 実行時にアルゴリズムを別のものに置き換えることができる。 欠点: 継承による解決策や「条件記述の単純化」のリファクタリングを使った方が簡単な場合には、それよりも設計が複雑になる。 アルゴリズムがコンテキストクラスとデータをやり取りする方法が複雑になる。 Decorator による拡張機能の書き換え (Move Embellishment to Decorator) 問題: コードがクラスの核となる責務に対する拡張機能を提供している。 対策: 拡張機能を Decorator に移動する。 利点: 拡張機能が取り除かれるのでクラスを単純にできる。 クラスの核となる責務と拡張機能とを効果的に区別できる。 関連する複数のクラスに含まれる重複した拡張ロジックを取り除くことができる。 欠点: 装飾対象のオブジェクトと装飾後のオブジェクトは異なるものになってしまう。 コードを理解したりデバッグしたりするのが困難な場合がある。 Decorator を組み合わせた際、互いに悪影響を及ぼす場合には、設計が複雑になる。 State による状態変化のための条件判断の置き換え (Replace State-Altering Conditionals with State) 問題: オブジェクトの状態遷移を制御する条件式が複雑である。 対策: 条件式ではなく、個々の状態とその間の遷移を扱う State クラスを使う。 利点: 状態を変えるための条件ロジックがなくなる、あるいは減る。 状態を変える複雑なロジックが単純になる。 状態を変えるロジックを俯瞰することができる。 欠点: 状態遷移ロジックがもともとわかりやすい場合には、設計が複雑になるだけである。 Composite による暗黙的なツリー構造の置き換え (Replace Implicit Tree with Composite) 問題: String などの基本データ型の表現によって、暗黙的なツリー構造を作っている。 対策: 基本データ型の表現を Composite で置き換える。 利点: ノードの形成、追加、削除といった手順の繰り返しをカプセル化できる。 同じようなロジックの増殖に対処する汎用的な方法となる。 クライアントの構築作業が簡単になる。 欠点: 暗黙的なツリー構造を作成するほうが簡単な場合には、設計が複雑になるだけである。 Command による条件付きディスパッチャの置き換え (Replace Conditional Dispatcher with Command) 問題: 条件ロジックによってリクエストを振り分け、アクションを実行している。 対策: アクションごとに Command を作成する。Command をコレクションに格納し、条件ロジックを Command を取り出して実行するコードに置き換える。 利点: 一律に同じやり方で、さまざまな振る舞いを実行するためのシンプルなメカニズムである。 どのリクエストをどのように処理するかを実行時に変更できる。 実装するためのコードが少ししか必要でない。 欠点: 条件付きディスパッチャで用が足りる場合には、設計が複雑になるだけである。 第8章: 汎用化 Template Method の形成 (Form Template Method) 問題: 複数のサブクラスの2つのメソッドが、同じ順番で似たようなステップを実行しているが、それらのステップはまったく同じではない。 対策: 各ステップを同じシグニチャを持つメソッド群に抽出してメソッドを汎用化し、それから汎用メソッドを引き上げて Template Method を形成する。 利点: 不変な振る舞いをスーパークラスに移すことで、サブクラス間の重複したコードを取り除くことができる。 汎用のアルゴリズムのステップを簡潔にし、効果的に伝えることができる。 サブクラスで簡単にアルゴリズムをカスタマイズできるようになる。 欠点: アルゴリズムを肉付けするためにサブクラスで多くのメソッドを実装しなければならない場合には、設計が複雑になる。 Composite の抽出 (Extract Composite) 問題: 階層内のサブクラスが同じ Composite を実装している。 対策: Composite を実装するスーパークラスを抽出する。 利点: 子に関する格納と処理の両ロジックの重複をなくすことができる。 子を処理するロジックを継承することが効果的に伝わる。 欠点: 特になし。 Composite による単数・複数別の処理の置き換え (Replace One/Many Distinctions with Composite) 問題: あるクラスが、1つのオブジェクトの場合と複数のオブジェクトの場合とを別のコードで処理している。 対策: Composite を使って、1つのコードで、1つのオブジェクトの場合と複数オブジェクトの場合との両方を処理できるようにする。 利点: 単数または複数のオブジェクト処理に関するコードの重複を取り除く。 単数または複数のオブジェクトを統一したやり方で処理できる。 複数オブジェクトの処理機能が豊富になる（OR表現など）。 欠点: Composite の構築時にタイプセーフかどうかの実行時チェックが必要なことがある。 Observer によるハードコードされた通知の置き換え (Replace Hard-Coded Notifications with Observer) 問題: 別のクラスの1つのインスタンスに対する通知がサブクラスにハードコーディングされている。 対策: Observer インタフェースを実装した任意のクラスの任意の数のインスタンスにスーパークラスが通知を送れるようにし、サブクラスを削除する。 利点: 観察対象と観察者の間の結合度が低くなる。 観察者が単数の場合にも複数の場合にも対処できる。 欠点: ハードコーディングされた通知で用が足りる場合には、設計が複雑になる。 通知がカスケードしている場合には、設計が複雑になる。 観察対象から観察者が削除されないと、メモリリークが起きる可能性がある。 Adapter によるインタフェースの統合 (Unify Interfaces with Adapter) 問題: クライアントが2つのクラスと相互作用していて、その1つが好ましいインタフェースを持っている。 対策: Adapter によってインタフェースを統合する。 利点: クライアントコードが同じインタフェースを通じて複数のクラスとやり取りできるため、コードの重複をなくしたり減らしたりできる。 共通のインタフェースを通じてオブジェクトやり取りできるため、クライアントコードが簡潔になる。 クライアントが複数のクラスとやり取りする方法を統合できる。 欠点: アダプタを作らなくてもクラスのインタフェースを変更できる場合には、設計が複雑になるだけである。 Adapter の抽出 (Extract Adapter) 問題: 1つのクラスが、コンポーネント、ライブラリ、API、あるいは他のエンティティの複数バージョンに対するアダプタになっている。 対策: コンポーネント、ライブラリ、API、あるいは他のエンティティのバージョンごとに Adapter を1つ抽出する。 利点: コンポーネントやライブラリや API のバージョンごとの違いを切り分けることができる。 クラスの責務を1つのバージョンに対応することだけに限定できる。 頻繁なコードの変更が必要な部分を限定できる。 欠点: Adapter で提供されていない重要な振る舞いをクライアントが使えなくなることがある。 Interpreter による暗黙的な言語処理の置き換え (Replace Implicit Language with Interpreter) ある言語の文法に関して、実装する必要のあるクラスが10程度までなら、Interpreter パターンを使ってモデリングするのが有効かもしれない。</description></item><item><title>C# で Microsoft Outlook の情報を取得する</title><link>https://maku.blog/p/eb5nx4z/</link><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eb5nx4z/</guid><description>組織内で Outlook を使用している場合は、プログラムから Outlook の情報（Exchange サーバの情報）を取得してごにょごにょすると、日々の作業を効率化できるかもしれません。 ここでは、C# から Outlook の情報を取得する方法を紹介します。
プログラミング言語に C# を使っていますが、もともとは VBA などのインタフェース (COM) として使われていたものなので、本格的にコーディングするときは、VBA のリファレンスが参考になります。
Outlook VBA リファレンス｜MSDN 以下のサンプルは、Visual Studio Community 2017 を使って確認しています。 Visual Studio で新規のプロジェクト（ここではシンプルにコンソールアプリを選択）を作成したら、まずは次のようにして Outlook のインタフェースの参照を追加してください。
プロジェクト(P) → 参照の追加(R) COM → Microsoft Outlook 14.0 Object Library 次のコードは、現在 Outlook を使用しているユーザの名前とメールアドレス、および上司の名前とメールアドレスを表示します。
using System; using Outlook = Microsoft.Office.Interop.Outlook; namespace ConsoleApp1 { class Program { static Outlook.Application outlookApp = new Outlook.Application(); // Exchange ユーザの情報を表示する static void ShowRecipientInfo(Outlook.ExchangeUser user) { Console.</description></item><item><title>2018-06-13 森川亮さんの話</title><link>https://maku.blog/p/uqk4oxg/</link><pubDate>Wed, 13 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uqk4oxg/</guid><description>元 LINE 社長の森川亮さんのお話を聞きました。 ちなみに名前は「りょう」ではなく「あきら」です。
雑誌のインタビュー記事も好きですけど、森川さんの話はやっぱり面白いですね。 口調もやさしい感じで好感が持てます。 内容よりもしゃべり方の方がって重要だなぁってこのごろ思います。
日本人は会議することが仕事だと思い込んでいる。他にすべきことがあるでしょう。 企業の中で出世しようと思い始めた時点でその人の成長は止まる。スティーブジョブズが出世しようと思ってあのようになりましたか？出世を考えなければ、自由に大きなことができるようになり、人として大きく伸びる。 （IT系の）企業の技術力に差はほとんどなくなってきている。新しいものを作ったとしても、すぐに真似されるのは当然。必要なのはスピードで、先にサービスを提供した企業はデータをたくさん集められる。それを利用して、次のサービスをまた素早く作る。それができるのが現代における強い会社だ。 などなど、働き方や企業のあり方に関していろいろためになるお話を聞けました。感謝です。
中でも、「出世を目標にし始めた時点で成長は止まる」 という意見はとても共感するものがありました。 自分がエンジニア寄りの人なのでバイアスかかってるかもしれませんが、出世競争みたいなのは過去の思い出みたいになるでしょうね。 リンダ・グラットンが 『ワークシフト』 の中でも述べているように、これからの人生100年時代は、自分の視野を広げつつも得意分野（職人的な力）を伸ばすことにフォーカスした方が幸せになれると思います。</description></item><item><title>2018-06-06 ボードゲーム部（ごきぶりポーカー、ナンジャモンジャ、フェレータ、ワードバスケット）</title><link>https://maku.blog/p/bdxmyrz/</link><pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bdxmyrz/</guid><description>今日はボードゲーム部の日。 ごきぶりポーカー、ナンジャモンジャ、フェレータ、ワードバスケットをプレイ。
今日も楽しかった〜。
ごきぶりポーカー ごきぶりポーカー Drei Magier メビウスゲームズ ごきぶりポーカーは、ダウトの発展版のようなゲーム。
嘘をついたり、それを見破ったりしながら、同じ種類の虫を４枚揃えてしまうか、８種類の虫をすべて揃えてしまったら負け。 ルールは簡単だけど、追い詰められると不利になって逆転しにくくなってしまうのは、ちょっとゲームバランス悪いかなぁ。 何か独自のルールを加えてバランスよくして遊ぶのがよさそう。
ナンジャモンジャ ナンジャモンジャ・ミドリ すごろくや ナンジャモンジャは、順番に一枚ずつカードをめくって名前を付けるのを繰り返し、同じカードが出た時にその名前を先に言った方が勝ち、というこれもシンプルなゲーム。 この間、テレビでジャニーズ WEST がやってました。
あたりまえですけど、自分で命名したカードが出るとすごく有利で（思い出しやすい）、得点するのはほとんど自分のカードが出たときになっちゃいますね。 だから、運の要素が結構強い。 でも、勝負にこだわらず、ワイワイやって楽しむとすごく面白い！
フェレータ フェレータ ニューゲームズオーダー (New Games Order) フェレータは裏切りのゲームです。 バラと鷹のチームに分かれて、10ターン戦ってポイントをたくさん稼いだ人の勝ち。
毎ターン、バラと鷹のどちらか勝利した方がポイントを得るのだけど、自分が所属するチームはころころ変わります。 それは、「反逆者」という役があるから。 毎ターンのはじめに、役割カードを順番に選んでいくのですが、ここで「反逆者」を選んだ人は寝返って別のチームに移動します。
この役割を決めるフェーズが一番面白いところですね。 毎回「反逆者」を誰が取ったのか読み合うという。。。 逆に言うと、他の役割にあまり差はなくて（戦力に＋5できるとか）、このあたりにもう少し工夫があったら非常によいゲームになったんじゃないかと思います。
手札として配られるカードは単純に、戦力が書かれたカード。 バラと鷹の勝負はこの戦力の足し算で行うのですが、みんな共通の意見は、「足し算めんどくさ！」
ワードバスケット ワードバスケット (Word Basket) メビウスゲームズ しりとりゲーム。 場に出ているカードに書かれたひらがな一文字で始まって、手持ちのカードのひらがな一文字で終わる単語を考えてカードを場に出していくというすごいシンプルなゲームです。
３文字以上の単語を考えればよいのですが、最後の１枚だけは４文字以上の単語で終わらなければいけません。 なかなか単語が思いつかない、そんな歯痒さを味わえるゲームです。 エッチな言葉ばっかり使ったらダメですよ〜。
なんか似たようなゲームを昔（30年くらい前）やったような気がするけど、思い出せない。。。 でもワードバスケット自体は 2002 年に考案されたみたいだから、ワードバスケットではないんですよね。 あ〜歯痒い。。。</description></item><item><title>英辞郎の PDIC の高度な使い方</title><link>https://maku.blog/p/en9hm8g/</link><pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/en9hm8g/</guid><description>「英辞郎 第十版」に付いている辞書ソフト PDIC-R (Personal Dictionary-R) の高度な使い方をメモメモ φ(・ｪ・o)
これを使いこなすと、英辞郎がかなり便利になります。
熟語の検索 take over + Enter と入力すると、take &amp;hellip; over という英文を検索することができる（&amp;hellip; は任意の数の単語） take ~ over + Enter と入力すると、熟語としての take over の意味そのものを検索することができる。訳語部において、~ は任意の目的語を意味している。 AND/OR 検索（関連語検索） WORD 欄に複数の単語をスペースや | で繋げて入力し、Enter キーを押すことで、AND 検索、OR 検索を行うことができます（関連語検索と言います）。
単語A 単語B + Enter 見出し語の AND 検索を行う。 スペースは半角でも全角でもよい。 単語A|単語B + Enter 見出し語の OR 検索を行う。 ヘルプには | の前後にスペースがあってもよいとされているが、実際はスペースがあるとうまくいかないっぽい。 単語A -単語B + Enter 見出し語に単語Aを含むが、単語Bは含まないものを検索する。 例: dog|cat -my &amp;ndash; 見出し語に「dog」あるいは「cat」を含むが「my」は含まないものを検索する。 単語A +単語B + Enter 見出し語に単語Aが含まれ、かつ、訳に単語Bが含まれるものを検索する。 例: dog cat +やれやれ &amp;ndash; 見出し語に「dog」と「cat」が含まれ、さらに、訳に「やれやれ」が含まれるものを検索する。 | や - は見出し語に作用するのに対し、+ は訳に対して作用するのでかなり特殊ですね。</description></item><item><title>読書メモ『ダイアグラム別 UML 徹底活用』井上樹</title><link>https://maku.blog/p/xfgoaq3/</link><pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xfgoaq3/</guid><description>ダイアグラム別UML徹底活用 第2版 井上 樹 翔泳社 （全13章）
1章: モデリングのメリットを考える モデリングの連続の末にプログラムというモデルの最終形態に辿り着くことが、システムを開発するということ。 図によるモデル化のメリット 情報量が多い 理解しやすい 誤解が少ない UML2.0 について ダイアグラムが10種類から13種類に増加（コンポジット図、相互作用概要図、タイミング図）し、次のようなことをモデル化できるようになった。 複数のインスタンスを内包するクラスの内部構造 複数のインタラクションの時系列上の流れ 複数のインスタンス間でのメッセージのやり取りと、それに伴う状態変化 ダイアグラム名称の一部変更 ステートチャート図 → ステートマシン図 コラボレーション図 → コミュニケーション図 「フレーム」が追加され、ダイアグラム全体を囲んだ入り、一部を囲んで説明を加えることができるようになった。ダイアグラムの一部をフレームとして囲んだところを畳み込めば、大きなダイアグラムでも全体を見渡しやすくなる。 2章: ユースケース図の注意点と使いどころ ユースケースは、**「こういうものを作るんだ」**ということを明らかにするために描く。 関連を結んだアクター＝ユースケースの起動者ではない。関連はあくまで関わり合いがあることだけを示す。 UML2.0 におけるユースケースの変更点は、extend の関係に対してノートで条件を書けるようになったこと。 役立つユースケースにするには 目的／読者を確認する 名前付けに注意する 抽象度: 「一般会員」や「レジ係」というように文章に出てくるくらいの抽象度がよい。 正確性: 対象を明示する（例: 貸出→ビデオを貸し出す、返却→ビデオの返却を受け付ける） 表現の統一: 同じ意味を示す言葉は揃える（例: 「貸し出す」と「レンタルする」） 粒度を揃える 機能分割にしない: 機能単位で描くと粒度が細かくなりすぎて、そのモデル化した対象がどんなサービスを提供しているのかわからなくなってしまう。サービスで分割することを意識する。 ≪include≫は1段階まで: 2段階以上にするとアクターにとって意味のある粒度のユースケースになりにくい。 ≪include≫、≪extend≫、汎化関係を混同しない ≪include≫: ≪include≫先のユースケースは必ず必要になることを意味する。プログラムの関数呼び出しのような感じで、複数のユースケースから共有できる（例: ビデオを借りる─include→会員かどうかを確認する）。 ≪extend≫: ≪extend≫でベースになっているユースケースにサービスを付加した場合は、ベースとなるユースケースの実行には≪extend≫で定義したユースケースは必ずしも必要ない（例: ビデオを借りる←extend─カードで料金を払う）。逆に、≪extend≫で定義されたユースケースを実行するには、必ずベースのユースケースが必要になる。 汎化関係: 汎化関係は機能を追加するのではなく、概念だけ共通だがまったく新しいユースケースを定義する（例: ビデオを借りる←汎化─ビデオを宅配で借りる）。 ユースケース記述と合わせる: ユースケース図だけでは誤解を招きやすいので、ユースケース図を描いたら、ユースケース記述も合わせて作成する。ユースケース図とユースケース記述を合わせて**「ユースケースモデル」**と呼んだりする。 3章: ユースケース記述の注意点と使いどころ ユースケース記述の概要 ユースケース記述はシステム開発の初期にユースケース図と一緒に作られ、システム外部から（利用者から）見たときの振る舞いを明確にする。 特に担当者を入れ替えながら開発が進んでいくプロジェクトなどでは、開発者間でシステムイメージを共有できるということは重要。 ユースケース記述は書くのに非常に手間のかかる成果物だが、システム開発に一貫したゴールを与えることができるのは大きなメリット。ユースケースのレベルで再利用できるようになると、より楽をできるようになる。 ユースケース駆動開発 ユースケースは進捗を計るベースとして使用できる。ユースケースを一単位とすると、代替フローや例外フローが含まれているため、作業単位の粒度としては大きくなりすぎることがある。そのような場合、ユースケース記述に書かれた**「シナリオ」を作業単位とする**とよい。 ユースケース駆動開発では、ユースケースのシナリオごとに、(1)分析、(2)設計、(3)実装、(4)テストという作業を進めていく。ユースケースを実現できたかどうか（それぞれのステップが完了したかどうか）のポイントは下記の通り。 分析: 分析のクラス図に書かれているクラス群を使って、ユースケース記述に書かれたシナリオを実現する相互作用図（シーケンス図、コレボレーション図）を作ることができる 設計: 設計のクラス図に書かれているクラス群を使って、ユースケース記述に書かれたシナリオを実現する相互作用図（シーケンス図、コラボレーション図）を作ることができる 実装: シナリオを実現するためのプログラムが書けている テスト: シナリオに書いてある通りにシステムが動いている ユースケース記述のテストへの活用 ユースケース記述に書かれた振る舞いは、要求元と合意されたものとなるので、テストケースの元ネタとして使うことができる。 テストケースとシナリオは対応するものなので、テストを意識してシナリオリストを作成すると、テストケースの作成が容易になる。イベントフロー（メインフロー＋代替フロー＋例外フロー）の組み合わせを網羅する形でシナリオリストを作るのがコツ。 イベントフローは３種類 メインフロー: 正常に処理が進んだ場合。 代替フロー: 正常系の代わり（エラーが発生した場合など）。代替フローを実行した場合でも事後条件は満たされる。 例外フロー: ユースケースの実行を断念しなければならないような場合。例外フローを実行した場合は事後条件は満たされない。 ユースケース記述のポイント 厳密に漏れなく書く 曖昧性のない厳密な記述がされており、システムの振る舞いが具体的に理解できること。 ユースケース記述の作成と合わせて用語集を作成するとよい。 イベントフローの書き出しは「アクターは～」、「システムは～」と動作の主語を必ず書く。 システムで実現すべきことはすべてユースケースに書かれているようにする 仕様変更が発生した場合など、ユースケース記述はこまめにメンテナンスする。 細かくしすぎない エンドユーザにもわかるレベルで記述する（エンドユーザーと開発者が共有するものなので）。ユーザマニュアルのようなレベルを想定するとちょうどよい。 データベースのテーブルや、画面レイアウト、画面遷移を意識する記述が出てきたら危険。 イベントフローに「システムは～する」という記述が連続して 4 ～ 5 ステップ続いたら詳細になりすぎている可能性が高い。 危険なワード: DB、テーブル、クエリ、キー、ID、コネクション、チャネル、セッション、トランザクション、ロック、ボタン、クリック、入力欄、インタフェース 補足資料を使う 文章だけで記述するのではなく、アクティビティ図や、スケッチ、表なども併用すればよい。 空欄を作らない ユースケース記述のフォーマットには項目がたくさんあるが、空白状態で放置しない。「T.</description></item><item><title>2018-05-27 日本ダービーに初めて行ってみた</title><link>https://maku.blog/p/de7i2di/</link><pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/de7i2di/</guid><description>今日は競馬ファンが熱狂する日本ダービー（東京優駿）の日。 競馬自体やったことないんですけど、日本ダービーは一度行ってみたかったので、電車乗り継いで府中の東京競馬場に行ってみました。 府中本町駅から専用の通路ができているので迷うことなく到着です。 なんかディズニーランドにいくような感覚に近い。
ダービーは3時過ぎからの第10レースなのですが、到着したお昼には人でいっぱいでした（来場者は11万8千人でした）。 ファミリーで来ている人たちも多いという噂でしたが、やっぱり競馬がメインなので子供連れは少ないですね。
馬券買うのは基本的に室内ですが、その周りも人だらけ。 場所取りが激しいです。 なんなのコレ。
パドックはお馬さん近くで見れて楽しいですね。 これだけでも来てよかった（＾o＾）
「場内」と呼ばれる、コースの中央のエリアにも入ることができます。 このエリアには子供の遊具とか、売店とかいろいろ出てます。 ここは比較的空いていて、レースを見ることもできるのですが、かなり遠い。。。 しかも中継モニタを見ることもできません（写真右端に写ってるやつの裏側がスクリーンになっている）。 双眼鏡を持って来ているおじさんがいたんですが、理由がわかりました。
しょうがないので第10レースのダービーは、通常の観戦エリアに戻って観戦しました。 ものすごい人で、遠くから見ないといけませんでしたが、すごい歓声で、迫力ありました。
ちなみに、戦績はというと、単勝が当たりました！ 100円しか買ってないけど。</description></item><item><title>VR（バーチャルリアリティ）系の製品アイデア</title><link>https://maku.blog/p/4ppftm9/</link><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4ppftm9/</guid><description> 超リアルペット。自分が画面の前に行ってバーチャルな猫を見るのではなく、バーチャルな猫の方が自分のいるところについてくる。 部屋全体がストリートビュー。Google のストリートビューは、通常は平面なディスプレイ上で使うが、部屋の中を360度ディスプレイにしてしまえば、本当にその場所にいるかのような空間を作り出せる。</description></item><item><title>ガジェット系の製品アイデア</title><link>https://maku.blog/p/54fbqm3/</link><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/54fbqm3/</guid><description> 首かけ型の万能ガジェット 一日中付けておくことを想定。目指すのはスマホの置き換え。スマホを持ち歩くのは面倒だし、置き忘れたりする。 暑い日には霧噴射したり、風出したりして涼しくしてくれる。 プロジェクタ機能が付いていて、手のひらなどに情報投影できる。でこぼこなところに映しても自動補正してきれいに見える。スマホの画面のようにタッチ操作可能。 テレビなどの家電のリモコンになる。自分の目線の方向を認識し、テレビを見てるならテレビのリモコンをテーブルに投影。 高精度にジェスチャ認識。テレビのリモコンの代わり、端末自体の操作などに使用可能。 音声認識で操作が可能。常にマイクが近くにあるので、いつでも使える。 音楽再生、電話ができる。音声は自分にしか聞こえない。 体調管理もしてくれる。 危険を教えてくれる。 電気自動車は静かなので近づいていることに気付かない。自分の方に向かってくる車があったら警告してくれる（ITS連携）。</description></item><item><title>ドローンを使ったアイデア</title><link>https://maku.blog/p/jbi6jqp/</link><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jbi6jqp/</guid><description> ドローンにプロジェクタをつけて地面に投影する。 草原や農場などをステージに 高層ビルなど側面に空中から投影 ドローンにスピーカーをつけて、ステージ後方の空中からの迫力サウンドを提供。 ドローンに映写用の幕などを広げさせる、そこにプロジェクションマッピング。 ドローンから霧噴射して、そこにプロジェクションマッピング。 ドローンからスプレー噴射で絵を描けるようにして、巨大な壁面アートを自動で作成。 炎天下の日に、ドローンから霧噴射して街の温度を下げる。 ドローンで社内便。何か送りたいときは、ドローンの方から席まで取りに来てくれる。 ドローンでペットの散歩。 車や重機などの工業用塗装。AIで形状把握、塗装、コーティングまで自動化。</description></item><item><title>ランダム ID 生成ツール</title><link>https://maku.blog/p/3nx9is3/</link><pubDate>Sat, 21 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3nx9is3/</guid><description>文字数: 文字候補: 再生成 指定した文字数のランダムな ID を生成します。 数字の 1（いち）とアルファベット小文字の l（エル）、数字の 0（ぜろ）とアルファベット大文字の O（オー）は区別しにくいので、デフォルトでは含めないようにしています。 このような UX 上の工夫は、さまざまな標準プロトコルで推奨されています。 例えば、下記は RFC 8628 におけるユーザーコード表示の例です。
参考: RFC 8628 - OAuth 2.0 Device Authorization Grant の例 It is RECOMMENDED to avoid character sets that contain two or more characters that can easily be confused with each other, like &amp;ldquo;0&amp;rdquo; and &amp;ldquo;O&amp;rdquo; or &amp;ldquo;1&amp;rdquo;, &amp;ldquo;l&amp;rdquo; and &amp;ldquo;I&amp;rdquo;. Furthermore, to the extent practical, when a character set contains a character that may be confused with characters outside the character set, a character outside the set MAY be substituted with the one in the character set with which it is commonly confused; for example, &amp;ldquo;O&amp;rdquo; may be substituted for &amp;ldquo;0&amp;rdquo; when using the numerical 0-9 character set.</description></item><item><title>Excel 関数のメモ</title><link>https://maku.blog/p/hewor72/</link><pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hewor72/</guid><description>文字列を繰り返す (REPT) 書式 =REPT(文字列, 繰り返し回数) 例: A1 セルに記述した数だけ `*` を表示する =REPT(&amp;#34;*&amp;#34;,A1) これを利用すれば、文字を使用した簡易的なヒストグラムを表示することができます。
日付から年/月/日/曜日など一部の情報を取得する 下記の表は、A1 セルに 2018-04-02（月） という日付データが入力されている場合に、各式の評価結果がどのようになるかを示しています。
式 結果 説明 =TEXT(A1,&amp;quot;m月&amp;quot;) 4月 書式指定で月を取得 =TEXT(A1,&amp;quot;aaa&amp;quot;) 月 書式指定で曜日を取得 =TEXT(A1, &amp;quot;aaaa&amp;quot;) 月曜日 書式指定で曜日を取得（&amp;ldquo;aaa曜日&amp;rdquo; でも同じ） =YEAR(A1) 2018 数値で年（4桁）を取得 =MONTH(A1) 4 数値で月 (1～12) を取得 =DAY(A1) 2 数値で日 (1～31） を取得 =WEEKDAY(A1) 2 数値で曜日 (1～7) を取得（日曜日が1） =WEEKNUM(A1) 14 その年の第何週目か 現在の日時を表示する 式 結果 説明 =TODAY() 2018/4/2 今日の日付 =NOW() 2018/4/2 9:24PM 現在時刻 ※表示形式を時刻にすると時刻部分が表示されます =NOW()-0.5 2018/4/2 9:24AM 12時間前の時刻asdofij 日付文字列から日付データに変換 =DATEVALUE(&amp;#34;2018-04-02&amp;#34;) DATEVALUE 関数は、日付文字列を、日付のシリアル値（内部的には 43192 といった数値）に変換します。 変換後の値を「年月日」のような形で正しく表示するには、セルの書式形式で「日付」や「時刻」を選択しておく必要があります。</description></item><item><title>読書メモ『運を味方にする カジノで一晩10億勝つ人の法則』片桐ロッキー寛士</title><link>https://maku.blog/p/3fas8ni/</link><pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3fas8ni/</guid><description> 運を味方にする カジノで一晩10億勝つ人の法則 片桐ロッキー寛士 幻冬舎 ラスベガスでディーラーをしている片桐さんのお話。
メモ 基本的にディーラーはお客さんの味方なので、アドバイスは聞いた方がよい。良好な関係を築いた方が何かと得。特にマナーがよい客には勝たせてあげたいと思う。 ディーラーの間では、カジノチップを数えることはバッドラックとされている。 --- プレーの最中は勝負に集中し、運の流れや場の空気を感じ取り、それらを賭けの判断につなげていく。そしてツキを感じたときに勝負する。そういうスタンスが勝てる人の共通点。 おすすめするのは、**勝負を連続したものと考えず、一回一回の勝負と捉えること**。一回ゲームが終わるごとにリセットする。 --- ゲームが終わるたびにリセットすれば、成功がすぐに驕りにつながることはなくなる。 運が向いてきたら、大きく賭ける。それが唯一、大きな勝ちを呼び込む方法です。 --- いつも同じ額を賭けていては、何のためにギャンブルをやっているかわかりません。 運が下がり続ける一方ということもある。負けたまま止めるのが苦手なのであれば、止めどきをルール化しておくのがよい。例えば、同じ番号に賭けて三回連続して負けたら止める、5 万円がなくなったら止める、など。**勝つ額を決めることはできないが、負ける額を決めることはできる**。 良い流れが来るまでは岩になれ。テーブルから離れなくても、いったん席を立って、一歩下がってゲームを見てみるだけでも効果がある。一歩下がったポジションから眺めていると、その場がクリアに見える。 100 枚が 1 枚になってもあきらめるのはまだ早い。そこから挽回するケースが稀ではない。最後の 1 枚だからこそ大切に扱うべき。 **長時間続けると必ず負ける**。勝っているときにいったんゲームを止め、利益を確保しておいて、休憩を挟むなどした後に、再びゼロからゲームを始めるのが一番賢い。多くの**負けの原因は、だんだんと賭ける額が大きくなって、運がマイナスに転じても、賭け金が大きいまま維持されてしまっていること**。運は常に上下している。勝負に勝つコツは、プレー、リセット、プレー、リセットとメリハリをつけて臨むこと。 取り戻すと思った時点で負けは確定。負けは負けと割り切り、新しい勝負を楽しむのだという気持ちで仕切り直す。 **損をする覚悟で勝負していると、その次に来るチャンスをうまく拾うことができる**。 **ギャンブルでも事業でもポジティブバカであることがよい作用をする**。</description></item><item><title>アプリや製品のアイデア: 部分共有スペース</title><link>https://maku.blog/p/7agmwph/</link><pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7agmwph/</guid><description>自宅やオフィスの部屋の一部のスペースをネットワーク連携させて、共同作業の場とする。</description></item><item><title>読書メモ『売れるゲームのUI/UX』西川善司、髙木貞武ほか</title><link>https://maku.blog/p/5jsixcb/</link><pubDate>Sun, 08 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5jsixcb/</guid><description> 売れるゲームのUI/UX 制作現場の舞台裏 株式会社Playce（西川善司、髙木貞武ほか） エムディエヌコーポレーション いろんなゲームを題材にして、UI/UX がどうあるべきか、これまでどう進化してきたかなどが述べられています。 ゲームセンターで異彩を放っている、ガンスリンガーストラトスの話が面白かったです。
アーケードゲームの理想は一般ユーザのプレイがそのまま他のユーザへのプロモーションになっていること。 ガンスリンガーストラトスは、コックピット形式の筐体を考えていたが、通り掛かった人にもよく見えるように今のデザインにした。 左右のアクリルパネルを手前に突き出すように配置することで、ひとり用のゲームだということが自然に分かるようにした。 時間貸しモードを搭載していて、1プレイ100円という通常モードだけでなく、25分500円、60分1000円といった料金体型でも遊べるようになっている。ゲームセンターのスタッフがこのような料金体系を実現するために仕事をしなくてもよい。 全国対戦モードでは、自分の実力に近いプレイヤーがマッチングされるようになっている。プレイヤーのランクは NESiCA に保存される。 「理由」がきちんと言えるのか、それとも言えないのかがプロとアマの違いだ。</description></item><item><title>読書メモ『超ノート術』佐藤ねじ</title><link>https://maku.blog/p/m6b879s/</link><pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m6b879s/</guid><description>超ノート術 佐藤ねじ 日経BP社 ブルーパドル 競争相手の少ないブルーオーシャンは見つけにくいので、それなら、水たまりなら見つけやすいだろうということで、「ブルーパドル」という会社を作ってしまった佐藤ねじさんの本。 働き方や、生き方について見直されつつある昨今、そういった小さなアイデアを商売につなげていくという考え方は今後重要になってくるかもしれないですね。
ねじさんの1軍ノート ねじさんは、博報堂ケトルの嶋浩一郎さんから影響を受けたという、1軍ノート、2軍ノートを作るという方法を採用しているみたいです。 1軍ノートには、モレスキンのような、ちょっとおしゃれなノートを使うことで、いつも携帯して、頻繁に開くというモチベーションを高めている。 そのノートには自分のすべてが詰まっている。
無地の1軍ノートは8マスに区切り、1マスごとにイメージ図と簡単な説明文を書いていく。 フォーマットをそろえてあるので、カタログのように見やすいし、いろんな場所で使える。
2軍ノートには思いついたことをどんどん書いていく。 2軍ノートから1軍ノートに書き写すかどうかは、こんまりさんが言っているのと同様、「ときめく」かどうかが基準。 このとき、ほとんどのアイデアはそのまま書き写されることはなく、何らかの新しい形に書き換えられて転記されることが多い。
前提を覆せば驚きが生まれる この視点が身につくと、あらゆるものについて、前提を変えられないかと発想できるようになる。 例えば、自分たちの作ったものを報告しあう会議では、順番にプロジェクタで映すのではなく、各自の席の上のノートPC上に表示して、展覧会のように、人が動き回って成果物を見ていく。 そうすると、雑談からいろんなヒントが得られるようになる。</description></item><item><title>2018-03-30 本当においしいコーヒーの話（コーヒーハンター川島良彰さん）</title><link>https://maku.blog/p/s363k9f/</link><pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s363k9f/</guid><description>ミカフェート代表取締役の川島良彰さんの話を聞く機会がありました。 JAL のコーヒーを納入されている会社です。 コーヒーハンターと呼ばれるだけあって、すごいこだわりでした。
ハンドソーティングという技 話のテーマの一つに「おいしいコーヒーの作り方」があって、よくコーヒーセミナーで説明されるドリップの仕方みたいな話をされるのかと思ったら、全然違う内容でした。 ミカフェートはコーヒー豆の栽培からとことんこだわっているところなので、コーヒー豆にフォーカスした話でした。
重要なのは豆の選別。 豆を挽く前に、ハンドソーティングして欠点豆を取り除くだけで全然違うコーヒーになる。
欠けている豆（貝殻豆） 煎り色が付いていないもの 虫食い豆 スタバである程度値の張る豆を買ってきても、上記のような豆がたくさん入っている。 コーヒーを粉ではなく、豆の状態で買う利点は、このハンドソーティングができるからなのだと。
コーヒーを豆で買っている理由を聞かれたら、「鮮度がいいから」という人がほとんどだと思います。 「ハンドソーティングできるからですよ」とか言えたらプロですね。
エチオピアの豆を使えない理由 コーヒー豆の輸送経路を考えると、エチオピアのコーヒー豆は使えない。 エチオピアは港などの輸送インフラがあまり整っていないので、どうしても長い陸路での輸送になってしまう。 50℃以上の環境に長期間放置されてしまうことがある輸送方法では、よい状態の豆を手に入れることができない。 理想的には温度差の少ない低温状態で、空路で輸送するのが望ましいけれど、そんな環境とは程遠い。
安いコーヒー豆ってどうして安いの？ スーパーなどで安く売られているコーヒー豆は、選別作業があまりされていないため、歩留まりが高くなるので安い。 例えば、豆のサイズは揃っていたほうが焙煎で火が通りやすいのだけど、このサイズの選別（統一）があまりされていない。 欠点豆の取り除きも行われていない。
あと、輸送も安く済む方法で行われている。 商社も儲けるために必死なので仕方ないけれど、赤道沿いの航路で2週間とかかけて輸送するので、豆へのダメージは避けられない。 昼は60℃、夜には20℃となったりして、湿気で劣化してしまう。
商社から豆を購入する一般のコーヒーチェーンなどでは、こういった輸送経路に対しては注文できないので、おいしいコーヒーを淹れるのには限界がある。 このあたりにこだわれるのがミカフェートの強みであると。
こういった話を聞くと、本当においしいコーヒーはどうしても高くついてしまうんだってことが分かりますね。 でもそういったこだわりを知ってこそ、本物を楽しめる。 知識を付けて、おいしいコーヒーを飲もう！
誰もやらないことをやろう！ 広告・宣伝にはふつうお金がかかるけど、誰もやらないことをやれば、勝手に記事にしてくれるので、自分で宣伝しなくてもよい。 コーヒーの話じゃないけど、商売の鉄則ですね。</description></item><item><title>読書メモ『世界でもっとも貧しい大統領 ホセ・ムヒカの言葉』佐藤美由紀</title><link>https://maku.blog/p/xqyuwm2/</link><pubDate>Mon, 12 Feb 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xqyuwm2/</guid><description>世界でもっとも貧しい大統領ホセ・ムヒカの言葉 佐藤美由紀 双葉社 物を買うときの基準 どんなモノやサービスを買うべきかは、次のように考えるとよい。
時間を奪うものではなく、自由な時間を増やすものであること 誰かを幸せにするものであること 発展と幸福 発展は、幸福を阻害するものであってはいけないのです。 発展は人類に幸福をもたらすものでなくてはなりません。 愛を育むこと、人間関係を築くこと、子供を育てること、友達を持つこと、そして必要最低限の物を持つこと。 発展は、これらをもたらすべきなのです。 幸福が私たちのもっとも大切なものだからです。
物と自由 もので溢れることが自由なのではなく、時間であふれることが自由なのです。 もし、少ししか物を持っていなければ、その物を守るための時間も少しで済みます。 物を持つことで人生を複雑にするより、私には、好きなことができる自由な時間の方が大切です。
自由な時間 自分の人生の時間を、好きなことに使っているときが、本当に自由なときなのです。 自分と家族の物質的な欲求を満たすために働く時間は自由ではないのです。
助けること、与えること 余裕のある人には弱者を助ける義務がある。 まずは自分の何かをあげること。どんなにボロクソな状態でも、必ず自分より悲惨な状態の人に何かをあげられます。 孤独は多分、死の次にもっとも悪いことです。</description></item><item><title>読書メモ『運命を変える 本物の言葉』桜井章一</title><link>https://maku.blog/p/y7ky8x2/</link><pubDate>Wed, 07 Feb 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/y7ky8x2/</guid><description> 運命を変える 本物の言葉 桜井章一 ゴマブックス はじめに 運がやってきたときに、瞬時にをそれを感じて、逃さないこと。 運は汚いことや卑怯なことを徹底的に嫌う。 運に好かれたいと思ったら、汚いことや卑怯なことは絶対にやってはいけない。 運は人間と似ている。運に好かれるということは、人に好かれ、自分自身に好かれる人間になるということ。 本物の言葉 （道）自分だけの「見えない道」を選んで、自分だけの何かを手にして欲しい。すでに誰かが歩んだ道は「見える道」、自ら切り開く道が「見えない道」だ。 （価値観）人生のベクトルを楽しみに向けていると、いい出会いがつくれるし、普段の心構えやその立ち居振る舞いが自然と運を呼び込む。 （運）姑息に価値を拾いに行く人よりも、キレイに負けることのできる度量を持った人の方へ、運の波は最終的に多く訪れる。 （現実）煩わしさも何もかも含めて、世の中の現実という波にうまく乗っていけばいい。 （責任）二者択一で、たとえ結果がマイナスに出ても、自分で選んだものは自分で責任をとる気持ちがあれば悔いは残らない。他人のせいにしたがる人は悔いが残る。ほかのものに責任転嫁したらラクになるというのは錯覚であり、自分の責任として真正面から本気で向き合った方がはるかにラクだ。そこから新たことを学べたりする。例えば、腕の骨を折れば、日常生活にはいろいろ支障をきたすが、その不自由さを体験して初めて気づくこともある。これまでできなかった体験をさせてくれる時間だと思えれば、落ち込むことも嘆く必要もない。 （感受性）本当の感受性とは、人が喜ぶことの「気づき」ができること。 （知恵）知恵は経験で身につけていくしかない。とにかく身体を動かしていろいろなことを体験していく。まわりの人たちが少しでも明るくなることを、楽しくなることを感じればいい。感じたら、瞬時に行動に移すこと。そうすれば、ズルさや雑念が入る余地はない。 （マニュアル）老舗にはモットーはあってもマニュアルはない。しっかりとしたモットーさえあれば、マニュアルはいらない。マニュアルに従っていると、人はだんだんと感じる力をなくしてしまう。 （数値）数字に価値を見出して数字を追っていくのに飽きたら、一度は目先を変えてみるのもいいかもしれない。 （従順）従順は怖い。一方的な押し付けでなく、常に考える機会を与えてくれる指導者が本物だ。 （慎重）いたずらに考える時間が長すぎると、往往にして的確な判断はできなくなる。後手にまわることで、最初にあったチャンスをどんどんつぶしてしまう。感じる力があれば、どの方向が正しいか瞬時に判断できる。「慎重に討議を重ねた結果」の決めごとは、それだけでダメだということ。本能で動くことに慣れれば、その判断も正確さを増していく。結果が出るまで待っていては、とうてい遅い。経過を見ながら自然に身体が動けば、心も身体も後悔しない。 （限界）肉体的には100％でも、精神的には80％だという感覚を持つことで、次回もより高いハードルに挑戦することができるようになる。 （リーダー）リーダーとは、個人の荷物を軽くして、そのぶん、公の荷物をたくさん背負う人です。 （目的意識）いまはみんな、目的意識に向かって結果を出すために、毎日を犠牲にしてつまらない過ごし方をしている。個人レベルの小さな損得にとらわれるのでなく、大地のようにゆったりとした気持ちで、いろいろな発見がある毎日の経過を楽しむほうが、よっぽどいい。 （手順）小さな変化を敏感にとらえられるようになると、次にどんな変化が訪れてくるのかを予測できる感性も養われてくる。 （常）どんな些細なことであれ、相手を不愉快にさせる原因をつくってしまったら、そのときは自分の負けだ。 （ストレス）ストレスを感じたら、まわりの人のことを気遣うこと。まわりの人のことを本気で気遣う気持ちがあれば、自分のストレスどころではなくなって、ストレスは消えてしまう。</description></item><item><title>2018-01-27 Coincheck が 580 億円の NEM 流出</title><link>https://maku.blog/p/zisgmqi/</link><pubDate>Sat, 27 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zisgmqi/</guid><description>ビットコイン取引所の Coincheck が時価総額 580 億円分の仮想通貨 NEM を流出し、仮想通貨市場に大きな衝撃が走りました。 結局、仮想通貨って理論的には安全と言われていても、人が介入する運用部分での人為的ミスは完全にはなくせないのですよね。 仮想通貨の取引所にお金を預けているということは、常にそれが 0 になるというリスクを抱えていることになります。 銀行のように 1000 万円までペイオフされる法制度が整えばマシになるのでしょうけど、現状を見る限り、当面そのような制度が作られることはないでしょう。
Abema TV で、23:30〜25:00 の緊急記者会見を見てました。 当初 30 分予定だったので、風呂に入りながら見ようと思ったけど、結局１時間くらい延長してのぼせました。。。
しかし、喧嘩腰な記者は何とかならないのですかね？ 質問をするのであれば、皆のためになる質問をしなければだめでしょう。 事実や今後の対応などを質問するのであればよいけど、答えられるはずない質問をして、単に攻めるだけの記者は質問をする資格などない。 そんなことを質問して無駄に時間をかけるくらいなら、早く記者会見を終しまいにして、対応に当たってもらった方が皆のためです。</description></item><item><title>読書メモ『勝率９割の選択 運に振りまわされず最善を選び、行動する方法』プロギャンブラーのぶき</title><link>https://maku.blog/p/j7habqw/</link><pubDate>Sat, 20 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j7habqw/</guid><description>勝率９割の選択 運に振りまわされず最善を選び、行動する方法 プロギャンブラーのぶき 総合法令出版 勝ちにこだわるな、勝つ準備にこだわれ 結果よりも過程にこだわるようにする。 勝負をする前の準備の方が大切。 自分で満足できるだけの準備をしていなければ、それが不安につながり、負けにつながる。
勝負をする前にひたすら勉強し、実力をつける。 それを続けて入れば、たとえ今回の勝負に負けたとしても、その後につながる。
３つの対人思考力 レベル１: 自分→自分の視点（自分の手だけを考える） レベル２: 自分→相手の視点（相手の手を考える） レベル３: 相手→自分の視点（相手から自分がどう見えているかを考える） プロはレベル３の視点を持たなければいけない。</description></item><item><title>2018-01-16 RIZAP 瀬戸健 社長の『失敗力』</title><link>https://maku.blog/p/xzpg8me/</link><pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xzpg8me/</guid><description>丸ビル７Ｆ丸ビルホールで RIZAP 社長の瀬戸健氏の『失敗力』という講演を聞いてきました。夕学五十講（せきがくごじゅっこう）という慶應丸の内シティキャンパス（慶應MCC）が主催する定例講演会のひとつです。とてもためになる話だったので、ざっと内容を書き残しておこうと思います。
瀬戸さんの経歴などは RIZAP 関連の雑誌記事やニュース記事などでよく読んでいたので、大体分かってたけれど、本人から話を聞くとやっぱり面白いですね。しゃべる能力に関してはすごい長けた人だと思います。RIZAP グループが数多くの M&amp;amp;A を成功させて急成長しているのも、この会話力あってこそなのでしょうね。
上場企業の社長さんの中には、学生時代にはあまり勉強ができなかったという人がたくさんいますが、瀬戸さんも同じように、高校時代の成績はビリに近かったみたいです（自身はあったのにほぼビリｗ）。先生に付けられたあだ名はセトキン（瀬戸菌）。ヒドイなｗ
高校生のときに彼女を年上の大学生に取られた後は、くやしさのあまり、死ぬほど勉強（三徹とか繰り返し）して明治大学に受かったとか。第一希望の早稲田には落ちてしまったけど、それまで必死に努力したことで、とても満足感があり、幸せだった。
こういった経験が、今の RIZAP の目標に達するまでのプロセスを重視するという精神につながっているんでしょうね。
大学時代の転機は、2、30歳年上の人に「瀬戸君は一般常識に欠けてるね」と言われたこと。確かにその通りだと思ったので、くやしくて、できることからやろうと思った。何かを達成するには「今できること」を一つずつやるしかない。そう思って最初の一歩は本屋さんに行って、勉強用の漫画を買った（活字は敷居が高すぎた）。次の一歩は、本を一日一回開くこと。本を読み始めるとすぐに寝てしまったけど、それでも毎日毎日繰り返していたらだんだんと読めるようになってきた。そして本をたくさん読んでいくうちに、「会社を作ることってそんなに難しくないんだ」ってことが分かって起業。RIZAP グループの社長をやっている今は、どんなに忙しくても一か月に 20～30 冊くらいは本を読んでいる。
起業した当初は、ユニクロで買ってきたシャツに目標を書いて、スーツの下に毎日来ていた。「26歳で会社を３社経営している」「28歳で上場企業の社長になっている」。動けない状態で病院に担ぎ込まれたときに、そのシャツを見られたときは恥ずかしかったとのことですが、実際に 28 歳に上場してます（起業して３年目）。目標を設定して、毎日それを見る、そこに向かって毎日１歩１歩進むことの大切さが分かりますね。すべての基本は「ゴール設定とアクション」。この積み重ねだけ。
一歩が踏み出せない人へのアドバイスは、強味だけを見て突き進むということ。SWOT 分析などでは弱みなども書きますが、「ない」ものは「ない」でしょうがないので、「ある」もの（強み）だけに注目して突き進まないとダメ。瀬戸さんも起業した当初は、実家がパン屋であるという強みを活かして、おからクッキーを売りまくったけど、経理とか流通とか全然わからなかった。でもなんとかなった。
強みを生かせばオッケー。
今はものすごい成長をし続けている RIZAP グループですが、瀬戸さんが 29 歳のときには事業で苦い体験をしています。ビリーズブートキャンプの大ヒットや、類似商品の出現で、おからクッキーの売り上げが不調になり、200 億円もあった会社の時価総額がわずか 7 億円にまで急落。従業員もどんどん辞めて、３分の１（80人→30人）にまで減った。自分の家も売り払った。ある朝、２人の社員が来て、「また辞めるのか」と思っていたら、「僕たちが社長を支えますから！」と言ってくれた。その一言で、社員のことを信じられなくなっていた自分に気が付き、目が覚めた。熱くなった。バカであるのはよいが、「社員を信じられない」バカにだけはなってはダメだと心に誓った。 そして、誰かの一言で人は変われるんだということに気付いた。
これが今の RIZAP の「人は変われる」というテーマになっていますね。
今の日本には、自分の可能性を信じて必死に努力をしている人は１％もいない。瀬戸社長のメッセージは、今はやりたいことをほとんどやれる時代になっている（海外で暮らすとか、昔は無理だった）ので、ものすごいチャンスな時代なんだということ。今やっていることが２、３年後の自分に確実に繋がっているので、ゴールを決めて、毎日のアクションを確実にこなせばよいのだということ。これがすべて。RIZAP もやっていることは極論すればこれだけ。
ただ、ゴールに到達するという１点だけが目標になるのはダメ。そこに向かってもがきながら進んでいくというプロセスが重要で、将来思い返したときの幸せにつながる。「悩み」があるということは、上を目指しているという証拠なのでよいこと。 悩みがある自分に自信を持てばいい！大変なことをひとつずつ乗り越えていくプロセスこそが宝物になるんだ！
おまけ Q&amp;amp;A Q. RIZAP トレーナーに何を教えているのか？ 1,000人以上いるトレーナーには、理念（原理・原則）を伝えている。テクニックを教えるという方法では絶対に破綻する。 テクニックは後からついてくるもので、皆が考え、工夫していくものだ。
Q. RIZAP が M&amp;amp;A した会社はなぜそんなに変われるのか？ 第一に、「お客様視点」で働けているかを見直すところから始めている。本当にこれができていない会社が多い。例えば、お客様のことを第一に考えずに営業をしている社員は苦しんでいる。そういったマインドが変われば会社全体が変わる。「やり方」については本を読めばすべて書いてある。本をたくさん読んでいる人がコンサルティングを受けても、「そんなことは知っている」と感じるだけだ。でも実際にはできてない。続けられない。大切なのは「やるべきことを続ける」ということ。
Q. RIZAP が M&amp;amp;A したくない会社は？ 経営者が本当に「変わりたい」という意思を持っていないところはダメ。話し合いで変わるように諭すんだけどね。</description></item><item><title>読書メモ『頭がいい人はなぜ、方眼ノートを使うのか？』高橋政史</title><link>https://maku.blog/p/zoqtqaj/</link><pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zoqtqaj/</guid><description>頭がいい人はなぜ、方眼ノートを使うのか？ 高橋政史 かんき出版 ポイント 書くことに億劫にならないためにも、紙質のよい、多少高価なノートを使うこと。方眼ノートにすればチャートなどもきれいに書けるので、それだけでモチベーションが上がる。 思考の基本は「事実に基づいて考えること」。外資系コンサルタントの思考がすぐれているのは、常に事実（ファクト）に基いて考えるから。 仕事ノートや、会議でホワイトボードを書くときは、「事実 (fact)」と「意見 (idea)」を明確に分けて書くとよい。 「事実（ファクト）」は、自分の目で見たことが一番確実。 方眼ノートは３つに分割して書く。左は「情報・事実・ファクト」、中央は「自分の気づき」、右に「要約・疑問点」。 文章力を向上させるには、ノートを「単語」ではなく「文章」で書き、その文章を読んだときに具体的なイメージが見えるように書くこと（これを著者は「見える！言葉」と呼んでいる）。 「見えない」言葉と「見える」言葉 ノートを記述するときは、その文章を見たときに、具体的にやることが「見える」ように記述する。
見えない (NG) 見える (Good) 検討する ３週間で実施判断の基準を作成する 共有する A4で１ページのフォーマットにまとめ参加者にメールする 見える化 論点を３つにまとめ、いつまでに、誰が、何をするか書く 浸透する 企業理念を１枚絵にして、社長が週１回その思いを語る 把握する 関係者にインタビューして問題点を３つ、アクションを１つにまとめる 意識する ハガキサイズの10項目リストを持ち歩き、９時、13時、18時にチェックする 感想 少なくとも、ノートや手帳に書き込むときは、事実と自分の意見を分けて書く ことに気をつけようと思った。 あと、日々文章力を鍛えるために、できるだけ伝わる 「文章」の形で、具体的に（固有名詞や数値を使って）書く ようにする。だからあまり小さな手帳は使わないようにしたい。</description></item><item><title>マネージメントに関して</title><link>https://maku.blog/p/29ss6t4/</link><pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/29ss6t4/</guid><description>マネージャーとマネジメントについて P.F.ドラッカー『マネジメント エッセンシャル版』より
変化の時こそ「基本」を確認。基本と原則に反するものは例外なく破たんする。 働く者が満足しても、仕事が生産的に行われなければ失敗である。仕事が生産的に行われても、人が生き生きと働けなければ失敗である。 マネージャーは権力を持たない。責任を持つだけである。その責任を果たすために権限を必要とする。 マネージャーの役割 投入した資源の総和より大きなものを生み出す生産性を創造すること。 あらゆる決定と行動において、直ちに必要とされているものと遠い将来に必要とされているものを調和させていくこと。 マネージャーの仕事 目標設定 組織化 動機付けとコミュニケーション 評価測定 人材開発 マネージャーにしてはいけない人 強みより弱みに目を向ける人 何が正しいかよりも誰が正しいかを重視する人 真摯さよりも頭のよさを重視する人 部下に脅威を感じさせる人 自らの仕事に高い基準を設定しない人 課題解決のステップ 現状把握: あるべき姿とのギャップを把握 目標設定: 何をいつまでに達成するか 原因分析: あるべき姿とのギャップの原因を明らかにする 仮説構築: 原因に対する仮設を立てる 計画 アクション ハックマントオールダムの職務特性モデル (Job Characteristics Model) ハックマンらは、職務への満足度を高め、動機付けに結びつく職務の特性を次の５つに分類しています。
Skill Variety（スキルの多様性） Task Identity（完結性） まとまりのあるタスクであること（全体のどの部分を担当しているのか分からないと不安になってしまうため） Significance（重要性） Autonomy（自律性） Feedback（フィードバック）</description></item><item><title>2018-01-01 ビットコインは投資でも何でもない</title><link>https://maku.blog/p/qfzhht4/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qfzhht4/</guid><description>2017年の年末はビットコインが盛り上がりましたね。1ビットコインが19000ドルを突破したとか何とか。
でもここにお金をつぎ込んでいる人はお金の使い方を考え直して欲しいと思います。
投資は本来は、将来成長していく事業などに先行して資金を投入していくもの。そこから生み出される付加価値があるこそ有意義なものです。でもビットコインにそのような価値はありません。
買う人がいるから上がる、それだけのチキンレースですね。売り抜けられた人はいいかもしれませんけど、その裏にそれだけの高値で買っている人がいるっていうことを忘れちゃいけません。FX と同じゼロサムゲームで、全体で見たら誰も儲かっておらず、付加価値を生み出してはいません。ブロックチェーンの社会的な実験をしたいのであれば、政府が発行する仮想通貨を使えばよいんです。
結局誰が得をするか？
それは売買手数料を稼いでいる金融業者と、売買で得られたお金に対して課税する政府です。売買を煽っているのは、そういった人たちの戦略ですからね。
本当に勝者になれるのは、ビットコインの購入者じゃないんだってことに早く気づきましょう。</description></item><item><title>2017-12-15 ROMEO ボールペン</title><link>https://maku.blog/p/f6pfj2j/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/f6pfj2j/</guid><description>ブックファーストに置いてあったちょっと高級そうなボールペンの試し書きをしてみたら、ヌルヌルサラサラで感動しました。
伊東屋が作っている ROMEO というボールペンらしいのですが、今まで味わったことないほどさらさら書けるボールペンでした。
試し書き用の紙も ROMEO のものだったので、紙の方にも原因があるのかなと思い、別の安そうな試し書き用の紙にも書いてみたらやっぱりヌルヌルサラサラ！
高級ボールペンをなめてました。買いたい物リストのトップテンに入りました。今年の自分へのクリスマスプレゼントはこれがいいかなー。高級といっても一万円以下で買えるので、すごく人気があるみたいです。
ペンは毎日使うものなので、本当に自分が満足するものを使いたいですね。</description></item><item><title>2017-11-14 為末大さん講演会</title><link>https://maku.blog/p/oae44u5/</link><pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oae44u5/</guid><description>元陸上選手の為末大さんのお話を聞いてきましたので φ(・ｪ・o) メモメモ。
最近は、どうしたら人が活力を持てるか？ 人間を理解することをテーマとして活動しておられるようです。
自分を理解する 気付いたのは、人間は個々の能力よりも、どんな環境 (ホットスポット) に身を置くかで発揮できるパフォーマンスが大きく変化するということ。
本来の自分を変えようとすると、変えられないので苦しむだけ。 例えば、几帳面な性格を根底から変えるのは難しい。 そうじゃなくて、変えられるもの（トレーニングのやり方など）に着目すべき。
自分らしさとは何か？ それを知るには、いろんなタイプの人にたくさん出会うしかない。
「夢」ではなく「やりたいこと」を考える ×「あなたの夢は何ですか？」 ○「あなたのやりたい事は何ですか？」 夢＝職業ではない。
職業は手段でしかないので、本当にやりたいこと、成し遂げたいことにフォーカスすべき。 例えば、「ケーキ屋さんになりたい」という夢を持つのはいいけれど、本当にやりたいこと、達成したいことはケーキ屋さんになるということではなく、おいしいケーキをお母さんに作ってあげて、「お母さんを笑顔にする」ということのはず。 そういった、本当の目的をちゃんと認識しないといけない。
「夢中」と「俯瞰」 人が活動するときは、「夢中／没頭」状態で動いているときと、「俯瞰／客観」状態で動いているときがある。 ただし、これらを同時にこなすことはできない。 夢中で没頭する時間は重要なので、それを続けた後で俯瞰する、というサイクルを意識的に繰り返すことが大切。</description></item><item><title>2017-11-03 Realforce キーボードを静音化</title><link>https://maku.blog/p/bzto4ey/</link><pubDate>Fri, 03 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bzto4ey/</guid><description>10年くらい前に買った東プレの Realforce を静音化してみました（このサイトを参考にさせていただきました）。
使用頻度の低いファンクションキーや、Home、End キーなどはあえて静音化せずにそのままにしてあります。そうすることで、いつでも静音化の効果を楽しめるようにしてます（笑）。下の動画で、ファンクションキーと、アルファベットキーの音の違いを聞いてみてください。
もともと Realforce は会社でも使えるくらい打鍵音の小さいキーボードですが、静音化してみると、ノーマルな Realforce の音がどれだけうるさかったが実感できます。
静音化はキーボードを分解してキーひとつずつに薄い布を挟んでいくのですが、キーを離した時に当たる部分に挟むのがポイントですね（押し下げた時に当たる部分ではない）。下の写真の、隙間から見えている赤い布がそれです。
キートップの洗濯のついでに静音化しようと、軽い気持ちで始めたのですが、はっきりいってめちゃんこ大変でした。まぁでも毎日使うものなので結果には満足してます。</description></item><item><title>読書メモ『人工知能が金融を支配する日』櫻井豊</title><link>https://maku.blog/p/pr4eox9/</link><pubDate>Tue, 19 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pr4eox9/</guid><description> 人工知能が金融を支配する日 櫻井豊 東洋経済 タイトルに「金融」とありますが、さまざまな人工知能について幅広く解説するような内容になっています。 世界中の金融業界がテクノロジーを駆使して歴史的な転換期に対応してきているのに対し、日本の金融業界がひどく遅れていることを指摘し、その打開策などについて述べています。 強力な人工知能が金融を支配しまった世界を想像すると本当に恐ろしいし、もしかするとそちらの方向にすでに進みつつあるのかもしれません。 間違いなく言えるのは、これからの日本の金融業界には、技術知識の豊富な人が必要不可欠であるということ。 ただし、現状の日本の金融業界にはそのような体制は作れないということ。。。
メモ 金融業の多くの非単純労働はロボット化される。 ビッグデータ時代の分析では、個人の信用リスクを リアルタイムにモニター できる。 LTCM はあっけなく崩壊したが、バリューに注目した投資スタイルはファンドに取り入れられた。LTCM の失敗はレラティブ・バリューという戦略自体の失敗ではなく、レバレッジのかけすぎや、本来のスタイルに反するようなポジションを取った結果であると判断したからだ。 世界中の銀行を監視する立場にある BIS も、レポートの中でビッグデータの活用に関して言及している。 日本のフィンテックは便利な機能止まりだ。 重要な本業に人工知能やビッグデータを活用することについてひどく遅れている。 ヘッジファンドというビジネスモデルが日本ではマイナーなであることも影響している。 戦後の護送船団方式による金融政策により、イノベーション能力が衰退した（アメリカと対照的）。 日本のトレーディングは経験と勘の比重が高すぎる。アメリカなどでは、数学・統計・テクノロジーを中心にしたクオンツ・トレーディングが優勢になっている。 東京の FX 市場も海外のロボトレーダーにシェアを奪われている。 重要なのは破壊的なテクノロジーを独占させないこと。 ディープマインドのようにオープンなスタンスを持ち続けないといけない。 これからの日本がやるべきこと 世界に負けないレベルの独自のテクノロジーを作り上げ、できるだけ 公共の目的で使用 すること。 既存の金融機関の利害関係を超越した体制を作ること。例えば、「業界横断的な組織」や「政府主導の組織」で研究を進めるのがよい。</description></item><item><title>2017-09-17 Netflix のベーシックプランとスタンダードプランの画質比較</title><link>https://maku.blog/p/ao6pgrk/</link><pubDate>Sun, 17 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ao6pgrk/</guid><description>Netflix はベーシックプラン（月650円）で契約してたんですが、毎日使っているのでスタンダードプラン（月950円）でもいいかなぁと思ってアップグレードしました。 SD 画質から HD 画質になるのでちょっと比較。
ベーシック（SD 画質） スタンダード（HD 画質） うーん、、写真だとわかりにくいですね（＾＾；
Full HD 画質の方は、DEATH NOTE の文字がくっきりしてます。
上の写真は Sony のテレビで表示したものですが、ノート PC でアニメを表示した場合の比較もキャプチャしておきます。
ベーシック（SD 画質） スタンダード（HD 画質） アニメの場合はさらに差が分かりにくい！
正直なところ SD 画質でも普通に楽しむことはできるんですが、300 円で上質な画質で楽しめるようになるのであれば、安いものですね。最初から Full HD のプランにしておけばよかったー。</description></item><item><title>2017-08-23 株式を家族間で移管</title><link>https://maku.blog/p/7bs74j9/</link><pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7bs74j9/</guid><description>SBI 証券証券口座にある株式を家族の証券口座に移管する申し込みをしてみました。
別の人の証券口座に株式を移す場合は「異名義移管」という扱いになって、サポートセンターに電話をしなければいけないようです。
SBI証券 ホーム &amp;gt; サービス案内 &amp;gt; 贈与等による異名義移管のお手続き 電話をしてお願いすると、いろいろ注意事項などを教えてくれて、２、３日で申し込み書類が送られてきます。一枚の書類に、移管銘柄は５つまでしか記入できないので、移管予定の銘柄数を伝えておく必要がありあす。
今回申し込んだ移管は、「本人のSBI証券特定口座」⇒「家族のSBI証券特定口座」という口座間の株式移管です。電話で注意事項をいろいろ説明してくれましたのでポイントをメモ。
移管先に「銘柄A」が既に存在する場合、移管元の「銘柄A」の部分移管はできない（移管元の「銘柄A」をすべて移動させることは可能）。 贈与税に関しては、詳しくは税務署に問い合わせてくださいとのこと。ただ、一般的には贈与金額は、移管実行日の終値や、前月の平均評価額、前々月の平均評価額を用いられることが多いとのこと。 部分移管に制約があることは初めて知りました。ちなみに、各銘柄の月ごとの平均終値は、東証の月間相場表のページで調べられます。贈与税の計算などが必要な場合は確認してみてください。
追記 (2017-08-25): こんな申し込み書類が届きました。住所とか全部手書きで書かないといけないんですね。もっとユーザにやさしい仕組みにしてくれればいいのになぁ。。。
図: 相続上場株式等 移管依頼書 図: 贈与届（兼 移管依頼書 及び 委任状） 図: 贈与契約書</description></item><item><title>読書メモ『１分間勉強法』石井貴士</title><link>https://maku.blog/p/w5w4375/</link><pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w5w4375/</guid><description>本当に頭がよくなる 1 分間勉強法 石井 貴士 KADOKAWA/中経出版 2014-03-27 効率的な勉強法について、**タイム・マジック（時間短縮の魔法）とカラー・マジック（右脳の魔法）**という２つの方法でまとめています。 気分転換のつもりで読んでみたけれど、書くという行為がいかに時間的に無駄かということや、右脳に働きかけるために色を使うべきだという意見は参考になりました。
タイムマジック 中心になっているのは１分間で本をリーディングするいう話ですね。 読むのではなくて、感覚で重要だと思うところを潜在意識で拾っていくという感じ。 Reading ではなくて Leading。 潜在意識に浸透させるために、できて当然だと思ってから読むということが大切らしい。 勉強法に限らず、**自分はできる！**と思って行動することは確かに重要ですね。
最初は左手でページをサクサクめくっていくということをとにかくやる。 読んでいないから分からない、という状況になるけど、それがまさに読まずに見ているという証拠なので、最初はそう感じるのが正解らしいです。 なるほどなるほど。 そう言われるとしばらく特訓してみようって気になりますね。 ちなみに左手でページをめくるというのも、イメージを捉える右脳を活性化させるためになるべく左手を動かすという理由からきています。
英単語を勉強するときは、1分で1単語を覚えるのではなく、1秒で1単語×60というジャブを繰り返すのが有効。 英単語を書くという行為は時間がかかるのでやってはいけない。 世の中でもっとも速いのは光なのだから、それを捉える視覚に特化して勉強するのが最強最速。 なるほど完璧な理論だ（＾＾）
専門家になるには、図書館にいってその分野の本を200冊読むのが手っ取り早い。 確かに１分で１冊読めるのであれば、そのくらいの勢いで知識をつけるのが早いですね。 知識をつけるためだけに学校に通うのはとても非効率。 自己満足に陥りやすい。
カラー・マジック 右脳は映像をつかさどっているので、色に反応する。 なので、記憶するときには色鮮やかなものを使った方がよい。 例えば、黒ペンじゃなくて、青ペンを使う。白い紙じゃなくて、色のついた紙（赤、緑、黄、青）を使う。
どこまで効果があるかは分からないけれど、色のついた製品を使うことくらいは簡単にできるので、試してみる価値はありますね。 ちなみに、色をたくさん使いすぎるのも逆に時間がかかって効率が悪いので、赤、緑、黄、青の４色に限定して重要度別に情報をまとめるのがよいようです。
本を読んだら、１ページくらいで色分けしてまとめておく（カラー・マジック・シート）。 これはあとから１秒で復習できる。 このシートが溜まって来たら、今度はシートを赤、緑、黄、青のクリアファイルにまとめておく。 赤のクリアファイルは常に持ち歩いて、各シート１秒で何度も復習することでバッチリ覚えることができる。</description></item><item><title>2017-08-07 シェアリングエコノミーの弊害</title><link>https://maku.blog/p/hy8ppr7/</link><pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hy8ppr7/</guid><description>自転車大国のオランダで、シェア自転車の撤去が始まるようです。世界的にもシェアリングシティとして有名なオランダがこのような対応を迫られることになったという事実は、モノにあふれる世の中が今後どのような方向に向かっていくべきかのヒントになりそうです。
シェアリングエコノミーの発想としては、自分の占有時間が限られているモノをシェアすることで、時間、空間などを効率的に利用しようというものです。シェア自転車の場合は、自転車を共有して交通の混雑をなくそうという発想ですが、もともと自転車の保有率が高いオランダでは、シェア自転車が入ることで余計に街が混雑してしまったとか。
昔ながらの発想で、既存のモノをシェアするだけであればこういった事態にはならなかったでしょう。たとえば、隣の家に工具を借りるとか、ある作業を得意な人に手伝ってもらうとか、そういったシェアは世の中の人を幸せにするシェアです。
でも、今回のケースでは、すでに皆が自転車を持っているのに、営利目的の企業がさらにシェア自転車を追加で投入することによって街に自転車があふれてしまった。企業がシェア用のモノを投入するのであれば、既存のモノとどう共存させていくのかを含めて考えていく責任を負うべきです。シェア自転車であれば、既存の自転車を回収する代わりにシェア自転車を使用する権利を提供するとか、街中の自転車量をモニタリングして適切な量だけ展開していくとか、そういったことも含めて考えないといけません。
シェアリングという概念が今後広まっていくことは確実で、それは自然なことなのだろうと思っています。 人がモノを自分の近くに置いておきたいのは、「自分が時間的、距離的にすぐに使えるもの」を確保したいといった欲求からであって、インターネットによるコミュニケーションや物流が発展するに従い、モノを所有することの必要性は減っていきます。 所有物を減らすことでストレスから解放され、逆に安心感を得るというスタイルが広まってきているのもうなずけますし、自分もそうありたいと思うようになってきました（年を取ったのかな？）。
シェアリングビジネスを考えるときは、利益を上げることも大切だけど、シェアによって作り出される幸せな世界がどんなものかを第一に考えるようにしたいですね。</description></item><item><title>2017-07-29 都会の中のオアシス「等々力渓谷」に行って見た</title><link>https://maku.blog/p/th8co6e/</link><pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/th8co6e/</guid><description>大井町線の等々力駅を降りて徒歩５分の等々力渓谷で散歩。
都会の中の渓谷なのでそんなに大きくはないけど、みんな涼みに来てますね。途中で一軒だけお茶するところがありました。二子玉川や自由が丘に行くついでに寄り道してみるのもよいかもしれません。</description></item><item><title>2017-07-20 インデックス投資家 梅屋敷商店街のランダム・ウォーカー</title><link>https://maku.blog/p/n4z4k6d/</link><pubDate>Thu, 20 Jul 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n4z4k6d/</guid><description>梅屋敷商店街のランダム・ウォーカーの水瀬ケンイチさんのお話を聞いてきました。
10 年以上インデックス投資を続けてきためずらしい方です。 もともとはデイトレーダーだったらしいですが、投資以外のことが忙しくてインデックスに乗り換えたとのこと。
趣味など他にやりたいことがいろいろあるのに、投資に時間を割くというのは本質的に間違っているという意見はハッとさせられるものがありますね。 投資を始めてしばらくすると、テクニカル分析やファンダメンタル分析が楽しくなってきます。 それはそれでよいのですけど、本当にやりたいことは投資じゃなくて、別のことでしょ？ってことを忘れないようにしなきゃですね。
水瀬さんがやっているインデックス投資の手順は、ごく一般的なこんな感じ。
２年分の生活費は確保 リスク許容度の把握 資産配分の決定（アセットアロケーション） 投資商品の決定 積み立てとリバランスを繰り返す アセットアロケーションは、配分自体が大切なのではなく、その組み合わせによって「期待リターン」と「リスク（ボラティリティ）」が何パーセントになるのかが重要。 例えば、期待リターンが +4.4% で、リスクが 13.6% であれば、一年後の資産は 68% の確率で、+18.0%〜-9.2% の範囲に収まる（１標準偏差）。 95% の確率で、+31.%〜-22.8% の範囲に収まる（２標準偏差）。
インデックス投資で「株式」に投資すべきだという結論は、過去の歴史から導かれてます。1801年からの200年で、金融商品の価格は次のように変化しています（インフレ率も考慮）。
現金 ・・・ 0.07倍 金 ・・・ 0.98倍 国際 ・・・ 952倍 株 ・・・ 60万倍 なんだかんだ言っても、資本主義経済は拡大再生産し続ける仕組みで回っているのだから、株式の価格は上昇し続けるという結論に至ったとのこと。
しかし、こうして比較してみると、現金で資産をずっと持っていることがものすごく損だということがよくわかりますね。すぐに使えるという意味では現金は最強なのかもしれないですけど、仮想通貨や IoT を利用した決済手段が主流になれば、現金の利点はどんどん減っていくのでしょう。
10 年以上インデックス投資を続けているとなると、リーマンショックや東日本大震災、ギリシャショック、チャイナショックなどをもろに食らっているわけですが、結局は2〜3 年程度で回復するため、収支は数十パーセントのプラスになっているようです。大ダメージを受けても撤退せず、10 年以上たんたんと積み立てを続けている人の話には説得力があります。
ちなみに、インデックス投資では、積み立て時に定額で購入し続けるドルコスト平均法が有名ですが、売りの出口戦略としては、定額ではなくて定率で少しずつ売っていくようにすれば価格変動の影響を減らすことができるとのこと。 例えば、老後に株資産の 5％ ずつを少しずつ売っていくようにすれば、株価が高い時にはたくさんの現金になり、株価が低い時には少量の現金になります（割安なときに株をたくさん売ってしまうのを防ぐことができる）。</description></item><item><title>2017-07-18 ゼロから生み出す力</title><link>https://maku.blog/p/e94pu2w/</link><pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e94pu2w/</guid><description>幸せに生きていくために必要なことってなんだろう？ 幸せの定義は人それぞれなのだから、必要なものも人それぞれで、ひとことで定義するのは難しいのかもしれません。でもあえて言えば、それはきっと自分の価値観を持って、それに従って生きるということ。自分にとっての幸せが何なのかをちゃんと考えて、そこを目指して進んでいくこと。
最近よく考えるのは、逆説的だけど、不安はどうすれば減らせるのかということです。不安を取り除いていけば、幸せな状態が残るはず。そんな考え方でもいいのかもしれません。
ちきりんさんが、著書『未来の働き方を考えよう』の中で、**「ストック型よりもフロー型が重要」**といっています。例えば、いくら貯金（ストック）を持っていても不安は尽きないけれど、稼ぐ力（フローを得る力）があれば、安楽に構えていることができる。
もっともですよね。今お金をたくさん持っていたとしても、元になったのが親から受け継いだ遺産や、宝くじで当たった大金だったとしたら、何らかの突発的な事故で失ってしまう可能性を考えると不安は消えません。でも、ゼロから稼ぐ力があれば、何が起きても大丈夫だという自身が持て、不安からは解消されるでしょう。
あるお金持ちがこう言っています。**「本当のお金持ちというのは、一億円持っている人ではなくて、一億円を稼ぐ力を持っている人のこと」**だと。みんな考えていることは同じですね。
企業の財務諸表であれば、バランスシート（現在の資産）ではなく、キャッシュフロー（稼ぐ力）の方が未来の成長のためには重要だと言うこと。
だから、幸せに生きるためには、「今何かを得ること」というよりは、「何かを得る力をつける」ということを考えて生きていくのがいいんだと思います。「稼ぐことではなくて、稼ぐ力をつけること」、**「人との繋がりをつくるのではなくて、人との繋がりをつくる力をつけること」**を考えよう。</description></item><item><title>2017-07-07 多くの人に動いてもらうにはインセンティブを与える</title><link>https://maku.blog/p/in9us4k/</link><pubDate>Fri, 07 Jul 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/in9us4k/</guid><description>大きな組織で働いていると、ときには何百人もの人を対象に指示・お願いをしなければいけないことがあります。
そういったときに、皆に確実に動いてもらうためには、何らかのインセンティブを与えるのが効果的です。例えば、ある作業をお願いする場合、
７月７日までに必ず完了するようにしてください と指示するだけでは多くの人に動いてもらうことはできません（３割くらいは動いてくれるかもしれません）。その後、進捗が思わしくないときには、次のような催促のメールを送りたくなるかもしれません。
期日までに終わらない場合は、定例ミーティングでその理由を報告してください このような指示は、動いてくれなかった人に罰則を与えているだけで、もともと達成したかった「期日までに終わらせる」という本質的な目的からずれてしまっています。 もちろん、罰則やルールで縛ることによって、人はある程度動いてくれるようになります。 しかし、同じ組織の仲間たちに罰則を与え、作業を強制させるというやり方はあまり気持ちのよいものではありません。
こんなときは、作業を進めることによって、何らかのメリットを得られるというインセンティブを与えられないかを考慮するとよいです。 例えば、
先に作業を完了したメンバから優先的に ～ を利用して構いません とか、
７月７日までに到着したデータは、こちらでまとめて登録します など、作業を早く終わらせることによって得られるメリットをいっしょに提示してあげると、皆のモチベーションは確実に上がります。 いっしょに提示するメリットが思いつかないという場合は、私がいつも使っている裏技があります。それは、「罰則を反対向きに提示してインセンティブとする」という方法です。例えば、
登録が７月７日に間に合わなかった場合は、登録後に全メンバに内容を報告してください という罰則がある場合、最初から次のようにお願いするのです。
登録後は全メンバに内容を報告してください。ただし、７月７日までに登録していただいた分に関しては、報告を免除します この２つ、実はお願いしていることはまったく同じです。 でも、ちょっと視点を変えてお願いするだけで、人を動かせるかどうかが変わってきます。</description></item><item><title>2017-07-03 図書館を利用して読書のペースを上げる</title><link>https://maku.blog/p/uy6nsvq/</link><pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uy6nsvq/</guid><description>読書量を増やそうとして本をたくさん本は買ったものはいいものの、積ん読ばかりが増えてしまう、という人は、図書館を活用してみるのがいいかもしれません。
自分で買った本は、自分の手元にずっと置いておけるため、いずれ読めばいいやと積ん読になりがちです。でも、図書館で借りた本は二週間で返さなければいけないので、例えば４冊借りてくれば、二週間で４冊読む、というペースが作れます。
図書館には新刊は少ないかもしれませんが、まずは読書のペースを掴むことが大切。今ではネットで蔵書を検索できるところも多いので、興味のありそうな本はたくさん見つけられるはずです。
一般的な書店での本の並べ方に慣れていると、50音順に整列されている図書館では、目的の本を見つけにくいかもしれません。図書館を活用するコツは検索システムを使って本を探すことです（館内の端末や、インターネットで）。
図書館は本を返却するのが面倒という人もいますが、区内の図書館であればどこの図書館でも返却できたり、夜間の返却ポストもあったりして、意外と気軽に利用できます。
今度のお休みは近くの図書館にでも行って、普段は読まないような本でも借りてみたらどうでしょうか。</description></item><item><title>2017-06-30 企業の成長には A/B テストの考え方が必要</title><link>https://maku.blog/p/7girbw9/</link><pubDate>Fri, 30 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7girbw9/</guid><description>ソフトウェア開発の世界では、A/B テストという改善手法が主流になってきています。 複数のデザインのアプリケーションをランダムに配信することで、どちらの方が効果が高いかを実際の顧客行動から導き出すというもの。
オバマさんの選挙キャンペーンでは、寄付金サイトの改善を A/B テストで繰り返すことによって、最終的に寄付金のコンバージョンレートを 49 ％向上させたらしいです（ようするに、失敗しない方法で、どんどん寄付する人してくれる人を増やし、最大限に寄付金を集めることができたということ）。
これって、考え方自体は普通のビジネスで昔からやっていることと同じですよね。どの改善案がお客様にとって受け入れられるのか、より利益を出すことができるのかを考えて実行していく。事業を大きくしていくというのは、このように改善方法を考えて、繰り返し適用していくことなので。
ソフトウェアの世界では、このような改善がよりシステマチックにできるようになってきたというだけのこと。顧客がどういった経路で商品の購入に至ったのか、どのあたりの情報を時間をかけて読んでいるのか、といった生の顧客データをリアルタイムに取得することができるので、本当に効果的な改善かどうかを確認したうえで大規模に展開していける。
一か八かでサービスをリニューアルする、という手法では企業は生き残れなくなってきています。顧客の購買行動などをダイレクトに改善につなげる A/B テストの考え方が必要。こういった効果的な改善を続けて行っている企業は強いです。A/B テストで明確な指標を設定して事業展開している企業は、戦略的撤退も迅速かつ的確です。
野口竜司さんの「A/B テストの教科書」は、A/B テストの考え方や進め方が体系的にまとまっていてわかりやすいですね。
パッと見では、主に Web サイトの改善にフォーカスしているように見えますが、A/B テストの思想的な部分もわかりやすく説明されているので、何らかの「改善活動」を行おうと思っている人には参考になると思います。
軽くポイントをメモしておきます。
A/B テストによる改善は、大体こんな流れで進めていきます。
(1) 課題の発見と管理 まずは、改善すべき個所（課題）を見つけるための調査を行います。アクセス解析データや、ユーザビリティテスト、アンケートなどで調査します。ここで、「大きな課題」を見つけられば、A/B テストによる改善のポテンシャル（リターン）も大きくなります。
「課題・仮説シート」の作成: 調査データとそこから導き出される課題を記入していきます。A/B テストによる改善は、継続的に行っていくものなので、課題はリスト化して管理しておきます。 「KPI マップ」の作成: 実際のアクセス解析データから KPI マップを作ると、テストのゴール設定（改善したい指標）や、改善効果の確認がやりやすくなります。ユーザがどの場所で離脱しているのか、ある経路の購入率はいくつかなどを一目で分かるようにフローチャートなどで図示します。KPI マップは月単位くらいで更新するのが理想です。KPI マップを利用して、重要視する指標（改善したい指標）を絞り込み、テストのターゲット（ゴール）とします。 (2) テスト計画と具体案の作成（改善仮説の設定） テスト計画では、今回改善対象とする箇所を決めていきます。
テストする場所の決定: 課題リストや KPI マップをもとに、どこをテストするのかを決定します。 テスト KPI の設定: KPI マップなどをもとにして、テストによって改善すべき「テスト KPI」を設定します。１つの最重要指標（購入完了率など）といくつかのサブ指標を設定し、効果を定量的に測れるようにします。 テスト仮説（案）の作成: どうすれば改善できるのかを「テスト仮説（案）」として洗い出していきます。テスト仮説がたくさんある場合は、最重要指標をルートとする「仮説ツリー」を作り、グルーピングします。 テスト様式の決定: どんな種類のテストを行うのか決めます。テストにかかる工数や期間に影響します。 テストロードマップの決定: どの時期に、どれくらいテストを行うのか決めます。 大枠のテスト計画が決まったら、具体的なテスト案（異なる表示パターンなど）を作成します。テストを繰り返すことを前提にし、「次のラウンドのテスト案」も作成しておくのが改善をスムーズに進めるコツです。
ワイヤーフレームの作成: テスト案と、どのような構成にするかのワイヤフレームを作成します。 クリエイティブの作成: A/B テスト用の、具体的なデザイン、コピーなどを作成します。ここで作成するものをクリエイティブと呼び、A/B テストではこのクリエイティブを切り替えてテストを行います。どの変更がどのような影響を与えるかを明確にするため、「１つのバリエーションで１つの仮説」だけを対象とするように注意して作成します。用意するクリエイティブのバリエーション数は、テストごとに３～５種類くらいが平均的です（A と B の２種類じゃないよ）。 スクリプトの作成: テストパターンにおいて JavaScript などで動的な制御が必要な場合は、クリエイティブの作成と同様にここで作成します。 (3) A/B テストツールの組み込みと実行 タグの設定: Web サイトであれば、A/B テストツールが発行するタグをページ内に組み込んで、アクセスを追跡できるようにします。独自形式のアプリケーションであれば、アクセスを追跡するための独自の仕組みが必要になるかもしれません。 テストパターン組み込み: テスト用に複数用意したクリエイティブを組み込み、A/B テストツールを利用して、ランダムにアクセスが発生するように設定します。独自形式のアプリケーションであれば、クリエイティブの切り替え処理のための独自の仕組みが必要になるかもしれません。 計測設定: A/B テストツールでは、ゴール設定を行うことで、成果を自動計測できます（例えば、購入完了のページをゴールとする）。 配信設定: 配信対象のユーザや端末を設定します。 動作検証: 本番環境でのテストの前に、正しく動作するかの検証を行います。 テスト開始: 本番環境でテストを開始し、モニタリングを行います。 (4) 結果分析と本番環境への反映 テスト結果の分析: テスト結果のデータを取得し、その原因を分析します。セグメント別の解析や、Google Analytics などによる解析結果を利用し、分析結果のサマリー文書を作成します。 本番環境への反映: テストで改善効果の高かったパターンを、本番サイトに適用します。 次のテスト立案: 分析結果のサマリーをもとに、次ラウンドのテスト計画へ進みます。</description></item><item><title>2017-06-29 情報収集の前に意思決定プロセスを決める</title><link>https://maku.blog/p/xcvvkie/</link><pubDate>Thu, 29 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xcvvkie/</guid><description>ちきりんさんの「自分のアタマで考えよう」より。
意思決定プロセスが明確になる前に、やみくもに情報収集を始めても、時間ばかりがすぎて何も決まらないという指摘。ふわっとしたプロジェクトではありがちな話でドキッとしました。
意思決定の判断基準が明確になっていれば、そのために必要な情報だけを集中して集めればよいので、無駄に情報収集に時間をかけてしまうのを防ぐことができます。情報の探しやすさも上がるでしょう。
情報収集という作業自体は、何のために情報を集めているのかが何となく分かっていれば始められてしまいます。でもそれだと、どれだけ情報を集めればよいか明確ではなくて、延々と情報収集に嵌ってしまう。そうではなく、意思決定プロセスがこうなっているから、その決定のために必要なこんな情報を集める、とちゃんと意識するようにすれば仕事の効率は上がりそうです。</description></item><item><title>2017-06-23 IPO 銘柄に値段がつかない</title><link>https://maku.blog/p/poesfyd/</link><pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/poesfyd/</guid><description>当選すれば必ず儲かるという伝説の IPO 銘柄（新規上場銘柄の株）についに当選しました！
同僚が。 いろんな証券会社で２年くらい申し込み続けてやっとゲットしたらしいです。 ディーエムソリューションズ (6549) というダイレクトメール事業などを行っている会社で、上場日は値段がつきませんでした。
あれ？
成行の売りが入っているのにどうして少しも売買成立しないの？ たしかに。
普通は少しでも成行売りが入っていたら、引け後（15:00）には必ず売買成立するのになんでだろうと思って調べてみたら、新規上場後の初値だけは、売り数と買い数が完全に一致するまで値段がつかないみたいですね。
だから、買いたい人がたくさんいれば、値段がつかず、次の日に持ち越されると。 初値で確実に売りたければ、成行売りを入れておけば OK ってことですね。
（結局、２日目に初値がついて、公募価格の約３倍になったみたいです。うらやましー）</description></item><item><title>2017-06-19 ゆるく考えよう</title><link>https://maku.blog/p/7pd9985/</link><pubDate>Mon, 19 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7pd9985/</guid><description>ちきりんさんの『「自分メディア」はこう作る！』という本がおもしろかったので、最初の著書である『ゆるく考えよう』も読んでみました。
外資系企業で働いてきた彼女が達した境地は、
自由に生きる、楽観的に生きる ということ。バリバリ働いてきた彼女だから、資産などに余裕があるっていう面もあると思うけど、幸せな人生を過ごすにはこういう考えをベースにして生きていくって大切ですよね。
自由に生きるといっても、何も考えずに過ごすのではなくて、ちきりんさんは**「インプットとアウトプット」のバランス**を重視してます。英語を勉強するときも、自分にどんなアウトプットが必要なのかを考えて、インプットの量を考えているから、無駄に勉強する必要がないし、その分だけ自由に生きることができる。アウトプットに必要なインプットがあればいい。
人生って結局、有限な時間をどのように使うかですよね。だから、その時間をどう過ごすのかを考えることは本当に大切なことだと思います。趣味のために時間を使うのか、仕事に没頭するのか、家族といっしょに過ごすのか。それをちゃんと考えた上で、有意義なものだと思えば、のんびり過ごすのは全然問題ない。ちきりんさんは逆に、「いつも予定が入っていることがいいこと」と考える人は下品だと切り捨ててます。さすがです。
これを読んで、ユダヤ人は休日は徹底して働かないという話を思い出しました。安息日である土曜日（シャバット）は、料理もせず、遠出もせず、とにかく休んで家族と過ごす。よりよく生きるということを追求すると、働かないで過ごす時間をいかに確保するかってとこに行き着くのかもしれないですね。
ちなみに、わたしたちは１週間が７日というのを常識だと思って暮らしていますが、もともとこの週７日という概念を作り上げたのもユダヤ人です。この週という概念がなければ、わたしたちは毎日毎日働きづめだったかもしれません。時間をどのように使うかの指針を与えてくれるこの発明は、自動車の発明よりも、インターネットの発明よりもすごいと思いませんか？
「働かない生活」を選んだちきりんさんですけど、別にバリバリ働く生活を否定しているわけではないんですよね。もし、今の仕事が本当に楽しくて楽しくてしょうがない、とても価値のあることだ、というのであれば、仕事に人生のほとんどの時間を割いてしまってもよいんじゃないかな、と思います。でもまくは、やっぱりある程度は余裕を持って生きていきたいなぁ。
というわけで、まくのブログも、ゆるゆるな感じにしていこうと思います。</description></item><item><title>2017-06-18 ブログで日記を書くときに気をつけること</title><link>https://maku.blog/p/z5xn5b5/</link><pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z5xn5b5/</guid><description>ちきりんさんの書籍を読んで、日記を書くときに気をつけること、ブログの価値を上げるために大切なことをまとめてみました。
日付は目立つようにレイアウトすること。 URL にも日付を含んでいると後々わかりやすい。 独自ドメインにこだわらない。内容で信用度を上げることの方が大切。 サイトの第一印象を上げたいのであれば、トップの部分（スクロールせずに表示される部分）には広告を入れない方がいい。 いきなり読者を集めようとしない。ブログが未熟なうちに読者を集めようとするより、おもしろい記事がたくさん集まったあとで、ブログを見つけてもらった方がいい。 特定の人を傷つけるようなこと、批判するようなことを書かない。そんなブログは質が高いとはいえない。実際にその人たちに会うことになったときのことを考える。 新しいコンテンツは必ず自分のサイトに載せる。ビジネスサイトからの依頼で記事をそちらに書くということをしていると、自分のメディアの価値が下がってしまう。転載を許可するような場合は、掲載期間をつけるのがよい。 ディスる、オワコン、ステマといったネットの中の人だけが使う言葉を使わない。 ネットの世界で話題になっていることを、世間一般で話題になっていると勘違いしない。 コメント欄があることでサイトの質が下がってしまうのであればコメント欄は外す（スパムとか広告とか投稿されるような場合）。 言われてみればもっともな感じですけど、小手先のテクニックで読者を集めようとしたり、収益を得ようとしたりしてしまいがちですよね。アクセスを稼ぐために、派手なタイトル（「○○するために必要な 10 のコト」みたいな）を付けるのも、本質的なブログの価値（記事の質）を上げているわけではないです。肝に命じておきたいです。
あと、ちきりんさんは、実名や外見を晒さないようにしていますが、これは次のようなリスクを考慮してのこと。
家族にまで影響が及ぶかもしれない 会社勤めの人は、その会社にまで影響が及ぶかもしれない 周りの目を気にした行動をとってしまうかもしれない（見栄を貼って高いものを買うとか） 自分を売り込むために、自分の写真を載せて、実名でブログを書く、ということが流行っていますが、こういったリスクはちゃんと考えておきたいですね。信頼度を上げるために自分の写真を載せるとよい、といったアドバイスがあったりしますが、信頼度は質の高い記事を書き続けることで上げていくべきもの。本当にブログが有名になってしまったら、芸能人と同じようにプライベートがなくなってしまうかもしれません。まくはそんな生活は嫌だ。</description></item><item><title>2017-06-17 読んでもらおうと意識しすぎない</title><link>https://maku.blog/p/kad9cep/</link><pubDate>Sat, 17 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kad9cep/</guid><description>近くの図書館に行って、「Chikirin の日記」のちきりんさんの本を読みました。
アフィリエイトでお金を稼ごう的な書籍がたくさん刊行されている中で、ちきりんさんのブログに対する考え方はグッとくるものがありますね。
「Chikirin の日記」は 2005 年から始まっていますが、彼女はブログを始める前から 25 年間も紙の日記をつけていて、日記は基本的に自分のためのものでした。なので、そもそもブログを始めるときに「はじめまして」みたいに読者のことを意識した書き方はしていないし、ブログで集客しようなどとも考えていませんでした。日記を書くためにネタを探すということはなく、自然な日常の行為として日記を続けています。
ブログが続かないという人は、ちきりんさんみたいに、「自分が考えたこと」を記録として残すだけ、くらいに考えれば簡単に続けられるかもしれません。
まくが見習うべきと思ったところは、自分のやりたいこと、ブログの目的やゴールをちゃんと意識して、その通りに行動しているところ。ちきりんさんのゴールは、
自分のブログを価値あるメディアに育てる ということ。彼女の定義では、「価値あるメディア」とは読者が似通っていて、絞り込まれているメディアのこと。例えば、読売新聞より日経新聞、地上波放送よりCS放送、というイメージです。自分の記事に共感してくれる「想定読者」を増やすことで、自分の意見を発信する場であるブログというメディアの価値を上げることを目標としています。たしかに月間 200 万 PV もあれば、発信力、影響力は大きなものになりますね。
そんな風にちゃんとゴールを設定して生活しているから、仕事を引き受けるべきか迷ったときに、「手間をかけずにブログの想定読者を増やすことができるか」、「ブログの価値を上げられるか」、という基準で判断することができます。
人生は 30000 日しかありません。自分のやりたいことやゴールを設定して、そこに一歩ずつ近づけるように毎日の行動を決めていきたいですね。
そんじゃーね。</description></item><item><title>2017-06-13 NURO 光がやっと開通、遅すぎて速すぎ！</title><link>https://maku.blog/p/2vu66jo/</link><pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2vu66jo/</guid><description>まくの家（賃貸）にも NURO 光がやってきました。４月下旬に申し込んでいたけどやっと開通です。やっとテザリング生活から解放された〜よ。噂通り、開通まではものすごく待たされて、1.5ヶ月近くもかかったけど、インターネットの通信速度は爆速でした。
なんということでしょう。545.11Mbps 出てます。これで作業が100倍はかどる・・・といいなぁ。
しかもこれ計測している裏で Netflix 再生してますからね。Netflix の再生もめちゃ速いです。Netflix はフレッツ光のときからサクサクでしたけど、NURO 光にしてからはもっとサクサクです。ロード時間なし。
NURO 光は、申し込みは早めにしないと待ち時間が大変ですけど、キャンペーン適用して料金もお得ですし、この爆速感はすばらしぃです。</description></item><item><title>配色サンプル (Color Combination)</title><link>https://maku.blog/p/y2kvx5f/</link><pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/y2kvx5f/</guid><description> http://www.honda.co.jp/kids/ より
#8bc7ed
(R139 G199 B237) #f8aaca
(R248 G170 B202) #c1d93b
(R193 G217 B59) #f2f0e9
(R242 G240 B233) #906c3a
(R144 G108 B58) #ffc823
(R255 G200 B35) http://blend-design.jp/ より
#7fc67f
(R127 G198 B127) #82d8d8
(R130 G216 B216) #d1a5db
(R209 G165 B219) #f78d7f
(R247 G141 B127) #dbb583
(R219 G181 B131) #f4c551
(R244 G197 B81)</description></item><item><title>2017-06-04 お名前.com で独自ドメインとって WordPress を共用サーバー SD ではじめてみた</title><link>https://maku.blog/p/akojpbr/</link><pubDate>Sun, 04 Jun 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/akojpbr/</guid><description>お名前.com でドメイン をとって、ついでに お名前.com のレンタルサーバー （共用サーバーSD）も借りました。 同じところでドメイン＆サーバー設定してしまえば、いろんなサイトの説明にまどわされることもないし楽ですよね。
お名前.com のレンタルサーバーであれば、稼働率99％以上保証という安定性があり、独自SSLが月額100円から使えるというところも決め手でした。SSL 対応すれば、Google の検索ランクにもプラス評価されるため、アクセスを集めるにはもはや SSL 対応は必須という状況になってきました。
早速、お名前.com 共用サーバーで WordPress を簡単インストールしようと思い、WordPress インストールボタンをポチッとしたら、
事前にインストールするドメインのネームサーバーを、弊社指定のネームサーバーに変更をお願いします。
というエラーが発生。。。
これは、独自ドメインを運用する DNS サーバーが、「お名前.com 共用サーバで提供されている DNS サーバ (dns01.gmoserver.jp)」に設定されておらず、「お名前.com（ドメインサービス）で提供されている DNS サーバ (dns1.onamae.com)」に設定されているということです。
共用サーバーと同時にドメイン取得したんだから、デフォルトで共用サーバー側の DNS へ結びつけてくれてもいいのに、このあたりの設定は結局自分でやらなきゃなんですね ^^;
あれ？？ドメインもレンタルサーバーもお名前.com で頼んだのに、
全然楽になってない！
まぁ、そんなもんだと思ってあきらめます。でも、お名前.com（GMO）もっとがんばれ！
固定 IP アドレスを提供しているレンタルサーバーであれば、お名前.com の DNS サーバを使い続けたまま、A レコード設定によって「独自ドメイン → 固定 IP アドレス」という結びつけができます。
でも、お名前.com 共用サーバーSDは、
メンテナンス等の影響で変動する場合もございますので、非公開とさせていただいております。共用サーバーSDプラン/ホームページエディタープランではお客様個別の固定IPアドレスのご用意はございません。
サーバーのIPアドレスを教えてください - お名前.comヘルプセンター と言っているので、独自ドメインを管理する DNS サーバ自体を、お名前.com の DNS サーバーから、お名前.com 共用サーバーの DNS サーバーに変更しなければいけません。
【レンタルサーバー】ネームサーバー（DNS）を教えてください 独自ドメインを管理する DNS サーバを変更するには、お名前.com のドメイン Navi から設定を行います。</description></item><item><title>読書メモ『シンプルに生きれば、すべてがうまくいく！』西村豪庸</title><link>https://maku.blog/p/s7d2r2f/</link><pubDate>Sat, 27 May 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s7d2r2f/</guid><description>感想 ★★★★☆ 4/5点。
事業の失敗や、離婚などを経てどん底に落ちた著者が、シンプルに考え、生きていくことの大切さを説いてくれます。モノや情報に溢れているこの世の中で、幸せになるためのカギは、「シンプル」のひとことに尽きるのかもしれません。
シンプルに生きれば、すべてがうまくいく！ 西村豪庸 KADOKAWA / 中経出版 読書メモ 第一章「身の回りを片付け、潜在意識を汚さない」 モノはすべて引き出しなどに収納して、外に出さない。 何がどこに入っているのか、すべて言えるくらいがちょうどいい。 モノを残す基準は、火事が起きたときに持ち出すもの。 迷ったら「とりあえずボックス」に入れて、置くべき場所を検討する（著者の場合はワインの木箱）。定位置と、この場所だけ探せばすべてが見つかるようになる。 荷物が少なければ身軽です。フットワークが軽くなります。─ 「ほぼ手ぶら」くらいのノリで旅に出てみませんか。 第二章「お金と仕事から自由になる考え方」 お金が増える ＝ 選択肢が増える ≠ 幸せになる 幸せなお金持ちというのは、人を大切にする人。 「目の前の人」を大切にして働いていく。 お金持ちはたくさんの水路（収入源）を作ることに努力する。 村全体のことを考えて、みんなと水路を作る。この考え方がコツ。 時給分だけ働くつもりでいると、結果的に損をする。求められたよりも、大きなものを先に与えていくこと。 稼げることより、好きなことの方がうまくいく。ただし、市場があることが条件。 何でもいいので、一番になっておいた方がいい。 ２つ以上の技能を持つことで価値が生まれる（マーケティングと会計を両方知っている、Windows と Mac 両方に詳しい、など）。ひとは何人ものひとに尋ねるよりも、一人のひとから聞く方を選ぶ。 「これだけは譲れない代わりに、ここは我慢する」というセットでアピールした方が、他の人も協力しやすい。 デイトレで成功できた理由は、「上がれ！」とか「下がれ！」とか祈らなくなったこと。 ビジネス体力をつける。１日に10冊くらいの本に目を通す。 第三章「人間関係の問題はわけて単純化する」 自分がコントロールできないことは、悩まない。 最初はとにかく、性善説にのっとって人を信用して付き合う。その結果、協力してくれたら関係を続ける。意地悪されたら付き合わない。 第四章「数字に置き換えてみると明確になる」 どのくらいの資産を持ちたいか、数値化して明確にした方が実現しやすい。 年収3000万円以下の人は、１秒あたり１円も稼いでいない。だから、１円を１秒かけて拾う価値がある。年収３億円以下なら、10円は拾うべき。 上司の評価、職場の評価に応えられなければ、何も始まらない。 第五章「とにかく場数を踏むことが成功につながる」 無能から有能になるためのプロセスは、失敗し続けること。でも絶対に失敗したくないことも決めておく（友達を失うような失敗など）。それ以外はどんな失敗も恐れず、前に進む。 人の成長は二次曲線。最初の伸びない時期にあきらめない。</description></item><item><title>読書メモ『手離す技術』桜井章一</title><link>https://maku.blog/p/9yzpr65/</link><pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9yzpr65/</guid><description> 手離す技術 桜井章一 講談社 人が本来成すべきなのは、人脈づくりではなく、いい人間関係を築いていくことなのだ。成功のために人間関係があるのではない。いい人間関係の先に成功があるということを忘れてはいけない。 幸せというものはそもそも、求めるものではなく、与えるものなのだ。「まわりの人を楽しませたい」「あの人の笑顔が見たい」、そんな純粋な気持ちで動ける人が、真の意味で「幸福な人」なのである。 結局、欲というのは、シンプルな形態のものであればあるほど、満たされるのである。だからなおのこと、いかにシンプルにできるかが問われてくる。 金とのつき合い方は、「気づいたら金がそこにあった」という程度がちょうどいい。握っているけれどいつでも手離せる感覚。 野菜は八百屋で、魚は魚屋で買うようにする。そのほうが商店街も元気になるし、地域のコミュニティも活性化される。 終わりが終わりなのは「生命の終わり」だけであって、そのほかの終わりはすべて始まりだという感覚を私は抱いている。だから、**たとえなにかを失ったとしても、「今度得ることの始まりだ」**と思えるのだ。 人間は、手に入れた知識や情報といったものをなかなか排出しようとしない。利益や利権、権力といったものにも、いつまでもしがみついていたりする。本来であれば、そういったすべてのものも、便や尿のように排出すべきものなのである。 上の立場の人間は、「いいことはすべて人のおかげ」にするのがいい。そうしていると、不思議と生きていく中で「文句」や「不平不満」というものがなくなっていく。 人は往々にして金、権力、情報など、「掴めるもの」にばかり価値を見出してしまう。しかし私は、「掴めないもの」こそ、大切であるといつも思っている。自分のまわりにある、掴めないものの存在を知り、感じることで、人間の本能や感覚といったものは研ぎ澄まされていく。</description></item><item><title>読書メモ『僕らが毎日やっている最強の読み方』佐藤優／池上彰</title><link>https://maku.blog/p/pk9h87c/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pk9h87c/</guid><description> 僕らが毎日やっている最強の読み方 佐藤優／池上彰 東洋経済新報社 池上さんおすすめの海外紙は、イギリスの経済紙の『フィナンシャル・タイムズ』。１紙630円と値は張るが、文章が平易で英語の勉強にもなる。一方で、『ニューヨーク・タイムズ』や『タイム』は気取った表現が多い。 『ウォールストリート・ジャーナル』もおすすめ。 佐藤優「dマガジン、ビューンなどの雑誌定額サービスは通勤時の空き時間に読むのがオススメ。無料のネット情報よりも質が高いので、こういったのを利用して時間を有効に使うべき」 まとまった時間には「書籍」を読んで深い知識を付ける。隙間時間には「雑誌」を読んで視野を広げる。 国際情勢を知るには『フォーリン・アフェアーズ・リポート』がオススメ。 ネットの記事は「編集」「校閲」の機能が欠如しているので、時間ばかりを浪費する効率の悪いメディア。やはり「新聞」や「雑誌」がよい。ネット上にも新聞社のサイトはあるが、時系列に記事が並んでしまうため、記事の重要度が分かりにくく時間の無駄になる（新聞を広げたように記事が配置されていればOK）。 ネット上には自分の好きな記事ばかり表示されるようになるので、知識が偏ってしまう危険もある。 調べものはネット記事や Wikipedia のような正しいかどうかわからないものを使うのではなく、まずは百科事典や辞書を使用すること。 東大生は歩きスマホをしている人が少ない。時間の使い方をわかっている。 佐藤優「リアルタイムでテレビを見る回数は、映画館に行く回数より少ない」 池上彰「テレビはまったく見ない」 池上優「どんなジャンルでもベースになる本は３冊以内。そういった本は時間をかけてしっかりと読み込む」 佐藤優「読んでいることで優位に立てるのが古典」</description></item><item><title>Ansible の ansible.cfg ファイルの検索順序</title><link>https://maku.blog/p/pamv6gq/</link><pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pamv6gq/</guid><description>Ansible の実行環境が参照する設定ファイル (ansible.cfg) は、下記のようなパスから検索されます。
環境変数 ANSIBLE_CONFIG で指定されたファイル ansible.cfg（カレントディレクトリ以下のファイル） ~/.ansible.cfg（ホームディレクトリ以下のファイル） /etc/ansible/ansible.cfg Git などで管理する場合は、Playbook の近くに一緒に入れておくとわかりやすいです（上記の 2 番目の方法）。</description></item><item><title>Ansible でインベントリーファイルの場所を指定する</title><link>https://maku.blog/p/eycnx9i/</link><pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eycnx9i/</guid><description>Ansible のコマンド（ansible や ansible-playbook）を実行すると、下記の順でインベントリーファイルが検索されます。
コマンドラインオプション -i で指定したファイル コンフィグファイル ansible.cfg 内の hostfile で指定したファイル（参考: ansible.cfg ファイルの検索パス） /etc/ansible/inventry 以下の例は、いずれもカレントディレクトリ内の hosts というファイルをインベントリファイルとして使用するように指定しています。
例: コマンドラインオプション (-i) で指定する方法 $ ansible myserver -i hosts -m ping 例: コンフィグファイル (ansible.cfg) で指定する方法 [defaults] hostfile = hosts</description></item><item><title>読書メモ『ゼロ ─ なにもない自分に小さなイチを足していく』堀江貴文</title><link>https://maku.blog/p/ttpeeux/</link><pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ttpeeux/</guid><description>ゼロ ─ なにもない自分に小さなイチを足していく 堀江貴文 ダイヤモンド社 感想 ★★★★ 4/5点。
ホリエモンの生い立ちなどが書かれていて親近感が湧くようになります。 起業をすることはみんなが思っているより普通にできることなんだよ、と説いてくれます。 会社員として働き続けることに疑問を持っている人にはオススメです。
メモ **やりたいことは「できっこない」という心のフタを外せば湯水のように溢れ出てくる。**やりたいことがないという人は最初から「できっこない」とあきらめている。 **わずかな期間でも会社経営を経験しておくと、ビジネススキルは飛躍的に向上する。**会社員を何年続けても身につかない仕事の本質だ。起業は誰でもできると考えるのが普通。この国で働く人のうち20人に1人くらいは経営者。 **お金よりも信用が価値を持つ。**1億円を持っている人が100万人のフォロワーを集めるのは難しいが、100万人のフォロワーを持つ人が1億円を集めるのは簡単。人生の崖っぷちに追い込まれたときに、あなたを救ってくれるのは信用だ。 **信用を得るにはまず自信を付けること。**背伸びしてでもできると言って引き受け、ハードルを越えていく。 **理性の声に従った決断には迷いも後悔もない。**感情に流された決断は後悔に襲われる可能性がある。ひとつの熟考よりも三つの即決。悩むことと考えることは違う。 自ら生み出した仕事に臨んでいるとき、あなたは「自分の時間」を生きている。 与えられた仕事をやらされているとき、あなたは「他人の時間」を生きている。 **やりがいというのは自ら「仕事をつくる」ことによって生まれる。**やりがいというのは仕事の内容ではなくて、「取り組み方」の問題だ。能動的に取り組むというプロセス自体が「仕事をつくる」ということ。 **没頭することで何かを好きになる。**没頭さえすればいつの間にか好きになる。仕事を嫌いだと思っている人はただの経験不足で、仕事に没頭したことがない人のこと。 自分の都合のいい情報だけでなく、たとえばツイッターでも、自分と意見の合わない有識者を一定数フォローすること。 情報弱者にならないためにも、かたっぱしから情報を取りまくろう。 ゼロ [ 堀江貴文 ]
価格：1512円（税込、送料無料) (2016/9/20時点)</description></item><item><title>読書メモ『99％の会社はいらない』堀江貴文</title><link>https://maku.blog/p/edpxk5d/</link><pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/edpxk5d/</guid><description> 99％の会社はいらない 堀江貴文 ベストセラーズ 飽きるのは決して悪いことではない。飽きてしまうということは、その物事にハマった結果だ。形になる前に止めてしまうのはよくないが、形になっているのであれば、それは次の仕事につながっている。 最優先していること以外は基本的にやらなくていい。自分に何ができて何ができないかなんて、自分が一番わかっているはず。だから不得意なところは人に任せてもいい。 ファーストペンギンよりも、セカンドペンギンの方が大事なのである。 「飛び込めば大きなものが得られるかもしれない」と思っているのだが、何かその確証や保険が欲しくなるのかもしれない。 ─ やらない言い訳をしていたら、いつまで経っても変わらない。だから、あまり考えすぎない方がいい。 新しいことをはじめるのは、決して苦しいものではない。なぜなら、面白いことや興味のあることをするからだ。だから、動いてみると、結果として面白いことの方が多いのだ。 大事なのは、ギブ・アンド・テイクではなく、ギブ・アンド・ギブの精神だ。 誰かに一緒に仕事をしたいと思ってもらおうなどとは、これっぽっちも考えていない。 ─ 認めてもらうかどうかは関係なく、お互いにとって何かの面で「Win-Win」の関係になればいい。 レベニューシェアにすることで頑張って事業を大きくしようという気持ちにもなれるし、夢を見ることもできる。その方がお互いにとっていいことだ。 他人に頼ることができなければすべてを自分でやらなければならなくなる。 &amp;ndash; もちろんときには裏切られることだってある。 ─ 裏切られたことはすぐに忘れる。そういうものだと思って行動するのが一番だ。 人が惹かれるスキルこそが、実はコミュニケーションスキルの本質だ。 ─ 資格なんてものは、スキルとしての差別化はまったくない。 「飼い犬」だっていつ飼い主がいなくなるかもわからないし、もしかしたら捨てられてしまうかもしれない。 ─ 自分がいる環境を見つめて欲しい。広い世界を見て欲しい。 行動するのは実は簡単である。バカになればいいのだ。</description></item><item><title>読書メモ『わたしの外国語学習法』ロンブ・カトー</title><link>https://maku.blog/p/t6nqgcj/</link><pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t6nqgcj/</guid><description>わたしの外国語学習法 ロンブ・カトー 筑摩書房 外国語を学習するのは、それ自体が面白いからでもある。
外国語学習に必要な最低限の時間は週10〜12時間。まず何よりも、時間の割り振りのバランスをとること。不可能ならば始める前によく考える。
外国語学習を始めた初日から学習計画に読書を盛り込むこと。能動的に読むこと。
言語から文法を学ぶのであって、文法から言語を学ぶのではない。
最も信頼のおける外国語の担い手は本であり、最も頼りになる教科書である。
パターンを反復する最良の手段が本。どんどん読もう。本は書き込みで真っ黒にしても、バラバラに分解してもよい。単語の無限の反復を保障し得るのは本だけ。
本はわたしたちの誠実な道連れとなってくれる。わたしたちがその本よりも成長するまで。
自分が興味を魅かれるものを読めばよい。映画俳優の本、推理小説、歌、精神医学の本、雑誌類、インテリアや衣類のデザインの本など。
英語は「書き言葉」と「話し言葉」がかなり異なるので、両方（二種類の言葉）を学ぶ必要がある。
心からお勧めしたいのは、学習用に改作され、注釈などを施した本。
外国語で独り言を言うのがオススメ。物を相手に対話するのもよい。
外国に移り住んでも、自発的に学習をしない人は、結局正しく話せるようにはならない。
その国を訪れることが、外国語を習得するための条件ではない。外国にいても、自国にいても、同じ時間をかけて覚え込める量は同じ。
母国語にない発音はウンザリするほどたくさんある。だから、まずは発音の違いが意味の違いを生んでしまうものから取り組む。
ラテン語以外の文字を使用する言語には難しいというレッテルが貼られているが、学んだことのあるものはそれが過大評価だということを知っている。
You may, but you can&amp;rsquo;t. （いいですよ、でもお出来になれんでしょう ー バーナード・ショー）
単語や名前を、真空管にぶら下がった格好で覚えようとするのはダメ。すでに知っている表現や概念と組み合わせることで何らかの情報を付加すると忘れない。語呂合わせでもよい。
自分の個性の反映された単語帳を自作する。類義語が反義語を書き込む。ただし、凝りすぎないこと。本当にその時に必要なものだけを書き込む。
単語の意味をコンテキストから言い当てることができた場合、快い感情を呼び起こしてくれる。何も考えずに辞書を引いたりするより、その成果は強固である。
会話をつなげる役割を持つフレーズに初期から取り組むこと。「かなり」「きっと」「非常に」「もちろん」「つまり」「たしかに」「また」「主に」「おそらく」「むしろ」「ずっと」「やはり」。この種の語句の一覧表を作成し、自動的に口をついて出てくるまで覚え込む。
参考書は日本人向けに書かれたものを使うこと。日本語と異なる概念にページ数を多く割いているから効率が良い。
外国語で語るということは、常に妥協するということだ。
毎日勉強すること。時間がなくても最低 10 分。意欲が減退するようなら、別の形を考える。教科書から離れてラジオを聞くとか、辞書をパラパラめくってみるとか。
独学する場合は、正しいとわかっている表現だけを覚え込むこと。自分で組み立てた表現は間違っている可能性がある。
成句や熟語的表現は、一〜三人称、単数で書き出して覚えること。be 〜 と書き出すのではなく、I am 〜 という実際に使う形で書き出す。
四方八方から攻める。「新聞を読む」「ラジオを聴く」「吹き替えなしの映画を見る」「外国語の講義を聞く」「教科書を使う」「文通する」「出会って会話する」
誤りを犯すことを恐れず、それを直してくれるよう頼む。
自分は目標を達成できるのだと固く確信すること。
土台の構築にこそ最大限のエネルギーが消耗されるのだということを忘れない。スタートを切る前にあきらめないこと。
外国語学習の結果は、次の式で表すことができる。（消費時間 ＋ 関心および意欲）／羞恥心。
誰にでもわかるような簡単な部分に分解し、解釈を組み立てていくようにすればよい。
演説の通訳は参考になる。使っていけない言い回しはしないし、言葉をつなぐ手法に長けている。
わたしの外国語学習法 [ カトー・ロンブ ]
価格：1026円（税込、送料無料) (2016/9/5時点)</description></item><item><title>読書メモ『ピーター流外国語習得術』ピーター・フランクル</title><link>https://maku.blog/p/kgc9pxa/</link><pubDate>Sat, 20 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kgc9pxa/</guid><description> ピーター流外国語習得術 ピーター・フランクル 岩波書店 たくさんの外国語を効率に学ぶにはどうしたらいいかというお話。 数学とジャグリングが得意なピーター・フランクル氏が書いてます。
最初の段階では対訳の本を読むのが効率がよい。探偵小説なら先が気になって最後まで読み通すことができる。 単語の丸暗記ではなく、詩を覚えるのがよい。詩は韻をふんでいるし、意味もある。 その言語で独り言を言うのがオススメ。 教科書は一冊だけでなく、何冊か買って勉強すること。いろんな教科書で何度も同じ単語や言い回しに触れることで覚えられる。 達成しやすい目標を立てること。短くて可愛らしい「星の王子さま」であれば、誰でも1ヶ月がんばれば読める。目標は低めに設定することで、ステップを踏んでいけばよい。高すぎる目標を立てると、道のりが遠すぎて、途中であきらめてしまいやすい。 わからない単語は必ずすぐに調べること。何度か出てきてから調べるという方法では、復習のチャンスを失ってしまう。調べた単語は自分用の単語帳に書いておく。次に出てきたときは、市販の辞書ではなく、まずは自分用の単語帳を見ることで復習の効果がある。違う意味で使われていたら、その都度意味を書き加えておく。 作文などの宿題は遊び感覚でやるとよい。例えば、複数の単語を使った作文の宿題なら、強引にひとつの文章に入れてしまうなど。 自分の生まれた国からちょっと離れて、ひろひろな人と交流して戻ってくると、自分のことをもっとよく理解できる。 外国語を勉強するときは、速く読むよりも集中してじっくり味わった方が、単語や言い回しを覚えられる。 同じグループの単語は同じ状況で使うことが多いので、一緒に覚えるのがよい。新しい色を覚えるときは、前に覚えた色をいっしょに思い出すことで復習できる。 他の日本人といっしょに毎日のように食べたり飲んだりする数を減らすべき。特に悪いのはお酒を飲んで酔っ払うこと。酔ってしまうと集中できなくなり、時間を無駄にしてしまう。 日本人の大きな問題は、いつも複雑なことを言おうとすること。努力してでも簡単に言うことが大切。自分のレベルをわきまえて簡単なことしか言わない方がよい。基本の基本を何度も繰り返すことで身に付いていき、長い時間会話することができるようになる。 その人の言語のレベルは「分」という単位で示すことができる。新しく会った人と何分間会話を続けられるかということ。 いつも大きな声で話すこと。自信がなくて間違っているかもしれないと思っても、大きな声でしゃべらないと、相手の反応が分からず、間違った使い方をしていることにも気付けない。間違っているときは、間違ったまま相手にちゃんと聞き取ってもらうことが大切。</description></item><item><title>読書メモ『レバレッジ・シンキング 無限大の成果を生み出す4つの自己投資術』本田直之</title><link>https://maku.blog/p/bsnij2z/</link><pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bsnij2z/</guid><description> レバレッジ・シンキング 無限大の成果を生み出す4つの自己投資術 本田直之 東洋経済新報社 感想 ★★★★☆ 4/5点。
本の中で難度も「レバレッジ」といういかにも新しい考え方っぽい言葉を使ってますが、簡単に言えば「効率化」ということですね。 隙間時間を使うとか、通勤時には読書するとかそういったちょっとした効率化のコツがたくさん書いてあります。 毎日ダラダラと過ごしてしまっているなぁと思っている人には参考になりそうです。
メモ ゴールを明確に描いていると、余計なことをやらないで済むようになる。ゴールを明確に描いていると、普段の生活の中で気付きや出会いが多くなる。チャンスを逃さなくて済む。 仕事がうまくいったときは、なぜうまくいったかを考えて仕組み化しておく。少ない労力で成果を上げることができるようになり、誰かに任せることもできる。 マニュアルが悪いのではなく、マニュアルの使い方が悪い。個々がマニュアルを超えた対応をすればよい。 良い習慣はすばらしい資産。資産を作るつもりで良い行動を習慣化していく。習慣にすれば、その行動に対してのストレスはなくなり、良いスパイラルになっていく。小さな習慣から作っていけばいい。帰宅後部屋が散らかっているのが嫌なのであれば、まずは**「帰宅後に靴を揃える」「今日出したものは今日中にしまう」**といった小さな習慣から作っていく。 読んだビジネス書の冊数を記録していく。記録に残すことで、もっとやろうというマインドが生まれる。 KSF (Key Success Factor) を探すことによって、短時間で大きな成果を上げられるようになる。重要なのは、それ以外のことをやらないということ。受験勉強で過去問をやるのは、勉強しなくてもよいところを探すため。合格ラインとのギャップがわかり、勉強の意欲が湧いてくる。 効率化を考えるときは、同時に何かできないかを考える。「風呂に入るときに読書する」、「通勤中にビジネス書を読む」、「ジョギング中に音声教材を聞く」、「会議に出るときは別の仕事の資料を持ち込んで隙間時間を利用する」など何でもやる。 同時にやって稼ぎに繋げている人もいる。「ガーデニングが趣味な人が緑化事業を立ち上げた」、「マンション購入が考えている人が賢いマンション選びの本を書いた」。 疲れたときこそゴロゴロ過ごすのではなく、普段通り体を動かすとよい。トレーニングすると疲れが取れることに気がついた。 人間が変わる方法は３つしかない。「時間配分を変える」「住む場所を変える」「つきあう人を変える」。 by 大前研一 時間をかけることでよい成果が出るわけではない。短時間で成果を上げることこそ重要。素早く動くということではなく、何をやるかを見極めることが重要。隙間時間を活用することも重要。 スケジュールを逆算して考えるには俯瞰できる月間のカレンダーがよい。 主催者の役割は、会ったその場で皆がお互いのことを知っているという状況にすること。あらかじめメールなどで全員のプロフィールやウェブサイト、著書などを共有しておく。</description></item><item><title>Nginx の設定: Nginx の設定ファイルの書き方が正しいか確認する (configtest, nginx -t)</title><link>https://maku.blog/p/3q8uzoo/</link><pubDate>Mon, 21 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3q8uzoo/</guid><description>nginx の configtest コマンドを使用すると、nginx のコンフィグファイルの記述方法が正しいかを確認することができます。 このコマンドは管理者権限で実行する必要があります。
$ sudo /etc/init.d/nginx configtest nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful nginx コマンド (/usr/sbin/nginx) を認識している環境であれば、このコマンドの -t オプションで確認することもできます。
$ sudo nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful</description></item><item><title>Nginx の設定: Nginx の設定ファイルの変更を反映する（再読み込み）</title><link>https://maku.blog/p/6aazmy3/</link><pubDate>Sun, 20 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6aazmy3/</guid><description>nginx の設定ファイル (/etc/nginx/nginx.conf や /etc/nginx/conf.d/*.conf) の内容を変更した場合は、下記のようにして反映することができます。
$ sudo service nginx reload $ sudo /etc/init.d/nginx reload nginx の起動はとても速いので、単純な Web コンテンツだけを提供しているの Web サーバであれば、nginx サービス自体を再起動してしまってもよいでしょう。
$ sudo service nginx restart $ sudo /etc/init.d/nginx restart</description></item><item><title>ソフトウェアアーキテクトが考えること</title><link>https://maku.blog/p/x2b2gw3/</link><pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x2b2gw3/</guid><description>ソフトウェアアーキテクチャとは アーキテクチャとは「要求と設計の橋渡し」である ─『オブジェクト開発の神髄』より
外部から見える特性 構成要素 構成要素間の関係 アーキテクトが考えること 何をもとにシステムを設計するか 部品をどのように組み立てるか システムをどのように動作保証するか パフォーマンス アーキテクチャドライバとは アーキテクチャを決定する要件のことを「アーキテクチャドライバ」といいます。 つまり、アーキテクチャドライバはアーキテクチャ設計のためのインプットとなります。 アーキテクチャドライバには以下の３つの要素があります。
制約（最重要。変更できないものだから） ビジネス制約 技術制約 品質特性 Performance 性能 Modifiability 変更容易性 Usability ユーザビリティ Availability 可用性 Security セキュリティ Testability テスト容易性 主な機能要件（重要性としては一番低い。ほとんどの場合、制約にかかわらず実現できるので） アーキテクチャドライバはステークホルダーとのコミュニケーションの道具であり、このアーキテクチャドライバの作成（文章作成）を行うのがアーキテクトの最初の仕事です。
アーキテクチャ設計のステップ アーキテクチャ要件抽出 アーキテクチャドライバの作成（要求を要件として分類する。上の３つの要素） ステークホルダーと仕様優先度レビュー アーキテクチャドライバに基づくシステムの分割 ソフトウェアアーキテクチャレビュー アーキテクチャドキュメント ソフトウェアは様々な視点で捉えられ、これをビュー (View) と呼びます。 アーキテクチャドキュメントはビューの集合と相互作用の説明で構成されます。
アーキテクトが作成すべき図の例 パッケージ図 パッケージ間の依存関係 それぞれのパッケージに何が配置されるか ソースコードやライブラリの物理構造 コンポーネント図 配置図 物理的なハードウェアやソフトウェアの配置 実行環境を表すノードとの接続関係など アーキテクチャパターン アーキテクチャパターンとは、「アーキテクチャの要素と要素間の関係を使い方の制約と共に特定したもの」です。 ─出展『Principles of software architecture』。
様々なアーキテクチャパターンが提唱されており、GOF のデザインパターンとは違い統一された解釈は存在しません。
Shaw and Garlan &amp;ldquo;Software Architecture&amp;rdquo; ― Shaw と Garlan のリスト Buschmann et al.</description></item><item><title>Linuxコマンド: curl コマンドの使い方メモ（GET/POST リクエスト、ファイルのダウンロード）</title><link>https://maku.blog/p/phdp2do/</link><pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/phdp2do/</guid><description>curl コマンドは URL を指定してサーバー上のリソースにアクセスするためのコマンドで、Web API のテストや、ファイルのダウンロードに使用できます。 昔は curl コマンドは Linux 用のコマンドという認識でしたが、Windows 10 には標準搭載されるようになりました。 curl は様々なプロトコルで通信できますが、主に HTTP/HTTPS が使用されます。
curl コマンドでファイルをダウンロードする curl コマンドはデフォルトではダウンロードしたファイルを標準出力に出力します。 -o（小文字のオー）オプションや、-O（大文字のオー）オプションを指定することで、ファイルに保存する ことができます。
指定したファイル名で保存 (-o) # カレントディレクトリに sample.zip という名前で保存（この場合は後述の -O を使うと楽） $ curl -L http://example.com/sample.zip -o sample.zip # 保存先を絶対パスで指定 $ curl -L http://example.com/sample.zip -o /tmp/sample.zip ダウンロード元と同じファイル名で保存 (-O) sample.zip という名前で保存 $ curl -L -O http://example.com/sample.zip curl コマンドで GET/POST リクエストを送信する REST API などのテストに curl コマンドを利用できます。
GET リクエスト 特にオプションを指定しなければ、HTTP の GET リクエストが送信されます。
PokeAPI を実行してみる $ curl https://pokeapi.</description></item><item><title>文字コード、フォント関連用語まとめ</title><link>https://maku.blog/p/nao2coz/</link><pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nao2coz/</guid><description>用語まとめ character map / charmap 特定のエンコーディングの文字コードを、glyph index にマッピングするための情報。１つの Font face は複数の charmap を含んでいることが多い。Mac 用の charmap、Unicode（Windows）の charmap など。 charset / 文字セット 「文字集合」と「エンコーディング」をセットにした概念。IANA が定義した。 font collection 複数の font face を 1 つのファイルに含んだもの。 font face font family に、Italic とか Bold とかの区別を加えたもの（ノーマルなものは Regular）。 font family Arial とか Courier とか。 glyph 文字を描画したときの形。フォントファイルは、ビットマップで glyph を持つこともあるし、ベクターデータで glyph を持つこともある。 ligature 合字。２文字以上をくっつくて１文字を表現したもの。 エンコーディング形式 / 文字符号化方式 / CES: Character Encoding Scheme 文字集合内の文字に割り当てられた数値を、コンピュータが実際に使用するバイト列に対応付ける方法。例: Shift_JIS、EUC-JP、ISO-2022-JP スクリプト スクリプト（書体）は言語の文字情報を表す記号の集まりです。スクリプトの例には、ラテン文字、アラビア文字、漢字、ギリシャ文字があります（参考: http://unicode.org/reports/tr24/ ）。 文字コード 文字に割り当てられた数値（バイト表現）のこと。まれに、エンコーディング形式のことを文字コードといったりする。例: 0x0102 文字集合 / 符号化文字集合 文字コードの集合。文字の見た目が同じであったとしても、文字集合ごとに、割り当てられる文字コードは異なる。例: JIS X 0208（JIS拡張漢字） 「文字集合」と、それに適用できる「エンコーディング形式」には関連があります。 例えば、文字集合 JIS X 0208 で使われるエンコーディング形式は ISO-2022-JP、EUC-JP、Shift_JIS などです。</description></item><item><title>Windows で ARIB 外字を表示できるフォント（Windows TV フォント）</title><link>https://maku.blog/p/bq86dfz/</link><pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bq86dfz/</guid><description>Windows 7 には、ARIB 外字を表示するフォントファイルがデフォルトで用意されています。 下記のファイルをダブルクリックすれば、インストールすることができます。
ファイル名 含まれているフォント C:\Windows\ehome\WTVGOTHIC-R.ttc Windows TV P丸ゴシック、Windows TV 丸ゴシック C:\Windows\ehome\WTVGOTHIC-RB.ttc Windows TV P太丸ゴシック、Windows TV 太丸ゴシック C:\Windows\ehome\WTVGOTHIC-S.ttc Windows TV Pゴシック、Windows TV ゴシック</description></item><item><title>文字列の類似度を計算する（LCS: 最長共通部分列）</title><link>https://maku.blog/p/a3jyhwd/</link><pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a3jyhwd/</guid><description>LCS とは LCS: Longest Common Subsequence（最長共通部分列） 問題とは、2 つのシーケンスから最長の共通部分列を探す問題です。
参考: Wikipedia - Longest common subsequence problem 参考: Wikipedia - 最長共通部分列問題 部分列は飛び飛びの要素で構成されていても構いませんが、順番はキープして作成する必要があります。下記の例は、2 つの文字列とその最長共通部分列 (LCS) を示したものです。
文字列1: &amp;ldquo;ABCDCE&amp;rdquo; 文字列2: &amp;ldquo;ACCDEX&amp;rdquo; LCS: &amp;ldquo;ACCE&amp;rdquo; or &amp;ldquo;ACDE&amp;rdquo; LCS の計算方法 LCS は、動的計画法（DP: Dynamic Programming）の例題としてよく示される問題で、DP を使うことで効率的に答えを求めることができます。 考え方としては、下記のような文字列の入ったスタックから、任意の順番で文字を取り出していく問題だとみなすと分かりやすいです。
どちらか一方から要素を取り出すときは、文字をマッチさせないと考えます。 両方の要素を同時に取り出すときは、そのタイミングで文字をマッチさせる（LCS を構成する要素）と考えます。
このように、任意の順番で取り出してマッチングしていったときに、最大の一致数になったものが LCS ということになります。
ここでは、DP（動的計画法）を使って、文字列 1 と文字列 2 の LCS の長さを求めるコードを考えてみます。
文字列 1 の長さを Len1、文字列 2 の長さを Len2 とします。 dp[i][j] には、文字列 1 の j 文字目までの部分文字列と、文字列 2 の i 文字目までの部分文字列を一致させた場合 LCS の長さを格納します。 まず、0 文字の部分文字列同士の LCS は当然 0 文字なので、</description></item><item><title>文字列の類似度を計算する（レーベンシュタイン距離）</title><link>https://maku.blog/p/xjw9ju7/</link><pubDate>Tue, 18 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjw9ju7/</guid><description>レーベンシュタイン距離とは レーベンシュタイン距離 (Levenshtein Distance) は、ある文字列に対して、何回の変更処理（削除、挿入、置換）を行えば対象の文字列に変換できるかを示します。
参考: Wikipedia - Levenshtein distance 参考: Wikipedia - レーベンシュタイン距離 レーベンシュタイン距離を効率的に計算するために、一般的に DP マッチング（動的計画法による距離計算）が使用されます（ここでは文字列間の距離を求めていますが、DP マッチングは単純に二つの波形を伸縮させながらマッチングするためにも使用されます）。 下記に詳細なマッチングの過程を示します。
2 つの文字列のレーベンシュタイン距離を求める 次のような文字列 A と文字列 B のレーベンシュタイン距離を求めるとします。
文字列 A = &amp;ldquo;CARROT&amp;rdquo; 文字列 B = &amp;ldquo;CAT&amp;rdquo; 文字列 A の文字数が i 文字、文字列 B の文字数が j 文字だとした場合の距離（最短変換数）を格納するための dp 配列を用意します。
dp[LenA + 1, LenB + 1] 下記の図は、この配列を表にしたものです。
セル内の数値は文字列を一致させるのに費やした変換手順数を表しており、dp[0, 0] は文字列 A も文字列 B も空文字だった場合の距離なので 0 です（空文字から空文字に変換するまでの手順数です）。 この表に左下から順番に手順数を埋めていき、最終的に右上の G が示している dp[7, 4] に文字列 A と文字列 B の距離が格納されます（&amp;ldquo;CAT&amp;rdquo; を &amp;ldquo;CARROT&amp;rdquo; に変換する手順数）。</description></item><item><title>private メソッドのユニットテストが書きたくなったら</title><link>https://maku.blog/p/nvetfsf/</link><pubDate>Thu, 16 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nvetfsf/</guid><description>private メソッドをテストすべきかどうかは色々意見がありますが、あるクラスの private メソッドの割合が、public メソッドに比べて非常に多くなった場合は、private メソッドのテストも書きたくなるかもしれません。
そのような場合は、クラス抽出のリファクタリングを考えるとよいです。 特定の処理がクラスとして抽出されれば、そのクラスを利用するインタフェースは public メソッドになるので、自然にテストを記述できるようになります。 もとのクラスの見通しもよくなり、一石二鳥です。
計算処理を担うようなメソッドはテストを記述するよい対象になりますが、private メソッドのままではテストが記述できません。 そのような場合は、public static なユーティリティメソッドに変更することで、テストを記述できるようにするとよいです。 そのメソッド内でフィールドにアクセスしないユーティリティメソッドになっていれば（ステートレス）、オブジェクトに副作用を与えることはないので、public メソッドにしても悪影響は出ません（カプセル化は崩れない）。
JxUnit のように private メソッドをテスト可能なフレームワークを使用するのもひとつの手です。 JxUnit は内部でリフレクションを利用して private メソッドのテストを可能にしています。</description></item><item><title>Android開発: ShapeDrawable で基本図形を描く</title><link>https://maku.blog/p/qj8p3eq/</link><pubDate>Sun, 03 Aug 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qj8p3eq/</guid><description>矩形の描画 private ShapeDrawable mDrawable = new ShapeDrawable(); private void draw(Canvas canvas) { mDrawable.setBounds(100, 100, 200, 200); mDrawable.getPaint().setColor(Color.YELLOW); mDrawable.draw(canvas); } 円、楕円の描画 private ShapeDrawable mDrawable = new ShapeDrawable(new OvalShape()); private void draw(Canvas canvas) { mDrawable.setBounds(100, 100, 200, 200); mDrawable.getPaint().setColor(Color.YELLOW); mDrawable.draw(canvas); }</description></item><item><title>Android開発: TextureView に関するメモ</title><link>https://maku.blog/p/2udtaq5/</link><pubDate>Thu, 24 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2udtaq5/</guid><description> 少ない数の Canvas#drawRect() や Canvas#drawText() をするなら、SurfaceView よりも描画が速い。ある程度たくさん描画すると、SurfaceView に負ける。さらにたくさん描画すると同じくらいになる。 ベンチマークを Xperia Tablet Z で取ると次のような感じ。 Rect(x100),Text(x100): SurfaceView 60fps, TextureView 80fps Rect(x500),Text(x500): SurfaceView 32fps, TextureView 27fps Rect(x1000),Text(x1000); SurfaceView 15fps, TextureView 15fps lockCanvas() ～ unlockCanvasAndPost() の中では毎回全体を描き直す必要がある。前回の描画情報が保持されることが保証されないため（TextureView#lockCanvas() の Javadoc を参照）。 SurfaceTextureListener#onSurfaceTextureDestroyed() は通常 return true するように実装する。 画面回転すると強制終了したりする（SurfaceView のときは大丈夫だった）。</description></item><item><title>macOS で JAVA_HOME に設定すべきパスを調べる（java_home コマンド）</title><link>https://maku.blog/p/7jkgzd4/</link><pubDate>Sat, 19 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7jkgzd4/</guid><description>複数の JDK がインストールされている場合にバージョンを切り替えて java (javac) コマンドを使用するには、JAVA_HOME 環境変数を設定します。 JAVA_HOME に設定すべきパスは、java_home コマンドで調べることができます。 下記は、Apple の JDK1.6、Oracle の JDK1.8 がインストールされている場合の出力例です。
$ /usr/libexec/java_home -v 1.6 /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home $ /usr/libexec/java_home -v 1.8 /Library/Java/JavaVirtualMachines/jdk1.8.0_11.jdk/Contents/Home 普段使用する JDK バージョンは、下記のように .bash_profile で設定しておけばよいでしょう。
~/.bash_profile # JDK 1.6 を使用する場合 export JAVA_HOME=$(/usr/libexec/java_home -v 1.6) # JDK 1.8 を使用する場合（デフォルト） export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</description></item><item><title>UnitTest メモ: ユニットテストの網羅レベルの種類 (C0/C1/C2)</title><link>https://maku.blog/p/aet7iu7/</link><pubDate>Fri, 04 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aet7iu7/</guid><description> C0 &amp;hellip; 「命令網羅」 全ての処理が正しく実行される C1 &amp;hellip; 「分岐網羅」 全ての条件が正しく実行される C2 &amp;hellip; 「条件網羅」 全ての組み合わせの経路が実行される</description></item><item><title>Groovy をインストールする</title><link>https://maku.blog/p/vtfddwb/</link><pubDate>Fri, 30 May 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vtfddwb/</guid><description>MacOSX に Groovy をインストールする GVM: Groovy enVironment Manager を使うと複数バージョンの Groovy を管理することができます。 ここでは、GVM を使って Groovy の環境をインストールする手順を示します。
1. GVM のインストール $ curl -s get.gvmtool.net | bash これで、.bash_profile に以下のように追加されて gvm コマンドにパスが通ります。
#THIS MUST BE AT THE END OF THE FILE FOR GVM TO WORK!!! [[ -s &amp;#34;/Users/maku/.gvm/bin/gvm-init.sh&amp;#34; ]] &amp;amp;&amp;amp; source &amp;#34;/Users/maku/.gvm/bin/gvm-init.sh&amp;#34; 2. GVM で groovy のインストール $ gvm list groovy # インストール可能なバージョン確認 $ gvm install groovy # 最新版のインストール $ gvm install groovy 2.3.2 # バージョンを指定してインストール これで、groovy や groovysh コマンドが使用できるようになります。 使用中の groovy のバージョンの確認、切り替えは以下のように行います。</description></item><item><title>数学メモ: 平均二乗誤差など</title><link>https://maku.blog/p/psotadn/</link><pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/psotadn/</guid><description>二乗平均平方根 (RMS: Root Mean Square) $$\operatorname{RMS}[x] = \sqrt{\frac{1}{n}\sum_{i=1}^n \left( x_i \right)^2}$$
各データの二乗をすべて足して平均をとり、さらに平方根をとったもの。
平均二乗平方根じゃなくて二乗平均平方根って言うんだね。
平均二乗誤差 (MSE: Mean Squared Error) $$\operatorname{MSE}=\frac{1}{n}\sum_{i=1}^n(y_i-\hat{y_i})^2$$
$y_i$ : 実際の値 $\hat{y_i}$ : 予測値 予測値とのずれの二乗をすべて足して平均をとったもの。
平均二乗誤差平方根 (RMSE: Root Mean Squared Error) $$\operatorname{RMSE}=\sqrt{\operatorname{MSE}}=\sqrt{\frac{1}{n}\sum_{i=1}^n(y_i-\hat{y_i})^2}$$
$y_i$ : 実際の値 $\hat{y_i}$ : 予測値 平均二乗誤差 (MSE: Mean Squared Error) の平方根。 実測値と予測値がどれほど異なっているかを表す。
標準偏差 標準偏差も基本的には RMSE と同じで、予測値の代わりに平均値を使っているだけ。
RMSE: 実測値と予測値のずれ 標準偏差: 実測値と（実測値の）平均値のずれ $$\operatorname{標準偏差(\sigma)}=\sqrt{\frac{1}{n} \sum_{i=1}^{n}(x_i - \bar{x})^2}=\sqrt{\frac{1}{n} \sum_{i=1}^{n}x_i^2 - \bar{x}^2}$$
$x_i$ : 実測値 $\bar{x}$ : 実測値の平均値</description></item><item><title>mongo シェルで find の結果をインデントして見やすく表示する (pretty)</title><link>https://maku.blog/p/uvusqb7/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uvusqb7/</guid><description>mongo シェルで find() を実行した結果を見やすいように整形するには、実行結果に対して pretty() を適用します。
&amp;gt; db.books.find().pretty() { &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;533973de50b35840de2dda25&amp;#34;), &amp;#34;title&amp;#34; : &amp;#34;Title 1&amp;#34;, &amp;#34;tags&amp;#34; : [ &amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34; ] } { &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;533973de50b35840de2dda26&amp;#34;), &amp;#34;title&amp;#34; : &amp;#34;Title 2&amp;#34;, &amp;#34;tags&amp;#34; : [ &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34; ] } { &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;533973de50b35840de2dda27&amp;#34;), &amp;#34;title&amp;#34; : &amp;#34;Title 3&amp;#34;, &amp;#34;tags&amp;#34; : [ &amp;#34;CCC&amp;#34;, &amp;#34;AAA&amp;#34; ] }</description></item><item><title>mongo シェルで MapReduce を実行する</title><link>https://maku.blog/p/qvkkcuj/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qvkkcuj/</guid><description>mongo シェルを使って、下記のような books コレクションに対して MapReduce をかけて、タグ情報のリスト（tags コレクション）を生成する方法を示します。
{ title: &amp;#39;Title 1&amp;#39;, tags: [&amp;#39;AAA&amp;#39;, &amp;#39;BBB&amp;#39;] } { title: &amp;#39;Title 2&amp;#39;, tags: [&amp;#39;BBB&amp;#39;, &amp;#39;CCC&amp;#39;] } { title: &amp;#39;Title 3&amp;#39;, tags: [&amp;#39;CCC&amp;#39;, &amp;#39;AAA&amp;#39;] } 作成される tags コレクションは、以下のようになることを想定しています。
{ &amp;#34;_id&amp;#34; : &amp;#34;AAA&amp;#34;, &amp;#34;value&amp;#34; : 2 } { &amp;#34;_id&amp;#34; : &amp;#34;BBB&amp;#34;, &amp;#34;value&amp;#34; : 2 } { &amp;#34;_id&amp;#34; : &amp;#34;CCC&amp;#34;, &amp;#34;value&amp;#34; : 2 } まずは、サンプルデータとなる books コレクションを作成します。
books.js use testdb; // books コレクションの初期化 db.books.drop(); db.books.save({title: &amp;#39;Title 1&amp;#39;, tags: [&amp;#39;AAA&amp;#39;, &amp;#39;BBB&amp;#39;]}); db.</description></item><item><title>Nginx の設定: Nginx でバーチャルホストを設定する（リバースプロキシ）</title><link>https://maku.blog/p/q8tw6c4/</link><pubDate>Tue, 03 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q8tw6c4/</guid><description>アクセス時のドメイン名により別の Web サーバに処理をフォワードする 例えば、http://test.example.com/ というアドレス（80番ポート）で nginx サーバにアクセスしてきたときに、localhost:7000 で動作している Web サーバに処理を委譲するには、下記のように設定します。
/etc/nginx/conf.d/test.example.com.conf server { listen 80; server_name test.example.com; location / { proxy_pass http://localhost:7000/; } } この機能を利用することで、一つの PC 内に複数の Web サーバを（異なるポート）で立ち上げておき、アクセスしてきた URL（のドメイン名）によって処理を振り分けることができます。 例えば、次のように Web サーバへのアクセスをフォワードできます。
http://aaa.example.com/ でアクセスされた場合 → localhost:7000 で処理 http://bbb.example.com/ でアクセスされた場合 → localhost:7100 で処理 http://ccc.example.com/ でアクセスされた場合 → localhost:7200 で処理 それぞれのドメインは同じ IP アドレスにマッピングされており、物理的には 1 つのマシンに対してアクセスが発生するのですが、クライアント（Web ブラウザのユーザ）から見ると、あたかも異なるホストにアクセスしているかのように見えます（ドメイン名が異なるので）。 バーチャルなホストが存在しているような動作をするということで、このような Web サーバの機能をバーチャルホストと呼びます。
また、このように、サーバ環境側（ここでは 80 ポートのサーバ）でいったんアクセスを受けておいて、アドレス等を見て別の内部サーバ（ここでは 7000 ポートで待ち受けているサーバなど）に処理をフォーワードする仕組みのことを、リバースプロキシと呼びます。
リバースプロキシというのは Web サーバのためだけの仕組みではなく、より一般的なサーバの仕組みを指す名前です。 nginx や Apache などの Web サーバのバーチャルホスト機能は、リバースプロキシの仕組み（概念）を利用して実現されているということです。</description></item><item><title>Nginx の設定: Nginx の設定ファイル (*.conf) の場所</title><link>https://maku.blog/p/pms426x/</link><pubDate>Mon, 02 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pms426x/</guid><description>nginx の設定ファイルは、/etc/nginx/nginx.conf です。 ソースからビルドする場合は、./configure の実行時にパスを指定できます。
この設定ファイルの中で、以下のように include ディレクティブが指定されているため、/etc/nginx/conf.d/ ディレクトリ内にある個別の設定ファイル (*.conf) も読み込まれるようになっています。
http { ... include /etc/nginx/conf.d/*.conf; } バーチャルホスト機能を利用して複数ドメインのサーバを運用するようなケースでは、ドメインごとに設定ファイルを分けておくと管理しやすいでしょう。 例えば、example.com ドメインのサーバ用には /etc/nginx/conf.d/example.com.conf を作成します。</description></item><item><title>Linuxコマンド: rsync コマンドで2つのディレクトリを同期する</title><link>https://maku.blog/p/c3s7wyx/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c3s7wyx/</guid><description>（Windows の場合は、WinSCP をコマンドラインで利用すると同じようなことを実現できます）。
rsync でディレクトリごとコピーする rsync コマンドを使って、src ディレクトリの内容を dst ディレクトリにコピーするには下記のように実行します。
例: src ディレクトリを dst ディレクトリにコピー $ rsync -av src/ dst # src ディレクトリの「中身」を dst ディレクトリ内へコピー $ rsync -av src dst # src ディレクトリを dst ディレクトリ内へコピー -a オプションは、パーミッションやタイムスタンプなどの情報を維持しつつ、ディレクトリを再帰的にコピーする指定をまとめて行うための archive オプションです。 -v オプションは転送情報などを出力する verbose オプションです。
上記例のように、ソースディレクトリの 最後にスラッシュをつけるかつけないかで意味が変わってくる ので注意してください。 2番目のように実行すると、結果として ./dst/src というディレクトリが作成されることになります。
コピー元にないファイルを削除する (&amp;ndash;delete) rsync コマンドはデフォルトでは、コピー先ディレクトリのファイルを削除することはありません。 コピー元 (src) に存在しないファイルを、コピー先 (dst) から削除したいときは、明示的に --delete オプションを付けて実行します。 つまり、2つのディレクトリを同じ内容にしたい（同期したい）のであれば、--delete オプションを付けて実行する必要があります。
例: src の内容を dst に同期させる（src に存在しないファイルは dst から削除する） $ rsync -av --delete src/ dst 指定した拡張子のファイルだけコピーする (&amp;ndash;include) 特定の種類のファイル（png ファイルなど）だけをコピーしたいときは、--include オプションと --exclude を組み合わせて以下のような感じで指定します。</description></item><item><title>Nginx の基本: Nginx をインストールする</title><link>https://maku.blog/p/wyeboxi/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wyeboxi/</guid><description>yum で nginx をインストールする ここでは、CentOS などの Linux 環境を想定し、nginx を yum でインストールします。 下記のような yum の設定ファイルを作成しておくことで、最新に近い nginx をインストールできるようになります。
/etc/yum.repos.d/nginx.repo [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 下記のコマンドで nginx をインストールします（バージョンアップも同じコマンドで実行できます）。
$ sudo yum install nginx インストールできたか確認するために、バージョンを表示してみましょう。
$ nginx -v nginx version: nginx/1.4.4 nginx の起動 下記のようにして nginx サーバを起動できます。
$ sudo service nginx start 動作しているかを確認。
$ sudo service nginx status nginx (pid 19996) is running... PC 起動時に nginx が自動起動するようにする nginx が無事に起動するようになったら、chkconfig でマシンの立ち上げ時に nginx が自動起動するようにしておきましょう。
nginx を自動起動するように設定 $ sudo chkconfig nginx on 設定内容の確認 $ chkconfig --list nginx nginx 0:off 1:off 2:on 3:on 4:on 5:on 6:off</description></item><item><title>Node.js で Evernote API を使用する（evernote モジュールインストールする）</title><link>https://maku.blog/p/ti537g4/</link><pubDate>Mon, 11 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ti537g4/</guid><description>Evernote API を使用するには、API キーの取得と、Sandbox 用アカウントの作成を行っておく必要があります。
API キーの取得: http://dev.evernote.com/#apikey Sandbox 用アカウントの作成: https://sandbox.evernote.com Node.js から Evernote API を使用するために、evernote モジュールをインストールします。
$ npm install evernote 下記のようにして、evernote モジュールをロードできれば準備完了です。
var Evernote = require(&amp;#39;evernote&amp;#39;).Evernote; console.log(Evernote.EDAM_VERSION_MAJOR); console.log(Evernote.EDAM_VERSION_MINOR);</description></item><item><title>Linuxコマンド: scp コマンドでファイルやディレクトリを転送する</title><link>https://maku.blog/p/buvv4fz/</link><pubDate>Sat, 09 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/buvv4fz/</guid><description>ここでは、scp を使ったファイル転送の方法を示していますが、ディレクトリ単位のファイルコピーやバックアップを行いたい場合は、rsync コマンドを使用したほうが効率的です。
ファイル送信 $ scp &amp;lt;localFile&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteFile&amp;gt; ファイル受信 $ scp &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteFile&amp;gt; &amp;lt;localFile&amp;gt; 例: リモートのホームディレクトリ内のファイルを取得 $ scp maku@maku.example.com:hello.txt hello.txt remoteFile の指定は、ホームディレクトリからの相対パスで OK です。
ディレクトリ送信 $ scp -r &amp;lt;localDir&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteDir&amp;gt; ディレクトリ受信 $ scp -r &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteDir&amp;gt; &amp;lt;localDir&amp;gt; 例: ホームディレクトリの sample ディレクトリを丸ごとダウンロード $ scp -r maku@maku.example.com:sample .</description></item><item><title>mongo シェルで各フィールドの型を調べる (typeof, instanceof)</title><link>https://maku.blog/p/yejmu4v/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yejmu4v/</guid><description>mongo シェルで、各フィールドの型（タイプ）を調べたいときは、typeof や instanceof を使用します。
フィールドの型を調べる typeof mydoc._id 指定した型のフィールドかどうか調べる mydoc._id instanceof ObjectId 参考リンク Data Types in the mongo Shell — MongoDB Manual</description></item><item><title>MongoDB の ObjectId について（Document の生成時間を調べる）</title><link>https://maku.blog/p/wdbr8dx/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wdbr8dx/</guid><description>MongoDB の各 Document（RDB でいうレコード）は、それぞれ _id というプライマリキーとなるフィールドを持っています。 この値は、何も指定しないと、自動的に ObjectId オブジェクトが生成されて設定されます。
&amp;gt; db.mycollection.insert({value:100}) &amp;gt; db.mycollection.findOne() { &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;5265e358c76d2a2f8b870057&amp;#34;), &amp;#34;value&amp;#34; : 100 } この ObjectId オブジェクトは BSON 形式 のオブジェクトで、内部的に以下のような値を保持しています。
フィールド サイズ 内容 Timestamp 4 bytes 生成時間（秒） Machine ID 3 bytes マシン固有値 PID 2 bytes プロセス ID Counter 3 bytes ランダム値から始まってインクリメントされる ObjectId オブジェクト内に含まれているタイムスタンプは、getTimestamp() メソッドによって取得できます。 これを利用すると、Document の _id フィールドから、その Document が生成された時間を調べることができます。
&amp;gt; db.mycollection.findOne()._id.getTimestamp() ISODate(&amp;#34;2013-10-22T02:30:48Z&amp;#34;) 参考リンク ObjectId — MongoDB Manual</description></item><item><title>プロダクトバックログとスプリントバックログの概念図</title><link>https://maku.blog/p/pwpgu5h/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pwpgu5h/</guid><description> 図: プロダクトバックログ</description></item><item><title>数学メモ: 任意の桁のレプ・ユニット (repeated units) を求める方法</title><link>https://maku.blog/p/29awadj/</link><pubDate>Sun, 26 May 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/29awadj/</guid><description>レプ・ユニット (repeated units) というのは、1 の連続した数字を表します（例: 1, 11, 111, 1111）。
n 桁のレプ・ユニットは、以下のような計算で求められます。
$$R_{n} = \frac{10^n - 1}{9}$$
下記は Python でこの計算をテストする例です。
repeated_units.py def repeated_units(n): return (10 ** n - 1) // 9 for i in range(1, 10): print(repeated_units(i)) 実行結果 1 11 111 1111 11111 111111 1111111 11111111 111111111 もちろん、Python のプログラムとしては、単純に繰り返し文字列を作成してから、それを数値に変換することもできます。
def repeated_units(n): return int(&amp;#39;1&amp;#39; * n)</description></item><item><title>数学メモ: 書籍『はじめての数論（原著第3版）』の練習問題メモ</title><link>https://maku.blog/p/qyohkjh/</link><pubDate>Wed, 22 May 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qyohkjh/</guid><description>練習問題 1.1 問題 平方数でも三角数でもある最初の 2 つの数は 1 と 36 である。次に小さな例を見つけよう。できれば、その次の例も見つけよう。三角数でありかつ平方数でもある数を見つける有効な方法を見つけることはできるだろうか？こうした性質をもつ数は無数にあると考えられるか？
解答 Python で三角数 (triangle number) ＝ 平方数 (square number) となる数値を見つけてみる。
#!/usr/bin/env python def triangle(k): return k * (k + 1) // 2 def square(k): return k ** 2 a = 1 b = 1 while True: tri = triangle(a) squ = square(b) if tri == squ: print(&amp;#39;triangle({}) = square({}) = {}&amp;#39;.format(a, b, tri)) a += 1 b += 1 elif tri &amp;lt; squ: a += 1 else: b += 1 if a &amp;gt; 10000000: break 実行結果 triangle(1) = square(1) = 1 triangle(8) = square(6) = 36 triangle(49) = square(35) = 1225 triangle(288) = square(204) = 41616 triangle(1681) = square(1189) = 1413721 triangle(9800) = square(6930) = 48024900 triangle(57121) = square(40391) = 1631432881 triangle(332928) = square(235416) = 55420693056 triangle(1940449) = square(1372105) = 1882672131025 数を大きくすれば、無数に見つかりそうな予感はします。</description></item><item><title>数学メモ: 累乗 (2^x) と階乗 (x!) の増え方を比べる</title><link>https://maku.blog/p/ts5mhjj/</link><pubDate>Thu, 02 May 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ts5mhjj/</guid><description>$2^x$ の値は、$x$ が増えるごとに 2倍、2倍、2倍、で増えていきます。 一方、$x!$ の値は、$x$ が増えるごとに 2倍、3倍、4倍、と増えていくので激しい増え方をします。 どちらも指数関数ですが、圧倒的に $x!$ の増え方の方が大きいです。
だからびっくりマークが付いているんですね。
値が、8 桁に到達するのは、それぞれ、
$2^{24}$ = 16777216 11! = 39916800 です。 組み合わせ問題を PC を使って総当たりで解く場合、これくらいのサイズで限界に達します（短い時間で解く場合）。 実際には、$2^{23}$ と 10! までの総当たりが限度と覚えておけばよいでしょう。
$2^x$ の増え方 $2^x$ は以下のような感じで増えます。
2**1 = 2 2**2 = 4 2**3 = 8 2**4 = 16 2**5 = 32 2**6 = 64 2**7 = 128 2**8 = 256 2**9 = 512 2**10 = 1024 2**11 = 2048 2**12 = 4096 2**13 = 8192 2**14 = 16384 2**15 = 32768 2**16 = 65536 2**17 = 131072 2**18 = 262144 2**19 = 524288 2**20 = 1048576 2**21 = 2097152 2**22 = 4194304 2**23 = 8388608 2**24 = 16777216 2**25 = 33554432 2**26 = 67108864 2**27 = 134217728 2**28 = 268435456 2**29 = 536870912 2**30 = 1073741824 2**31 = 2147483648 2**32 = 4294967296 2**33 = 8589934592 2**34 = 17179869184 2**35 = 34359738368 2**36 = 68719476736 2**37 = 137438953472 2**38 = 274877906944 2**39 = 549755813888 2**40 = 1099511627776 2**41 = 2199023255552 2**42 = 4398046511104 2**43 = 8796093022208 2**44 = 17592186044416 2**45 = 35184372088832 2**46 = 70368744177664 2**47 = 140737488355328 2**48 = 281474976710656 2**49 = 562949953421312 2**50 = 1125899906842624 x!</description></item><item><title>数学メモ: TeX の記法のメモ</title><link>https://maku.blog/p/oau2e7h/</link><pubDate>Mon, 29 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oau2e7h/</guid><description>演算子、等号（不等号） 演算子 $a+b$ a+b (plus) $a-b$ a-b (minus) $a \times b$ a \times b (multiplied by, times) $a \pm b$ a \pm b (plus or minus) 等号・不等号 $x+y = z$ x+y = z (equal to) $x+y \equiv z$ x+y \equiv z (identical to) （定義・合同） $x+y \neq z$ x+y \neq z (not equal to) $x+y \lt z$ x+y \lt z (less than)（そのまま &amp;lt; でも OK） $x+y \gt z$ x+y \gt z (greater than)（そのまま &amp;gt; でも OK） $x+y \leq z$ x+y \leq z (less than or equal to) $x+y \geq z$ x+y \geq z (greater than or equal to) $x+y \ll z$ x+y \ll z (much less than) $x+y \gg z$ x+y \gg z (much greater than) 近似 $x+y \sim z$ x+y \sim z (similar) $x+y \simeq z$ x+y \simeq z (similar equal) $x+y \approx z$ x+y \approx z (approximately equal) 対数 (logarithm) $\log x$ \log x $\log_2 x$ \log_2 x 対数の底が 2 場合 $\log_{10} x$ \log_{10} x 常用対数 (common logarithm) $\ln x$ \ln x 自然対数 (natural logarithm) 10 を底とする対数を常用対数 (common logarithm) と呼びます。 また、ネイピア数 $\mathrm{e}$ を底とする対数を、自然対数 (natural logarithm) と呼びます。 自然対数はラテン語で logarithmus naturalis なので、ln と略します。</description></item><item><title>数学メモ: 公式 - 二次方程式の解</title><link>https://maku.blog/p/x3d286c/</link><pubDate>Mon, 29 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3d286c/</guid><description>$ax^2 + bx + c = 0$ の解は、$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$ になります。
元の式を平方完成して、$$a(x + \frac{b}{2a})^2 - \frac{b^2}{4a} + c$$ の形にして計算すると上の式を導くことができます。</description></item><item><title>業務プロセスの表記法 (BPMN)</title><link>https://maku.blog/p/47ogzwo/</link><pubDate>Mon, 22 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/47ogzwo/</guid><description>BPMN (Business Process Modeling Notation) の概要 BPMN.org - http://www.bpmn.org/ アメリカの非営利団体である BPMI (Business Process Management Initiative) が策定。 BPM (Business Process Management) を進める際の標準記述言語。 BPMN は、業務フローを図にするときの表記法を定義しています。業務フローの図って、誰が描いても大体同じような感じになるものだけど、表記法の標準があるのであれば、それを使うのがよいですね。
大まかには、以下のような記号を使って描いていきます。
丸 &amp;ndash; イベントの発生、終了 四角 &amp;ndash; タスク 菱形 &amp;ndash; 分岐 矢印（実線） &amp;ndash; シーケンスのフロー 矢印（点線） &amp;ndash; データのフロー それぞれのタスクを担当する組織などを表現したい場合は、全体のフローを短冊状に区切って表現すれば OK。これも一応、Swimlane という記法として定義されてます。
参考サイト: 情報システム用語事典：BPMN（びーぴーえむえぬ） - ITmedia エンタープライズ</description></item><item><title>ソフトウェアテストに関するリンク</title><link>https://maku.blog/p/6f8k3ns/</link><pubDate>Mon, 25 Mar 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6f8k3ns/</guid><description> ソフトウェアテスト標準用語集 2012-04-01 時点で Version 2.1</description></item><item><title>HTTP ヘッダに関するメモ</title><link>https://maku.blog/p/3kkchub/</link><pubDate>Sat, 15 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3kkchub/</guid><description>HTTP1.1 Host 指定 HTTP1.1 では、メッセージヘッダーに Host: &amp;lt;ドメイン&amp;gt; の指定が必須です（これが唯一の必須ヘッダーです）。 これは、1 台の Web サーバーで複数のドメインを運用する、バーチャルホストの機能を実現するために必要とされています。 Web サーバーは、Host ヘッダーで示されたドメイン名と、相対 URI (/index.html など）を組み合わせて、実際のどのリソースを返すかを判断します。 HTTP1.0 を使う場合は、Host: の指定は必要ありません。
HTTP キープアライブ HTTP1.1 では、最初にスリーウェイハンドシェイクしたら、そのコネクションを一定時間使い続けることで、複数のリソースファイルの取得を効率化しています。 これを HTTP キープアライブ (KeepAlive) といい、HTTP1.1 では標準の振る舞いになっています（HTTP ヘッダーに Connection: keep-alive が付いていると考えるが規定の動作)。 例えば、ブラウザで Web ページを開くと、HTML ファイルだけではなく、CSS ファイルや画像ファイルなどのリソースを取得するために複数のリクエストが発行されますが、そこでは同じコネクションが使用されます。
コネクションの切断は、サーバーが設定しているタイムアウト時間を過ぎたときに行われますが、クライアントあるいはサーバーが Connection: close ヘッダーを含めることで、切断する意志を伝えることができます。
プロキシ経由時の「リクエスト行」の URI について プロキシサーバを介する場合は、リクエスト行に 絶対アドレス指定 で URI を指定する必要があります。 これは、リクエストを受け取ったプロキシサーバが、リクエストの転送先サーバを判断するためです。 逆に、プロキシを使わない場合は、リクエスト URI は相対パスで指定します。
Client ｜ ｜ GET http://target.example.com/index.html HTTP/1.1 ▽ Proxy server ｜ ｜ GET /index.html HTTP/1.1 ▽ target.</description></item><item><title>数学メモ: 公式 - 二項定理</title><link>https://maku.blog/p/draiajt/</link><pubDate>Sat, 10 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/draiajt/</guid><description>二項定理の公式 $$(a+b)^n=\sum_{r=0}^{n} {}_n \mathrm{C}_r a^{n-r}b^{n}$$
例: 2乗の場合 $$ \begin{aligned} (a+b)^2 &amp;amp;= \sum_{r=0}^{2} {}_2 \mathrm {C}_r a^{2-r}b^r \\ &amp;amp;= {}_2 \mathrm{C}_0 a^2b^0 + {}_2 \mathrm{C}_1 a^1b^1 + {}_2 \mathrm{C}_2 a^0b^2 \\ &amp;amp;= a^2 + 2ab + b^2 \end{aligned} $$
例: 3乗の場合 $$ \begin{aligned} (a+b)^3 &amp;amp;= \sum_{r=0}^{3} {}_3 \mathrm{C}_r a^{3-r}b^r \\ &amp;amp;= {}_3 \mathrm{C}_0 a^3b^0 + {}_3 \mathrm{C}_1 a^2b^1 + {}_3 \mathrm{C}_2 a^1b^2 + {}_3 \mathrm{C}_3 a^0b^3 \\ &amp;amp;= a^3 + 3a^2b + 3ab^2 + b^3 \end{aligned} $$</description></item><item><title>ソフトウェア開発手法のまとめ</title><link>https://maku.blog/p/herfwex/</link><pubDate>Sun, 04 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/herfwex/</guid><description> XP (eXtream Programming) Kent Beck が指揮。 12 のプラクティスがあり、それぞれが連携している。 顧客との連携を重視する。「オンサイト顧客」というプラクティスでは、開発チームに顧客を含めてしまう。 SCRUM マイクロソフトで発祥。 マネジメントに焦点を当てたプロセス。 それぞれの役割に、強い権力付けがされているのが特徴。 1ヶ月のスプリントの間、スクラムマスターはスクラムチームを外の雑音から守る。 約10分で終わるスタンドアップミーティングで一日を始める。 クリスタル Alistair Cockburn が提唱するプロジェクトのテンプレート群。 メンバー数などから、クリスタルクリア、イエロー、オレンジ、レッドと分類される。 規模が大きくなると、ドキュメントを多く作るような規則になっていく。 ASD (Adaptive Software Development) Jim Highsmith と Sam Bayer が作成。 RAD (Rapid Application Development) の考えから作成されたアジャイル開発プロセス。 複雑性の理論により、「Speculate（推測） ➡ Collaborate（強調） ➡ Learn（学習）」の繰り返しでプロジェクトを順応させていく。 大規模開発は、メンバー数を増やすことで可能にする。 リーン開発 Poppendieck 夫妻が提唱。 無駄を省きながらプロジェクトを進める開発手法。 プロジェクト開発中の待ち時間になっている部分を少なくすることでプロジェクトを短期間に終わらせようとする考え。 FDD (Feature Driven Development) ボーランドが提唱。 開発の単位を「機能」とする。 機能のリリースは2週間単位。 機能の完成度は「赤：未着手」「黄：作業中」「緑：完成」の3段階のみで表現。 機能単位で担当を割り当てる。クラス単位で担当を決めることで、人同士のやり取りが、クラス間のやり取りに等しくなるという利点がある。 TDD (Test Driven Development) XP と同じ Kent Beck が提唱。 XP のテストファーストの考え方を、プロセス全体に適用したもの。 GUI の開発であっても、クラスを疎結合にすることで、テストの自動化を考える。</description></item><item><title>電子署名と電子証明書の基礎</title><link>https://maku.blog/p/fzwyf7z/</link><pubDate>Fri, 28 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fzwyf7z/</guid><description>電子署名と電子証明書の話がごっちゃになってることが多いので、まとめておきます。
電子署名（デジタル署名）(digital signature) 「電子署名」とは、送信するデータに付加されるもので、そのデータの作成者やデータが改ざんされていないことをを確認するためのものです。 別の言い方をすると、受け取ったデータが第三者によって作られた 偽物でないことを確認するための印 です。
以下のような手順で、データが偽物でないかを確認します。
データ送信側の「電子署名の作成」手順 送信するデータのメッセージダイジェスト（ハッシュ値）を求める。 メッセージダイジェストを非公開鍵 (private key) で暗号化し、「電子署名」とする。 データ送信時には、データと「電子署名」を一緒に送る。 データ受信側の「電子署名の確認」手順 受信したデータのメッセージダイジェスト（ハッシュ値）を求める。 受信した「電子署名」を「送信者の公開鍵」で復号化し、メッセージダイジェストに戻す。 1 と 2 のメッセージダイジェストが等しければ、本人が作成したデータだと分かる。 上記の手順からも分かるように、一般的に「電子署名」の仕組みには、公開鍵暗号方式 が用いられます。 問題は、「送信者の公開鍵」の交換方法が定義されていないことです。 偽物の公開鍵が使われると、なりすましができてしまいます。 データの受信者は、何らかの方法で「本物の送信者の公開鍵」を取得しなければいけません。
もちろん、公開鍵を手渡しで渡せれば安全ですが、不特定多数のサーバーとの通信のたびにそんなことはやっていられません。 そこで、公開鍵が本物であるかを証明するための、「電子証明書」が必要になってきます。 電子証明書の仕組みを使うと、通信相手の Web サーバーから、直接そのサーバーの公開鍵を取得できるようになります。
電子証明書（デジタル証明書) (digital certificate) 電子証明書とは？ 公開鍵が偽物であると、公開鍵暗号方式は意味をなさなくなるため、公開鍵の正当性を証明することが重要になってきます。 電子証明書は、ある公開鍵が本物であることを証明する ためのものです。 大まかに書いてしまうと、公開鍵を次のようにパッケージングしたものです。
電子証明書 = 公開鍵 &amp;#43; 本物の公開鍵であることを示す署名 電子証明書の発行（公開鍵への署名） 電子証明書は、公開鍵が本物であることを示すためのものですが、その電子証明書自体が本物であることを示すために、末尾に電子署名 が付加されます。 その署名は、公開鍵を作成したユーザが行うこともあるし（オレオレ証明書）、信頼のおける第三者が行うこともあります。 通常は、信頼のおける第三者機関である 認証局 (CA: Certificate Authority) が電子証明書への署名を行い、電子証明書の発行を行います。
☝️ CA の署名は本物か 電子証明書は、そこに含まれている公開鍵が正しいものかどうかを、CA 署名で確認できるようにしたものですが、その CA 署名自体が本物なのかという問題があります。 CA 署名の真正性も電子証明書によって確かめます。 Windows や macOS などの OS には、有名どころの CA の電子証明書（ルート CA 証明書）があらかじめインストールされており、サーバー証明書内の CA 署名が本物であるかを調べられるようになっています（参考: macOS で利用できるルート証明書の一覧）。</description></item><item><title>Doxygen のコメントの書き方: メンバ変数の行末コメント</title><link>https://maku.blog/p/n83ryrp/</link><pubDate>Tue, 10 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n83ryrp/</guid><description>メンバ変数の後ろにドキュメント・ブロックを置くことができます。
class Hoge { ... int var1; ///&amp;lt; ドキュメント int var2; //!&amp;lt; ドキュメント int var3; /*!&amp;lt; ドキュメント */ int var4; /**&amp;lt; ドキュメント */ }; enum の各エントリに対しても同様にドキュメントを記述することができます。 このように、行末に1行で記述したドキュメントは、Brief description として扱われます。</description></item><item><title>XAMPP/Apache の DocumentRoot を設定する</title><link>https://maku.blog/p/6h47cno/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6h47cno/</guid><description>httpd.conf を編集 例えば、Mac OSX にインストールした XAMPP の Apache の場合は、/Applications/XAMPP/xamppfiles/etc/httpd.conf を編集します。
(1) DocumentRoot の変更 DocumentRoot &amp;#34;/Applications/XAMPP/xamppfiles/htdocs&amp;#34; ↓ DocumentRoot &amp;#34;/Users/maku/website/public_html&amp;#34; (2) 対応する Directory ディレクトリの変更 &amp;lt;Directory &amp;#34;/Applications/XAMPP/xamppfiles/htdocs&amp;#34;&amp;gt; ↓ &amp;lt;Directory &amp;#34;/Users/maku/website/public_html&amp;#34;&amp;gt; トラブルシューティング http://localhost/ にアクセスしたときに以下のようなエラーが出た場合は、DocumentRoot に設定したディレクトリのパーミッションを確認します。
Access forbidden! You don&amp;#39;t have permission to access the requested directory. There is either no index document or the directory is read-protected. 例えば、DocumentRoot として、/aaa/bbb/ccc を設定した場合、/aaa、/aaa/bbb、/aaa/bbb/ccc 全てに read パーミッションがついている必要があります。
$ chmod 0755 /aaa $ chmod 0755 /aaa/bbb $ chmod 0755 /aaa/bbb/ccc</description></item><item><title>Unicode 関連リンク</title><link>https://maku.blog/p/dn3okad/</link><pubDate>Fri, 27 Apr 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dn3okad/</guid><description> Omniglot &amp;ndash; Language index http://www.omniglot.com/writing/languages.htm 言語ごとに Glyph の一覧を確認できます Unicode Codepoint Chart http://inamidst.com/stuff/unidata/ Unicode のブロックごとに Glyph を確認できます。 Unicode.org &amp;ndash; Languages and Scripts http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/languages_and_scripts.html 言語と、Unicode Script のマッピングを確認できます。 Unicode.org &amp;ndash; Scripts.txt http://unicode.org/Public/UNIDATA/Scripts.txt Unicode Script に対する Code point を確認できます。 Unicode.org &amp;ndash; CodeChart http://www.unicode.org/Public/6.1.0/charts/CodeCharts.pdf Unicode すべての文字一覧（80MB 以上） ISO15924 http://www.unicode.org/iso15924/ http://www.unicode.org/iso15924/iso15924-codes.html 4 文字のスクリプトコードを定義しています。</description></item><item><title>Insertion Sort（挿入ソート）の実装練習</title><link>https://maku.blog/p/axg4xms/</link><pubDate>Tue, 10 Apr 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/axg4xms/</guid><description>Insertion Sort 実装の練習！ void insertion_sort(int vals[], int size) { for (int i = 1; i &amp;lt; size; ++i) { // Insert vals[i] into the sorted sequence vals[0..i-1]. int key = vals[i]; int j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; vals[j] &amp;gt; key) { vals[j + 1] = vals[j]; --j; } vals[j + 1] = key; } } 降順ソート (descending order) にするには、vals[j] &amp;gt; key というところを、vals[j] &amp;lt; key にするだけで OK。</description></item><item><title>数学メモ: 駒大数学科の問題</title><link>https://maku.blog/p/iju5ion/</link><pubDate>Tue, 20 Mar 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iju5ion/</guid><description>ビートたけしの『駒大数学科』で出てきた問題で、中村先生の解答がかっこよかったのでメモメモ。
問題 「3で割ると2余る」「5で割ると3余る」「11で割ると9余る」整数のうち、1000以下の最大のものを求めよ。 解答 以下のように、それぞれを「○の倍数＋□」という表現に変えて、□ のところを強引に合わせる。
「3で割ると2余る」→「3の倍数+1」−2 と考える 「5で割ると3余る」→「5の倍数」−2 と考える 「11で割ると9余る」→「11の倍数」−2 と考える すると、答えとなる数は次のように表現できる。
$$(3m+1) \times 5 \times 11 - 2$$
これが、1000 より小さい数になればよいので、m=5 のときの 878 という値が正解となる。</description></item><item><title>Linuxメモ: apt (apt-get) コマンドの使い方メモ</title><link>https://maku.blog/p/rdq2cnx/</link><pubDate>Tue, 21 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq2cnx/</guid><description>apt と dpkg の違い Debian/Ubuntu 系 Linux のパッケージ管理には apt (apt-get) コマンドを使いますが、 Low-Level なパッケージ管理コマンドとして dpkg コマンドも備えています。
参考: DebianPackageManagement - Debian Wiki 参考: AptCLI - Debian Wiki dpkg コマンドは純粋にシステムにパッケージをインストールする部分のみを担うため、インターネットからパッケージをダウンロードしたり、依存関係を自動解決したりする仕組みは備えていません。 そこで、apt は dpkg をラップする形でこれらの機能を提供します。
dpkg &amp;hellip; Debian/Ubuntu にパッケージをインストールする仕組み apt &amp;hellip; パッケージの依存関係を解決してダウンロードし、パッケージをインストールする仕組み（ただし、インストールには内部的に dpkg が使われる） apt と apt-get の違い 2016 年にリリースされた Ubuntu 16.04 の頃から、apt-get コマンドの代わりに apt コマンドが使われるようになりました。 2020 年にリリースされた Ubuntu 20.04 でも apt-get、apt-cache コマンドは使用可能ですが、今後は主に apt コマンドを使っていくことになりそうです。
apt はもともと Linux Mint ユーザーによって作られたコマンドで、これまで apt-get や apt-cache などに散らばっていたコマンド群を整理して使いやすくしています。</description></item><item><title>Linuxメモ: デバイスドライバ作成の雑多メモ</title><link>https://maku.blog/p/tm4iwbq/</link><pubDate>Wed, 08 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tm4iwbq/</guid><description> デバイスドライバは kernel 空間で動作するプログラムで、kernel の機能を使って実装することができる。一方、通常のプログラムはユーザランドで動作する。 デバイスドライバは kernel 自体に組み込んでしまう方法と、ローダブルモジュールとして動的にロード (insmod)、アンロード (rmmod) できるようにする方法がある。 ユーザランドで動作する普通のプログラムが、デバイスドライバの機能を使うには、デバイスファイルを介してアクセスする。 デバイスファイルの操作は、open、close、read、write のような基本的なファイル操作関数を使用する。</description></item><item><title>読書メモ『ファミコンの驚くべき発想力 －限界を突破する技術に学べ－』松浦健一郎</title><link>https://maku.blog/p/ym2pdnb/</link><pubDate>Sun, 15 Jan 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ym2pdnb/</guid><description>ファミコンの驚くべき発想力 －限界を突破する技術に学べ－ 松浦 健一郎、司 ゆき 技術評論社 前半はファミコンの CPU 6502 についての仕様の話が続いてちょっと退屈だけど、後半はドルアーガの迷路生成のアルゴリズムなどが書いてあって面白いです。 実は迷路生成はランダムだけど、乱数生成のシードを工夫したりして、ユーザには規則性があると思わせているところはなるほどと思いました。
基本的には読み物形式で進んでいくのですが、技術的な話題として、加算、減算だけで実現する乗算、除算のアルゴリズムや、ファミコンのスプライトやラスタースクロールの仕組み、垂直帰線期間、水平帰線期間の話など、現在のプログラマでも知っておいたほうがよい知識を幅広く扱ってます。
個人的に面白いと思ったのは、初期のドラクエのゲーム内で使われるカタカナが
イ・カ・キ・コ・シ・ス・タ・ト・ヘ・ホ マ・ミ・ム・メ・ラ・リ・ル・レ・ロ・ン の 20 文字に制限されていて（ROM の容量制約）、呪文もこれらの組み合わせだけで作られているというところでした。
ホイミ、メラ、ギラ、マホカンタ、、、確かに！</description></item><item><title>数学メモ: 頂点の重心と面の重心</title><link>https://maku.blog/p/v2y4dwt/</link><pubDate>Fri, 16 Dec 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v2y4dwt/</guid><description>頂点の重心 数学的な求め方: 各頂点のx座標、y座標を平均する 物理的な意味: 各頂点におもりを付けて、各頂点から張った糸をまとめて吊り上げて平行になる点が、頂点の重心。 面の重心 数学的な求め方: 面を三角形に分割し、それぞれの三角形の重心を求め、各三角形の面積を重みとして重み付き平均を求める 物理的な意味: 図形の一点に穴を開けて壁などに吊るし、垂直な線を引く。これをもう一カ所の点で同じことをして、線が交わる場所が面の重心。 性質 三角形、長方形、平行四辺形において、頂点の重心と面の重心は一致する。 三角形の重心は、中線（頂点と向かい合う辺の中点を結ぶ線）が交わるところ。 四角形の重心は、向かい合う頂点を結んだ線が交わるところ。</description></item><item><title>JavaFX2 で CheckBox を ScrollPane に並べる</title><link>https://maku.blog/p/j6jv8iu/</link><pubDate>Mon, 10 Oct 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6jv8iu/</guid><description>Main.java import javafx.application.Application; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.control.CheckBox; import javafx.scene.layout.VBox; import javafx.scene.paint.Color; import javafx.stage.Stage; public class Main extends Application { public static void main(String[] args) { launch(args); } private Group createRootGroup() { CheckBox cb1 = new CheckBox(&amp;#34;First&amp;#34;); CheckBox cb2 = new CheckBox(&amp;#34;Second&amp;#34;); CheckBox cb3 = new CheckBox(&amp;#34;Third&amp;#34;); // Align vertically VBox vbox = new VBox(); vbox.setSpacing(10); vbox.getChildren().add(cb1); vbox.getChildren().add(cb2); vbox.getChildren().add(cb3); // Add to the root Group root = new Group(); root.</description></item><item><title>JavaFX2 で HelloWorld（ウィンドウの表示）</title><link>https://maku.blog/p/haq7myf/</link><pubDate>Mon, 10 Oct 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/haq7myf/</guid><description> Main.java import javafx.application.Application; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.paint.Color; import javafx.stage.Stage; public class Main extends Application { public static void main(String[] args) { launch(args); } @Override public void start(Stage primaryStage) { Group root = new Group(); Scene scene = new Scene(root, 400, 300, Color.GRAY); primaryStage.setScene(scene); primaryStage.show(); } }</description></item><item><title>Android開発: Handler.post した Runnable タスクがメインスレッドで実行される仕組み</title><link>https://maku.blog/p/9ne93oc/</link><pubDate>Mon, 08 Aug 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9ne93oc/</guid><description>Android プログラムで UI 操作を行う場合は、その処理はアプリのメインスレッドから行わなければいけません（Android に限らずほとんどの OS で同じような感じです）。 Activity の onCreate メソッドなどを呼び出しているのがそのアプリのメインスレッドであり、Android ではイコール UI スレッドです。 タイマー処理などで、UI を更新する場合はこのメインスレッドから行う必要があり、新しく立ち上げた別のスレッドから UI を更新することはできません。
このようなケースで利用できるのが android.os.Handler クラスです。 Handler#post メソッドに Runnable オブジェクトを渡すと、最終的にその Handler オブジェクトを生成したスレッドで Runnable オブジェクトの run メソッドが実行されるようになっています。 つまり、Handler オブジェクトを Application のメインスレッドから（例えば Activity のフィールドとして）生成しておけば、そこに post した Runnable タスクは、メインスレッドで実行されることが保証されます。
Handler#post メソッドは、内部的にはスレッドローカルな Looper に結び付けられた MessageQueue オブジェクトに処理をキューイングしています。 Handler オブジェクトをメインスレッドから生成すれば、メインスレッド上の MessageQueue と結び付けられ、その MessageQueue が Looper によってメインスレッド上で処理されるという流れになっています。
別の言い方をすれば、メインスレッドの MessageQueue に対して、Runnable タスクを投入するためのインタフェースとなるのが Handler オブジェクトというわけです。</description></item><item><title>秀丸: カラーマーカーを設定してジャンプする</title><link>https://maku.blog/p/2bqp8i3/</link><pubDate>Thu, 14 Jul 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2bqp8i3/</guid><description>秀丸のメニューから、その他 → キー割り当て で以下のような感じでショートカットキーを設定しておくと、任意の行にさくっとブックマークできるので便利です。
現在行をマーク/マーク解除 &amp;ndash; Alt+Ctrl+Right マーク一覧 &amp;ndash; Alt+Ctrl+Left マーク行の下検索 &amp;ndash; Alt+Ctrl+Down マーク行の上検索 &amp;ndash; Alt+Ctrl+Up あとは、以下のようにマークした行全体を強調するようにすると見やすくなります。
その他 → ファイルタイプ別の設定 → デザイン/表示 と辿る マークした行全体をカラー表示 にチェック</description></item><item><title>Linuxコマンド: テンポラリディレクトリを作成する (mktemp)</title><link>https://maku.blog/p/oo32y2x/</link><pubDate>Thu, 30 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oo32y2x/</guid><description>mktemp コマンドを使用して、一時ディレクトリを作成することができます。
$ mktemp -d /tmp/tmp.LE04SMiEzq mktemp コマンドは、作成したファイルやディレクトリのパスを表示するので、シェルスクリプト内で以下のようにすれば、そのパスを変数に格納することができます。
tempdir=`mktemp -d`</description></item><item><title>Linuxコマンド: ディレクトリのサイズを調べる (du)</title><link>https://maku.blog/p/95pkhzc/</link><pubDate>Wed, 29 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/95pkhzc/</guid><description>du コマンドを使って、ディレクトリ内のファイルの合計サイズを調べることができます。
$ du -hs mydir 685M mydir 各オプションは次のような効果があります。
-h (--human-readable) &amp;hellip; 人に読みやすい単位でサイズ表示します（例: 1K、234M、2G） -s (--summarize) &amp;hellip; 合計サイズのみを表示します サイズ部分だけを表示したい場合は、cut コマンドで 1 番目のフィールドを切り出してしまうのが手っ取り早いです。
$ du -hs mydir | cut -f1 685M</description></item><item><title>Linux の system 関数で任意のプログラムを実行する</title><link>https://maku.blog/p/neegpac/</link><pubDate>Wed, 22 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/neegpac/</guid><description>Linux の system 関数は、プログラムの起動に失敗すると -1 を返します。 また、戻り値を WEXITSTATUS マクロにかけると、呼び出したプログラム自体の終了コード（正常時は 0）を取得することができます。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; // system(), WEXITSTATUS bool doSystem(const char* command) { int ret = system(command); if (ret == -1) { fprintf(stderr, &amp;#34;ERROR: Cannot execute [%s]\n&amp;#34;, command); return false; } int exitStatus = WEXITSTATUS(ret); if (exitStatus != 0) { fprintf(stderr, &amp;#34;ERROR: [%s] returns error %d\n&amp;#34;, command, exitStatus); return false; } return true; }</description></item><item><title>Linuxコマンド: ファイルの MIME メディアタイプを調べる (file)</title><link>https://maku.blog/p/6i7dvxj/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6i7dvxj/</guid><description>file コマンドに -i オプションを付けて実行すると、そのファイルの MIME タイプを調べることができます。
$ file -i sample.txt sample.txt: text/plain; charset=us-ascii</description></item><item><title>Linuxコマンド: ファイルの内容を8進数や16進数でダンプする (od)</title><link>https://maku.blog/p/cw7ekxc/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cw7ekxc/</guid><description>od コマンドの基本（8 進数でダンプする） od (octal dump) コマンドを使用すると、ファイルの内容を 8 進数や 16 進数でダンプすることができます。
ファイル内容を 8 進数でダンプする $ od sample.jar | head -5 0000000 045520 002003 000024 000010 000010 122216 037257 000000 0000020 000000 000000 000000 000000 000000 000024 000000 042515 0000040 040524 044455 043116 046457 047101 043111 051505 027124 0000060 043115 106505 005313 030302 042420 001767 103771 040374 0000100 072502 121341 133273 020473 145340 106255 044315 007207 先頭のカラムはアドレスを示しています。
アドレスの後ろからは、6 文字ずつに区切って 8 進数のデータが並びます。 8 進数では 1 文字が 3 ビットなので、6 文字で最大 18 ビットを示すことができますが、od コマンドの出力では、その内の 16 ビット（= 2 バイト）を使用しています。 頭の 2 ビットは必ず 0 でパディングされているので、各カラムの先頭の数字は 0 か 1 になります（アスキーコードのテキストなら必ず 0 でしょう）。</description></item><item><title>CPU のアーキテクチャ名と CPU 名の対応表</title><link>https://maku.blog/p/v7bxgmn/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v7bxgmn/</guid><description>Intel 系 CPU アーキテクチャ名 CPU名 i386 80386 i486 80486 i586 Pentium, MMX Pentium i686 Pentium Pro, Pentium II, Pentium III, Pentium 4 athlon Athlon, Athlon MP, Athlon XP x86_64 Opteron, Athlon64, Xeon (EM64T), Core, Core2Duo メモ x86 (IA-32) Intel 社の 8086 系のプロセッサの略称。（binary hacks より） x86_64 (AMD64) AMD が設計した x86 上位互換の 64 ビットプロセッサのアーキテクチャ。（binary hacks より）</description></item><item><title>Linuxメモ: デバイスドライバのライセンスについて</title><link>https://maku.blog/p/89tt5ie/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/89tt5ie/</guid><description>デバイスドライバを Linux カーネルに直接取り込む（静的リンクする）場合は GPL になります。 Linux カーネル自体が GPL なので、ドライバも GPL になるということです。 このようなドライバはランレベル 1 でロードされます。
カーネルモジュール（ローダブルモジュール）としてドライバを動的にロードする場合は、ライセンスは開発者が決めることができます。 通常はランレベル 3 になった時点で、insmod や modprobe コマンドでロードします。
カーネルモジュールとして作成するドライバのライセンスは、 コードの中で以下のように MODULE_LICENSE マクロを使用して指定します。
MODULE_LICENSE(&amp;#34;Dual BSD/GPL&amp;#34;); ライセンスは以下のものから選択することができます。
GPL GPL v2 GPL and additional rights Dual BSD/GPL Dual MIT/GPL Dual MPL/GPL Proprietary # default</description></item><item><title>読書メモ『外国語上達法』千野栄一</title><link>https://maku.blog/p/crfin42/</link><pubDate>Fri, 27 May 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/crfin42/</guid><description> 外国語上達法 千野栄一 岩波書店 ポイントメモ はじめに 決して忘れていはいけない忠告「忘れることを恐れるな」。 目的と目標 「なんでこの外国語を習うのか」ということを明確にする。 必要とする量だけ学習する。 どの言語を三拍子揃った言語にし、どの言語を受け身な読めるだけの言語にするかをよく考える。 本を読んで理解が出来ればいい言語を、書いたり話したりできるようにするのは、無駄な努力である。 必要なもの 外国人に日本語を教え、かわりにその外国語を学ぶというのはよく聞くが、そうやっても上達しないのはお金を使っていないから。 1日に6時間ずつ4日やるより、2時間ずつ12日した方がいい。 覚えなければいけないのはたったの2つ「語彙と文法」。 まずは単語を知らなくては駄目。 次の3つが揃っているのが望ましい「いい教科書」「いい教師」「いい辞書」。 語彙 まず何はともあれ、やみくもに千の単語を覚えることが必要。 千の単語を覚えるのに辞書を引くのは無駄。辞書を使うのはもっと後のことで、この段階ではすでに訳のついている単語を覚える。 千語習得の時間は短くなければならず、そこで十分に時間をとれるときに新しい言語を学び始めるように計画する。 確実な500語は、不確実な2000語より、その言語を習得するのに有効である。 頻度数の高いものから覚えるべき。 大体どの言語のテキストでも、3000語覚えれば、テキストの90％は理解できる。 頻度数の高い語は原則として短い。短い語はなるべく覚えた方がいい。 文法 母語と外国語ではどこが違うかに細かく気を配れる人にとっては、文法はとても面白い分野である。 文法は補助手段であり学習の目的ではない。 多くの人が必要とするのは文法の基礎的知識である。 黒枠に入っている変化表は全部覚えなければならない。 1冊の学習書の中の変化表を全部切り抜いてビッシリ張り直すと、大体10ページくらいになる。 最初の1、2ヶ月のうちに、この10ページを徹底的に覚える。そして何度も繰り返す。 不規則変化するものは、基本語彙であり、頻度数が高く、この表も重要である。 教科書 語学書は薄くなければならない。とりわけ、初歩の学習書はそうである。 新しく出て来た単語が、次の課で再び登場するようなテキストがいいテキストである。 関係のない文を集めているテキストより、1つのテーマで貫かれているテキストがよい。 例文はそのまま実際に使ってもいい文からのみできているべきである。 辞書 辞書を上手に使うには、編集主幹のはしがき、編集の方針、使い方の指示を必ず読む。少しのスペースの中に編集者の血の滲むような思いが込められている。 自分の程度にあった学習辞典を見つけるのは、語学攻略の大事なポイント。 学習辞典に出ていない単語に出会ったら、その単語は当分覚えなくていいと思うべき。 発音 後になってよくない発音を矯正するのは、困難というより不可能に近い。 発音に関しては初めが肝心である。 レアリア チェコ語に「レアーリエ」(reálie) という語があり、「ある時期の生活や文芸作品などに特徴的な細かい事実や具体的なデータ」という説明がついている。 「レアリア」の知識が、外国語の上達にとってはとても大切。 英語を母語として話す人なら当然知っていることを、外国語として英語を使う人は知らないことがある。レアリアはこの差を補っていこうとするもの。 人名にせよ地名にせよ、固有名詞はその最たるもので、それらを知っているか知らないかは、全体の理解に大きな影響を持っている。 その外国語を支えている文化、歴史、社会……という様々な分野の知識を身につけておけば、それは外国語の理解の際に、まるで隠し味のように後から効いてくる。 まとめ 短時間ものすごく集中することより、学習を規則的に持続していくこと。 繰り返しは忘却の特効薬。 たとえ短い時間でも毎日することが大切で、減食やジョギングと同じように少しずつでも毎日する方がいい。 2つの原語より3つの言語、3つの言語より4つの言語と進むにつれて、その人の視野は複眼的になり、物事の違った面が見えてくる。ただ、その言語が使い物になることがその条件。</description></item><item><title>Android開発: LowMemoryKiller の動きのメモ</title><link>https://maku.blog/p/7s4vnax/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7s4vnax/</guid><description>Android の lowmemorykiller では、最もメモリを使っていて、oom_adj の値が大きいものが殺されます。
oom_adj の値は、/proc/&amp;lt;Process ID&amp;gt;/oom_adj に書かれた値です。 本来は Linux の oom (Out of memory) killer が使うファイルですが、Android の lowmemorykiller もこのファイルを使っています。
oom_adj の値は -16～15 をとり、小さいほど殺されにくくなります。デフォルトは 0 です。 ただし、oom_adj に OOM_DISABLE (-17) を設定すると、lowmemorykiller の対象外になるようです。
oom_adj の値を確認したり、強引に変更したい場合はこんな感じ。
# cat /proc/1234/oom_adj 0 # echo -16 &amp;gt; /proc/1234/oom_adj</description></item><item><title>辞書アプリのアイデア</title><link>https://maku.blog/p/ticmqdo/</link><pubDate>Sat, 23 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ticmqdo/</guid><description>辞書ソフト (MemDic) アイデア、コンセプト Web 上にある辞書のデータはそのまま活かしたいので、基本は Web 上の辞書をマッシュアップ（プラグイン形式）で検索。Web 上に存在しない語句は独自で追加できるようにする。Web 上に存在する語句についても、コメントなどを追加できるようにする。 タグ（カテゴリ分け）をできるようにし、自分仕様にカスタマイズされた単語帳のように使えるようにする。 コメントをユーザ間で共有できるとなお Good。 複数の辞書はプラグイン形式で追加できる（ワンタッチで ON/OFF）。</description></item><item><title>TeraTerm マクロのメモ</title><link>https://maku.blog/p/kx7myd9/</link><pubDate>Tue, 19 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kx7myd9/</guid><description>マクロの起動の仕方 TeraTerm が起動している場合 メニューから Control → Macro でマクロファイル (.ttl) を選択 TeraTerm を起動してマクロを実行する場合 C:\&amp;gt; ttermpro.exe /M=sample.ttl TeraTerm を起動せずにマクロを実行する場合 C:\&amp;gt; ttpmacro.exe sample.ttl マクロの実行中止ダイアログを表示しないようにするには、/V オプションをつけます。 ttpmacro.exe でマクロを実行した場合、マクロ中で connect コマンドを実行したときに TeraTerm が表示されます。
例1: COM1 ポートでシリアル接続する場合 connect &amp;#39;/C=1&amp;#39; 例2: TCP/IP (Telnet) 接続する場合 connect &amp;#39;host.example.com&amp;#39; 例3: TCP/IP (any port) 接続する場合 connect &amp;#39;host.example.com:8080&amp;#39; 文字列を表示する (dispstr) dispstr を使えば、TeraTerm アプリケーションの機能として文字列を表示できます。 マクロの実行経過などを表示したい場合などは dispstr を使うのがよいでしょう。
dispstr &amp;#39;Hello World&amp;#39;#$0A 末尾の #$0A は改行コード (LF) を表しています。
間違えやすいものに sendln がありますが、これは接続先の端末に対してコマンドを送るものです。 以下のように echo コマンドを送信した場合は、リモートの端末上で echo コマンドが実行されることになります。</description></item><item><title>秀丸: 秀丸で OR 検索する (grep)</title><link>https://maku.blog/p/q5w35me/</link><pubDate>Mon, 18 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q5w35me/</guid><description>秀丸の検索 (grep) 機能で OR 検索をしたいときは、正規表現にチェックを入れて、以下のように検索する文字列を | で区切れば OK です。
Pattern A | Pattern B</description></item><item><title>Kent Beck の CollectingParameter パターン</title><link>https://maku.blog/p/8yhxet9/</link><pubDate>Sun, 10 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8yhxet9/</guid><description>Collecting Parameter の特徴 巡回するオブジェクトの戻り値をベースに目的のデータを構築するのではなく、パラメータに渡したオブジェクトを使ってデータを構築する。
戻り値となるオブジェクトのインスタンス化を防ぐことができるので、コードの実行速度が上がる。 戻り値をベースにしたデータ構築よりも、より柔軟なタイミングでデータの構築が行える（例えば、メソッドの実行途中で結果を append できる）ようになり、コードを分割しやすくなる。 参考文献: 『パターン思考リファクタリング入門』 第10章 累積処理
Collecting Parameter を使わない場合の実装例 public String extractText() { StringBuilder results = new StringBuilder(); Node node = null; while ((node = nodeList.next()) != null) { results.append(node.toString()); // 戻り値をベースにしたデータ構築 } return results.toString(); } Collecting Parameter を使う場合の実装例 public String extractText() { StringBuilder results = new StringBuilder(); Node node = null; while ((node = nodeList.next()) != null) { node.getText(results); // パラメータをベースにデータ構築 } return results.</description></item><item><title>読書メモ『こんな小さなことで愛される77のマナー』大原敬子</title><link>https://maku.blog/p/xmc9kvq/</link><pubDate>Tue, 08 Mar 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xmc9kvq/</guid><description>こんな小さなことで愛される77のマナー 大原敬子 PHP研究所 ポイントメモ 嫌いな人に会うときは、その目的さえわかれば会うときの態度は自ずから変わってくる。嫌だと言っているのは、自分の感情。
大事なのは、相手に清潔感を与えることを心がけること。
視線を反らさない。 小声で話さない。 ばか遠慮はしない。 背筋を伸ばして座る。 自分の意志を曖昧に答えない。 意味不明な笑い顔を作らない。 自分を立派に見せなければ、緊張しないで人に会うことができる。
自分を誇示しない。 自分を素直に出す。 自分を信じる。 部下に馬鹿にされたとき、
距離をおく。軽く見られる人は、けじめをつけることに無頓着。 視線をそらさない。「うかつな嘘は言えないな」と思わせること。 体を動かさない。本当に自信があると、しっかりと相手を見て話します。あることに集中すると、体は静止するもの。 どんなに安いアクセサリーでも、肌の手入れの行き届いた人が身につけているのを見ると、思わず見とれてしまいます。
湿度の低いヨーロッパは足の蒸れは少ないと言います。しかし、長い時間履いているときは、香水で中底を拭くのです。
お金では絶対に買えない自分の文化教養を身につけることが、本当のブランド的生き方です。行動の積み重ねがその人の品行を作ります。心の積み重ねがその人の品性を築きます。
言葉の順番に気をつける。
○はい、そうです。 ×そうですね、はい。 ○それは違います。 ×違います、それは。 ○今日も頑張ったね。 ×今日はがんばったね。 励まし、やる気を起こさせるには「も」を使う。
○今日も料理おいしいね。 ×今日は料理おいしいね。 最初に相手の名前で話しかけること。
Jさん、これはできません。Sくん、今日はだめです。 許せない人がいる人には生きるエネルギーがあります。それを生産性を高めることに使うことです。
「お母さんできたよ」「まあすばらしい」視線は違う方に向いているのです。子供はその母親の視線から、嘘を感じ取るのです。言葉はなくても目が「すごい」という表情をしたとき、子供は信じます。
思いやりは相手のことを考えて行動すること。その思いやりは相手に聞くこと。
「お茶を入れてください」 → 「濃いめのお茶がよろしいですか？」 「急いで企画書を書いてくれないか」 → 「いつまでに作ればよろしいでしょうか？」 「この書類をとじておいてください」 → 「各分野ごとですか、それともひとまとめですか？」 几帳面な人は人間関係がギクシャクすることがあります。ていねいな人はギクシャクはありません。人の行動を見て苛々したときは、ていねいな心ではなく、自分の義務感からの几帳面さだと思うことです。</description></item><item><title>Linuxメモ: syslog のログの保存先の設定</title><link>https://maku.blog/p/rm78k9i/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rm78k9i/</guid><description>/etc/syslog.conf に以下のように記述されていれば、debug レベルのログは /var/log/debug に、info, notice, warn レベルのログは /var/log/messages に記録されます。
*.=debug; \ auth,authpriv.none;\ news.none;mail.none -/var/log/debug *.=info;*.=notice;*.=warn;\ auth,authpriv.none;\ cron,daemon.none;\ mail,news.none -/var/log/messages</description></item><item><title>SQL の検索結果をソートする (ORDER BY)</title><link>https://maku.blog/p/6ebo58o/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6ebo58o/</guid><description>SELECT によるレコードの検索結果の並び順は不定なので、特定のカラムでソートしたい場合は、明示的に ORDER BY 指定を行う必要があります。
書式 SELECT * FROM tbl ORDER BY col 複数のカラムでソートしたい場合は、カンマでチェック順にカラム名を並べます。
SELECT * FROM tbl ORDER BY a, b, c 昇順 (ASC)、降順 (DESC) を指定するには以下のように末尾に追加するだけです。
SELECT * FROM tbl ORDER BY col ASC -- 昇順 (default) SELECT * FROM tbl ORDER BY col DESC -- 降順 NULL がどのように扱われるかはデータベースによって異なります。</description></item><item><title>日本語入力時に数字を必ず半角で入力する</title><link>https://maku.blog/p/ey8rn5z/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ey8rn5z/</guid><description>Mac OSX の場合 ことえりで「ひらがな」入力状態にする。 「あ」のアイコンを右クリックして「環境設定を表示」を選択。 「入力文字」の項目で、「数字を全角で入力」のチェックを外す。 Windows Vista (MS IME) の場合 言語バーを右クリックして「設定」を選択。 Microsoft Office IME2007 を選択して「プロパティ」を開く。 「オートコレクト」タブの英字、数字を「常に半角に変換」に設定。 MS IME の場合、英数字を入力してから一回はスペースを押す必要があります。</description></item><item><title>Android開発: レイアウトの種類まとめ</title><link>https://maku.blog/p/64zojt6/</link><pubDate>Mon, 10 Jan 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/64zojt6/</guid><description> FrameLayout ウィジェットを左上に１つだけ配置する。 FrameLayout の中で複数の View を配置した場合は、最後に表示したものが上に重ねて表示される。 LinearLayout 水平か、垂直に一直線にウィジェットを並べる。 水平: android:orientation=&amp;quot;horizontal&amp;quot; 垂直: android:orientation=&amp;quot;vertical&amp;quot; ConstraintLayout フラットなビュー階層を持つ大きくて複雑なレイアウトを作成する。 RelativeLayout より柔軟。 LinearLayout を組み合わせてレイアウトを入れ子構造にするとパフォーマンスが悪くなるが、ConstraintLayout ひとつでフラットにビューを配置すると効率的な描画が可能。 TableLayout HTML の TABLE 要素のようにウィジェットを並べる。 RelativeLayout 他のウィジェットとの相対的な位置関係で配置する。 参照されるウィジェットは、参照するウィジェットよりも先に定義されていなければならない。 AbsoluteLayout（非推奨） 絶対座標でウィジェットを配置する。 それぞれの Layout を入れ子にして、その中にウィジェットを配置していくことで複雑なレイアウトを作成することができます。
&amp;lt;LinearLayout ...&amp;gt; &amp;lt;LinearLayout ...&amp;gt; ... &amp;lt;/LinearLayout&amp;gt; &amp;lt;LinearLayout ...&amp;gt; ... &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt;</description></item><item><title>読書メモ『The Secret Book』石井裕之、苫米地英人ほか</title><link>https://maku.blog/p/3u8vrba/</link><pubDate>Tue, 04 Jan 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3u8vrba/</guid><description>フォレスト出版が無料で配布していた「THE SECRET BOOK」のメモ、抜粋。
悶々としている気分から一歩踏み出そう！ by 石井裕之 &amp;ndash; 1963年生まれ。有限会社オープーアソシエイツ代表取締役。
セミナーに参加して一度だけ話を聞くよりも、セミナーを収録したテープを何度も何度も聴くことのほうがプラスになります。 オーディオにはあって本にはないもの。それはリズムの効用です。その意味でも、繰り返し聴くことは重要なのです。 音で聴かないと入ってこないというところがありました。 だから、昔テレビでやっていたドラマ「大草原の小さな家」の二カ国語放送の英語部分だけを録音して何度も聴いて英語を勉強してたりしていました。 英語でも、次から次へと新しい文章を覚えるよりも、むしろ同じ文章を繰り返し聴くことでリズムを浸透させるのです。そうすると、音の響きでこれは正しいか間違っているかどうかわかるようになってくるのです。 世間のセミナーは、単に情報を伝えているだけのものがほとんどです。しかし、本来セミナーはそういうものではなく、参加者の潜在意識を巻き込んで、参加者と一体になってリアルタイムで作り上げていくものだと思っています。そのレベルになると、もはやテープではカバーできない。ライブのセミナーでなければ実現できないものになります。 脳科学でわかった！もっとも効率的な勉強法 by 苫米地英人 &amp;ndash; 1959年生まれ。ドクター苫米地ワークス代表。
理想の教材は「オリジナルの人」が語っているもの。その点から考えると、本当に教授が顔を出しているので、放送大学は役に立ちます。 新しいファイナンス理論を学びたかったら、アメリカのファイナスプログラムを作った人たちのところに直接行って学ぶのが理想。それが不可能な場合は、動画。動画もダメな場合は、音声。本人がしゃべっているという音声の言語の中にたくさんの情報を集めていく。それがDVD・CDを使いなさいという理由。 グレゴリー・チャイティンが数学全般にわたって不完全性の定理を証明したレクチャーはユーチューブでガンガン見ることができます。ゲーテルの不完全性の定理が完成させられた瞬間です。 慣れてきたら、仕事をしながらとか、雑誌を読みながらとか、「〜しながら」CDやDVDを聴いたり、観たりしてもいい。人間の脳は、同時に何でもできます。 同時通訳者は、通訳しながら会議中に編み物をしている人もいるくらいです。国連のおばちゃんとかそうやってます。慣れの問題だし、脳はいくらでも調節できます。それは、私が『頭の回転が50倍速くなる脳の作り方』（フォレスト出版）の中でやり方を書いたように、ボトルネック外しが必要になります。 推論するときも常に並列で考えた方がいい。たくさんのことを同時にやるということは、シリアルボトルネックを外す訓練です。 親は子供に、抽象化する訓練をさせなきゃいけない。それは「説明」させればいい。親は子供に常に「なんでそうするの？」と聞かなきゃいけない。何をやっても全部説明させること。親も教えるときには「赤信号で止まるのは、赤信号は止まらなければいけないと学校で教わったと思うけど、なんでそう思う？」と説明させなきゃいけない。 経営者としての深い悩みを解決する方法 by 中山和義 &amp;ndash; 1966年生まれ。メンタルヘルス協会公認心理カウンセラー。
本で「こういうことを社員にさせるのがいい」とあると、すぐやらせます。そういうときに本がすごく便利です。それを読ませれば社員と共有できるからです。 今日はこれからの人生のバースデー by 箱田忠昭 &amp;ndash; インサイトラーニング（株）代表取締役。
「箱田さんどうしたの？遅れちゃダメじゃないですか」と怒られると思っていたのに、「大変でしたね？大丈夫ですか？」と心配されたんです。・・・デールカーネギーコースでは「相手の立場に立て」と教えられていました。 ずっと若い頃から勉強していれば必ず勝つ、ということではないでしょうか。 「コマ切れ時間」にすぐやる仕事なり、勉強のリストを作っておき、15分時間ができたらすぐ取りかかれるようにしておきます。 一流の人から教えてもらう！ by 本田健 &amp;ndash; 経営コンサルティング会社などを経営。
多くの成功者が「成功の秘訣」として必ず挙げる事柄がありました。「成功するためには本を読みなさい」ということと、「CD教材を聴きなさい」ということです。 学歴なんかあっても、「従業員」として働かざるを得ない。自分のビジネスをやるために本当に必要なのは、専門知識だ。それはセミナーやCD教材で学べる。 一流の人たちが何十年もかけて学んだこと・・・たった2、3時間でマスターできるのです。 スピーチの技術だとか、マーケティング、セールス、コミュニケーション術・・・そういう「人間関係」に関するものについては、人の言葉、すなわち音声のほうが、深く理解できるのです。 本や人との出会いと同じように、そこにCDもある。 海外のミステリー小説はオーディオブックをよく利用しています（これが英語のリスニングのいい勉強になるのです）。 ひとつの考え方が人生のすべてを変える可能性もあります。だから、そういう考え方に出会うチャンスは、できるだけ多く持ってもらいたいです。</description></item><item><title>読書メモ『Javaの鉄則』ピーター・ハガー</title><link>https://maku.blog/p/kojyx2x/</link><pubDate>Mon, 22 Nov 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kojyx2x/</guid><description>Javaの鉄則 ピーター・ハガー ピアソンエデュケーション 鉄則1 パラメータは参照渡しではなく値で渡される パラメータを参照渡しするという誤解がある。Java ではパラメータはすべて値渡しされる。オブジェクトをパラメータで渡す場合は、オブジェクトへの参照が値渡しされる。つまり、以下のようにしても呼び出し元のオブジェクトは変更されない。
public void doSomething(MyClass obj) { obj = new MyClass(); } 鉄則2 定数データおよび定数オブジェクトへの参照に final を使う final で定数を定義すると、別の場所での 代入 がエラーになる。
public class MyClass { private static final int mInt = 100; private static final Circle mCircle = new Circle(3.0); ... 例えば上記のように宣言されている場合、以下のような代入処理がエラーになる。
mInt = 200; // Error! mCircle = new Circle(5.0); // Error! オブジェクトの参照先の値は変更できることに注意。
mCircle.setRadius(6.0); // OK 鉄則3 非 static メソッドはデフォルトでオーバーライドできることを理解する メソッドを final で宣言すると、そのメソッドはサブクラスでオーバーライドできなくなる。 クラスを final で宣言すると、そのクラスはサブクラス化できなくなる。すべてのメソッドを暗黙のうちに final で宣言するのと同じ。 ▽メモ &amp;ndash; ユニットテストの書きやすさを考慮すると、final 宣言は実はあまり使うべきではない。参考：『レガシーコード改善ガイド』。</description></item><item><title>Android開発: 3種類のタイムスタンプの使い分け</title><link>https://maku.blog/p/sfvqxtr/</link><pubDate>Tue, 09 Nov 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sfvqxtr/</guid><description>Android において long 型のタイムスタンプを取得する方法には、以下の 3 種類があり、それぞれ意味が異なるため、用途に応じて使い分ける必要があります。
System. currentTimeMillis() Epoch (1970-01-01) を基準にしたシステムタイムまでの経過ミリ秒。 ユーザがシステムの現在時刻を変更すると、過去にジャンプしたりするので、タイムスタンプベースのタイマーなどに使用するべきではない。時計の UI を表示するときに使用する。 android.os.SystemClock. elapsedRealtime() Android 端末をブートしてからの経過ミリ秒。uptimeMillis() とは異なり、スリープ中にもカウントされる。 AlarmManager はスリープ中の時間もカウントして発火するので、内部で elapsedRealtime() ベースのタイマを使用する。これは、AlarmManager のタイプで ELAPSED_REALTIME (ELAPSED_REALTIME_WAKEUP) を指定した場合の振る舞いで、RTC (RTC_WAKEUP) を指定すれば、System.currentTimeMillis() ベースのタイマで発火するように指定することもできる。 android.os.SystemClock. uptimeMillis() Android 端末をブートしてからの経過ミリ秒。スリープ中にはカウントされない。 タイムスタンプベースのタイマーに使用できる。例えば Handler クラスは、uptimeMillis() ベースのタイマを使用して非同期コールバックを発火している。 AlarmManager Handler.
postAtTime Handler.
sendMessageAtTime System.currentTimeMillis
UTC（システム時刻設定で変化） ○
RTC(_WAKEUP) × × SystemClock.elapsedRealtime
ブートからの経過時間（スリープ時間含む） ○
ELAPSED_REALTIME(_WAKEUP) × × SystemClock.uptimeMillis
ブートからの経過時間（スリープ時間含まず） ×
（スリープ時カウントできないため） ○ ○</description></item><item><title>読書メモ『レガシーコード改善ガイド』マイケル・C・フェザーズ</title><link>https://maku.blog/p/p6awy3z/</link><pubDate>Sat, 30 Oct 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p6awy3z/</guid><description>レガシーコード改善ガイド マイケル・C・フェザーズ 翔泳社 はじめに テストのないコードは悪いコード（レガシーコード）である。
これがマイケル・C・フェザーズの強いメッセージです。 どれだけうまく書かれているかは関係ない。テストが書かれていない＝悪であるとまで言い切っています。 どれだけ美しいか、オブジェクト指向か、きちんとカプセル化されているかは関係ない。テストがなきゃだめだ！
第1部 変更のメカニズム 第1章 ソフトウェアの変更 リファクタリングでは、 小さな変更を繰り返し行う。 変更を容易に行うためテストでサポートする。 機能を変更すべきではない。 コードの変更時に問題になるのは、影響範囲を把握できないこと。変更を安全に行うために最も重要なことは、影響範囲を理解すること。 変更を避けると腕がなまってしまう。大きなクラスを分割する作業は週に２，３回くらい行っていないと、困難な仕事になってしまう。頻繁に変更を行っていれば、何が分割できるかの検討をつけやすくなり、変更作業が容易になる。 第2章 フィードバックを得ながらの作業 テストを用意することには、「正しいことを確認するため」だけでなく、「変更を検出するため」という目的もある。 特定のコードにエラーがあると思ったときにテストハーネスを利用できれば、手早くテストコードを書いて、本当にそこにエラーがあるのか確認することができる。 優れた単体テストの条件 実行が速い: 速く走らないとしたら、それは単体テストではない。0.1 秒もかかっていたら遅い単体テストである。「DBアクセス」、「ネットワーク通信」、「ファイルシステムアクセス」、「実行するための環境設定」が必要なものは単体テストとは言えない。 問題個所の特定がしやすい 他のクラスと依存関係があるクラスはテストハーネスに入れられない。例えば、DbConnection に依存しているクラスをテストしたい場合は、まずはインタフェース IDbConnection を導入して依存を切る必要がある。 価値をもたらす機能的な変更を行いながら、システムのより多くの部分をテストで保護していくべき。 扱いやすくなるように大きなクラスを分割するといった些細なことによって、アプリケーションに大きな違いが出てくる。 第3章 検出と分離 テストを整備する際に依存関係を排除するのには2つの理由がある。 検出: コードの計算した値にアクセスできないときに、それを検出するために依存関係を排除する。 分離: コードをテストハーネスに入れて実行することすらできないとき、分離するために依存関係を排除する。 ソフトウェアを分離するには様々な方法があるが、検出のための主な手段は「強調クラスの擬装」のひとつしかない。 あるクラスの依存をインタフェースの導入によってなくした場合、そのクラスに FakeObject を渡してテストすることになる。FakeObject ではテスト対象のクラスから渡されたデータを記録することで、テスト対象のクラスが正しくデータを渡しているかを検証できる。依存部分を切り離すことにより、依存していたインタフェースでやりとりしているデータが正しいかどうかをテストすることができる。 public void testPrintItem() { FakePrinter printer = new FakePrinter(); Item item = new Item(printer); // テスト対象のクラス item.doSomething(100); // テスト対象のメソッド assertEquals(&amp;#34;This is a result&amp;#34;, item.getLastLine()); } オブジェクト指向以外の言語では、代替関数を定義して、その中でテストからアクセスできるグローバルなデータに値を記録する。 擬装オブジェクトに、結果が正しいかを確認する機能を追加したものが「モックオブジェクト」。モックオブジェクトは協力なツールだが、すべての言語に対応するモックオブジェクトフレームが提供されているわけではない。しかし、大抵の場合は、単純な擬装オブジェクトで十分である。 第4章 接合モデル テストが可能になるようにクラスを取り出す作業を行っていると、どのような設計が優れているかという基準が変わってくる。 ソフトウェアを接合部 (Seam) という観点から見ることで、コードにすでに含まれている依存関係を排除するための手掛かりを見出すことが可能になる。Seam とは直接その場所を変更しなくても、プログラムの振る舞いを変えられることのできる場所。 Java では同じ名前のクラスを別のディレクトリに置き、CLASSPATH を変更することで別のクラスにリンクすることができる。（リンク接合部: link seam） 第5章 ツール 自動リファクタリングツール: リファクタリングツールを使って自動リファクタリングを行う場合、振る舞いが変わっていないか注意する必要がある。例えば、リファクタリング後に、あるメソッドの呼び出し回数が変わっている場合、そのメソッドに副作用があると振る舞いが変化する。 モックオブジェクト (mock object): 他のコードを取り除いて、テスト時に自分のコードを完全に実行させるには、代わりに正しい値を返してくれるものが必要になる。オブジェクト指向のコードでは、これをモックオブジェクトと呼ぶ。 単体テストハーネス: xUnit テスティングフレームワークは、ほとんどの言語に移植されている。JUnit, CppUnit, NUnit&amp;hellip; 一般的なテストハーネス: FIT (Framework for Integrated Test) は統合テスト用のテスティングフレームワーク。システムに関する文書を書き、その中にシステムの入力と出力について記述した表を含めることができれば、FIT フレームワークがテストを実行してくれる。FitNesse は wiki 上に構築された FIT で、FIT テストを定義するときに階層構造の Web ページを使うことができる。 第2部 ソフトウェアの変更 第6章 時間がないのに変更しなければなりません 一般的に変更箇所は集中する。今日ソフトウェアを変更しているのであれば、近い将来、そのすぐ近くを変更することになる。 今すぐクラスを変更しなければならないのなら、テストハーネス内でそのクラスのインスタンス化を試みてみる。 システムに新しい要件を加えるときの方法。 スプラウトメソッド (sprout method): 新しい機能を新しいメソッドとして記述する方法。既存のコードに直接手を加えるよりも望ましい結果をもたらす。 長所: 古いコードと新しいコードを明確に区別できる。 短所: 元のコードはテストするわけでもなく、改善するわけでもない。 スプラウトクラス (sprout class): 変更部分を新しいクラスで実現する方法。変更対象の既存のクラスをテストハーネス内でインスタンス化できない場合は、テストを書けないのでスプラウトメソッドは使えない。既存クラスの依存を排除するのに時間がかかりすぎる場合、新しいクラスを導入して、そこだけテスト可能にするという方法がある。 長所: コードを直接書き換える方法よりも、確信を持って変更を進められる。 短所: 仕組みが複雑になること。 第7章 いつまで経っても変更作業が終わりません あまりに多くの依存関係を持つクラスは、大きなコードの塊を切り離し、テストで保護できるかどうかを調べるとよい。</description></item><item><title>ネットワークトラブルの調査手順</title><link>https://maku.blog/p/eecgkww/</link><pubDate>Sun, 10 Oct 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eecgkww/</guid><description>ネットワークトラブルはホストに近いところからチェックしていくのがセオリーです。 ソフトウェア的要因よりも、ハードウェア的要因の方を先に調べるのがよいです。
ハードウェア的要因 ケーブルの断線 NIC の故障 電源の故障 ポートの接触不良 機器の熱暴走 ソフトウェア的要因 IP アドレスの設定ミス デフォルトゲートウェイの設定ミス VLAN の設定ミス ルーティングテーブルの不具合 サーバアプリケーションの設定ミス／不具合 参考: NETWORKWORLD - May 2007
ping による調査 あるホストに ping が通らないときは、以下の順番で ping を通す確認をしていきます。 テスト結果は正常時の結果と比べなければ意味がないので、正常時の tracert 結果などを定期的にとっておくことが重要です。
ループバックアドレスに対して ping TCP/IP モジュールの異常の可能性 ホストの IP アドレスへ ping OS が NIC を認識していない可能性 同じスイッチに接続された別の PC へ ping スイッチのポート、ケーブルの故障 VLAN の設定ミス、接続ミス スイッチ自体には IP アドレスは設定されないので、別の PC に ping することで、スイッチまでの接続を確認する。 ルータに ping ルータのダウン、アドレス設定ミス ルータの別のポートへ ping ルーティングプロセスの異常 インタフェースの設定ミス ルータは複数のネットワークにつながっているので、別のネットワーク用のポートにも ping する必要がある。 異なるネットワークの PC へ ping tracert で、通信不能ネットワークを切り分け ターゲットホストに ping ターゲットホストのダウン アプリケーソンレベルの確認 参考: NETWORKWORLD - May 2007</description></item><item><title>SQLite のテーブル作成に関するメモ</title><link>https://maku.blog/p/2iccv8a/</link><pubDate>Sun, 01 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2iccv8a/</guid><description>SQLite 3 のフィールド型 テーブル作成時 (CREATE TABLE) に指定したフィールド定義に含まれているテキストにより、以下のようにフィールド型が決定されます。
INTEGER 型: INT という文字列を含む場合。 TEXT 型: CHAR、CLOB、TEXT を含む場合。 NONE 型: BLOB を含む型、あるいはデータ型が特定されない場合。 NUMERIC 型: それ以外の場合。 テーブルが存在しない場合だけテーブルを作成する (IF NOT EXISTS) CREATE TABLE IF NOT EXISTS tbl(id INTEGER PRIMARY KEY, name TEXT, bin BLOB); 逆に、テーブルが存在する場合だけテーブルを削除するということもできます。 この場合は、IF NOT EXISTS の代わりに、IF EXISTS を使用します。
DROP TABLE IF EXISTS tbl; NULL の追加を禁止する (NOT NULL) フィールドの定義時に、NOT NULL というフィールド制約を加えておくと、データ追加時にそのフィールドの値を省略できないようになります。
CREATE TABLE tbl(f1 NOT NULL, f2, f3); 動作確認 sqlite&amp;gt; INSERT INTO tbl(f1, f2) VALUES(100, 200); sqlite&amp;gt; INSERT INTO tbl(f2, f3) VALUES(200, 300); SQL error: tbl.</description></item><item><title>Excel でよく使うショートカット</title><link>https://maku.blog/p/h45duja/</link><pubDate>Mon, 31 May 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h45duja/</guid><description>ウィンドウ制御 ショートカット 説明 Ctrl + F1 リボンを最小化する／元に戻す Ctrl + PageDown 次のシートへ Ctrl + PageUp 前のシートへ Ctrl + Tab 次のブックへ Ctrl + Shift + Tab 前のブックへ Alt リボンをアクティブにする（左右キーでタブ切り替え） カーソル移動 ショートカット 説明 Enter 入力確定してカーソルを下へ Shift + Enter 入力確定してカーソルを上へ Tab 入力確定してカーソルを右へ Shift + Tab 入力確定してカーソルを左へ Home 先頭の列にジャンプ Ctrl + カーソル 値のあるセル範囲で境界位置へジャンプ（End → カーソルでも同様） Ctrl + Home 一番左上 (A1) にジャンプ Ctrl + End データのある矩形範囲の一番右下にジャンプ 編集 行と列の挿入、削除 ショートカット 説明 Shift + Space 行を選択 Ctrl + Space 列を選択 Ctrl + A 全体の選択 Ctrl + - 選択したセルの削除 Ctrl + + 新しくセルを挿入 上記の組み合わせで、行や列の削除、挿入がキーボードだけで素早く行えます。 例えば、行を削除したければ、Shift + Space で行を選択し、Ctrl + - で削除できます。</description></item><item><title>読書メモ『ピープルウェア』トム・デマルコ、ティモシー・リスター</title><link>https://maku.blog/p/5oc7g4c/</link><pubDate>Sun, 31 Jan 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5oc7g4c/</guid><description> ピープルウェア トム・デマルコ、ティモシー・リスター 日経BP社 感想 マネージャー、リーダーの立場にある人にはぜひ読んで欲しい本です。 ずいぶん前に書かれた本ですが、ソフトウェア開発の本質は「人」であるということを訴えているバイブル的な書籍であり、その内容は色褪せることがありません。 多くの企業が生産性について誤解している部分を「人」を中心に解き明かしていきます。 **オープンすぎるオフィスレイアウト**、**リーダーとの進捗確認になってしまっているチームミーティング**、**競争心をあおいでしまう管理者**など、誰しも心当たりのありそうなことをはっきりダメなものと指摘しています。 21世紀に入り、「オープンなオフィスはよいものだ」というおかしな風潮が広がってしまったように感じます。 世の中の「できる」ソフトウェア開発者はそのような盲目的な考え方が間違いであることを認識しているはずですが、オフィスのレイアウトをオープンなものに変えようとする人ってプロのプログラマーじゃないことが多いんですよね。。。 この本がもう一度見直される日が来ることを願ってやみません。 抜粋＆メモ 担当者が自分で作り込んだ問題を摘出した場合でも、「よくやった」と誉める。 管理者は、むしろ働き過ぎないように、時折、気を配らなければならない。こうすると、すばらしい仕事がどんどん出来上がる。 本当に人を知る管理者は、ユニークな個性こそが、プロジェクト内の不思議な作用を活発にし効果的にすることをよく認識している。 プロジェクトチームを結束させる能力のある人は、普通に仕事をする人の二人分の価値がある。 生産性を論じるときは、退職問題に触れないと全く意味がない。生産性を上げると退職率も上がる危険がある。 コストは全体のコスト、つまり、退職者の補充に費やした余計な費用を含むべきである。 早くヤレとせかせれば、雑な仕事をするだけで、質の高い仕事はしない。 チームワークのよいチームの管理者は、チーム内のお荷物的な作業者に対してどなりたい気持ちをぐっと我慢している。 目標値の設定者は以下の順で生産性が高い。 目標なし システムアナリスト プログラマー 管理者 生産性向上の問題は、安易な解決法では手に負えない。そんなものは、すべてとうの昔に考えられ適用されてしまった。よい実績は、効果的な人の扱い方、作業場所は社風の改善などの手段を講じることで得られる。 開発者の主な仕事は、ユーザー流の表現で表したユーザー要求を、厳密な処理手順に変換するための、人と人とのコミュニケーションである。これは絶対に必要な仕事であり、自動化できるはずがない。 管理者の役割は、人を働かせることにあるのではなくて、人を働く気にさせることである。 企業におけるプログラマーの能力差は10倍あるといわれている。しかし、企業自体の生産性にも10倍の開きがある。 作業環境と生産性の相関関係は極めて顕著である。以下のオフィス環境を考慮すべき。 一人当たりのスペース 十分に静かか？ プライバシーは十分か？ 電話の呼出音を消せるか？ 電話を他へ転送できるか？ 無意味な割り込みが多くないか？ 現在のオフィスを今はやりの「開放型オフィス」に変える場合、その前にプログラマーの生産性への影響を十分に調査する必要がある。 プログラミングコンテストの結果を総合すると、参加者の58％が現在のオフィスは騒々しいと考えており、また、61％が個人の場所がなく、プライバシーが脅かされていることに不満を感じている。さらに、54％が自宅には会社よりもずっとよい作業場所がある、と回答している。 「オフィスは騒々しい」と回答したプログラマーは、「自分は不良を作り込む可能性が高い」と公言しているのに等しい。 特定の作業に対して投入された時間の総合計を集計しているところはあるが、これだけでは投入時間の質は不明である。 どんなものでも、計測しようと思えば必ずできるし、測定しないでいるよりもずっとよい。── ギルブの法則 困ったことに電話の弊害にはみんな慣れてしまい、誰も気にしなくなってしまった。 精神集中して仕事に没頭したいときには、かかってきた電話を無視できるような、現実的で効果的な方法を考えなければならない。 前面8フィート（2.4ｍ）以内にめくら壁を設けてはならない。8フィート以内にめくら壁があると、目の休まることがない。 窓から外の景色を見えないような部屋は、凶悪犯をぶちこんでおく刑務所と変わりない。 もし、彼が最初からその仕事に適していなければ、変化は決して起こりえない。 力のある管理者は、チームのメンバーが頭を丸坊主にしようがネクタイをしめないでいようが一向に気にしない。チームの誇りの対象は、チームメンバーが成し遂げた成果だけである。 成功する管理者の多くは、局所的なエントロピーを大幅に下げる。── 組織は死後硬直を起こしているかもしれないが、その一部であるプロジェクトは生き生きとして活動することができる。 応募者に過去の仕事について聞くのはよいが、見せてほしいというのはよくない、といった不文律があるようだ。だが、要求すれば、応募者はほとんど例外なく喜んでサンプルを持参する。──求人側が応募者に成果一覧表を持参するよう支持することはあまりないが、なぜそうしないのだろう。 能力テストは、従業員の「自己」評価には素晴らしい道具だ。 失敗の最もたるものは移転だ。退職がどんなに高くついたか信じられないだろう。 最良の組織は、意識的にベストになろうとして奮闘する。これは、全員に共通した目標であり、これによって、共通の方向づけ、共に分かち合う充足感、および強力な結束効果が生まれる。 退職率が最も低い会社に共通した特徴は、生涯教育プログラムの充実である。 書類の山は災いをもたらすだけで、問題の解決にはならない。 作業規定が示す全くその通りに仕事を行えば、仕事はほとんど止まってしまう。 ソフトウェア業界全体では、新しいアプローチを探し求め、それを自社内でやってみたこともないのに、規格として強制するようなことが広く行われている。 人は、他と違った扱いを受けることに魅力を感じ、注目されることを好み、珍しいものに好奇心をよせる。これはその後、ホーソン効果と呼ばれるようになった。つまりホーソン効果は、人は何か新しいことをやろうとしたとき、それをよりよくやろうとする、ことを示している。 挑戦はチームのメンバーに一緒になって努力する目標を与えることからこそ重要なのだ。──人は最良の仕事仲間を持ったとき、愉快な気分になるし、力の限りを尽くす。 結束したチームは、生意気で、自己満足的で、神経を苛立たせ、排他的かもしれないが、管理者の真の目標に対しては、交換可能な部品の集まりのようなグループが果たすよりも、はるかに、大きな役割を果たすことは間違いない。 陰険なイメージをふくらませるために、チームのメンバーは黒い服を着用しはじめた（ここから黒集団の名がついた）。プログラムがテストに引っかかると恐ろしい声でケタケタ笑った。 与えられたグループでやっていこうといったん決めたならば、最良んの戦術は部下を信頼することである。 少しはミスをさせたらよい。 自己防衛的な管理手段の中で最も明白なものは、作業規定マニュアルと、管理者による技術的な干渉である。この2つが揃えば、プロジェクトは長期的に見て失敗する運命にある。 隣にいる他のグループの作業者は、騒音と分裂の源である。作業者が同じチームにいるときは、同じ時間帯では静かにすることとが多いから、精神集中を妨げられることも少ない。 複数の結束したチームに同時に身を置くことはできない。時間を分断されたらチームは結束しない。 まやかしの製品を開発している開発者同士は、互いに視線を避けるようになる。自分たちがやっていることをやめられるなら、救われた気持ちになると、みんなが感じている。 部下に自分の評価の一部を委ねていることは、少々乱暴で恐ろしいことと思うかもしれないが、それがみんなに最善を尽くさせる道なのだ。 どの地位の人も、どんな不服従が許されるかよく知っている。──判断を誤っても、部下は自分たちのことを考えてくれるその管理者を支持するだろう。 自分が働きたいと思っている人と仕事ができる方が重要だったのだ。 品質至上主義は、世間一般からチームを際立った存在にするので、チームを一つに結束させる役割を果たす。 「不器用な作用」を醸し出すがうまい管理者は、仕事をいくつかに分割し、その一つひとつが、それなりに完成感を味わえるようにする。そんな管理者は、上級管理者やユーザーには、せいぜい2つに分ければ十分な仕事を、20ものバージョンに分けるように工夫する。──分割した新バージョンは、要するに打ち上げ用である。 成功する管理の本質は、みんなを同じ方向に向かわせ、管理者でさえ前進を止められないところまで燃え上がらせることにあるのだ。 プロジェクトが完了した際には、少なくとも他のプロジェクトを選択する余地を与えるべきである。 恒久的なリーダーは、やがて仲間として扱われなくなり、チームメンバーとの相互作用は崩壊しはじめる。 プロジェクトを、新しい技術を用いた試行プロジェクトとして実施した方が、費用が少なくて済む可能性が高い（生産性が上がる可能性が高い）。 試行プロジェクトの賢明なやり方は、一部分だけを新しい方法でやってみることである。 人は、期限通りに仕事をするために多くの残業をするのではなく、仕事が期限通りできそうもないことがわかったときに、非難から身を守るためにそれをやるのだ。 チーム内の競争は、コーチングを困難にし、または不可能にするという直接の影響がある。──管理者が、何かチーム内の競争心をあおるようなことをしたら、チーム殺し的と見なければならない。 真の利益をもたらすプロジェクトのすべては、それと共に真のリスクを伴うものだ。 組織が「成熟」するにつれて、次第にリスクを避けるようになる。CMM のレベルが上がったことを証拠で示せ、との厳しい監視の下にいる組織に、真の挑戦は期待できそうもない。 最もやる価値のあるプロジェクトとは、それはあなたのところの（CMM の）レベルを一つ完全に下げざるをえないプロジェクトだ。 サタイア・モデルがきわめて重要な理由は、「混乱」が変化には絶対必要な部分であることを、我々に認識させたことである。素朴な第二ステージだけのモデルでは、混乱を予期しない。それが起こると、それを「新しい状況」になったものと誤解してしまう。 逆説的に、変化は、もし失敗──少なくともちょっとした失敗──が、成功と同じように許される場合のみ、成功の可能性がある。 中間管理層の強力なリーダーシップがあって、はじめて学習センターは成功する。 管理における究極の罪は、人の時間を浪費することだ。 現状を把握するためにはミーティングは必要ない。現状把握だけの問題なら、他人の時間の浪費をもっと少なくする方法がいくらでもある。 本当に有効な会議は、出席者全員が一つの問題を一緒に討議する必要がある場合に開く。ミーティングの目的はコンセンサスにたどり着くことだ。そんな会議は、定義からも明らかなように、臨機応変に開く。臨機応変ということは、定期的ではない。 設計作業は、集中しなければならないし、作業場所が静かで、少人数での密度の高い会話が必要。</description></item><item><title>読書メモ『仕事は楽しいかね２』デイル・ドーテン</title><link>https://maku.blog/p/8npfate/</link><pubDate>Sun, 27 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8npfate/</guid><description> 仕事は楽しいかね2 デイル・ドーテン きこ書房 『仕事は楽しいかね』デイル・ドーテン の続きです。
感想 ★★★★★ 5/5点。
本作では優れた上司になるための話が物語り風に進んでいきます。 前作と根本的な考え方は同じで、部下に変化のための自由、チャンスを与えることで魅力的な職場にするといったことが書かれています。 部下を持つような立場になったら、定期的に読み返して元気をもらいたい本です。
抜粋＆メモ きみの求める答えは「仕事をしない」ということではないと思う。必要なのは、人と人との「結びつき」を仕事に取り入れることなんだ。 「ほんもの」の部下とは、管理される必要がなく、上司にいい仕事をさせ、部署全体をより高いレベルに引き上げるような部下だ。 きみに必要なのは「最強の逸材」、つまり独創的な考え方をする人、独立独歩のできる人だ。同僚はもちろん上司のことも向上させる人。新たな行動規範を打ち立てる人。 「ほんもの」の上司と「ほんもの」の部下は、同じものを職場に求めている。自由（管理がない、平凡でない、愚か者がいない）、変化、チャンス。 「ほんもの」の上司と部下は、互いを管理の苦痛から解放している。 優れた上司の仕事は、魅力的な職場環境をつくることだ。 事務用品で有名な 3M（スリーエム）社の「15パーセント・ルール」。社員は好きなプロジェクトを自分で選び、勤務時間の15％をそれに充てるんだ。このプログラムなら「我が社は並みの職場とは違います」と言っていることになる。 「カジュアル・フライデー」ではなく「フォーマル・マンデー」という日を設けた。週に1日だけ、社員はカジュアルな服装ではなく、昔ながらの背広にネクタイという格好をするんだ。 優れた上司のもとで働き始めた人間ははっきりと知る。給料よりももっと大切なもの、つまりチャンスと変化が得られることをね。 優れた上司は規則ではなく高い規準を決める。些細なことには寛大に、重要なことには細心に。 ウェルカーはすぐに隊員たちのところへ行き、砲撃の準備を八分以内に完了する方法を考え出せ、と命令した。彼はその方法を教えなかった。ただ規準を定め、どうすればいいのかは部下たち自身に考えさせた。 優れた上司はお役所的な体制の外でどう仕事をすべきかを知っている。 優れた上司は答えを教えず、質問を投げかける。部下に答えを見つけさせることのほうが、答えそのものより大切である。 変化は冒険だ。しかし試みならやり直しがきくし、ちょっと無謀なことだってできる。私は、新しいプロジェクトは試みと位置づけて、試験的なことを少し含めるようにしていった。 部署の管理をうまくやるには、一日中、二つの質問をするだけでいい。もっといい方法はないか？これがきみにできる最善のことか？ ロータスを扱っているかどうかを尋ねた。何軒のかの店は「はい、やっています」としか答えなかったが、ある店はこう答えた。「もちろんですとも。私どもは輸入車を専門に扱っています。」「はい」のひとことですませるより、ずっといい答えが必ずある。 上司が間違いを認めることがわかれば、上司に対して意見を述べるのはそうするだけの価値のあることだと思うはずです。そして上司が変わることがわかれば、彼らも変わります。 優れた部下は、問題が起きたり混乱しているときにこそ、素晴らしい力を発揮する。彼らのおかげでみんな落ち着きを取り戻す。彼らの自身が伝わるのだ。 仕事選びの大切な基準は「いまより幸せになれること」なんだ！ 彼は「うちに来て手伝ってくれ」とは言わず、「あなたが、ほしいものを手に入れるお手伝いをしよう」と言った。 私は優秀なアシスタントが辞めるのを許すのは間違いではないかと思ったが、代わりとなる人材のリストがあれば、部下の転職にもずいぶん手を貸しやすいだろうと考え直した。 スカウトのプロセスは、単に大勢の人と知り合いになることじゃない。優秀な人たちの仕事をよく知ることなんだ。 上司が部下に与える時間や気配りは、上司自身に返ってくるんだ。クビにする人たちを敵にまわすのではなく、彼らと同盟を結ぶわけだから。 単なる友だち関係なら一時的ということもあるだろうけど、同盟関係は何があっても壊れることはない。 優れた上司を選べば確実に才能を伸ばしていける。そして、自分が仕事をしていく上で、大切な役割を引き受けてくれる生涯の同志を得られるんだ。 会社を去った人も、あとに残っている人たちのことなんか思い出すこともない。だけど、本当に優れた上司は本当に優れた部下のことを決して忘れないし、連絡も絶やさないものなんだ。 いくつかの試みを1、2週間以内に実行できそうだと思った。また、こうした試みに積極的に取り組んでくれそうな部下としぶる部下を、見きわめることもできた。 彼らがどういう人間かを知るだけではだめで、自分がどういう人間かを彼らに知らせる必要があるってことだからね。 私の部署で何か話をしてもらえないか頼んでみようと思います。部下のためにいろんな人を招いて「弁当を食べながらの勉強会」をやっている人ですし、きっと来てくれると思うんです。そうすれば、私たちの試みのことを詳しく知ってもらえます。</description></item><item><title>読書メモ『不機嫌な職場 - なぜ社員同士で協力できないのか』</title><link>https://maku.blog/p/cbvx4d5/</link><pubDate>Sat, 26 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cbvx4d5/</guid><description> 不機嫌な職場 - なぜ社員同士で協力できないのか 河合太介、高橋克徳、永田稔、渡部幹 講談社 感想 ★★★☆☆ 3/5点。
タイトル通り、なぜ社員同士で協力できないかという「原因」を把握するためによい本。 ただ、それをどう解決していくかについてはあまり述べられていないので、そのあたりは自分で考えなきゃですね。
メモ 中間管理職に責任を押し付けても、何も解決しない。 実際は組織マネジメントの問題、あるいは組織全体でつくりだしている風土、価値観や行動原理の問題。 こうした問題の原因を特定することなく、壊れた人たちをその都度、医者に診てもらうだけでは、何も解決しない。 声をあげれば、自分が矢面に立たなければならなくなる。それが、苦痛であり、自分自身がさらに仕事を抱え込むことになりかねない。おかしいと思っていても黙っていよう。そんな心理が働いてはいないか。 大事なのは、自分で迷うことがあれば、おかしいと思うことがあれば、それを周囲に伝え、一緒に解決していくプロセスを共有すること。 協力をしないという行動の連鎖が、結局は自分を苦しめることになる。このことをすべての人が理解しなければならない。 個人の業務や役割分担も同様である。この括りで働きましょうね、という役割構造を持っている。▼悪い点 仕事をしているようだが、実のところ何をしているのかわからない人。まったく中身が分からない仕事。あの人が辞めると、仕事自体が止まるといわれている状態。 日本の会社は仕事が属人的になっており、誰が何をしているのか、誰に何を聞いたらいいのかすら、外国人の自分には分からない。 従来、組織としては必要だからと社員がお互いに手を差し伸べて行っていた業務は、個人の成果にはあまり関係がないということで、次々となくなった。 深さを追求しなければならないことに加え、個々人を束ねることが仕事を進める上で必要になっている。 以前だったら、誰かが対応して問題は起きなかったようなトラブルが頻発するようになった。 インフォーマルネットワークの弱体化により、知り合う機会が減少した。 会社組織自体がシステム化されていなかったため、人間関係などに依存する部分が多かったので、中途ではいると、ゼロから人間関係の構築をしなければならず、仕事上も不利だった。 会社はあてにならないものだと学習していった。そうなると頼りになるのは結局、自分の腕＝スキルだけということになる。 このとき、もっとも重要となるのは「不振の連鎖」を防ぐことである。多くの場合、この連鎖はコミュニケーションの不全による誤解に端を発する。 部下には最大限協力する意図があったとしても、失敗した際に上司が、「お前がわざと手抜きしているからだ」というふうに考えてしまったら、部下は協力する意図さえなくし、新たな不信の連鎖を招いてしまう。 重要なのは、自分が協力する意図と自分に協力してもらうニーズを、周りのみんなにわかってもらうための方策を皆で実践すること。 グーグルの構造 … その時々のテーマで立ち上がり、終わると消えてゆく──このように流動的な組織のため、役割が固定化してしまうことによる「タコツボ化」は構造的には発生しにくい。 グーグルの採用基準 … 他のグーグルの人と一緒に働けるか？自分で動ける人か？ 働きやすい環境、世界でもトップ水準の仲間、お互いが認知される風土、これらがエンジニアにとっての価値のある報酬となっている。この報酬は、グーグルという場そのものが提供するものである。この報酬を永続的に受け取るためには、グーグルという会社を永続的に存続させることである。 みんなに注目されたり、ほめられる。一緒に喜びを分かち合える。その方がずっと自分という存在に自身が持てるようになり、前向きな気持ちが持てるようになる。 ──最初はまったく意見がでなかったという。そこで考えられたのが、「ワクワク楽しいミーティング」に変えようということだった。 寄田院長は、「ありがとうは伝染する」と言っている。まず自分からありがとう。その気持ちがスタッフに伝わり、スタッフ間に伝わり、患者に伝わる。 1つの方法論ではなく、多様な取り組みで、社員を協力というベクトルに向けて囲い込んでいる。──この種の取り組みはすぐに効果があらわれる類のものではない。──社内の関係性が明らかに変わりはじめたと感じるまでに、「3年くらいかかった」と口を揃えて言う。 全員が、個人の利益を超えた共通目標・価値観を「共有化」するための工夫に取り組むことが大切。──人材の流動化、多様化が著しい現在、こうした流動化、多様化に対応するような、「共有化」作業を徹底して行っているだろうか。 立派な冊子、モノはつくったが、配布して終わっている。こうした施策で終わっていないだろうか。 「壁をつくらないから、何でも意見を言いなさい」というところまでは、多くの組織で行われている。しかし、そこで出てくる意見を1つひとつまじめみ取り上げないならば、社員は、そのうち馬鹿らしくなる。 その人が病気等で休んだ場合は、お手上げになる。責任感が強い人だと、そのことがわかっているから休めなくなる。失格マネージャーにいたっては、「休まれると困るから」と言って、その人の休暇申請をなかなか認めない。 仕事に余裕があるときに、自分の仕事の手順書マニュアルを作成するという習慣。──引継ぎ後、何か相談したいことがあったときも、そのマニュアルをもとに相談できる。──引き継いだ人は、そのマニュアルをバージョンアップするのが習慣。 自分の仕事で最高の仕事をしたかったら、周辺分野の知見をあわせて持つこと。 武田薬品工業の取り組み … 異動者に対して、「ローテーションポイント」という加算評価ポイントを付加している。これは異動損にならないように、未経験職務、習熟に時間を要する職務に異動をする場合、最長で三年（二年が通常）にわたって、評価でポイントを加算する仕組み。 「いまどきの若者は、社員同士の飲み会等に出たがらない」。しかし、それは若い人が、「あなたとの飲み会が嫌」なのであり、「あなたとの旅行が嫌」なのかもしれないと、自分を疑ってみる必要がある。 「人の顔をお互いに知ろう」と呼びかけたところで、そんな場所に行きたいという動機は働かない。──そこに人が集まるためには、その旅行自体が魅力的なものでなければならない。 ブログやイントラネットが良いと聞いて、それを導入して失敗している会社は、ただ、それをシステムとして導入するところで終わっている──固い、つまらないもにしていては、ダメ。 自分がいい仕事をする上で、欠かせない協力をしてくれた裏方の社名を三名選出し、その社員も次の週に、同じように表彰されるという工夫。</description></item><item><title>読書メモ『仕事は楽しいかね』デイル・ドーテン</title><link>https://maku.blog/p/8sinbv4/</link><pubDate>Wed, 23 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8sinbv4/</guid><description> 仕事は楽しいかね デイル・ドーテン きこ書房 感想 ★★★★★ 5/5点。
毎日何か新しいことにチャレンジすることの素晴らしさに気付かせてくれます。 「明日は今日と違う自分になる」「試すことに失敗はないから、とにかくいろんなことを試してみよう」がキーワード。
この書籍は、続きの 『仕事は楽しいかね２』デイル・ドーテン も出ています。
抜粋メモ 試してみることに失敗はない。 頭のいい人がする一番愚かな質問は、『あなたは五年後、どんな地位についていたいですか』というものだ。 僕は人生の中で何をすべきかなんて、問いかけなくなった──どうせ、人生なんて思いどおりにはならないからね。 今日の目標は明日のマンネリ。 明日は今日と違う自分になる。 人は違うものになって初めてより良くなれるんだから。 人生は進化だ。そして進化の素晴らしいところは、最終的にどこに行き着くか、まったくわからないところなんだ。 彼（ビル・ゲイツ）は、目標はつねにコンピューターに違ったやり方で処理させる方法を見つけることだとも明言していた。 遊び感覚でいろいろやって、成り行きを見守る。 チャンスの数が十分にあれば、チャンスはきみの友人になるのだ。 まぐれ当たり専門家になるべきかもしれないよ。 注意さえ払い始めたら、目にできるありとあらゆるところに偶然が転がっているのがわかると思うよ。 昔はよく人にこう聞いたものだ、「どんなことを考えているのかね？」今じゃこう聞く、「何を試してきたのかね？」。 望みうる最良のものは、手に入れたものを好きになることなんだよ。 十六の企業は、持つべき姿勢をしっかり育てて、それから画期的な成功を収めたんじゃない。画期的な成功を収めて、それから持つべき姿勢について、もっともらしい話をしたんだ。 目標や夢がないからという理由で失敗した事業を、僕は知らない。 いざその夢なり目標なりを実行に移して市場に入り込むと、十人中九人が失敗する。ろくでもない秘訣だね、そんな目標や夢なんて。 もし、ビジネスに対するきみの唯一の目標が、僕が仕事のために打ち立てている目標──つまり、日々違ったものになるというものだったら、どうなっていただろう。 小説を研究しても小説家になれないように、成功を研究しても成功は手に入らない。 成功の宝くじでは、勝つチャンスは何百と手に入るし、そのほとんどは大損するようなものじゃない。 人は、変化は大嫌いだが、試してみることは大好きなんだ。 チャレンジの中で一番大切なのは、心を開くことだ。だけど一度開いてしまえば、あとはそこにいろんなアイデアが流れ込んでくる。 きみはたぶん何十もの素晴らしいアイデアに、目の前を通り過ぎさせてきてしまっていると思うよ。 あらゆることをしろ。素晴らしいアイデアは、どこからやってくるかわからないのだから。 できることはどんどん変えてごらん。みんなが、きみが変えていることに気がつくくらいに何でも変えるんだ。好奇心を旺盛にすること。実験好きな人だと評判になったら、みんなのほうからアイデアを持ってきてくれるようになるよ。 リストを三つ作るんだ。── 仕事上でやったミスを全部書き出すこと。── 問題点を書き出すこと。── 仕事に関してやっているすべてのことをリストアップすること。── 一度書いたら、二度と書かないこと。同じものは決して書いてはいけない。つねにリストを変化させること。 まずはとにかく始めること。どのアイデアが最終的に実を結んで、どのアイデアが実を結ばないか、確かめる方法なんてないんだから。できるかぎりいろんなことをとにかくやってみること。そうすれば、そのアイデアがまた別のアイデアを引き寄せる。 問題というのは、自分がどんなにうまくその問題に対処できるかを示すチャンスだってことだ。 試すことは簡単だが、変えるのは難しい。 活用しようと思うことはどんなものでも活用すること、そして拝借できそうなアイデアをあちこち探すこと。 報告書に書くデータについてはどうだろう。いまとは違う方法を採れないだろうか。 仕事としてしているあらゆることを書き出し、私が出くわした、あるいは同僚が出くわしたあらゆる問題をリストに連ねてみると、試すためのアイデアを生み出すのは簡単なことだった。</description></item><item><title>読書メモ『ソフトウェアアーキテクトが知るべき97のこと』鈴木雄介 監修</title><link>https://maku.blog/p/ejm5wd2/</link><pubDate>Fri, 18 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ejm5wd2/</guid><description> ソフトウェアアーキテクトが知るべき97のこと 鈴木 雄介 (監修) オライリージャパン 共感した部分をメモ。
新しくてクールなソリューションを使ってみたいという誘惑は大きい。でも、正しいものを選んだ方が、チームも顧客も幸せになれますし、いろんなストレスも減ります。すると、時間に余裕ができてきます。 相手の言うことをよい方にとらえ、考え方を聞くチャンスと思って話し合いに臨みましょう。そうすれば、相手からより多くのことを学べますし、相手が防衛的になって空に閉じこもってしまう危険性も減るでしょう。 ソフトウェア・アーキテクトは、自分がリーダーでもあることを忘れがちです。しかし、健全な職場で能力を発揮するためには、リーダーとして同僚から一目置かれるようにならなければなりません。 アーキテクチャーの策定プロセスにデベロッパーたちを参加させていれば、彼らから自発的、積極的な姿勢を引き出すことができます。 アプリケーションのパフォーマンスとスケーラビリティを左右する最大の要因は、アプリケーションのアーキテクチャだ。 ユーザが必要だという機能や特徴に、実は何を求めているかをたずねれば、アーキテクトは本当の問題を考えることができます。 アーキテクトという地位に就いてからは、コミュニケーションの相手は人間になります。 複数の相手に自分の考えを説明するときは、いつでも立って話をしなさい。── 立ち上がると、自動的に威厳と自身が伝わるようになります。 システムがさまざまな形でエラーを起こすことを受け入れること。 ソフトウェア・アーキテクトはエラーを吸収し、正常な部分を保護するセーフモードを作ることができます。 交渉では、絶対に最初の要求を取り下げてはいけません。 「速い」は、要件にはなりません。── 要件を満たすかどうかを判断するための客観的な指標がないからです。── 要件として認められるのは、このような形のものです。「1500ミリ秒以内にユーザーの入力に反応しなければならない」 実装するチーム・メンバーを尊重し、彼らの言葉に耳を傾けましょう。彼らが設計書に手こずっているなら、彼らが正しくて設計が間違っているか、そうでないにしても曖昧だということです。 すべての設計書は、実装しながら書き直していく必要があるのです。 パフォーマンステストはできる限り早い段階で開始したほうがいい。──最大の理由は、どのような変更を加えたときにパフォーマンスか急降下したかがわかること。 ソフトウェア・アーキテクトの仕事は、単に技術的な問題をクリアすることだけではなく、それら技術要件と、プロジェクトに関わる利害関係者のビジネス要件との間でバランスを取ることが求められる。 時間を割いて、仕事が早くできるようにシステムを作りましょう。そうすれば、流れが良くなり、独りよがりな仕事をする理由がなくなるので、最終的には開発のペースを上げることができます。モックを使い、シミュレーターを作り、依存関係を減らし、システムを小さなモジュールに分割し、その他何でもできることをしましょう。コミットエンドランを決めてやろうなどと思う理由さえなくしてしまうのです。 アーキテクトは、企業の目的と経営の現実に基づいて技術的な決定を導いていかなければなりません。 汎用性に至るルートとしてもっともよいのは、個別の具体例を理解し、そのエッセンスを煮詰めていくうちに、共通の解にたどり着くというものです。推測による汎用性よりも、経験を通じた単純性の方が役に立つのです。よく似た設計案から1つを選択するときは、汎用性よりも単純性という価値基準が決め手になります。──気まぐれに柔軟性を追求すると、意図的であれ偶然であれ、単純な設計が持っている優れた性質をみすみす失うことが多いのです。 すぐれたアーキテクトは、模範となってチームをリードしなければなりません。──チームメンバーがすることなら何でもできる必要があります。──アーキテクトがテクノロジーを理解していないようなら、チームメンバーは自分たちのアーキテクトにどうやって信頼を置いたらよいでしょうか。 ビジネスの役に立つという目標に向かってチームを動かしていくために、アーキテクトはビジネスのことも理解していなければなりません。 プロジェクトマネージャーは、日常的な管理を行う人です。ありふれた仕事や人員の管理のためにアーキテクトが忙殺されないように、アーキテクトを助けます。 アーキテクチャーを設計するときに、トレードオフがどのようなものになるかを把握するためのツールがいくつかあります。ポピュラーなのは、ATAM と CBAM です。 選択肢 A と B のどちらを選ぶかではなく、A、B のどちらを選んでも、それほど重大な意味を持たないようにするために、どう設計するかを考えるのです。 どれを選ぶべきかがはっきりしない場合には、判断をしないという判断をしましょう。実際的な知識に基づいて、今よりも責任を持って判断を下せるようになるまで、実質的な判断を先延ばしにするのです。 信頼できる人で、必要なときに苦い現実を言ってくれるような人は、とても貴重な存在になります。 あると思わないものを探す人はいません。再利用可能なものについての情報を「プッシュ」していけば、再利用に成功する確率が上がります。──わずかな研修を施すだけで、再利用ということでは全員が同じレベルを維持しているという状態に大きく近づけることができます。 チームを大切にしなさい。チームメンバーは、単なるリソースではありません。あなたとともに設計を進めるコラボレーターであり、あなたのセーフティネットにもなってくれる人たちです。大切にされていないと感じている人たちは、セーフティネットにはなってくれません。 上空300ｍからの目は、適切なレベルでの情報を与えてくれます。──クラス、メソッドレベルの指標群である CheckStyle からの出力をスプレッドシートに取り込みし、グラフ化するようなことです。InfoViz ツールキットを使えば、同じ指標をツリーマップで表示できます。また、GraphViz は、複雑な依存グラフを図示できる優れたツールです。──図表が美しければ、おそらくシステムもよいものになっている。 判断の時期が迫ったことに気づいたアーキテクトは、数人のデベロッパーに問題のソリューションをそれぞれ考えさせ、しばらくそれぞれその方向で作業をするように頼みます。そして、最後の瞬間が近づいたときにミーティングを実施し、それらのソリューションの長所と短所を評価します。──アーキテクトは意思決定する必要すらありません。ただ、意思決定プロセスをリードすればよいのです。──結局、もっとも安くて済むのは、複数のソリューションを試してみる方法なのです。 ソフトウェア・アーキテクトの仕事は、ビジネスの問題、目標、要件を理解し、それらを満足させることのできる技術アーキテクチャーを作ることです。──彼らは、最高幹部やビジネスユーザーが使っているドメイン言語でコミュニケーションをとることができます。すると、このソフトウェア・アーキテクトは仕事がわかっているという強い信頼が生まれます。 チームメートに自己裁量を与えてそれぞれの創造力とコーディング能力を発揮させることがとても大切。 正しい課題を選ばなければ、危険な目に遭います。 複雑なアーキテクチャーは、単純なアーキテクチャーよりもかなり高い確率で失敗します。プロジェクトのスコープを縮小すれば、多くの場合、アーキテクチャーも小規模になります。スコープ縮小は、アーキテクトが成功の確率を上げるためにできるもっとも効果的な戦略の1つなのです。 自分の判断がそれらの人々に与える影響をかならず意識するようにしてください。自分の負担が重くなっても、彼らのためになる仕事をしようと思うようになるはずです。 優れたシステム仕様は、応答時間そのものだけでなく、作業時間も規定します。 アーキテクチャー／デザインパターンは、基本的に、エンタープライズ・アーキテクチャーパターン、アプリケーション・アーキテクチャーパターン、インテグレーションパターン、デザインパターンの4種類に分類できます。 アンチパターンについても学んでおくことも大切です。http://en.wikipedia.org/wiki/Anti-pattern まず何よりも状況について考え、そこからもっともシンプルなソリューションにたどり着くようにすべき。 それぞれのタイプの中でもっとも優秀な人々だけを集めたとしても、そのチームには、問題へのアプローチのしかたが1種類しかありませんので、できることは大きく制約されます。 むしろ、アーキテクトの役割は、さまざまな利害関係を持つ人々の間の対立を調停すること。 誰かが何かをしなければ重複は消えません。その誰かとはあなたなのです。 優れたアーキテクトは、プロジェクト、チーム、キャリアを進歩させるような新しいアイデア、ツール、デザインに対して開かれた心を持っています。時間の大半を管理会議に費やしたり、逆にコーディングばかりしていてはいけません。優れたアイデアは認め、アイデアが育つ雰囲気を作るのです。 開発関係者は、別のソリューションではなくそのソリューションが選ばれた理由や、どのようなトレードオフが含まれているかを明確に理解していなければなりません。──ドキュメントは、「決定の内容は何か」、「なぜそのような決定をしたか」という基本的な問いに答えるものでなければなりません。 自分のアイデアや信念が議論に耐えられないようなものなら、そんなものを基礎としてシステムを作るより、今それは誤りだと気付くほうがよほどよい。 早い段階で保守リーダーの参加を求める。保守リーダーを開発チームの中心メンバーに据える。アプリケーションのサポート計画に保守リーダーを加える。 抽象的に見ると、すべてのアルゴリズムは、データのあるバージョンを別のバージョンに変換する作業です。プログラム全体は、データをさまざまなリビジョンに変化させていく変換処理を集めたものにすぎません。──データ指向の見方を取れば、複雑なシステムでも、相手にできる程度の細部をまとめたものに圧縮できます。 解決策が1つしか見つからないことはまれです。おそらく、アーキテクトがそのドメインでは経験不足なのでしょう。自分を抑えて経験のある他の人に助けを求めたほうがよいです。 設計や実装を完璧なものにしたいという誘惑に負けてはなりません。「十分よい」レベルを狙い、そこまで達したら立ち止まるのです。──アーキテクチャーと設計にずれがなく、実装は正しく動作してパフォーマンス要件を満たし、コードが簡潔明快でドキュメント化されていれば十分よいと言えます。 意見の不一致を受け入れて仕事を進めることを覚えましょう。 失敗したプロジェクトを振り返ってみると、失敗したのは、能力がないからではなく、勤勉さと危機意識が欠けていたからだと分かります。 アジャイルであろがなかろうが、自分の判断プロセスが完全に把握できていなければなりません。次の2つの条件が満たされるまで、アーキテクチャー上の決定を下したといってはなりません。──決定事項をきちんと文書化する。──影響を受ける人に決定事項を伝える。 未来のないテクノロジーのために、プロジェクトを危険にさらさないように注意すべきです。 システムは設計した通りにはならない、と理解しなければなりません。 複数のフレームワークを導入する場合は、互いに重複がなく、何かに特化したフレームワークを選ぶこと。 最後に参加したプロジェクトを最初からやり直すことができるとすれば、何を変えたいのかを聞けば、教訓を応用する能力があるかどうかが推測できます。 今のニーズにもっとも合うソリューションを選びましょう。それ以外のものは、未来の選択として誤っているだけでなく、今の選択としても誤っているのです。 最初から大規模なシステムを設計することにはほとんどメリットはありません。──大きな設計ではなく、大きなビジョンを持つのです。 計算機を扱うにあたって、もっと本質的な知識とは？アルゴリズムとデータ構造、情報理論、計算機の動作原理、情報検索、情報圧縮…などなど。これらの知識は、ウェブでは手に入りにくい。──情報源は書籍（特に大学の教科書）や学術論文にあります。 開発中のドキュメントと保守ドキュメントを明確に区別することが重要となります。</description></item><item><title>VIM のフォントを設定する (gvimrc)</title><link>https://maku.blog/p/ba6kwjd/</link><pubDate>Wed, 09 Sep 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ba6kwjd/</guid><description>Gvim のフォントは、guifont にフォント名と、pt 数を指定することで変更できます。
:set guifont Courier:14 &amp;#34;Windows の場合 :set guifont Courier\ 14 &amp;#34;Linux の場合 フォントの候補をカンマで区切って複数指定することができます。
:set guifont=Courier\ New:12, Arial:10 フォントの高さと幅を別々に指定することもできます。
:set guifont=FixedSys:w10:h8 フォントをダイアログから選んで設定する場合は、次のコマンドを実行します。
:set guifont=* 詳しくは、
:help &amp;#39;guifont&amp;#39; (gvimrc) ファイルタイプ別にフォントを設定する 例: *.txt ファイルを開いた場合のフォントを設定する autocmd BufEnter *.txt set guifont=Arial\ 12</description></item><item><title>TeraTerm でログを自動保存する</title><link>https://maku.blog/p/oi9yak2/</link><pubDate>Fri, 17 Jul 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oi9yak2/</guid><description>TeraTerm 起動時にログを自動でファイルに保存するようにする （Version: TeraTerm 4.62 で確認）
メニューから、Setup → Additional settings&amp;hellip; Log のタブを開き、例えば以下のように設定 Default Log File Name (strftime format): %Y%m%dT%H%M%S-log.txt Default Log Save Folder: D:\y\log\teraterm Auto start loggin: Check 最後に Setup → Save setup で設定を保存 これで、TeraTerm 起動時に自動で 20090717T201506-log.txt のような名前で、ログファイルを作成してくれるようになります。
ログファイルの各行に Windows システム時刻を付加する 以下のように設定しておくと、
メニューから File → Log&amp;hellip; （ログ取得中の場合はいったんログ取得を停止してから） Option から Timestamp にチェックを入れて Save 最後に Setup → Save setup で設定を保存 ログファイルの各行に以下のような、時刻のプレフィックスが付くようになります。
[Tue Jun 28 13:37:27.890 2011] ... [Tue Jun 28 13:37:30.590 2011] .</description></item><item><title>Doxygen のコメントの書き方: TODO コメント</title><link>https://maku.blog/p/8nnbyho/</link><pubDate>Tue, 09 Jun 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8nnbyho/</guid><description>関数のコメントとして、以下のように @todo タグを入れておくと、 ドキュメント内の Member Function Documentation の節で、TODO リストとして表示されるようになります。
ヘッダファイルではなく、CPP ファイル内にインラインコメントとして @todo を含めることもできます。 この場合は、ヘッダファイル内の関数コメントとして有効な Doxygen コメントを記述しておく必要があります。
/** * @brief Brief description. * @todo Modify macros. */ void Hoge(); void MyClass::Hoge() { /// @todo Modify macro name. TEMPORARY_MACRO(); }</description></item><item><title>Doxygen のコメントの書き方: 関数のコメント</title><link>https://maku.blog/p/t3xmq3m/</link><pubDate>Tue, 09 Jun 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t3xmq3m/</guid><description>関数のコメントの書き方 ここでは、Javadoc スタイルのコメント記法を使っています。
/** * @brief Brief description 1. * Brief description 2. * * Detailed description 1. * Detailed description 2. * @param[in] param1 Param1&amp;#39;s explanation. * @param[out] param2 Param2&amp;#39;s explanation. * @param[in,out] param3 Param3&amp;#39;s explanation. * @return The number of channels in the list. * @see RelatedFunction() */ int MyFunc(int param1, const Foo&amp;amp; param2, Bar&amp;amp; param3); Brief description と Detailed description の間には空行を入れるようにします。 できれば Brief description は一行で書くようにしてください。
Detailed description を記述しない場合は、以下のように空行を省略しても大丈夫です（コマンドが切れ目になるので）。</description></item><item><title>Doxygen の基本的な使い方と初期設定</title><link>https://maku.blog/p/ne3ocwx/</link><pubDate>Tue, 09 Jun 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ne3ocwx/</guid><description>コマンド 設定ファイル Doxyfile を作成する $ doxygen -g 次のように -s オプションを付けて生成すれば、最小限のコメントを含んだ Doxyfile を生成できます。
$ doxygen -s -g ドキュメントを生成する $ doxygen [configName] ※設定ファイル名を省略した場合は、Doxyfile が使用されます。
Doxyfile で最低限設定しておいた方がよさそうなタグ プロジェクト名を指定 PROJECT_NAME = MyProject HTML 形式のドキュメントだけを作成するように設定 GENERATE_HTML = YES GENERATE_CHI = NO GENERATE_LATEX = NO ※これがデフォルトで YES になってる GENERATE_RTF = NO GENERATE_MAN = NO HTML 出力形式の設定 SOURCE_BROWSER = YES # Files tab includes *.cpp files. GENERATE_TREEVIEW = YES # A side panel will be generated. doxygen コマンド実行時に warning 以外の出力を抑制する QUIET = NO WARNINGS = YES 下位ディレクトリも処理 RECURSIVE = YES</description></item><item><title>Doxygen の設定いろいろ (Doxyfile)</title><link>https://maku.blog/p/x79fc82/</link><pubDate>Tue, 09 Jun 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x79fc82/</guid><description>基本的な設定 プロジェクト名を指定 PROJECT_NAME = MyProject HTML 形式のドキュメントだけを作成するように設定 GENERATE_HTML = YES GENERATE_CHI = NO GENERATE_LATEX = NO ※これがデフォルトで YES になってる GENERATE_RTF = NO GENERATE_MAN = NO HTML 出力形式の設定 SOURCE_BROWSER = YES # Files tab includes *.cpp files. GENERATE_TREEVIEW = YES # A side panel will be generated. doxygen コマンド実行時に warning 以外の出力を抑制する QUIET = NO WARNINGS = YES 指定したディレクトリ内のファイルを対象にする 例: カレントディレクトリ以下を対象にする（デフォルト） INPUT = RECURSIVE = YES 例: 指定したディレクトリ以下を対象にする INPUT = /home/john/src RECURSIVE = YES 特定のディレクトリを対象外にする パターンに一致する名前のディレクトリをドキュメント化の対象から外すことができます。</description></item><item><title>読書メモ『情報整理術クマガイ式』熊谷正寿</title><link>https://maku.blog/p/b2zio3x/</link><pubDate>Sat, 07 Feb 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b2zio3x/</guid><description> 情報整理術クマガイ式 熊谷正寿 かんき出版 夢を実現するには時間が必要 → 情報を探すのには時間がかかる → 情報を整理して時間を確保しよう。 というコンセプトの本。
専門家や経営者のブログを定期的に巡回すると勉強になる。 情報整理は手間がかかるくらいでよい。情報整理の際に情報に触れることで、頭の中が整理され、記憶に残りやすくなる。 お気に入りでファイルを管理するようにすると、マウスを動かしていくだけでフォルダをどんどん開いていける。 予定に関連するファイルは次のように分けた時系列フォルダに入れておくとよい。例えば、毎週水曜日にチェックしなければならない Web サイトのショートカットを「毎週／水」のディレクトリに入れておけば、水曜日にそのディレクトリをチェックするだけでよい。定例会議で使う資料もここから辿ることができる。 「毎月」フォルダ &amp;ndash; 1日～31日 のサブフォルダを作る。 「毎週」フィルダ &amp;ndash; 月～日 のサブフォルダを作る。 「毎日」フォルダ 1つの用件に対しては1枚のリフィルを使う。1枚のリフィルにたくさんの用件を記述してしまうと、インデックスをつけて検索できなくなるし、並び替えて情報を整理することもできなくなる。リフィルに限らず、ポストイットやA4用紙に関しても同様。 今すぐディープな情報が欲しいと思ったら、とにかく情報をたくさん集めるとよい。ただし、夢や目標を明確にしてから情報収集に望むこと。たくさんの情報に接しているうちに、情報を選別する目が養われる。 「メディア情報」と「人情報」はバランスよく集めないとダメ。 「一日一改善」を目標にする。 会議を行う時は、遅くても前日の午後5時までにアジェンダ、必要な資料を参加者全員にメールする。会議内で数字の説明をすることなく、すぐに意見をぶつけ合うことができる。 訪問の要請があったら失礼のないように用件をメールで送ってもらうとよい。わざわざ会わなくても済む案件が多い。 「事前に資料を揃えておきたい」 「案件に詳しい担当者を同席させたい」 「お力になれるかどうか検討したい」 「誠実に対応したい」 電話は机の左側に置いて左手で受話器を取るようにすると、右手でメモを取りながら話すことができる。 GMOインターネットでは「挨拶抜きの社内電話応対ルール」決めている。1日に10回電話するとしたら、1回につき20秒節約できるとして、1ヵ月で1時間もの時間を節約できる。 ある金融機関のストラテジストの話。「成功する秘訣は？」「絶対に風邪をひかないこと」 ビタミン剤を眠る前に飲むと眠っている間に疲れを取ってくれる。 集中力が落ちてきたと思ったら、ブドウ糖のサプリメントをとると頭がスッキリしてくる。講演会や会議の前に取ると集中できる。</description></item><item><title>ライフハック: GTD 風の E-mail 分類手法 (Email Inbox Zero)</title><link>https://maku.blog/p/ckahx6k/</link><pubDate>Tue, 03 Feb 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ckahx6k/</guid><description>メールの処理方法に関するハック The inbox makeover｜Macworld Google Video - Inbox Zero Email: Empty Your Inbox with the Trusted Trio こんな感じでやってみるのがよいかも メールを受信したら以下のフォルダに一気にガーっと振り分け、Inboxの中は0件にする（InboxZero 方式）。振り分け終わったら、上から処理する。
Respond: すぐに返信できるもの（5分以内に返信できるもの）。 Action: なんらかの作業が必要なもの（資料をまとめたり、調査が必要なものなど） 。 Waiting: 誰かの返事待ち。 Archive: 今後参照する可能性のあるもの。 NotImportant: 今後参照する可能性のないもの。読む時間がなかったらスルーしても困らないもの。 Spam: スパムメール。 NotImportant、Spam に入れるべきメールは Subject から判断できるものも多いので、フィルタ機能で自動で Inbox から移動するようにしておく。直接ゴミ箱に入れずにいったん Span に入れるのは、スパムじゃないものまで捨ててしまうのを念のため防ぐため。
Archive フォルダ内のメールは検索で探すことを基本とする。場合によってはサブフォルダを作って分類したり、タグを付けて管理してもよい。</description></item><item><title>メモアプリ/Wikiのアイデア</title><link>https://maku.blog/p/z9r3xt9/</link><pubDate>Fri, 30 Jan 2009 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z9r3xt9/</guid><description>ファイル名に ID とタイトルを両方いれる ＜ID＞_＜Wikiページのタイトル＞.wiki のようなファイル名にすれば、ファイル名から ID と Title の両方が取得できる。 ファイル名が長くなるのが欠点か。
子ノードの管理 ページ内にリンクを張っておくと、 そのページが自動的にツリー表示で子ノードとして表示される。
通常ファイルの付加情報を別ファイルで管理する sample.zip に付加情報を追加する場合は、同じディレクトリに sample.zip.additionalinfo のようなファイルを生成し、そのファイル内に &amp;ldquo;Title: サンプル&amp;rdquo; のように書いておく。
ファイルの一覧を表示するときなどは、上記のメタデータを利用して表示するとわかりやすい。
バックアップはビューアごと CD-R/DVD-R へ メモをバックアップするときは、そのとき使っていたビューアもいっしょに焼いて、 焼いた CD-R から直接メモを参照できるようにしたい。 ビューアもいっしょに焼くのは、メモのフォーマットが変わったりしても、その CD-R 内のメモは確実に読めるようにするため。
プラグイン機能でページごと拡張 プラグインは文字の装飾などに使うだけではなく、そのページの属性を拡張してしまう用途にも使える。 例えば、Wikidpad のケースでは、ページの中に [color: blue] と書いておくと、そのページのツリー項目が青色で表示される。
WikidPad の Attributes という考え方 WikidPad には Attributes という機能があって、ページの中に [Attribute: Value] というテキストを含んでおくと、左のツリービューの Views というノードからその位置に簡単にジャンプできるようになる。 Attribute 名は次のように階層化して管理することもできる。
[Foo.Bar.Hoge: Value] どうやって、ジャンプ先のインデックスを作ってるんだろ？
本文とヘッダの編集は別のエディタで メモの本文と、付加情報を示すヘッダ部分は別々の画面（エディタ）で編集できるようにしてもよいかも。 その場合、編集画面は Perforce のクライアント設定のようにテンポラリ・ファイルを Vim などで開いて情報入力することができるといい感じ。
ローカルファイルを簡単に扱えるメモ管理ソフトだと導入しやすい 既存のテキストファイル (.txt) があるディレクトリを操作して、自動的にデータベースを作成し、いろいろ付加情報を追加できるようなソフトになっていると導入しやすいかも。 ただ、ファイル名を変更したときなどに整合性を保つのが大変か。</description></item><item><title>SQLite 雑多メモ</title><link>https://maku.blog/p/w5x4797/</link><pubDate>Sun, 16 Nov 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w5x4797/</guid><description>SQLite にできないこと SQL Features That SQLite Does Not Implement より。
ユーザごとにアクセス制限ができない。 GRANT によるアクセス権限の制御はできない。 SQLite にはデータベースサーバが存在せず、クライアントが直接 DB ファイルにアクセスする形式のため、サーバでの GRANT によるアクセス権限の制御ができない。 そのユーザーがファイルにアクセスできるということは、そのデータベースに対して何でもできるということを示す。 VIEW は使えるがリードオンリーである。 SQLite 2 と SQLite 3 の違い バージョン 3 では BLOB (Binary Large OBject) がサポートされた。 バージョン 3 のほうがデータベースファイルのサイズがコンパクトになる。 整数の連番を生成する ROWID がバージョン 2 では 32bit、バージョン 3 では 64bit。 SQLite 2 のデータベースファイルを SQLite 3 のデーターベース形式に変換する $ sqlite db2 .dump | sqlite3 db3 各言語用の SQLite ライブラリ SQLite Wrappers Python で SQLite を操作する PEP 249 &amp;ndash; Python Database API Specification v2.</description></item><item><title>『アジャイルソフトウェア開発の奥義』ロバート・C・マーチン（輪講メモ）</title><link>https://maku.blog/p/fn9ris5/</link><pubDate>Mon, 27 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fn9ris5/</guid><description>今回読み進める本は、『アジャイルソフトウェア開発の奥義』です。 第2版までは日本語版が出てます。内容的にはどの版のものを読んでも大丈夫。
第1版 アジャイルソフトウェア開発の奥義 ロバート・C・マーチン ソフトバンククリエイティブ 第2版 アジャイルソフトウェア開発の奥義 第2版 オブジェクト指向開発の神髄と匠の技 ロバート・C・マーチン ソフトバンククリエイティブ 第3版 Agile Principles, Patterns, and Practices in C# Robert C. Martin Prentice Hall ちなみに版が進むごとにサンプルコードの言語がより高水準な言語に変わっています。
第1版: C/C++ 第2版: Java 第3版: C# 第1版と第2版の内容はほとんど一緒だけど、第3版には各種ダイアグラムに関する説明の Chapter.14～20 が追加で挿入されています。 C/C++ のコードで読みたい場合は、書店からなくなる前に第1版を買っておいた方がよいです。
以下、各章ごとのポイントや議論のメモです。
Preface（序文） 単なるパターン集ではなく、そのパターンが「なぜ」生き残ったのかという過程を知ることが大切。 著者 Robert C. Martin（Object Mentor 社の創設者。社長）は、11個のオブジェクト指向の原則をまとめている。それに従って設計することで、デザインパターンですら導き出される。 Section I: Agile Development（アジャイル開発） ▼議論 Q. アジャイルを大規模な開発に適用できるか？
当初は大規模開発に適さないのでは？という懸念があったが、結果として大規模開発においてもアジャイル開発が主流になりつつある。ただ、いつものことだが日本では普及が遅れている。 大規模プロジェクトにおけるアジャイル開発に関しては、下記の記事や書籍が参考になる。
IBM Rational アジャイル開発 (そのうち3分の1は従業員数10,000人以上) の88%がアジャイル・プロセスを使用中または評価中である 書籍: 『The Object Primer（邦題: オブジェクト開発の神髄）』 アジャイルソフトウェア開発の長所の一つ: 規模の大小を問わずうまくいく。 The Rational Edge (72) アジャイル開発の広範な普及を目指して The Rational Edge (28) 大規模プロジェクトにアジャイルを適用する方法 「この大規模プロジェクトがアジャイル手法で管理できるのか？ 」という疑問が出てくる。その答えはイエスだ。 アジャイルソフトウェアプロセスを使ってオフショア開発（English） アジャイルソフトウェアプロセスを使ってオフショア開発（日本語） 分析と設計はオンショアで行い、構築をオフショアで行い、そして受入試験をオンショアで行うというやり方よりも、オフショアのチームにできるだけ多くの工程をやらせると問題が改善される。作業工程に沿って分けるのではなく、機能面に沿った分割を行う。 バグフィクスからやらせると、開発者は変更するよりも多くのコードを読むことになるので、コードベースに精通することができた。 オフショア開発においては、ドキュメントを作成するための時間を確保する必要がある。 最低限、IM と Wiki、良質の電話回線を用意すること。 Chapter 1.</description></item><item><title>読書メモ『手帳フル活用術 仕事の達人、27人の手のうち！』</title><link>https://maku.blog/p/ot2a7rx/</link><pubDate>Sun, 12 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ot2a7rx/</guid><description>文庫本サイズなので、最初に読む手帳本としてはよいかも。
「会いたい人」を手帳に書いておくとよい。それを何度も見ることで意識することができ、それを回りに吹聴することで自然にコネクションができたりする。 心理学に「ザイアンスの単純接触の原理」がある。何度も何度も手帳をチェックすれば、その内容を好きになってくる。 「このテーマについてもっと情報を集めたい」と思ったら、手帳のよく見える場所にそのテーマのキーワードを書き込んでおく。普段何気なく見過ごしてしまう情報も、意識していることで脳に飛び込んでくるようになる。このように潜在意識が欲求を理解することを大脳生理学で「オートマトン」という。 「部下指導日記」をつける。部下ごとに毎日、どんな教育をしたか、どんなアドバイスをしたかを書き込んでいく。 言われたことをその場で手帳に書き込まないと、相手が心配する。 手帳に記された予定に沿って、どんな準備をするかが大切。 「やりたいこと」を書き下すとよい。下記はその例。 コンサルタント業 人のプロデュース 単行本の執筆 小説家 翻訳家 ルポライター 経済評論家 経営評論家 雑誌の連載 テレビ出演 講演 各種セミナーの企画・運営 教育（大学、ビジネススクール） 漫才・落語作家 番組の企画（テレビ、ラジオ） 映画のプロデュース（企画、脚本など） 出版社の経営 飲食店の経営 飲食店のプロデュース 芸能プロダクション経営 イベントの企画・運営 テレビキャスター ラジオパーソナリティ 旅行企画・主催 手帳に書く5つの「夢リスト」 To Do List（何をやりたいのか、何をやるべきか） To Be List（どんな人になりたいのか、どんな状況にしたいのか） To Have List（何が欲しいのか、何があれば便利か） To Meet List（誰に会いたいのか、どういう人と会うべきか） To Study List（一番勉強したいことは何か、自分の生涯学習は何か） すべての仕事でもっとも大切なことは「ゴールの設定」。仕事ができる人はゴールを決めてからいつスタートするかを考える。 自分自身が気づいていない「コンピタンシー」を発見するために、周囲の人に、自分にはどんな能力があるのか意見をもらうといい。</description></item><item><title>読書メモ『人生は手帳で変わる 第4世代手帳フランクリン・プランナーを使いこなす』</title><link>https://maku.blog/p/bymt9rp/</link><pubDate>Wed, 08 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bymt9rp/</guid><description>フランクリン・プランナーでは、自分の中で最も大切なこと (Value, Role, Mission) をはっきりさせて、その価値観にそった行動をすることに着眼しています。 この本の付録にある、「演習：最も大切なことを発見するためのヒント」は使えそうです。
ある男性の価値観の例 常に誠実であること 何事にもチャレンジすること 物事に柔軟に対応すること 正直であること 経済的に自立すること 前向きに考えること 言ったことは実行すること 謙虚であること 今やっている仕事が不本意なものであっても、自分の目的を実現するための一歩なのだと決めて取り組めば、モチベーションはまったく違ってくる。 会議を成功させるためには、その目的をはっきりさせることがもっとも大切となる。どんなミーティングでも、その目的は 3 つしか存在しない。 決定するためのミーティング 各人のアイデアを自由に出し合うブレーンストーミングのためのミーティング 告知、情報提供のためのミーティング タスクをこなす上で最も重要なのは、タスクを「いつ始めるか」。今日やることをリストにするだけでなく、何時から何時の間にやると明記することが必要。</description></item><item><title>読書メモ『人生は手帳で変わる』の付録『最も大切なことを発見するためのヒント』</title><link>https://maku.blog/p/r55ad8w/</link><pubDate>Wed, 08 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r55ad8w/</guid><description>「価値観 (Value)」を考える 10年後にはどのような人になりたいですか？ 例：周りから尊敬される人 人と接する上で何が一番大切ですか？ 例：どんなときでも誠実に対応すること 失うと生きる気力がなくなるものはなんですか？ 例：家族と一緒に過ごす時間 今後の人生において最も身に付けたい才能や能力はなんですか？ 例：周りの人の能力を最大限に引き出せるような教える能力 あなたが最も得意だったことはなんですか？ 例：周りの人たちとコミュニケーションをとること。 あなたがこれまでに最もわくわくしたことはどのようなことでしたか？ 例：自分の子供の成長が実感できたこと あなたが心の底から「リラックス」できる時間はどのような時ですか？ 例：家族だけでゆっくりとした時間を過ごしているとき あなたの理想とする人は、何を最も大事にしているのでしょうか？ 例：友情 あなたが出会った人の中で、最も愛する人は誰ですか？ 例：妻 人生の中で、学ぶことの多かった失敗、挫折体験はなんですか？ 例：大学受験で失敗したこと。⇒地道に努力する必要性を知った。 仕事とプライベートで共通して言える指針はなんですか？ 例：できるだけ嘘をつかないで事にあたる。 20年後の自分に質問して価値観を考える（あらゆる面で満足している自分をイメージして） あなたがそのような成功をおさめたのはどうしてですか？ 例：地道な努力を続けた そのようになるには何が必要でしたか？ 例：周りの人に恵まれた そのように運にも恵まれるには、あなたが何をしてきたからですか？ 例：誠意をつくして正直でありつづけた 「役割 (Role)」を考える 「役割」と、その中で「実現したいこと」を考える。 例：父親、友人、夫、上司（部下）、子供、兄弟、社会の一員、テニスクラブのメンバー 「ミッション (Mission)」を考える（自分自身の憲法） あなたの人生のなかで、充実感の高かった成功体験は何でしたか？ 例：全国スピーチ大会で優勝したこと ⇒ 自分を素直にアピールすることに長けていた。 今後仕事面で実現したいことは何ですか？ 例：独立してレストランを開く プライベートで、すばらしい結果をもたらすとおもわれることは何ですか？ 例：子供と野球チームを作り、親子の対話を欠かさない 毎日の生活で気をつけていることは何ですか？ 例：元気に挨拶をし、周りの人を気持ちよくさせる 私生活で最も価値があると考える活動は何ですか？ 例：地球環境にやさしいリサイクル活動を行う 今後の人生でやりたいことは何ですか？ 例：つりに打ち込み、名人になる 今、十分な時間があれば誰と何をしたいですか？ 例：妻と一緒に全大陸を旅行する これからの人生で一番実現したいことは何ですか？ 例：事業を成功させる あなたの理想とする人生はどのようなことを成し遂げた人ですか？ 例：周りの人に常に元気を与え続けた父のようになる あなたの人生のなかで大きな影響を受けた人はどんな点が最も優れていましたか？ 例：どんな人とも分け隔てなく付き合おうとした点 あなたの得意なものは何でしたか？また今後どう活かしますか？ 例：みなの前でしゃべること。 ⇒ 「話す」ことに充実感を感じ、リーダーシップをとることに誇りを感じる 弔辞（ちょうじ）を考えてミッションを明らかにする 私生活での友人の弔辞の例 例：誠実で信頼できる友に先立たれ、大きな喪失感を味わっています 職場の同僚の弔辞の例 例：皆を率いたリーダーを喪い、明日から路頭に迷いかねません 地域社会の知人の弔辞の例 例：誰からも愛されたあなたですから、天国でも楽しく過ごされることでしょう 家族からの弔辞の例 例：子供たちの良き手本となり家族を正しい方向へ導いてくれました 職場の部下（上司）からの弔辞の例 例：先輩がいらしたからこそ横道にそれずに歩んでこられました 最も大切なこと（Value, Role, Mission）が明らかになったら 「価値観」に説明文をつける 「役割」に説明文をつける 長期目標とそのためのステップを設定する</description></item><item><title>CppUnit の使い方メモ</title><link>https://maku.blog/p/nyj2hxe/</link><pubDate>Tue, 19 Aug 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nyj2hxe/</guid><description>CppUnit-x のダウンロード＆インストール Version: CppUnit-x 20020331 Red Hat Linux 9 SourceForge.JP: Project Info - CppUnit-x http://sourceforge.jp/projects/cppunit-x/ CppUnit-x は数多くある CppUnit の派生物の中でも移植性が高いといわれています。 2008-08-19 現在のバージョンは 20020331 です。 次のように CppUnit-x のアーカイブをダウンロードしてインストールします。
$ wget http://iij.dl.sourceforge.jp/cppunit-x/8452/cppunit-x-20020331.tar.gz $ tar xzvf cppunit-x-20020331.tar.gz $ cd cppunit-x-20020331 $ ./configure $ make $ su # make install これにより、以下のようなライブラリやヘッダファイルがインストールされます。
/usr/local/lib/libcppunit.a /usr/local/include/cppunit/*.h はじめての CppUnit-x テストが 1 つだけの場合は、TestCase のサブクラスで runTest() メソッドをオーバーライドしてテストコードを実装します。 TestRunner オブジェクトに TestCase オブジェクトを追加して TestRunner::run() でテストを実行できます。 TestRunner::run() を呼び出すと、TestRunner に登録された TestCase の runTest() が順に呼び出されます。 次の例のように、名前空間の使用宣言に、USING_NAMESPACE_CPPUNIT というマクロを使用すると、名前空間をサポートしていないコンパイラを使った場合にもそのままコンパイルできるようになります。</description></item><item><title>TV規格: ISDB(ARIB)メモ</title><link>https://maku.blog/p/h52ih57/</link><pubDate>Mon, 14 Jul 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h52ih57/</guid><description>自動表示メッセージ (Auto Message) 左下に表示される B-CAS 関連のメッセージ枠などに関する仕様です。 詳しくは「ARIB TR-B14 5.10 自動表示メッセージ表示」を参照
EMM共通メッセージセクションの自動表示消去種別というもので表示の ON/OFF を行う 0x00 消去可: ユーザ操作で表示 OFF してもよい 0x01 消去不可: 出しっぱにしなきゃダメ 0x02 表示消去: 今消すべし 映像といっしょに EPG（番組表）などが表示されている場合に、自動表示メッセージを表示するかどうかは商品仕様による（表示 OFF にしているものがほとんど）。 表示枠は視聴を邪魔しないように半透明などにするのが望ましい（とは言っても、視聴の邪魔をして有料契約させる意図がある）。 文字色は商品仕様によるが、無彩色にして必要以上に目立たせないのが望ましい。 録画された番組を再生する場合にも、TS データに基づいて表示する。契約情報などは、その時装着されている IC カードに基づいて判断すること。 デコードに関するメッセージ、例えば IC カード抜け（デスクランブルできない）などのメッセージは優先して表示してよい。IC カードを装着してデコードできる状態になってから（映像が見えてから）自動表示メッセージを改めて表示すれば OK。 Network ID、TS ID、Service ID などのユニーク性に関して 『ＢＳ/広帯域ＣＳデジタル放送運用規定 ARIB TR-B15　6.5版（第二分冊） 5.3 識別子の運用』より。 network_id: BS デジタル放送に対して1 個割り当て。日本国内でユニーク。 transport_stream_id: 各TS に対し割り当て。ネットワーク内でユニーク。 service_id(=program_number): 各編成チャンネルに対し割り当て。ネットワーク内でユニーク。 event_id: 各イベントに対し割り当て。service 内でユニーク。 broadcaster_idブロードキャスタに対して割り当て。オリジナルネットワーク内でユニーク。 series_id: 番組のシリーズに対して割り当て。ブロードキャスタ内の同一メディ アタイプに属するサービス群内でユニーク。 8.2.1 event_id の再使用について（時間方向の一意性）より 終了時刻を過ぎれば、そのイベントに付与された event_id の値は、EIT から消え、一定時間後、別のイベントに対し同じ値を付与することが可能となる。 しかし、終了時刻から 24 時間以内は別のイベントに対し同じ値を付与し EIT に記述してはならない。</description></item><item><title>将棋、チェスなどの対人ゲームで待ち時間を減らすアイデア</title><link>https://maku.blog/p/pd4aqk6/</link><pubDate>Mon, 14 Jul 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pd4aqk6/</guid><description>将棋やチェスって、相手が長考する人だと待っている時間がヒマだったりしますよね（その時間も考えろよという話ですが）。 あと、今はもうないかもしれませんが、手紙を使って手を進めていくゲームなどでも待ち時間はすごく長いです。
こんなときは、2枚の盤を使って同時に先手・後手になって交互に指す、というのが面白いです。 つまり、同じ相手とやる多面指しです。 うまくタイミングが合うと、常に自分の手番になります（笑）。
別に将棋ｘ２でやらなくても、オセロと碁、将棋とチェスみたいに別のゲームを同時にやっても面白いです。 慣れるまでは頭の体操みたいになっちゃいますけど。</description></item><item><title>クワイン・マクラスキー法 (Quine-McCluskey algorithm)</title><link>https://maku.blog/p/m4x8mcw/</link><pubDate>Fri, 20 Jun 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4x8mcw/</guid><description>カルノー・マップを用いた Bool 演算の簡易化のような処理を、単純な処理の繰り返しで行えるようにしたもの。コンピュータでの処理に向いている。
クワイン・マクラスキー法 - Wikipedia Petrick&amp;rsquo;s method - Wikipedia</description></item><item><title>無名サブルーチンとクロージャ</title><link>https://maku.blog/p/r58xbyk/</link><pubDate>Wed, 30 Apr 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r58xbyk/</guid><description>『初めての Perl 第3版』より
クロージャ (closure) は非常に強力な概念で、Lisp の世界から持ってきたものです。クロージャとは、（荒っぽい言い方をすれば）自分自身のプライベートなデータを持っている無名サブルーチンです。
『続・初めての Perl』より
その時点で存在するすべてのレキシカル変数に、宣言された時点からアクセスできるサブルーチンをクロージャ (closure) と呼びます（クロージャは、もともとは数学用語です）。
例えば、以下の callback サーブルーチンは、レキシカル変数 $count を参照するクロージャといえます。
my $count = 0; sub callback { ++$count; }</description></item><item><title>ライフハック／未分類メモ</title><link>https://maku.blog/p/j26fuew/</link><pubDate>Sun, 16 Sep 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j26fuew/</guid><description>ストレスフリーに過ごすコツ 自分の心配ではなく、他人のことを気遣うようにする。他人のことを考えていれば、自分のことで悩む暇はなくなる。 何かに夢中になること。読書、ゲーム、運動、DIY などなんでもよい。 プレゼンテーションの上達方法 ロールモデルを持つ 例えば、レーガン大統領のプレゼンをイメージし、彼とどこが違うのかを分析する。 他人のアドバイスは反論せずに真摯に受け止める 自分のプレゼンを客観的に分析する 参考: 先見経済 2005-11-07「プレゼン力を鍛える（西野浩輝）」
三日坊主の防止法 目標は現実的なものを設定する。 目標を達成したら何が得られるかを明確にする。 目標を細分化して達成感を得られやすいようにする。 参考: BIG tomorrow May 2006「三日坊主を直すための方法・大研究」
2 つの作業の期間を合わせてリズムを作る 例: ブリタ（浄水器）のカートリッジを変える時に台所で使うスポンジを新しいものに交換する。</description></item><item><title>大規模なコードを読み解くコツ（コードリーディング）</title><link>https://maku.blog/p/b34f2vu/</link><pubDate>Sat, 12 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b34f2vu/</guid><description>階層構造の意味をメモする 大規模なプロジェクトのソースコードを読む場合は、まずはディレクトリがどのようなポリシーで分けられているのか、各ディレクトリ内のコードの役割などのメモを作成していくことをオススメします。
役割のわからないディレクトリについては、そのままにしておいて、わかった時点で詳細を追加していけば OK です。
project +-- tools（ほげほげ用のツール） +-- src +-- hogeui（ほげほげインタフェースに関するクラス） +-- foobar（？）</description></item><item><title>Linuxコマンド: パッチファイルを作成・適用する (diff, patch)</title><link>https://maku.blog/p/nyehhfd/</link><pubDate>Fri, 11 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nyehhfd/</guid><description>パッチの基本 (diff/patch) パッチファイルの作成 sample.cpp #include &amp;lt;iostraem&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;AAA&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } ew/sample.cpp #include &amp;lt;iostraem&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;BBB&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 例えば、上記のような sample.cpp の内容を new/sample.cpp に変更するためのパッチファイルを作成するには、次のように diff コマンドを実行します。
$ diff -u sample.cpp new/sample.cpp &amp;gt; sample.patch -u オプションは unified diff 形式で差分を出力することを示しています（他の形式でも出力可能ですが、patch 用のパッチファイルを作成するときは、ほとんどの場合 unified diff 形式が使用されるようです）。
これで、次のようなパッチファイルが生成されます。
sample.patch --- sample.cpp 2007-05-11 20:36:13.265625000 +0900 +++ new/sample.cpp 2007-05-11 20:26:31.875000000 +0900 @@ -1,6 +1,6 @@ #include &amp;lt;iostraem&amp;gt; int main() { - std::cout &amp;lt;&amp;lt; &amp;#34;AAA&amp;#34; &amp;lt;&amp;lt; std::endl; + std::cout &amp;lt;&amp;lt; &amp;#34;BBB&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 差分を表示している各行の 1 文字目は次のような意味を持っています。</description></item><item><title>ライフハック: ライフハックのライフハック</title><link>https://maku.blog/p/4kntagu/</link><pubDate>Fri, 11 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4kntagu/</guid><description>実行したい LifeHacks や、心構えのリストは常に持ち歩いて定期的に見直せるようにしておくとよいです。
実行すべき LifeHacks の内容を忘れてしまっては意味がないので。</description></item><item><title>ライフハック: 遠出したときの写真の撮り方</title><link>https://maku.blog/p/9658789/</link><pubDate>Thu, 10 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9658789/</guid><description>旅行にいったときや、遠くへ散歩に出かけたときなどは、ルールを決めて写真を撮っておくようにすると、その行動を後日思い出しやすくなります。
場所を移動したときは、場所が分かる写真を撮る 電車に乗る場合は、ホームなどで必ず駅名や地名の入ったものを写真に撮っておくようにします。 車や飛行機、船などで移動する場合も同様。 最近の携帯電話のカメラは GPS 情報が付加されるけど、写真内に地名が分かるものを写しておいたほうが手っ取り早いです。
一時間おきくらいに何でもいいから周辺の写真を撮る どんな場所にどれくらい時間をかけたかを思い出せます。 理想的には一時間おきに自分が見ている風景を自動的に撮影してくれる装置みたいなのがあればいいんですけどね。</description></item><item><title>ビリヤード: 最近の練習メニュー</title><link>https://maku.blog/p/d88pph6/</link><pubDate>Wed, 09 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d88pph6/</guid><description> 左手で 15 球入れる センターショット 10 球 押し引きを交互に 5 球ずつ（スクラッチさせる） フットショット　左右交互に 5 球ずつ への字　左右交互に 5 球ずつ 土手撞き　左右交互に 5 球ずつ 力加減の調整　左右 5 球ずつ バンクショット 練習方法模索中。。。 ボーラード 3 フレームとミスした配置の練習（3 連続ストライクを目指す） 出しや入れに失敗したら、その配置をできるだけ正確にメモして、その配置を納得するまで練習。 リカバリに失敗した場合は、リカバリする配置にしてしまった原因の配置と、リカバリショットの両方を練習すること。 メモが溜まれば、自分の苦手な配置のパターンが分かってくる。 Artistic Pool の課題球の練習 http://www.artisticpoolplayers.com/ 特殊な撞き方やキュー切れをアップさせることでプレーの幅を広げる。 自分のショットのスキルがどれだけ未熟かを認識できます。。。 その他の練習配置など</description></item><item><title>河口湖かちかち山へ</title><link>https://maku.blog/p/8rjkpe3/</link><pubDate>Wed, 02 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8rjkpe3/</guid><description>自然に癒されたくなったので河口湖へ。 河口湖駅から歩いて 15 分くらいで行けます。 湖の前のお店でほうとうを食べて、ロープウェイでかちかち山に登りました。 かちかち山からは河口湖の他に、富士山とか富士急ハイランドとか見渡せます。
う～～～ん、空気がうまーい。 と深呼吸したら、流れてきたタバコの煙をおもいっきり吸い込んでげほほっ。</description></item><item><title>富士急ハイランド、ええじゃないか</title><link>https://maku.blog/p/tamw4a7/</link><pubDate>Tue, 01 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tamw4a7/</guid><description>突然「ええじゃないか」に乗りたくなったので富士急ハイランドへ。 8 時開園だったので、4 時に起きて電車で 5 時発くらいの電車に乗って行きました。 ねむー。
前日は暑かったので薄着でいったら、曇っていてめちゃんこ寒かったので、中で上着を購入。
とりあえず 3 大ジェットコースター？のフジヤマ、ドドンパ、ええじゃないかに乗りました。 ドドンパは急発進していきなり 170 km くらい出すので、顔が風圧でぐにゃぐにゃです。 フジヤマは地上 80 メートルくらいまで上るし、さらに寒くてガクブル。 ええじゃないかは座席がぐるんぐるん回ったけど、ホールド感がすごいあったので、3 つの中では一番平和な乗り物でした。
近くにふじやま温泉ってのがあったので、そこで疲れをとってご飯たべて、歩いて 15 分くらいのビジネスホテルでねんねこ（富士急フリーパス込みで 8500 円でした）。
ふじやま温泉は風呂出た後にくつろげるスペースがたくさんあって結構よかったです。 ただ、富士急ハイランドを挟んで駅の反対側にあるから帰り道がかなり困ります。 ぐるーっと回って駅側に出るのは歩きだと結構遠いので、タクシー乗るのがおすすめかな。</description></item><item><title>シルク・ドゥ・ソレイユの「ドラリオン」見てきた</title><link>https://maku.blog/p/d4huh4e/</link><pubDate>Sat, 28 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d4huh4e/</guid><description>原宿駅近くの国立代々木競技場の横辺りに、シルク・ドゥ・ソレイユのドラリオンを見に行きました。12:30 から 15:00 まで。
シルク・ドゥ・ソレイユは、２年おきくらいに日本でミュージカル風のサーカスやってるグループです。サルティンバンコとかアレグリアとかが有名かな（見たことないけど）。 DVD でも出ているみたいなので今度見てみよっと。
簡単に言えば、サーカスの豪華版のようなものだけど、普通のサーカスに比べると、質が全然違います。技、音楽、衣装、パフォーマンスなど、見せ方がうまい。
とはいっても、高度な技がすべて成功することはなくて、何度かミスすることがありました。シルク・ドゥ・ソレイユがすごいのはここからで、ミスをすると同時にみんなが踊りだして、そのダンスの中でセットの修復などを済ませてしまう。普通のサーカスだったら、もう一回チャレンジしますよ的なパフォーマンスになってしまうんだけど、流れを乱さずにミスのフォローをするってところに感動しました。そのフォローの仕方を見たくて、途中からミスして欲しくなってしまいました。
SS席 11000 円はちょっと高めかなと思ったけど、それだけの価値はありました。</description></item><item><title>ビリヤードのアイデア: 詰めビリヤードという遊び方</title><link>https://maku.blog/p/3vej2ej/</link><pubDate>Thu, 19 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3vej2ej/</guid><description>昔、ビリヤードの雑誌の『球&amp;rsquo;s』か何かに、エフレン・レイズは球を取り出すのが面倒なので、練習ではポケットに入れないことがあるって書いてありました。 これは球が穴にプールされるタイプのテーブルの場合の話だと思うけど、ポケットさせないで練習するっていうのが結構新鮮でした。 ビリヤード場でそんな練習してる人ってほとんど見たことないから。
これを読んで思ったんですけど、ポケットビリヤードの台でも、先球をポケットさせない遊び方はもっとたくさんあっていいと思います。 カイルンなんかはその代表例だけど、キャロム系のゲームに捉われずにもっといろいろ楽しみ方はあるはず（アーティスティックは初心者には難しすぎ）。
例えば、ある条件を満たせたら得点ゲットとか、手球を課題通り動かせたらＯＫ、みたいな。 言うなれば、詰め将棋ならぬ、詰めビリヤードみたいな遊び方があってもいいと思う。
簡単な問題例として、以下の配置。
クリア条件: 手球フリーで、先球を 3 クッション以上させて、手球と先球をキスさせる
解答例はこちら: 20070419-002.png
いろんな遊び方、独特な練習方法を試して、個性的なスキルを身に付けていきたいですね。</description></item><item><title>ビリヤードのコツ: 左右を捻るときの顔のラインに注意</title><link>https://maku.blog/p/pnzzne6/</link><pubDate>Thu, 12 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pnzzne6/</guid><description>左右の撞点を撞くときは、キューのラインだけ平行移動させるのではなく、顔のラインをキューのライン上に乗せること。こうしないと、キューを真っ直ぐ出せないので、払うような撞き方になってしまう。カーブの出にくいショットをするためにも重要。
特に、こんな感じのレール沿いで強めに突く場合、払うような撞き方になってしまうと押しがかかりにくくなったり、方向がずれてガコりやすい。</description></item><item><title>ビリヤードのコツ: 素振りとラストストロークの調子を変えない</title><link>https://maku.blog/p/asgh5yd/</link><pubDate>Tue, 10 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/asgh5yd/</guid><description>素振りに意味を持たせるためにも、素振りとラストストロークで、ストロークの調子を変えてはいけません。 相対的なスピード自体は若干変わるのはしょうがないけど、全体のリズムを保つ感じ。
例えば、
上体の位置を変えない 握り方を変えない 力の入れ具合を変えない 前腕の軌道、キュー方向（ベクトル）の変化具合を変えない プロのラストストロークは、B級くらいの人と比べて、素振りとラストストロークのギャップが小さいのがよく分かります。 とくにハードショットのとき。
ラストストロークで急に力が入ってしまう癖のある人は、バックスイングの頂点まで脱力を保ちつつ、同じ軌道でキューを引くことに気をつけるとよいです。</description></item><item><title>ビリヤードのコツ: すべての動作を滑らかに</title><link>https://maku.blog/p/cxx9oa2/</link><pubDate>Mon, 02 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cxx9oa2/</guid><description>緊張していてもキューをまっすぐ振るコツは、すべての動作を滑らかにすること。 動作を滑らかにするには、スピードを一定にすることに気をつける。
ひとつはキューの振りのスピード（バックスイングからフォロースルーまで）。 ストロークのスピードが安定しないと、手球の動きも安定しない。 カクカクしたストロークはダメ。
もうひとつは自分なりのルーチンの動作のスピード（移動→狙う→構える→素振り→ラストストローク）。 各動作を滑らかに繋げられれば、乱れが減って落ち着けるし、見た目もきっとエレガント。
ストロークで意識するのは、肘から下の前腕が滑らかに真っ直ぐ出せるかどうか。 あくまで頭、ブリッジは動かさず、手首は使わずに柔らかく。</description></item><item><title>ビリヤードのアイデア: 練習配置用スポットシール</title><link>https://maku.blog/p/t9urz45/</link><pubDate>Thu, 15 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t9urz45/</guid><description>新しいビリヤード練習アイテム開発しましたっ。 同じ配置を繰り返し練習するためのスポットシールです。
ポスト○ットに穴あけただけ。。
市販されてるパンチ穴シールでもよいけど、練習用に使う場合は粘着力がもっと弱い方がよいので。</description></item><item><title>ビリヤードのコツ: コンビネーションからの出し</title><link>https://maku.blog/p/445q6w9/</link><pubDate>Wed, 14 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/445q6w9/</guid><description>やや右側に当て、手球より長く走らせてネクストを作る。 ネクストは右上コーナー狙いか、上サイドになる。 ネクストを左上のコーナーに取ろうとしても、先球は手球よりも右側に出るので失敗する。</description></item><item><title>SQLite の日時関連の処理</title><link>https://maku.blog/p/qwtoj94/</link><pubDate>Sat, 17 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwtoj94/</guid><description>現在の日時を取得する（テキスト形式） 日付＋時刻 sqlite&amp;gt; select datetime(&amp;#39;now&amp;#39;) 2007-02-17 07:53:30 日付のみ sqlite&amp;gt; select date(&amp;#39;now&amp;#39;) 2007-02-17 時刻のみ sqlite&amp;gt; select time(&amp;#39;now&amp;#39;) 07:53:30 これらのデータ型は TEXT 型です。
sqlite&amp;gt; select typeof(datetime(&amp;#39;now&amp;#39;)); text 現在の日時を現地時間で取得する（テキスト形式） sqlite&amp;gt; select datetime(&amp;#39;now&amp;#39;, &amp;#39;localtime&amp;#39;) 2007-02-17 16:53:30 sqlite&amp;gt; select date(&amp;#39;now&amp;#39;, &amp;#39;localtime&amp;#39;) 2007-02-17 sqlite&amp;gt; select time(&amp;#39;now&amp;#39;, &amp;#39;localtime&amp;#39;) 16:53:30 ある標準時を現地時刻へ変換する sqlite&amp;gt; select datetime(&amp;#39;2007-02-17 21:30:00&amp;#39;, &amp;#39;localtime&amp;#39;); 2007-02-18 06:30:00 sqlite&amp;gt; select time(&amp;#39;21:30:00&amp;#39;, &amp;#39;localtime&amp;#39;); 06:30:00</description></item><item><title>Doxygen でどのコメントスタイルを使うべきかの考察</title><link>https://maku.blog/p/qnnukuj/</link><pubDate>Tue, 08 Aug 2006 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qnnukuj/</guid><description>方法(1) Javadoc スタイル これが一番よく使われている記法だと思います。 特にこだわりがないのであれば、この記法を使っておくのが無難です。
/** * @brief Brief description. * * Detail description. * @param a hogehoge * @param b hogehoge */ void Hoge(int a, int b); 特徴 brief コマンドの後ろに空行が必要なため、行数が増えてしまうし、少しアンバランスな感じになる。 ひとつのコメントブロックとして判別しやすい。 簡易説明は 2 行以上に渡って記述できる（その代わり、brief の下に空行が必要という制約がある）。 簡易説明だけでよい場合にすっきり書くのが難しい（その場合は /// で一行で済ませる手がある）。 一行の Brief description だけ記述したい場合でも、以下のように @brief が必要です。
/** * @brief Brief description. */ void Hoge(); あるいは、
/** @brief Brief description. */ void Hoge(); 通常は Javadoc スタイルで書いておいて、一行の Brief description だけを記述したい場合だけ、C# スタイルのコメントを使うのがすっきりするかもしれません。
/// Brief description.</description></item><item><title>読書メモ『アイデアのつくり方』ジェームス・ウェブ・ヤング</title><link>https://maku.blog/p/96rfove/</link><pubDate>Sat, 24 Jun 2006 00:00:00 +0000</pubDate><guid>https://maku.blog/p/96rfove/</guid><description> アイデアのつくり方 ジェームス・ウェブ・ヤング CCCメディアハウス いろんなブログで絶賛されているほど目から鱗という感じではないですが、アイデアが生まれる過程がどのようなものかが分かりやすく記述されています。 あまりに古い文献（原著 1940 年）なので、コンピュータやネットの活用方法については何も触れられていません。
アイデア作成に大切な２つのこと アイデアとは既存の要素の新しい組み合わせである。 組み合わせる才能は事物の関連性を見つける才能に依存する。 言葉はそれ自身がアイデアである 言葉をマスターするとアイデアは息を吹き返す。 言葉はアイデアのシンボルであり、言葉を集めることでアイデアを集められる。 アイデアを生み出す手順 下記に示したものがアイデア作成までの 5 ステップであり、ひとつでも順番を飛ばしてはいけない。 1, 2, 5 は意識的活動の時期に行われるもので、3, 4 は無意識的活動の時期に行われるものである。
第1段階 … 資料を集める アイデアの種がなければアイデアは生まれないためこのステップを飛ばさないこと。 実際は資料集めをほとんどせずにアイデアが浮かぶことを待ってる人が多い。 資料集めは大変な作業であり、積極的な収集活動が必要。 カード索引法を学ぶとよい。3 インチ x 5 インチのカードにアイデアの断片を書き込んで分類していく方法。 一般的資料を集めるためにスクラップ・ブックのようなファイルを作成するのも有益。 第2段階 … データの咀嚼 心の中で資料に手を加える。 事実をあまり直視せず、意味の声に耳を傾けるのがコツ（一種の放心状態に近い）。 この段階で思い浮かんだアイデアは、どんなに突飛で不完全なものでも書き留めておくこと。 この段階でもカード索引法が利用できる。 ふたつの事実を並べてどうすればその二つが噛み合うかなどを考えてみる。 パズルを組み合わせる努力を実際にやりとげ、考えに考え抜いた結果、頭の中がごっちゃになって絶望状態に陥った時点でやっと第三段階へ移行してよい。 第3段階 … 孵化段階 意識の外で、データの組み合わせが勝手に行われることを待つ段階。 問題をできるだけ意識の外に追いやり、努力することを完全に放棄する。 ただし、想像力や感情を刺激する環境に身を置いておくこと（劇場や映画へ出かけたり、小説を読んだりする）。 第4段階 … アイデア誕生の瞬間 もっとも期待していないときにアイデアは訪れる（寝起きや、風呂に入っているときなど）。 第5段階 … アイデアのチェック アイデアを具体化させ、現実の世界へと展開させる。 これをやらないために、ほとんどのアイデアは世に出ることなく消えていく。 アイデアを胸の底にしまいこんでしまわず、理解ある人の批判を仰ぐこと。 良いアイデアはそれ自身が成長する性質を持っている。 良いアイデアは人々を刺激し、人々の意見を集める。</description></item><item><title>読書メモ『ヤル気が格段に高まる科学的習慣』BIG tomorrow August 2005</title><link>https://maku.blog/p/dk63fzr/</link><pubDate>Wed, 24 May 2006 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dk63fzr/</guid><description> 昼食後に10分昼寝する。カフェインの含まれたコーヒーがお茶を飲んで目を閉じると、10分くらいで自然に目が覚める。 脳を刺激するなら大腿筋を使って歩く。 デスクワークに疲れた時は、首や肩を揉むよりも、太ももを30回叩いた方がよい。 気持ちよく目覚めるには、音より光。キッチンタイマーとライトを使って、30分前くらいに ON になるようにしておくと自然に目が覚める。 朝起き上がる前に、20秒くらい手と足の指を開いたり閉じたりするとよい。目覚めモードになる。 低い枕を使った方が血流がよくなり、ストレス解消できる。 光と音は厚手のカーテンで完全にシャットアウトするのが快眠のポイント。 起きる時間よりも寝る時間を一定にする。 毎日腹筋を200回すると頭がスッキリする、という人もいる。 就寝前のゲーム、食事、カフェインは快眠の妨げになる。 食事後に入浴する時は、1時間30分の間をおいてからがよい。消化吸収に悪いから。 アイデアは歩いているときにひらめく。</description></item><item><title>特許の読み方（請求項に関して）</title><link>https://maku.blog/p/q7abhn6/</link><pubDate>Tue, 02 May 2006 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7abhn6/</guid><description>特許として有効な範囲は「請求項」に挙げられているもの。 「請求項」は1個のこともあれば、200個のこともある。
請求項が複数ある場合は、請求項1が一番抽象的（全体を包含したもの）になっており、他の請求項はそれを掘り下げるものになっている。 言い換えると、それぞれの請求項はツリー構造のような関係になっている。 親の請求項を掘り下げているものは、文末に「〜請求3に記載の〜」のように記述されることが多い。
請求項の階層の上位のものが特許として認められれば、その有効範囲は広くなる。 逆に部分的に認められれば、有効範囲は狭くなる。
請求項は重要だが、その後ろにある「説明」の章を読んだ方が全体の内容、要点（課題、手段）は分かりやすい。 まずは説明の最初の方を読んで、この特許が何を解決しようとしているかの目星をつけるとよい。</description></item><item><title>暗号技術まとめ</title><link>https://maku.blog/p/6rn67mc/</link><pubDate>Tue, 20 Dec 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6rn67mc/</guid><description>暗号技術についてのメモです。
共通鍵暗号 ブロック暗号 ブロック暗号というのは、共通鍵暗号の一種。 データを一定のブロックごとに暗号化する方式。 高速な暗号化処理を行える。
Triple DES - 1990年代。64 bit のブロック暗号 DES を 3 回繰り返す暗号化アルゴリズム。かつては米国政府標準暗号だった。 MISTY1 - 1990年代。三菱電機が開発した 128 bit 暗号鍵を持つ 64 bit ブロック暗号アルゴリズム。 CAST-128 - 64 bit ブロック暗号。 Camellia - 2000年代。128 bit ブロック暗号。NTT・三菱電機。 AES: Advanced Encryption Standard - 2000年代。128 bit ブロック暗号。 SEED - 128 bit ブロック暗号。 国際標準のブロック暗号 (ISO/IEC18033-3) は、Camellia、AES、SEED、CAST-128、MISTY1、Triple DES。
ストリーム暗号 MUGI MULTI-S01 SNOW 国際標準のストリーム暗号 (ISO/IEC18033-4) は、MUGI、MULTI-S01、SNOW。
公開鍵暗号 RSA RSA: Rivest - Shamir - Adleman - 大きな素数の素因数分解が難しいという根拠に基づいた暗号方式。 楕円曲線暗号 楕円曲線状での離散対数問題に基づいた公開鍵暗号方式。</description></item><item><title>秀丸: 日時挿入マクロ</title><link>https://maku.blog/p/a9u6j7f/</link><pubDate>Mon, 31 Jan 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a9u6j7f/</guid><description>カーソル位置に、2005-01-31 14:07:33 といった現在の日時を挿入するマクロです。
my_insert_datetime.mac //disableinvert; //disabledraw; call DayOfWeekStr; // 挿入用文字列を作成 #i = -1; #i = #i + 1; $str[#i] = year + &amp;#34;-&amp;#34; + month + &amp;#34;-&amp;#34; + day; #i = #i + 1; $str[#i] = year + &amp;#34;-&amp;#34; + month + &amp;#34;-&amp;#34; + day + &amp;#34; &amp;#34; + hour + &amp;#34;:&amp;#34; + minute; #i = #i + 1; $str[#i] = year + &amp;#34;-&amp;#34; + month + &amp;#34;-&amp;#34; + day + &amp;#34; &amp;#34; + hour + &amp;#34;:&amp;#34; + minute + &amp;#34;:&amp;#34; + second; #i = #i + 1; $str[#i] = year + &amp;#34;-&amp;#34; + month + &amp;#34;-&amp;#34; + day + &amp;#34; (&amp;#34; + $$return + &amp;#34;)&amp;#34;; #i = #i + 1; $str[#i] = year + &amp;#34;-&amp;#34; + month + &amp;#34;-&amp;#34; + day + &amp;#34; (&amp;#34; + $$return + &amp;#34;)&amp;#34; + &amp;#34; &amp;#34; + hour + &amp;#34;:&amp;#34; + minute; #i = #i + 1; $str[#i] = year + &amp;#34;-&amp;#34; + month + &amp;#34;-&amp;#34; + day + &amp;#34; (&amp;#34; + $$return + &amp;#34;)&amp;#34; + &amp;#34; &amp;#34; + hour + &amp;#34;:&amp;#34; + minute + &amp;#34;:&amp;#34; + second; // 表示用文字列を作成 #j = 0; while (#j &amp;lt;= #i) { $showstr[#j] = &amp;#34;&amp;amp;&amp;#34; + str(#j + 1) + &amp;#34; &amp;#34; + $str[#j]; #j = #j + 1; } menuarray $showstr, #i+1; #n = result; // result は 1 回しか参照できないので保存 (Ver 4.</description></item><item><title>ビリヤードのルール: 2 Ball Pool Carom</title><link>https://maku.blog/p/4r6ht6g/</link><pubDate>Sat, 08 Jan 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4r6ht6g/</guid><description>ポケットビリヤードの台で遊ぶキャロムです。
配置・ブレイク 手玉はヘッドスポット、1 番をセンタースポット、2 番をフットスポットに配置。 ブレイクでセーフティは禁止。 勝敗 先に 20 点、40 点などの得点に達したほうが勝ち。 あるいは 10 回ずつ撞いて得点の多いほうが勝ち。 得点 2 つの的球に手玉を当てられれば 1 点。 1 つの的球をポケットしつつもう 1 つの的球に当てたら 2 点。 2 つの的球を同時にポケットしたら 3 点。 ファールした場合は 0 点。 ポケットされた的球の処理 残っている的球から距離が遠くなるように、ヘッドスポットかフットスポットのどちらかに置く。 テーブル上に残っている的球がヘッドスポットよりフットスポットに近い場合 → ヘッドスポットへ テーブル上に残っている的球がフットスポットよりヘッドスポットに近い場合 → フットスポットへ 2 つとも的球がポケットされた場合 → ヘッドスポットとフットスポットへ ただし、戻した的球が手玉と重なってしまう場合は、センタースポットを候補に入れて再選択。 ファール 手玉がどちらの的球にも当たらない場合はファール。 ノークッションファールはなし。 ファールした場合は 1 点マイナス。 ファールした場合は手球フリー。引球で当てられる位置におけば、もう一点は確実。 連続 3 ファールしても負けにはならない。</description></item><item><title>ビリヤードのルール: Bank Pool</title><link>https://maku.blog/p/i6iu7iu/</link><pubDate>Sat, 08 Jan 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i6iu7iu/</guid><description>かならずバンクショットで的球をポケットするゲーム。
配置・ブレイク 15 個の的球を順番に関係なくラックする。 ブレイクで入った的球はバンクでなくても全部得点になる。 ブレイクでセーフティは禁止。 勝敗 8 つの的球を先に落としたほうが勝ち。 得点 コールショット（狙う球の番号とポケットを指定）でポケットしたら 1 点。 ファール 通常のファールは、ペナルティとして 1 点減点で、手玉フリー。 指定したポケット以外に的球が入ったらファールで、ペナルティとして 1 点減点。フットスポットへ的球を戻す。 的球が場外した場合はファールだがペナルティによる減点なし。 3 連続ファールしたらそのゲームは負けとなる。</description></item><item><title>かんたん料理シリーズ</title><link>https://maku.blog/p/3939qxt/</link><pubDate>Wed, 21 Jan 2004 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3939qxt/</guid><description>鶏肉の照り焼き 『会社の星』で簡単な照り焼きの作り方やってたのでφ(･ｪ･o)~メモメモ
たれの材料（甘辛しょうゆ） しょうゆ 1カップ 酒 1/2カップ 砂糖 100g 作り方 鶏肉を茹でて、ひと口大にに切る。 フライパンで焼き目をつける感じで焼く。 焼いているときにたれをかける。 もやしとほうれん草と挽肉のピリ辛ミソあえ（一人分） （おおきめのお皿が必要）
材料 ほうれん草 － １束 もやし － ５０ｇ Ａ 挽肉 － ５０ｇ サラダ油 － 小さじ１ みそ － 小さじ１ 豆板醤 － 小さじ１ さとう － 小さじ１ 作り方 ほうれん草を５ｃｍくらいに切って皿に入れる もやしを洗って皿に入れる Ａを混ぜて皿に入れる レンジで４分加熱 混ぜてできあがり！ 簡単たまご野菜丼 材料 A 卵 １個 しょうゆ 小さじ１ 酒 小さじ１ 豚挽き肉 80g 野菜少し （ニンジン1/2の薄切りとか） 作り方 豚と野菜を炒める A を入れて半熟でご飯にかける さばとねぎの味噌煮 材料 さば １切れ 長ねぎ １本 煮汁 水 １カップ みそ 大さじ１ みりん 1／4カップ 作り方 ねぎを５ｃｍに切って軽く焦げるまでやく なべに煮汁を入れて 1 と さばをいれて15分くらい煮込む（途中で煮汁をかけながら） 煮汁が減ってきてとろとろになったら火を止めて完成 ※さばがないのでブリで作ったらあんましおいしくなかった(-_-</description></item><item><title>IETF によるプロトコル標準化の流れ</title><link>https://maku.blog/p/44o4a9p/</link><pubDate>Wed, 01 Oct 2003 00:00:00 +0000</pubDate><guid>https://maku.blog/p/44o4a9p/</guid><description>プロトタイプが普及する 独自バージョンが作られるようになる IETF (Internet Engineering Task Force) の援助で Working group が作られる Working group は「インターネットドラフト」としてプロトコルを文書化する IETF の IESG (Internet Engineering Steering Group) に提出する 実験期間を経て、IESG によって RFC 番号が割り当てられ、修正などをして「実験 RFC」として公表される 実際の運用によるテストを経て、IESG が「提案標準」として認定する IESG が「ドラフト標準」に推薦する プロトコルに STD 番号が割り当てられ、RFC に加えて STD となる 上記の流れで最低でも 10 ヵ月以上はかかる。</description></item><item><title>数値計算系のプログラムメモ</title><link>https://maku.blog/p/m3p8hh6/</link><pubDate>Sat, 20 Oct 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m3p8hh6/</guid><description>n が 2 のべき乗か判定する long powerof2(long n) { return (n &amp;gt; 0) &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0); }</description></item><item><title>画像処理メモ: 画像の 2 値化の閾値を求める方法いろいろ</title><link>https://maku.blog/p/uyp4geh/</link><pubDate>Fri, 25 May 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uyp4geh/</guid><description> 平均法（平均を取るだけ）← 使えない Pタイル法（物体・背景の面積が分かっている場合）← 自動ではない モード法（極小を求める）← グラフを滑らかにする必要がある 判別分析法（クラス間分散が最大となるところで２値化する）← Good</description></item><item><title>C/C++サンプル: TCP クライアント／サーバー</title><link>https://maku.blog/p/tgt7it6/</link><pubDate>Fri, 11 May 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tgt7it6/</guid><description>むかーし書いたやつ。 だっさーいコードが残ってるかも (^^;
CTcpClient / CTcpServer ライブラリ CTcpClient.h / CTcpClient.cpp CTcpServer.h / CTcpServer.cpp socket.h Makefile 使用例 SimpleTcpServer.cpp SimpleTcpClient.cpp Makefile</description></item><item><title>C/C++サンプル: TCP ポートスキャナー</title><link>https://maku.blog/p/xwfr3cm/</link><pubDate>Fri, 11 May 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xwfr3cm/</guid><description>むかーし書いたコードです。 だっさーいコードが残ってるかも (^^;
portscan.cpp</description></item><item><title>C/C++サンプル: エンディアンの判定</title><link>https://maku.blog/p/g9q6kyf/</link><pubDate>Fri, 11 May 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/g9q6kyf/</guid><description>使用している PC のホストバイトオーダーが、ビッグエンディアンかリトルエンディアンかを調べるプログラムです。
endian.cpp #include &amp;lt;iostream&amp;gt; using namespace std; int main() { union { char c[2]; short s; } u; u.s = 0x0102; if (u.c[0] == 0x01 &amp;amp;&amp;amp; u.c[1] == 0x02) cout &amp;lt;&amp;lt; &amp;#34;Big-endian&amp;#34; &amp;lt;&amp;lt; endl; else if (u.c[0] == 0x02 &amp;amp;&amp;amp; u.c[1] == 0x01) cout &amp;lt;&amp;lt; &amp;#34;Little-endian&amp;#34; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &amp;#34;Unknown&amp;#34; &amp;lt;&amp;lt; endl; return 0; }</description></item><item><title>TV規格: DVBメモ</title><link>https://maku.blog/p/oi66eim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oi66eim/</guid><description>DVB について DVB (Digital Video Broadcasting) はヨーロッパのデジタル放送規格。標準化団体名でもある。DVB には以下のような種類がある。
DVB-T (Terrestrial) &amp;ndash; 地上デジタル放送の規格 DVB-S (Satellite) &amp;ndash; 衛星放送の規格 DVB-C (Cable) &amp;ndash; CATV の規格 ISDB (Integrated Services Digital Broadcasting) は日本、ブラジル向けのデジタル放送規格。ちなみに ARIB (Association of Radio Industries and Broadcast): 社団法人電波産業会というのは通信・放送分野の研究、標準化などを行う団体名であって規格の名前ではない。ISDB には以下のような種類がある。
ISDB-T (Terrestrial) &amp;ndash; 地上デジタル放送の規格 ISDB-S (Satellite) &amp;ndash; 衛星放送の規格 ISDB-TSB (Terrestrial for Sound Broadcasting) &amp;ndash; 地上デジタルラジオ放送の規格 DVB の資料 EPG に関することを知りたかったら、DVB SI 系の資料を読むと良い。まずは、DVB の Web サイトにある、DVB SI の 2 冊の Bluebook (PDF) から読み始めると楽（150ページくらい）。Bluebook はメアド登録しなくてもダウンロードできる。
DVB - Digital Video Broadcasting [Standards &amp;amp; Technology] → [Standards &amp;amp; BlueBooks] → DVB SI 日本、ブラジル向けのデジタル放送規格 ISDB も DVB をもとに考えられているので、DVB の資料を先に読んでおくと理解しやすい。</description></item><item><title>パワーポイントのおすすめ設定</title><link>https://maku.blog/p/qm9cfjn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qm9cfjn/</guid><description>PowerPoint のおすすめのフォント PowerPoint のフォントは、Windows Vista 以降であれば、
和文: メイリオ 欧文: Segoe UI で統一すると、そこそこ見た目が整います。
スライドマスタでフォントを設定する手順は下記の通りです。
メニューの [表示] =&amp;gt; [スライドマスター] を選択。 スライドマスタータブの [フォント] =&amp;gt; [新しいテーマのフォントパターンの作成] を選択。 英数字用のフォントで「Segoe UI」、日本語文字用のフォントで「メイリオ」を選択。 ちなみに、メイリオの代わりに Meiryo UI を使用すると、文字幅が若干縮まります。 Meiryo UI は Windows 7 で標準搭載されたフォントで、Windows のリボン UI 上のテキストを狭いスペースで表示できるように最適化されたものらしいです。 通常は「メイリオ」の方を使用しておけばよいでしょう。 もし、テキストをたくさん含めなければいけない資料を作らないといけなくなった場合は、「Meiryo UI」の方を使ってみるとよいかもしれません。
参考: Windows デベロッパーセンター ─ フォント
スライドの縦横比率は 16:9 スライドの縦横比率は 16:9 が主流です。 PowerPoint 2013 からはデフォルトで 16:9 になってます。
メニューの [表示] =&amp;gt; [スライドマスター] を選択。 スライドマスタータブの [ページ設定] を選択。 スライドのサイズ指定で 16:9 を選択。 PowerPoint ファイルを共有するときはフォントを埋め込む 異なる環境で PowerPoint ファイル開いたときに、設定したフォントで正しく描画されるようにするには、PowerPoint ファイルにフォントを埋め込んでおく必要があります。</description></item><item><title>ビリヤードの雑多メモ</title><link>https://maku.blog/p/8rhjqk4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8rhjqk4/</guid><description>センターショットばかりやるのはなぜダメか？ 実はまっすぐ見えていないのに、たまたま視線のズレとストロークのズレが打ち消しあってまっすぐ付けているかのように勘違いしてしまうことがある。フリのある球も適度に練習するべき。 手球をストップさせるための力加減の許容範囲が広いため、力加減を調整する撞き方を身につけにくい。フリがある球は手球のスピードや回転によって狙いが変わるが、センターショットだけやっているとこの感覚を覚えられない。 ダブルイマジナリーボールで狙う方法 通常イマジナリーボールは、ポケットから見て的球の後ろ側に作りますが、その反対側（ポケット側）にも作るようにすると、的球の転がりイメージしやすくなります。</description></item><item><title>ライフハック: 掃除テクニック</title><link>https://maku.blog/p/o7mkmjt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o7mkmjt/</guid><description> 台所のシンクは大根の切れ端 or レモンでこするときれいになる。 ガスコンロまわりの油汚れ 塩を振りまいてレモンでこするときれいになる。 軽く湿らせたメラミンスポンジでこすると、油のベトベトはすっきり取れる（ただし、メラミンスポンジは減りは早い^^;）</description></item><item><title>心に響く言葉とか</title><link>https://maku.blog/p/pjsq9sp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pjsq9sp/</guid><description> 実装しなくなったら、エンジニアとしての人生はそこで終了ですよ ── マイクロソフト元社長 他社製品を見たら改善を考えるより、別のアプローチを考えろ ── 映画『スティーブ・ジョブズ』 ミスタードリラーの主人公ホリ・ススムの父親は、ディグダグの主人公ヒロ・タイゾウ ── 『レトロゲーム忍法帖』忍者増田 プログラマーが「できない」と言った瞬間にそのアイディアは死ぬんです。だから「できない」と言うんだったら、「ここまでならできるけど」と言えよ ── 任天堂 岩田聡 aibo の開発では議論が白熱しても、そこに aibo がいると、なぜだかみんな笑顔になれた ── aibo 開発者</description></item><item><title>見たドラマの記録</title><link>https://maku.blog/p/zwgs69e/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zwgs69e/</guid><description>白い春 （全11回） ★★★★★ 5/5点。
内容というより阿部さんがいい味だしてるなぁ。 亡くなった妻や子供のために必死になるところとか、 お金あんましないのにポーンとあげちゃうところとか、 自分より人のことを大切にして生きてるのが素敵です。
24 TWENTY FOUR シーズンⅥ （全24話） ★★★★☆ 4/5点。
テロの核攻撃を阻止するために悪戦苦闘する話かと思ってたら、 いつのまにか中国との基板争奪戦になってたという話。 CTU の作戦よりも、モリスとクロエの微妙な関係のほうが気になりました。
しかし、ジャックの撃った弾が確実に敵に当たるわ当たるわ。 無敵かいな。
銭ゲバ ★★★★★ 5/5点。
やっぱり貧乏ものドラマは面白い。 主人公の松山ケンイチさんよりも、椎名桔平さんの方がいい味出してるなぁ。 「お～こわいこわい」っていう、人をおちょくるような感じとか大好き。 最後まで何を考えてるのか分かんないのもいい雰囲気出してます。
ドラマ最終回の終わり方もまさに銭ゲバって感じですね。
プリズンブレイク シーズン3 ★★★★★ 5/5点。
刑務所ソーナのどろどろした雰囲気が生々しくて面白い。 それぞれのキャラクタがみんな魅力的で、どのキャラクタのシーンになっても見ていて飽きないです。 中でもティーバッグが好きだなぁ。
ブラッディ・マンデイ ★★★★☆ 4/5点。
天才ハッカーがテロリストのテロをハッキングで阻止するドラマ。 Microsoft がサポートしているということで、 コマンドラインでの入力も本物っぽく見せてるところがすごい。 技術指導者が Python 好きなのか、Python ばっかり使ってたｗ
Bluetooth を数秒で乗っ取って、敵のボスの声を音声合成で作成して 偽の指示を出すシーンはバビった。どんだけ天才やねんｗ
スクラップ・ティーチャー ★★★★★ 5/5点。
毎回各教師が問題を起こしていくのだけれど、 みんないい方向に解決していく。 そして最終回はすべてがうまくいってハッピーエンドするところは 見ていて気持ちがよいです。 生徒を大切にする気持ちをまっすぐぶつける杉先生の姿は 全国の先生に見てもらいたいくらいです。
結婚できない男 ★★★★★ 5/5点。
トリックと同じ感じで阿部寛さんがいい味だしてます。 素直でないと思ったらたまに素直で、 自分のポリシーだけは曲げない。 そんなキャラクターは何回見ても飽きないです。
ライアー・ゲーム ★★★★☆ 4/5点。
嘘ついて騙し合ってお金を稼ぐドラマ。 演出はちょっとちゃっちいけど、 人を信じることが正しいんだとみんなが最後に団結するところがよかったな。 ヨコヤが泣き崩れるシーンも好き。</description></item><item><title>見た映画の記録</title><link>https://maku.blog/p/okpz4jx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/okpz4jx/</guid><description>E.T. 20 周年アニバーサリー特別版 （2002年 アメリカ） ★★★☆☆ 3/5点。
今見るとなんだか平凡な宇宙人映画。 警察に囲まれたときに、自転車で飛んで行ってしまうシーンは、 当時の子供たちに夢を与えたんだろうなぁ。
パイレーツオブカリビアン デッドマンズ・チェスト （2006年 アメリカ） ★★★★★ 5/5点。
パイレーツオブカリビアンの2作目（の前編）。 呪いで死ねなくなって、顔にフジツボが付いてしまってたり、 顔がタコだったり気持ち悪いのがいっぱい出てくるところが面白い。 エリザベスは男装してたほうが凛々しくてかわいいです。
20世紀少年 ＜最終章＞ ぼくらの旗 ★★★★★ 5/5点。
最終章が一番面白かった。 映画の終わりに歌をもってくると、 いい感じになっちゃうからちょっとずるい。 ケンジは体がボロボロのくせに、 ロボットのはしごはものすごくしっかり登るのが不思議でした。 あんなの絶対振り落とされるよ。
パイレーツ・オブ・カリビアン 呪われた海賊たち （2003年 アメリカ） ★★★★☆ 4/5点。
おちゃめなジョニー・デップがかわいい。 この映画に出てくる他の海賊たちも極悪非道という感じはしないですね。 のろわれたメダルを全部集めたらしいけど、あれだけ大量のメダルを どうやって探したんだろ？
マチルダ （1996年 アメリカ） ★★☆☆☆ 2/5点。
ひどい家族、ひどい校長先生に囲まれた環境で 幼いマチルダがなぜか超能力を身につけ、校長先生をこらしめる話。
子供向けっぽいストーリーでした。 マチルダの天才ぶりや、超能力がいまいち活かしきれていない感じ。
リロ＆スティッチ （2002年 アメリカ） ★★☆☆☆ 2/5点。
物を破壊しまくるロボットをペットとして飼う話。 もともとかわいくないスティッチが、 家族がほしくなってくところがかわいい。
努力しないで出世する方法 （1967年 アメリカ） ★★☆☆☆ 2/5点。
本に書いてある通りに行動して大成功する話。 あれだけ口が達者でどんどんアプローチしていけば、 普通に仕事していても成功しそうな気がします。。 どう見ても努力してます。 この映画はミュージカル風になっていて、まじめなストーリーではないです。
雀魔アカギ （1997年 日本） ★★★★☆ 4/5点。</description></item><item><title>読んだマンガの記録</title><link>https://maku.blog/p/oappodj/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oappodj/</guid><description>RiNGO （全3巻） 高校生の考えたゲームがゲーム会社に採用されて、 その中のバーチャルアイドル RiNGO を育てていく話。
ゲームショーで RiNGO を紹介しただけで あそこまで人気が出てしまうのがちょっと不自然だったけど、 それがおたくパワーなのかな。 幼なじみは結構いい味だしてたから、もっと活躍させて欲しかった。
主人公は最後に独立してゲーム会社を立ち上げるわけだけど、 そこで最初に作ったゲームがカクカクポリゴン○○○ゲー。。 力が抜けました。</description></item></channel></rss>