<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>D3.js 関連記事 on まくろぐ</title><link>https://maku.blog/p/j3fmwym/</link><description>Recent content in D3.js 関連記事 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 03 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/j3fmwym/index.xml" rel="self" type="application/rss+xml"/><item><title>D3.js による SVG 描画の基本</title><link>https://maku.blog/p/v38nmhw/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v38nmhw/</guid><description>D3.js は、クライアントサイド JavaScript で SVG 描画を行うためのライブラリです。 素の JavaScript（バニラ JavaScript) だけでも svg 要素を動的に構築していくことはできますが、D3.js を使うことでよりシンプルな API を使って描画処理を記述することができます。 ここでは、D3.js で基礎的な SVG 描画を行う方法を紹介します。
矩形を 1 つ追加する D3.js で矩形を描画するには、d3.select() で svg 要素を選択し（D3 セレクションオブジェクトを取得）、そこに append() メソッドで rect 要素を追加します。 そして、メソッドチェーンさせる形で attr() を呼び出し、rect の属性（サイズや色）を設定していきます。
次の例では、svg 要素に緑色の矩形を 1 つ追加しています。 rect 要素の塗り潰し色は fill 属性で指定することに注意してください（CSS の &amp;ldquo;background&amp;rdquo; プロパティとは名前が異なります）。
図: 矩形の表示 &amp;lt;svg id=&amp;#34;svg-wp3vzdr&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;100&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; d3.select(&amp;#34;#svg-wp3vzdr&amp;#34;) // svg 要素を選択 .append(&amp;#34;rect&amp;#34;) // svg 内に rect 要素を追加 .attr(&amp;#34;x&amp;#34;, 10) // rect 要素の属性値を設定 .attr(&amp;#34;y&amp;#34;, 10) .</description></item><item><title>D3.js のデータ結合を理解する (1) data/enter/exit/join の基本</title><link>https://maku.blog/p/bp2btie/</link><pubDate>Sun, 01 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bp2btie/</guid><description>D3.js の宣言的なアプローチ D3.js を使ったビジュアライゼーションでは、配列データを描画要素と対応付ける（データ結合する）とき、次のようにメソッドをチェーンさせる記述方法がよく出てきます (selectAll() → data() → enter() → append())。
D3.js コードのよくある書き方 const data = [1, 2, 3, 4, 5]; svg.selectAll(&amp;#34;circle&amp;#34;) .data(data) .enter() .append(&amp;#34;circle&amp;#34;) .attr(&amp;#34;cx&amp;#34;, (_d, i) =&amp;gt; i * 35 + 25) .attr(&amp;#34;cy&amp;#34;, 25) .attr(&amp;#34;r&amp;#34;, 10); 最初はとっつきにくいかもしれませんが、この記述方法は、D3.js が 宣言的プログラミング (Declarative Programming) のアプローチを採用した結果であり、これがあるからこそ D3.js のコードはシンプルに記述できるようになっています。
「宣言的」という言葉は、「データが最終的にどのように表現されるべきか」 をコードで表現するアプローチを指します。 その表現に到達するための詳細な処理手順をコーディングする必要がなくなるため、コードが読みやすく、不具合が発生しにくくなります。
D3.js によるデータ結合処理は、一般的に次のような流れで実装します。
selectAll() メソッドで、データの結合先にする描画要素群のセレクションオブジェクトを作成する。この段階では、描画要素は存在しなくてもよい（初回の呼び出し時には描画要素数は 0）。 data() メソッドで、データ配列を上記の描画要素群にマッピングする。 3 種類のセレクション (enter/exit/update) に対する処理を定義する。 次に、3 種類のセレクションについて説明します。
データ結合時の 3 つのセレクション D3.js のデータ結合では、次のような 3 種類のセレクションに分けて描画内容を定義します。
セレクション 説明 enter セレクション 「データ数 ＞ 描画要素数」のときに、新しい描画要素を追加する処理 exit セレクション 「データ数 ＜ 描画要素数」のときに、不要な描画要素を削除する処理 update セレクション データが更新されたときに、既存の描画要素の表示を更新する処理 enter セクション 図: enter セレクションのイメージ enter セレクションは、データ数の方が既存の描画要素数よりも多いときに、追加すべき要素を参照するためのセレクションです。 要は、enter セレクションに対して、新しい描画要素を追加する処理 を定義すれば OK です。 enter セレクションを取得するには、data() メソッドの戻り値のセレクションオブジェクトに対して、enter() メソッドを呼び出します。</description></item><item><title>D3.js のデータ結合を理解する (2) データ配列の要素ごとに表示／非表示を切り替える</title><link>https://maku.blog/p/nxe97gx/</link><pubDate>Mon, 09 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nxe97gx/</guid><description>この記事は、D3.js のデータ結合まわりのメソッド (data/enter/exit/join) の基本を理解していることを前提としています。
参考: D3.js のデータ結合を理解する (1) data/enter/exit/join の基本 D3.js でデータ配列の内容をプロットするとき、各要素の値を元にその要素を表示するか表示しないかを制御したいことがあります。 このようなケースでは、D3.js の仕組みで処理しようと考えがちですが、単純にデータ配列の要素をフィルタしてから、selection.data() でデータ結合してやれば OK です。
次の例では、データ配列 (data) の enabled プロパティを見て、描画要素の表示／非表示を制御しています。 とはいっても、データ配列の要素を filter() メソッドで先にフィルタしているだけです。
図: 表示の on/off 制御 const data = [ { pos: 1, color: &amp;#34;#f00&amp;#34;, enabled: true }, { pos: 2, color: &amp;#34;#0f0&amp;#34;, enabled: false }, { pos: 3, color: &amp;#34;#00f&amp;#34;, enabled: true }, ] // 先にデータ配列をフィルタしておく const filteredData = data.filter((d) =&amp;gt; d.enabled) d3.select(&amp;#34;#svg-6y3q&amp;#34;) .selectAll(&amp;#34;circle&amp;#34;) .data(filteredData, (d) =&amp;gt; d.</description></item><item><title>D3.js でレイヤー用の g 要素を作成するユーティリティ関数 (layer)</title><link>https://maku.blog/p/298nhnq/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/298nhnq/</guid><description>便利な layer 関数を実装する SVG の g 要素は、描画要素の表示順序を制御するためのレイヤーとして使われることがあります（参考: SVG の g 要素の使い方）。 D3.js でレイヤー構造を作るのは簡単で、次のように任意のセレクションオブジェクトの append() メソッドで g 要素を追加するだけです。
function draw(data) { const svg = d3.select(&amp;#34;#mysvg&amp;#34;); const layer1 = svg.append(&amp;#34;g&amp;#34;); // 奥に表示するレイヤー const layer2 = svg.append(&amp;#34;g&amp;#34;); // 手前に表示するレイヤー // layer1 への描画 layer1.selectAll(&amp;#34;circle&amp;#34;) .data(data) .join(&amp;#34;circle&amp;#34;) .attr(&amp;#34;cx&amp;#34;, () =&amp;gt; Math.random() * 170 + 15) .attr(&amp;#34;cy&amp;#34;, () =&amp;gt; Math.random() * 40 + 15) .attr(&amp;#34;r&amp;#34;, 10) .attr(&amp;#34;fill&amp;#34;, &amp;#34;#00f9&amp;#34;) // layer2 への描画（省略） } 注意しなければいけないのは、上記のように直接 append() メソッドを呼び出す場合は、このコードが 1 度だけ実行されるようにしておくことです。 D3.</description></item><item><title>D3.js で SVG の右上に凡例 (legend) を表示する</title><link>https://maku.blog/p/ykjrz2b/</link><pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ykjrz2b/</guid><description>D3.js を使用してデータを色分けしてプロットする場合、グラフの右上などに凡例（色の意味）を表示したくなります。 ここでは、色を管理するために d3.scaleOrdinal() を使用していると仮定し、凡例を表示する方法を説明します。 d3.scaleOrdinal() 関数についての詳細は、以下の記事をご参照ください。
参考: D3.js のスケール関数: scaleOrdinal でカテゴリデータを別の値にマッピングする カラースケールから凡例に並べる項目を取り出す d3.scaleOrdinal() 関数で作成したスケール関数（下記例では color）に何らかのデータを引数で渡すと、そのデータに対応する色情報を返してくれます。
import * as d3 from &amp;#39;d3&amp;#39;; // D3.js 組み込みのカラースケール const color = d3.scaleOrdinal(d3.schemeCategory10); const c1 = color(&amp;#39;A&amp;#39;); //=&amp;gt; &amp;#39;#1f77b4&amp;#39; const c2 = color(&amp;#39;B&amp;#39;); //=&amp;gt; &amp;#39;#ff7f0e&amp;#39; const c3 = color(&amp;#39;C&amp;#39;); //=&amp;gt; &amp;#39;#2ca02c&amp;#39; const c4 = color(&amp;#39;A&amp;#39;); //=&amp;gt; &amp;#39;#1f77b4&amp;#39; const c5 = color(&amp;#39;B&amp;#39;); //=&amp;gt; &amp;#39;#ff7f0e&amp;#39; 上記の例の場合、A、B、C という 3 種類のデータに対して、3 種類の色が割り当てられています。 このとき、カラースケール (color) の内部では、これまで入力された A、B、C というキー情報が管理されており、domain() メソッドを引数なしで呼び出すことで取り出すことができます。</description></item><item><title>D3.js の call メソッドを使ってメソッドチェーン処理をスマートに記述する</title><link>https://maku.blog/p/994xjma/</link><pubDate>Sun, 08 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/994xjma/</guid><description>call メソッドの基本 D3 セレクションオブジェクトの call() メソッドを使うと、任意の関数に自身のセレクションオブジェクト (this) を渡す形で呼び出すことができます。 下記コードの (A) と (B) は同じ振る舞いになります。
&amp;lt;script&amp;gt; function setMessage(selection) { selection.text(&amp;#39;Hello&amp;#39;); } // (A) 普通の関数呼びだし // setMessage(d3.select(&amp;#39;#msg&amp;#39;)); // (B) call による関数呼び出し d3.select(&amp;#39;#msg&amp;#39;).call(setMessage); &amp;lt;/script&amp;gt; &amp;lt;div id=&amp;#39;msg&amp;#39;&amp;gt;&amp;lt;/div&amp;gt; call() メソッド呼び出し時の第 2 引数以降は、第 1 引数で指定した関数にパラメーターとして渡されます。
function setMessage(selection, message) { selection.text(message); } d3.select(&amp;#39;#msg&amp;#39;) .call(setMessage, &amp;#39;Hello&amp;#39;); call メソッドの使いどころ selection.call() メソッドの戻り値は、呼び出し元のレシーバーである selection オブジェクト自身 (this) になります。 これは、つまり、selection オブジェクトに対するメソッドのチェーンを続けられるということです。
例えば、次のように、svg 要素の D3 セレクションオブジェクトに対して複数の処理を行うコードを考えてみます。
const data = [50, 100, 150]; const svg = d3.</description></item><item><title>D3.js のスケール関数: scaleOrdinal でカテゴリデータを別の値にマッピングする</title><link>https://maku.blog/p/73b94gi/</link><pubDate>Sat, 30 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/73b94gi/</guid><description>scaleOrdinal の基本 D3.js のスケールモジュール (d3-scale) が提供する scaleOrdinal() 関数を使用すると、カテゴリデータを別の値にマッピングする関数を簡単に作成することができます。
☝️ カテゴリデータと数量データ カテゴリデータ (categorical data) というのは、統計学やデータ分析において使用されるデータ型のひとつで、通常、カテゴリを示すラベルや文字列で表現されます。 カテゴリデータは、定性データまたは質的データとも呼ばれます。 例えば、血液型や都道府県などがカテゴリデータです。
一方、価格や身長のような 数量データ (quantitative data) は本来はカテゴリデータではありませんが、特定の範囲でグルーピングすることで、カテゴリ化することができます（価格(円) → 低価格／中価格／高価格）。 カテゴリ化することを離散化 (discretization) やビン化 (binning) と呼ぶこともあります。
次の例では、AWS/Azure/GCP という入力値を、#ff9900/#0072c6/#db4437 というカラーコードに変換するスケール関数を作成しています。
const colorScale = d3.scaleOrdinal() .domain([&amp;#34;AWS&amp;#34;, &amp;#34;Azure&amp;#34;, &amp;#34;GCP&amp;#34;]) // この入力が .range([&amp;#34;#ff9900&amp;#34;, &amp;#34;#0072c6&amp;#34;, &amp;#34;#db4437&amp;#34;]); // この出力にマッピングされる console.log(colorScale(&amp;#34;AWS&amp;#34;)); //=&amp;gt; &amp;#34;#ff9900&amp;#34; console.log(colorScale(&amp;#34;Azure&amp;#34;)); //=&amp;gt; &amp;#34;#0072c6&amp;#34; console.log(colorScale(&amp;#34;GCP&amp;#34;)); //=&amp;gt; &amp;#34;#db4437&amp;#34; 上記の例では、入力値をカラーコードの文字列にマッピングしていますが、描画要素の座標値やサイズなど、任意の型の値にマッピングできます。 次の例では、実際に 2 つのスケール関数を作成して、SVG の描画に使用しています。
図: scaleOrdinal による色のマッピング 上記の実装コード &amp;lt;svg id=&amp;#34;svg-hfuouiw&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;80&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.</description></item><item><title>D3.js で矢印を表示する (defs, marker, marker-end)</title><link>https://maku.blog/p/gtg33no/</link><pubDate>Fri, 29 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gtg33no/</guid><description>marker 要素で矢印の形を定義する D3.js で line 要素や path 要素の先端に矢印を表示するには、marker 要素で矢印形状を定義して、それを line 要素などの marker-end 属性（あるいは marker-start 属性）にセットします。
次の例では、2 つの circle 要素とそれらを結ぶ line 要素を配置し、line 要素の終端に矢印を表示しています。
図: 矢印の表示 上記 SVG を出力するためのコード &amp;lt;svg id=&amp;#34;svg-h2cqngx&amp;#34; width=&amp;#34;120&amp;#34; height=&amp;#34;70&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; // 始点と終点の座標 const p1 = { x: 20, y: 50 } const p2 = { x: 100, y: 20 } const MARKER_ID = &amp;#34;MyMarker&amp;#34; // マーカー (marker) を定義する function createMarker(selection) { selection.append(&amp;#34;defs&amp;#34;) .append(&amp;#34;marker&amp;#34;) .attr(&amp;#34;id&amp;#34;, MARKER_ID) .attr(&amp;#34;viewBox&amp;#34;, &amp;#34;0 0 2 2&amp;#34;) .</description></item><item><title>D3.js で描画要素をクリックしたときに選択状態にする</title><link>https://maku.blog/p/6sijufz/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6sijufz/</guid><description>SVG 描画要素の選択状態を表現する D3.js で描画した要素（rect や circle など）をマウスクリックで選択できるようにすると、いろいろな操作を実現できます。
選択された要素に紐づけられたデータ (datum) を、別の場所に詳細情報として表示する 選択された要素に対して、一連の操作を行う 問題は、どのように要素の選択状態を表現するかですが、ここでは、要素をクリックしたときに、CSS のクラス selected を動的に付加することで選択状態を表現してみます。
次の例では、並んでいる丸をクリックすると見た目が変化します（選択状態を表現しています）。 逆に、別の丸の見た目はリセットされます。
図: 丸をクリックして選択状態にする 実装コード &amp;lt;style&amp;gt; circle { cursor: pointer; } /* 選択された要素に付加するクラス */ .selected { fill: cyan; stroke: red; stroke-width: 5; cursor: default; } &amp;lt;/style&amp;gt; &amp;lt;svg id=&amp;#34;svg-uh6jd9p&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;50&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-uh6jd9p&amp;#34;) const data = [{}, {}, {}] // データ数だけ circle 要素を追加 const circles = svg.selectAll(&amp;#34;circle&amp;#34;) .data(data) .join(&amp;#34;circle&amp;#34;) .attr(&amp;#34;cx&amp;#34;, (_d, i) =&amp;gt; i * 50 + 50) .</description></item><item><title>D3.js で描画内容をズームやパン操作できるようにする (d3-zoom)</title><link>https://maku.blog/p/w2xmuae/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w2xmuae/</guid><description>d3-zoom とは D3.js に組み込まれている d3-zoom モジュールは、下記のようなユーザー操作をハンドルためのモジュールです。
マウスホイールによるズーム操作 マウスドラッグによるパン操作 タッチパネルのピンチイン、ピンチアウトによるズーム操作 タッチパネルのスワイプによるパン操作 d3-zoom によるイベントハンドリング処理は描画処理とは独立しているので、SVG や Canvas、スケール (d3-scale)、軸 (d3-axis) などと自在に組み合わせて使うことができます。
d3-zoom の簡単な使用例 実装例 下記の svg 画像の中で、ドラッグやホイール操作を行うと、矩形のズームや移動を行うことができます。
図: d3-zoom によるズーム／パン操作 実装コード &amp;lt;svg id=&amp;#34;svg-gh4oas2&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;100&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-gh4oas2&amp;#34;) const topLayer = svg.append(&amp;#34;g&amp;#34;) // このレイヤーごと動かすことにする // 矩形を 1 つ追加 topLayer .append(&amp;#34;rect&amp;#34;) .attr(&amp;#34;x&amp;#34;, 80) .attr(&amp;#34;y&amp;#34;, 40) .attr(&amp;#34;width&amp;#34;, 40) .attr(&amp;#34;height&amp;#34;, 20) .attr(&amp;#34;fill&amp;#34;, &amp;#34;green&amp;#34;) svg.call(d3.zoom().on(&amp;#34;zoom&amp;#34;, zoomed)) // zoom behavior を登録する function zoomed(event) { // イベントが発生したらイベントオブジェクトの内容に従って transform するだけ topLayer.</description></item><item><title>D3.js による Force Simulation (3) 各ノードをドラッグして動かせるようにする</title><link>https://maku.blog/p/8dmb73t/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8dmb73t/</guid><description>d3-drag モジュールとは D3.js は、マウスによるドラッグ操作や、タブレットなどでのタッチドラッグ操作を扱うための d3-drag モジュールを提供しています（d3 モジュールに内包されています）。 d3-drag は Force Simulation (d3-force) 用のモジュールではありませんが、よく d3-force と組み合わせて使用されます。 Force Simulation では、各ノードの座標値が tick イベントと連動して刻々と変化するため、ドラッグ中はノードの座標値をマウスカーソル位置に固定するなどの処理が必要です。
参考: Force Simulation (d3-force) の基本 d3-drag の基本的な使い方 次のサンプルでは、svg 内の circle 要素をドラッグして動かせるようにしています。
図: d3-drag によるノードのドラッグ ソースコード &amp;lt;svg id=&amp;#34;svg-p4vddjh&amp;#34; width=&amp;#34;300&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-p4vddjh&amp;#34;) const width = +svg.attr(&amp;#34;width&amp;#34;) const height = +svg.attr(&amp;#34;height&amp;#34;) // ノード配列 const nodesData = [{}, {}, {}, {}] // ノードを描画するための circle 要素を svg に追加しておく const circles = svg.</description></item><item><title>D3.js による Force Simulation (2) link force でノードを結合する</title><link>https://maku.blog/p/9ujohp6/</link><pubDate>Thu, 14 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9ujohp6/</guid><description>link force とは D3.js の Force simulation (d3-force) には様々なフォースを設定することができ、それにより各ノードの動き（レイアウト）を制御できるようになっています。 link force はそのようなフォースのひとつで、ノード間にリンク情報を設定することにより、バネのような力を発生させます。 接続された 2 つのノードのうち、一方の位置を動かすと、もう一方のノードが引っ張られて動くようになります。
図: link force のイメージ 参考: Force Simulation (d3-force) の基本 link force の基本的な使い方 次の例では、4 つのノードに環状に繋がるような link force を設定しています（ここではリンクの可視化はしていません）。
図: link force を設定したフォースシミュレーション ソースコード &amp;lt;svg id=&amp;#34;svg-a2f28wm&amp;#34; width=&amp;#34;300&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-a2f28wm&amp;#34;) const width = +svg.attr(&amp;#34;width&amp;#34;) const height = +svg.attr(&amp;#34;height&amp;#34;) // ノード配列 const nodesData = [{}, {}, {}, {}] // リンク配列 const linksData = [ { source: 0, target: 1 }, { source: 1, target: 2 }, { source: 2, target: 3 }, { source: 3, target: 0 }, ] // ノードを描画するための circle 要素を svg に追加しておく const circles = svg.</description></item><item><title>D3.js による Force Simulation (1) d3-force の基本</title><link>https://maku.blog/p/6kavdch/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6kavdch/</guid><description>d3-force とは D3.js の Force Simulation (d3-force) モジュールは、粒子（ノード）間の引力を考慮した座標計算を行うためのライブラリです（d3 モジュールに含まれています）。 主に、ノードとエッジで表現されるネットワークモデルをビジュアライズするために利用されます。 d3-force によって逐次計算される座標をもとにノードやエッジを描画することで、レイアウトが収束していく過程をアニメーションさせて見せることができます。
次の例では、d3-force を使って 5 つのノードの座標値を計算して、SVG の circle 要素として描画しています。
図: d3-force によるレイアウト 実装コード &amp;lt;svg id=&amp;#34;#svg-gi3ajww&amp;#34; width=&amp;#34;300&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-gi3ajww&amp;#34;) const width = +svg.attr(&amp;#34;width&amp;#34;) const height = +svg.attr(&amp;#34;height&amp;#34;) // ノード配列（どんなオブジェクトでもよい） const nodesData = [{}, {}, {}, {}, {}] // ノードを描画するための circle 要素を svg に追加しておく const circles = svg.selectAll(&amp;#34;circle&amp;#34;) .data(nodesData) .join(&amp;#34;circle&amp;#34;) .attr(&amp;#34;r&amp;#34;, 10) .attr(&amp;#34;fill&amp;#34;, &amp;#34;blue&amp;#34;) // Simulation オブジェクトの作成とフォース設定 const simulation = d3.</description></item><item><title>D3.js でキーボードイベントを扱う (keydown)</title><link>https://maku.blog/p/6emds9m/</link><pubDate>Mon, 11 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6emds9m/</guid><description>D3.js でキーボードからの入力イベントを扱うコードのサンプルです。
図: クリックしてから上下左右キーで動かす 次の例では、svg 要素でキーボードイベントをハンドルしています。 svg 要素がフォーカスされた状態でカーソルキー（上下左右）を入力すると、丸印 (circle) が上下左右に動きます。
&amp;lt;svg id=&amp;#34;svg-z5a3fzu&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;100&amp;#34;&amp;gt;&amp;lt;/svg&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-z5a3fzu&amp;#34;); // D3 Selection オブジェクトを取得 svg .on(&amp;#34;keydown&amp;#34;, handleKeyDown) // keydown イベントのハンドラーを設定 .attr(&amp;#34;tabindex&amp;#34;, 0) // フォーカスを当てられるようにする // .node().focus() // 自動でフォーカスする場合 // カーソルキーで動かせる丸を表示 const circle = svg.append(&amp;#34;circle&amp;#34;) .attr(&amp;#34;cx&amp;#34;, 100) .attr(&amp;#34;cy&amp;#34;, 50) .attr(&amp;#34;r&amp;#34;, 10) .attr(&amp;#34;fill&amp;#34;, &amp;#34;dodgerblue&amp;#34;) function handleKeyDown(event) { switch (event.code) { case &amp;#34;ArrowLeft&amp;#34;: circle.attr(&amp;#34;cx&amp;#34;, +circle.attr(&amp;#34;cx&amp;#34;) - 5) event.preventDefault(); break; case &amp;#34;ArrowRight&amp;#34;: circle.attr(&amp;#34;cx&amp;#34;, +circle.attr(&amp;#34;cx&amp;#34;) + 5) event.</description></item><item><title>D3.js でボタンなどの入力要素を扱う</title><link>https://maku.blog/p/s5zrgp3/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s5zrgp3/</guid><description>D3.js は主に SVG の描画に使われるライブラリですが、一般的な DOM 要素のイベントをハンドルするためにも使用できます。 ここでは、ボタンやテキスト入力要素を D3.js で扱う例を示します。
次の例では、ボタン (button) をクリックしたときに、その独自属性 (data-color) にセットされた値を取り出しています。 この仕組みを利用すれば、ボタンを押したときに SVG の表示内容を切り替えるといったことが可能です。
Green Yellow Red ボタンを押してみて
&amp;lt;div id=&amp;#34;buttonContainer&amp;#34;&amp;gt; &amp;lt;button data-color=&amp;#34;g&amp;#34;&amp;gt;Green&amp;lt;/button&amp;gt; &amp;lt;button data-color=&amp;#34;y&amp;#34;&amp;gt;Yellow&amp;lt;/button&amp;gt; &amp;lt;button data-color=&amp;#34;r&amp;#34;&amp;gt;Red&amp;lt;/button&amp;gt; &amp;lt;p id=&amp;#34;message&amp;#34;&amp;gt;ボタンを押してみて&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34;&amp;gt; import * as d3 from &amp;#34;https://cdn.jsdelivr.net/npm/d3@7/+esm&amp;#34;; d3.selectAll(&amp;#34;#buttonContainer button&amp;#34;) .on(&amp;#34;click&amp;#34;, function() { const color = d3.select(this).attr(&amp;#34;data-color&amp;#34;) d3.select(&amp;#34;#message&amp;#34;).text(`選択したカラーコード = ${color}`) }) &amp;lt;/script&amp;gt; 上記の例では、click ハンドラーの中で、d3.select() を使って D3 セレクションオブジェクトを生成していますが、次のように従来の DOM API だけを使って記述することも可能です。
.on(&amp;#34;click&amp;#34;, (event) =&amp;gt; { const color = event.target.dataset[&amp;#34;color&amp;#34;] // button の data-color の値を取得 document.</description></item><item><title>D3.js で各要素から任意のデータを取り出す (datum)</title><link>https://maku.blog/p/8m4drzr/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8m4drzr/</guid><description>図: D3 セレクションのデータを参照する D3 セレクションオブジェクトの datum() メソッドを使うと、任意のデータ（オブジェクト）を紐づけて、後から自由に参照できるようになります。 例えば、任意の要素上でマウスイベントが発生した場合に、その要素のデータを参照するというのが典型的な使用方法です。 D3 セレクションオブジェクトに紐づけられたデータを参照するときは、datum() メソッドを引数なしで呼び出します。 D3.js で複数要素をまとめて追加する際には data() メソッドを使用しますが、それでセットしたデータも datum() メソッドで参照することができます。
下記の例では、3 つの circle 要素のデータとして、name プロパティと color プロパティを持つ独自のオブジェクトを紐づけています。
&amp;lt;svg id=&amp;#34;svg-vmhww5v&amp;#34; w=&amp;#34;200&amp;#34; h=&amp;#34;100&amp;#34; /&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-vmhww5v&amp;#34;); // 3 つの circle 要素に紐づけるデータ const data = [ { name: &amp;#34;circle-1&amp;#34;, color: &amp;#34;cyan&amp;#34; }, { name: &amp;#34;circle-2&amp;#34;, color: &amp;#34;yellow&amp;#34; }, { name: &amp;#34;circle-3&amp;#34;, color: &amp;#34;magenta&amp;#34; }, ]; // 情報表示用の text 要素 const text = svg.</description></item><item><title>D3.js でマウスイベントを扱う (click, mousemove, mouseover, mouseout)</title><link>https://maku.blog/p/ffz4v3w/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ffz4v3w/</guid><description>D3.js でマウスイベントを扱うコードのサンプルです。
click イベント 図: click イベントをハンドルする D3.js でマウスのクリックイベントをハンドルするには、D3 Selection オブジェクトに click イベントハンドラを追加します。 上記の svg 要素内でクリックすると、その座標にピンク色の円が表示されます。
&amp;lt;svg id=&amp;#34;svg-vwuifrt&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;100&amp;#34; /&amp;gt; &amp;lt;script&amp;gt; const svg = d3.select(&amp;#34;#svg-vwuifrt&amp;#34;); // D3 Selection オブジェクトを取得 svg.on(&amp;#34;click&amp;#34;, (event) =&amp;gt; { const [x, y] = d3.pointer(event) svg.append(&amp;#34;circle&amp;#34;) .attr(&amp;#34;cx&amp;#34;, x) .attr(&amp;#34;cy&amp;#34;, y) .attr(&amp;#34;r&amp;#34;, 10) .attr(&amp;#34;fill&amp;#34;, &amp;#34;deeppink&amp;#34;) .style(&amp;#34;fill-opacity&amp;#34;, 0.5) }) &amp;lt;/script&amp;gt; event.clientX や event.clientY でマウスカーソルの座標値を取得してしまうと、ブラウザのクライアント領域全体の座標値になってしまうので、d3.point() で svg 要素内の座標値に変換するところがポイントです。
mousemove イベント 図: mousemove イベントをハンドルする D3.js でマウスカーソルを動かしたときのイベントをハンドルするには、D3 Selection オブジェクトに mousemove イベントハンドラを追加します。 上記の svg 要素内でマウスカーソルを動かすと、現在の座標値を表示します。</description></item></channel></rss>