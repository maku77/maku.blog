<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>プログラム雑多メモ on まくろぐ</title><link>https://maku.blog/p/sfs4fq2/</link><description>Recent content in プログラム雑多メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 09 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/sfs4fq2/index.xml" rel="self" type="application/rss+xml"/><item><title>プログラムでレインボーカラー（虹色）のグラデーションを作成するには</title><link>https://maku.blog/p/4cbbh6o/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4cbbh6o/</guid><description>とあるコーディングにおいて、色を滑らかに変化させる必要があったのでメモメモ。
RGB ではなく HSV で考える 何らかのプログラミング言語から虹色のグラデーションを作る必要がある場合、RGB の色空間で色調整を行うのは大変ですが、HSV の色空間で考えると簡単に表現することができます。
図: HSV 色空間 参考: HSV 色空間 - Wikipedia HSV はそれぞれ下記のような情報を表しており、
色相 (Hue): 0～360 彩度 (Saturation・Chroma): 0～1 明度 (Value・Brightness): 0～1 このうち、色相 (Hue) の値を 0～360 の間で変化させてやることでレインボーカラーを表現することができます。
プログラムのサンプル 図: 虹色グラデーションの描画 例えば、Android では、android.graphics.Color.HSVToColor() という関数を使用すると、HSV 色空間における値を、描画に使用するカラーデータに変換することができます。
下記の ColorGenerator クラスの nextColor() メソッドを連続して呼び出すと、徐々に変わっていく色をひとつずつ取り出すことができます。 やっていることは、メソッドの呼び出しごとに、色相 (Hue) の値を少しずつ変化させているだけです。 色相 (Hue) が、何度の nextColor() 呼び出しで一周するかは、コンストラクタの steps パラメータで指定できるようにしています。
ColorGenerator.kt class ColorGenerator(val steps: Int, initialHue: Float = 0.0F) { private val hueStep: Float = 360F / steps private var currentHue = initialHue fun nextColor(): Int { val hsv = floatArrayOf(currentHue, 1.</description></item><item><title>C# で Microsoft Outlook の情報を取得する</title><link>https://maku.blog/p/eb5nx4z/</link><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eb5nx4z/</guid><description>組織内で Outlook を使用している場合は、プログラムから Outlook の情報（Exchange サーバの情報）を取得してごにょごにょすると、日々の作業を効率化できるかもしれません。 ここでは、C# から Outlook の情報を取得する方法を紹介します。
プログラミング言語に C# を使っていますが、もともとは VBA などのインタフェース (COM) として使われていたものなので、本格的にコーディングするときは、VBA のリファレンスが参考になります。
Outlook VBA リファレンス｜MSDN 以下のサンプルは、Visual Studio Community 2017 を使って確認しています。 Visual Studio で新規のプロジェクト（ここではシンプルにコンソールアプリを選択）を作成したら、まずは次のようにして Outlook のインタフェースの参照を追加してください。
プロジェクト(P) → 参照の追加(R) COM → Microsoft Outlook 14.0 Object Library 次のコードは、現在 Outlook を使用しているユーザの名前とメールアドレス、および上司の名前とメールアドレスを表示します。
using System; using Outlook = Microsoft.Office.Interop.Outlook; namespace ConsoleApp1 { class Program { static Outlook.Application outlookApp = new Outlook.Application(); // Exchange ユーザの情報を表示する static void ShowRecipientInfo(Outlook.ExchangeUser user) { Console.</description></item><item><title>文字列の類似度を計算する（LCS: 最長共通部分列）</title><link>https://maku.blog/p/a3jyhwd/</link><pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a3jyhwd/</guid><description>LCS とは LCS: Longest Common Subsequence（最長共通部分列） 問題とは、2 つのシーケンスから最長の共通部分列を探す問題です。
参考: Wikipedia - Longest common subsequence problem 参考: Wikipedia - 最長共通部分列問題 部分列は飛び飛びの要素で構成されていても構いませんが、順番はキープして作成する必要があります。下記の例は、2 つの文字列とその最長共通部分列 (LCS) を示したものです。
文字列1: "ABCDCE" 文字列2: "ACCDEX" LCS: "ACCE" or "ACDE" LCS の計算方法 LCS は、動的計画法（DP: Dynamic Programming）の例題としてよく示される問題で、DP を使うことで効率的に答えを求めることができます。 考え方としては、下記のような文字列の入ったスタックから、任意の順番で文字を取り出していく問題だとみなすと分かりやすいです。
どちらか一方から要素を取り出すときは、文字をマッチさせないと考えます。 両方の要素を同時に取り出すときは、そのタイミングで文字をマッチさせる（LCS を構成する要素）と考えます。
このように、任意の順番で取り出してマッチングしていったときに、最大の一致数になったものが LCS ということになります。
ここでは、DP（動的計画法）を使って、文字列 1 と文字列 2 の LCS の長さを求めるコードを考えてみます。
文字列 1 の長さを Len1、文字列 2 の長さを Len2 とします。 dp[i][j] には、文字列 1 の j 文字目までの部分文字列と、文字列 2 の i 文字目までの部分文字列を一致させた場合 LCS の長さを格納します。 まず、0 文字の部分文字列同士の LCS は当然 0 文字なので、</description></item><item><title>文字列の類似度を計算する（レーベンシュタイン距離）</title><link>https://maku.blog/p/xjw9ju7/</link><pubDate>Tue, 18 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjw9ju7/</guid><description>レーベンシュタイン距離とは レーベンシュタイン距離 (Levenshtein Distance) は、ある文字列に対して、何回の変更処理（削除、挿入、置換）を行えば対象の文字列に変換できるかを示します。
参考: Wikipedia - Levenshtein distance 参考: Wikipedia - レーベンシュタイン距離 レーベンシュタイン距離を効率的に計算するために、一般的に DP マッチング（動的計画法による距離計算）が使用されます（ここでは文字列間の距離を求めていますが、DP マッチングは単純に二つの波形を伸縮させながらマッチングするためにも使用されます）。 下記に詳細なマッチングの過程を示します。
2 つの文字列のレーベンシュタイン距離を求める 次のような文字列 A と文字列 B のレーベンシュタイン距離を求めるとします。
文字列 A = "CARROT" 文字列 B = "CAT" 文字列 A の文字数が i 文字、文字列 B の文字数が j 文字だとした場合の距離（最短変換数）を格納するための dp 配列を用意します。
dp[LenA + 1, LenB + 1] 下記の図は、この配列を表にしたものです。
セル内の数値は文字列を一致させるのに費やした変換手順数を表しており、dp[0, 0] は文字列 A も文字列 B も空文字だった場合の距離なので 0 です（空文字から空文字に変換するまでの手順数です）。 この表に左下から順番に手順数を埋めていき、最終的に右上の G が示している dp[7, 4] に文字列 A と文字列 B の距離が格納されます（"</description></item><item><title>private メソッドのユニットテストが書きたくなったら</title><link>https://maku.blog/p/nvetfsf/</link><pubDate>Thu, 16 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nvetfsf/</guid><description>private メソッドをテストすべきかどうかは色々意見がありますが、あるクラスの private メソッドの割合が、public メソッドに比べて非常に多くなった場合は、private メソッドのテストも書きたくなるかもしれません。
そのような場合は、クラス抽出のリファクタリングを考えるとよいです。 特定の処理がクラスとして抽出されれば、そのクラスを利用するインタフェースは public メソッドになるので、自然にテストを記述できるようになります。 もとのクラスの見通しもよくなり、一石二鳥です。
計算処理を担うようなメソッドはテストを記述するよい対象になりますが、private メソッドのままではテストが記述できません。 そのような場合は、public static なユーティリティメソッドに変更することで、テストを記述できるようにするとよいです。 そのメソッド内でフィールドにアクセスしないユーティリティメソッドになっていれば（ステートレス）、オブジェクトに副作用を与えることはないので、public メソッドにしても悪影響は出ません（カプセル化は崩れない）。
JxUnit のように private メソッドをテスト可能なフレームワークを使用するのもひとつの手です。 JxUnit は内部でリフレクションを利用して private メソッドのテストを可能にしています。</description></item><item><title>Groovy をインストールする</title><link>https://maku.blog/p/vtfddwb/</link><pubDate>Fri, 30 May 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vtfddwb/</guid><description>MacOSX に Groovy をインストールする GVM: Groovy enVironment Manager を使うと複数バージョンの Groovy を管理することができます。 ここでは、GVM を使って Groovy の環境をインストールする手順を示します。
1. GVM のインストール $ curl -s get.gvmtool.net | bash これで、.bash_profile に以下のように追加されて gvm コマンドにパスが通ります。
#THIS MUST BE AT THE END OF THE FILE FOR GVM TO WORK!!! [[ -s &amp;#34;/Users/maku/.gvm/bin/gvm-init.sh&amp;#34; ]] &amp;amp;&amp;amp; source &amp;#34;/Users/maku/.gvm/bin/gvm-init.sh&amp;#34; 2. GVM で groovy のインストール $ gvm list groovy # インストール可能なバージョン確認 $ gvm install groovy # 最新版のインストール $ gvm install groovy 2.3.2 # バージョンを指定してインストール これで、groovy や groovysh コマンドが使用できるようになります。 使用中の groovy のバージョンの確認、切り替えは以下のように行います。</description></item><item><title>HMAC-SHA256 コードを生成する</title><link>https://maku.blog/p/uqhbb5p/</link><pubDate>Fri, 02 Aug 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uqhbb5p/</guid><description>Python で HMAC-SHA256 を生成する 下記の siggen.py スクリプトは、コマンドライン引数で渡された「秘密鍵テキスト」と「メッセージ」をもとに HMAC (Hash-based Message Authentication Code) 署名を生成します。
siggen.py import sys import hashlib import hmac def usage(): print(&amp;#39;python &amp;#39; + sys.argv[0] + &amp;#39; &amp;lt;key&amp;gt; &amp;lt;message&amp;gt;&amp;#39;) sys.exit(1) if __name__ == &amp;#39;__main__&amp;#39;: if len(sys.argv) &amp;lt; 3: usage() key = sys.argv[1] msg = sys.argv[2] sig = hmac.new(key.encode(&amp;#39;ascii&amp;#39;), msg.encode(&amp;#39;ascii&amp;#39;), hashlib.sha256) print(sig.hexdigest()) 使用例 $ python siggen.py &amp;#39;SecretKey&amp;#39; &amp;#39;YourMessage&amp;#39; 8aff2951003c218bd26ee43c99e30527a0c30e06042008a60935ef1ab28891ec ここでは、SHA256 ハッシュ関数を使用していますが (HMAC-SHA256)、hashlib.sha256 の部分を変更すれば、他のハッシュ関数を適用することができます。
openssl コマンドで HMAC-SHA256 を生成する Linux や macOS などの、openssl コマンドを使用できる環境では、下記のようにして簡単に HMAC-SHA256 を求めることができます。</description></item><item><title>ソフトウェア開発手法のまとめ</title><link>https://maku.blog/p/herfwex/</link><pubDate>Sun, 04 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/herfwex/</guid><description> XP (eXtream Programming) Kent Beck が指揮。 12 のプラクティスがあり、それぞれが連携している。 顧客との連携を重視する。「オンサイト顧客」というプラクティスでは、開発チームに顧客を含めてしまう。 SCRUM マイクロソフトで発祥。 マネジメントに焦点を当てたプロセス。 それぞれの役割に、強い権力付けがされているのが特徴。 1ヶ月のスプリントの間、スクラムマスターはスクラムチームを外の雑音から守る。 約10分で終わるスタンドアップミーティングで一日を始める。 クリスタル Alistair Cockburn が提唱するプロジェクトのテンプレート群。 メンバー数などから、クリスタルクリア、イエロー、オレンジ、レッドと分類される。 規模が大きくなると、ドキュメントを多く作るような規則になっていく。 ASD (Adaptive Software Development) Jim Highsmith と Sam Bayer が作成。 RAD (Rapid Application Development) の考えから作成されたアジャイル開発プロセス。 複雑性の理論により、「Speculate（推測） ➡ Collaborate（強調） ➡ Learn（学習）」の繰り返しでプロジェクトを順応させていく。 大規模開発は、メンバー数を増やすことで可能にする。 リーン開発 Poppendieck 夫妻が提唱。 無駄を省きながらプロジェクトを進める開発手法。 プロジェクト開発中の待ち時間になっている部分を少なくすることでプロジェクトを短期間に終わらせようとする考え。 FDD (Feature Driven Development) ボーランドが提唱。 開発の単位を「機能」とする。 機能のリリースは2週間単位。 機能の完成度は「赤：未着手」「黄：作業中」「緑：完成」の3段階のみで表現。 機能単位で担当を割り当てる。クラス単位で担当を決めることで、人同士のやり取りが、クラス間のやり取りに等しくなるという利点がある。 TDD (Test Driven Development) XP と同じ Kent Beck が提唱。 XP のテストファーストの考え方を、プロセス全体に適用したもの。 GUI の開発であっても、クラスを疎結合にすることで、テストの自動化を考える。</description></item><item><title>クワイン・マクラスキー法 (Quine-McCluskey algorithm)</title><link>https://maku.blog/p/m4x8mcw/</link><pubDate>Fri, 20 Jun 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4x8mcw/</guid><description>カルノー・マップを用いた Bool 演算の簡易化のような処理を、単純な処理の繰り返しで行えるようにしたもの。コンピュータでの処理に向いている。
クワイン・マクラスキー法 - Wikipedia Petrick&amp;rsquo;s method - Wikipedia</description></item><item><title>無名サブルーチンとクロージャ</title><link>https://maku.blog/p/r58xbyk/</link><pubDate>Wed, 30 Apr 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r58xbyk/</guid><description>『初めての Perl 第3版』より
クロージャ (closure) は非常に強力な概念で、Lisp の世界から持ってきたものです。クロージャとは、（荒っぽい言い方をすれば）自分自身のプライベートなデータを持っている無名サブルーチンです。
『続・初めての Perl』より
その時点で存在するすべてのレキシカル変数に、宣言された時点からアクセスできるサブルーチンをクロージャ (closure) と呼びます（クロージャは、もともとは数学用語です）。
例えば、以下の callback サーブルーチンは、レキシカル変数 $count を参照するクロージャといえます。
my $count = 0; sub callback { ++$count; }</description></item><item><title>大規模なコードを読み解くコツ（コードリーディング）</title><link>https://maku.blog/p/b34f2vu/</link><pubDate>Sat, 12 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b34f2vu/</guid><description>階層構造の意味をメモする 大規模なプロジェクトのソースコードを読む場合は、まずはディレクトリがどのようなポリシーで分けられているのか、各ディレクトリ内のコードの役割などのメモを作成していくことをオススメします。
役割のわからないディレクトリについては、そのままにしておいて、わかった時点で詳細を追加していけば OK です。
project +-- tools（ほげほげ用のツール） +-- src +-- hogeui（ほげほげインタフェースに関するクラス） +-- foobar（？）</description></item><item><title>数値計算系のプログラムメモ</title><link>https://maku.blog/p/m3p8hh6/</link><pubDate>Sat, 20 Oct 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m3p8hh6/</guid><description>n が 2 のべき乗か判定する long powerof2(long n) { return (n &amp;gt; 0) &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0); }</description></item></channel></rss>