<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GraphQL クエリ仕様 on まくろぐ</title><link>https://maku.blog/p/mqdu9nz/</link><description>Recent content in GraphQL クエリ仕様 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 28 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/mqdu9nz/index.xml" rel="self" type="application/rss+xml"/><item><title>GraphQL クエリ仕様: クエリで変数を使用する</title><link>https://maku.blog/p/dtwtpzj/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtwtpzj/</guid><description>変数定義と変数値の指定 特定のパラメーターのみ値を変えて複数の GraphQL のクエリを発行したい場合は、ドキュメント内で query や mutation を定義するときに、変数定義 (variable definitions) を追加します。
次の GetBook クエリでは、$id: String! という変数定義を行っています。 これは、クエリ実行時に id という名前の文字列変数を参照することを示しています。 そして、型名に ! が付いているので、変数値の指定は必須です。
変数を参照するクエリの例 queryGetBook($id:String!){book(id:$id){idtitleprice}} 指定された id 変数の値は、book フィールドの id 引数として渡され、対応する書籍を取得するリクエストとして処理されます。
肝心の変数の値は、query や mutation などのドキュメントとは異なる variables という HTTP ペイロード・フィールドで GraphQL サーバーへ送ります（HTTP POST 経由での GraphQL API 呼び出しの場合）。 ただ、このあたりの variables フィールドの送信に関しては、通常は各種言語用の GraphQL ライブラリに隠蔽されているため、明示的に HTTP POST リクエストのペイロードを設定することはありません。 例えば、React 用の Apollo Client ライブラリは、次のような感じで変数を設定するインタフェースを提供しています。
const { loading, error, data } = useQuery&amp;lt;QueryType, VarType&amp;gt;(query, { variables: { id: &amp;#34;book-123&amp;#34; } }) Web ブラウザ上で GraphQL API のテストを行える GraphiQL（グラフィカル） の UI では、次のようにドキュメントと変数を別々に記述できるようになっています。</description></item><item><title>GraphQL クエリ仕様: ディレクティブによる条件分岐 (@include, @skip)</title><link>https://maku.blog/p/dcdv7rv/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dcdv7rv/</guid><description>GraphQL クエリで、各フィールド名（あるいはフラグメント）の後ろに @include ディレクティブや @skip ディレクティブを配置すると、if 引数で指定した条件によってそのフィールドを取得するかどうかを制御できます。
fieldName@include(if:$someTest)fieldName@skip(if:$someTest)@include ディレクティブと @skip ディレクティブの違いは、if 引数の判定が逆転しているだけです。
@include(if: Boolean) ディレクティブ if 引数の値が true のときにのみフィールドを取得します @skip(if: Boolean) ディレクティブ if 引数の値が false のときにのみフィールドを取得します クエリ内での @include ディレクティブによる条件分岐 queryQueryOrganization($org:String!,$details:Boolean=false){organization(login:$org){namedescriptionwebsiteUrl@include(if:$details){}} variables { &amp;#34;org&amp;#34;: &amp;#34;graphql&amp;#34;, &amp;#34;details&amp;#34;: true }</description></item><item><title>GraphQL クエリ仕様: フィールド名にエイリアスを付ける</title><link>https://maku.blog/p/vnkd4ur/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vnkd4ur/</guid><description>GraphQL クエリ言語の フィールド・エイリアス 機能を使うと、取得したフィールド値を参照するときに、任意の別名を付けて参照することができます。 例えば、GraphQL スキーマとしては company というフィールド名で定義されているものを、companyName という JSON プロパティ名で返して欲しいときは、次のようにフィールド・エイリアスを使用します。
GraphQL クエリ queryProfileInfoWithAlias{user(login:&amp;#34;maku77&amp;#34;){namecompanyName:companybio}} レスポンス { &amp;#34;data&amp;#34;: { &amp;#34;user&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Makkuma&amp;#34;, &amp;#34;companyName&amp;#34;: &amp;#34;maku maku company&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;すーぱーぷにぐらまー&amp;#34; } } } フィールド・エイリアスは、同名のフィールドを異なる引数で取得するときに役立ちます。
GraphQL クエリ query{maku77:user(login:&amp;#34;maku77&amp;#34;){...basicUserInfo}puni:user(login:&amp;#34;puni&amp;#34;){...basicUserInfo}}fragmentbasicUserInfoonUser{namebio} 上記のように 1 つのクエリの中で同名のフィールド（ここでは user）を要求する場合に、フィールド・エイリアス（ここでは maku と puni）を付けることで、レスポンスのプロパティ名がコンフリクトしないようにします。 というより、このケースではエイリアスを設定しないと、リクエスト時にエラーになります。
レスポンス { &amp;#34;data&amp;#34;: { &amp;#34;maku77&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Makkuma&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;すーぱーぷにぐらまー&amp;#34; }, &amp;#34;puni&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Puni Puni&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;ぷにぷにぷにょーん&amp;#34; }, } } なお、上記クエリ内の .</description></item><item><title>GraphQL クエリ仕様: フラグメント (Fragments) とインラインフラグメント (Inline Fragments)</title><link>https://maku.blog/p/wiv7it5/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wiv7it5/</guid><description>GraphQL フラグメントでクエリをパーツ化する フラグメントの基本 GraphQL クエリの中で、同じようなフィールドの指定（選択セット）を複数回使用する場合、それを フラグメント (Fragments) という再利用可能な選択セットとして切り出して定義しておくことができます。
例えば次の GraphQL クエリは、GitHub から自分のユーザー情報 (viewer) と、特定のユーザーの情報 (user) を一度に取得しています。
GraphQL クエリ queryQueryTwoUsers{viewer{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}user(login:&amp;#34;ログインID&amp;#34;){loginnameurlwebsiteUrlavatarUrl}} viewer フィールドと user フィールドは、両方とも User 型 のフィールドで、しかも、上記の例では User オブジェクトの中の同じフィールドを参照しています。 明らかに冗長な書き方です。
このようなケースでは、あるオブジェクトの特定のフィールドを参照するための選択セット (selection set) を、フラグメントの形で定義することができます。 次の例では、User オブジェクトの特定のフィールドを選択するための userFragment というフラグメントを定義し、クエリ内で参照しています。
GraphQL クエリ queryQueryTwoUsers{viewer{...userFragment}user(login:&amp;#34;ログインID&amp;#34;){...userFragment}}# User オブジェクトの中のフィールドを選択するためのフラグメントfragmentuserFragmentonUser{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像} フラグメントを使用する場所では、...userFragment のようにドットを 3 つ付けて参照します。 これを GraphQL 用語で フラグメント・スプレッド（fragment spread) といいます。 その場所にフラグメントの内容を「展開する」という意味です。 JavaScript でオブジェクトを展開するときのスプレッド構文 (.</description></item></channel></rss>