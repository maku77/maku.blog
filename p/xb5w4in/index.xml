<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>デザインパターン/UMLのメモ on まくろぐ</title><link>https://maku.blog/p/xb5w4in/</link><description>Recent content in デザインパターン/UMLのメモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 08 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/xb5w4in/index.xml" rel="self" type="application/rss+xml"/><item><title>１時間で分かる GoF デザインパターン</title><link>https://maku.blog/p/7gmjvza/</link><pubDate>Tue, 13 May 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7gmjvza/</guid><description>オブジェクト指向における再利用のためのデザインパターン エリック ガンマ, ラルフ ジョンソン, リチャード ヘルム, ジョン ブリシディース ソフトバンククリエイティブ 増補改訂版Java言語で学ぶデザインパターン入門 結城 浩 ソフトバンククリエイティブ デザインパターンの輪講をしたときのメモ。
生成に関するパターン (Creational Patterns) (1) Abstract Factory パターン 同種の複数のオブジェクト生成を concrete factory クラスとして種類ごとにまとめ、実際の生成は abstract factory クラスの抽象化されたインタフェース経由で行う。一貫した種類のインスタンスを作ることができる。
実装イメージ TvFactory tvFactory = new SonyTvFactory(); // Sony 製の TV を作るための TvFactory ... tvFactory.CreatePanel(); // SonyPanel を生成 tvFactory.CreateTuner(); // SonyTuner を生成 ... どのような手順で factory method を呼び出すかを定義すると、それは Builder パターンになる。
(2) Builder パターン オブジェクトの生成手順を共通化して使いまわし、異なるオブジェクトを作成。</description></item><item><title>UML ダイアグラムの一覧と分類</title><link>https://maku.blog/p/yzs49gv/</link><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yzs49gv/</guid><description>構造図 (structual diagrams) クラス図: クラス、特性、関係 コンポーネント図: コンポーネントの構造と接続 コンポジット構造図（複合構造図）: クラスのランタイム分割 配置図: ノードへの成果物の配置 オブジェクト図: インスタンスの接続の基本例 パッケージ図: コンパイル時の階層構造 振る舞い図 (behavioral diagrams) アクティビティ図: 手続き的なまたは並行な振る舞い ユースケース図: ユーザーがシステムとどう対話（相互作用）するか ステートマシン図（状態マシン図）: オブジェクトの存続期間にイベントがオブジェクトに加える変更の内容 相互作用図 シーケンス図: オブジェクト間の相互作用（シーケンスを重視） コミュニケーション図: オブジェクト間の相互作用（リンクを重視）UML1ではコラボレーション図と呼ばれていた タイミング図: オブジェクト間の相互作用（タイミングを重視）(UML2) 相互作用概要図: シーケンス図とアクティビティ図を合わせたもの (UML2)</description></item><item><title>デザインパターン: MVC パターンのメモ</title><link>https://maku.blog/p/cps3nt8/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cps3nt8/</guid><description>MVC パターンの構造 オブジェクト図 ≪生成コード&amp;#x1F4D6;≫ シーケンス図 図: シーケンス図 ≪生成コード&amp;#x1F4D6;≫ M (Model) 処理。ビジネス・ロジック。
アプリケーションが使用するデータを保持し、アプリケーション固有の処理を実行する。 外部のストレージ（データベース）に保存するためのインタフェースなどを備えていてもよい。
特に、保持するデータを参照するための public インタフェースだけを備えているものを Model ということもある。J2EE デザインパターンでは、純粋にデータのみを保持するものを Value Object と呼んでいる。
View、Controller とは関連性を持たないのが望ましい。 Model オブジェクトは、自分自身がどのように表示されるかを知らない。
特定の実行環境に依存しないのが望ましい。 例えば、特定のフレームワーク上に構築されたアプリケーションであっても、Model クラスだけは別のフレームワークでも使用できるようにするべき。つまり、フレームワークに特化したインタフェースを備えてはいけない。
V (View) 表示。プレゼンテーション・ロジック。
データを目に見える形で表示するためのコード。ウィンドウアプリケーションでは、ウィンドウ内に表示するウィジット等の表示、Web アプリケーションでは、HTML の出力などが View に当たる。
C (Controller) 入力。インタラクション・ロジック。
ユーザやシステムからのイベントを受けとり、Model や View の作成、更新、相互作用を管理する。
MVC パターンの Pros and Cons 利点 (Pros.) UI コードにビジネスロジックが入るのを防ぐことができる。 ユニットテストしやすい。 欠点 (Cons.) スケールしない（UI は個々に作成できるが、モデルを分離しにくい） Contoller が肥大化しやすい（View からの処理がすべて Controller 経由になる） SOLID 原則の S (Single responsibility principle) と I (Interface segregation principle) に違反してしまう。 View と Controller の関連 多くの GUI toolkit では、V (View) と C (Controller) は複雑に絡み合っている。なぜなら、C (Controller) は、それ自体が画面上に表示される widget であることが多いから。</description></item><item><title>デザインパターン: MVP パターンのメモ</title><link>https://maku.blog/p/5wu6fbv/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5wu6fbv/</guid><description>MVP (Model-View-Presenter) パターンでは、MVC (Model-View-Controller) パターンと異なり、View と Model が直接やり取りせず、すべて Presenter 経由でのやり取りになります（亜種としてデータバインディングを使用するケースもあります）。
MVP パターンの構造 オブジェクト図 ≪生成コード&amp;#x1F4D6;≫ シーケンス図 ≪生成コード&amp;#x1F4D6;≫ MVP の構成要素 View: 描画ロジックを持つ。自分自身が能動的に描画処理を行うことはなく、Presenter からの要求で描画処理を行うため、Passive View と呼ばれる。Presenter に言われたとおりに、渡されたデータを描画するだけ。ユーザの入力を受け、Presenter へ通知する。 Presenter: ユーザイベントをハンドルし、具体的なアクションを実行する (Proxy)。データを Model から取得し、View が扱える形に加工して描画情報として渡す。 Model: ビジネスロジックとデータ保持（およびデータ取得処理）を担う。DB や Web サービスと通信してデータを取得する役割を持つ。必要に応じて Presenter へ変更通知を送る。 MVP の Pros and Cons Pros. 複雑なタスクをシンプルなタスクに分割できる。 クラスが小さくなり、不具合が入りにくくデバッグしやすくなる。 ユニットテストできる。 Cons. 各レイヤを繋ぐ退屈な作業が必要。 Model が特定のユースケースに結びついてしまい再利用しにくい。 View と Presenter が特定のデータ形式により結び付けられてしまう（Model の提供するデータを Presenter 経由で View に渡すときにデータの依存ができる）。 MVP の各コンポーネントの生成過程 MVP パターンを導入しようとするときに、最初に迷うのがオブジェクトの所有関係をどうするかだと思います。 下記は MVP の一般的なオブジェクトの生成過程です。</description></item><item><title>Kent Beck の CollectingParameter パターン</title><link>https://maku.blog/p/8yhxet9/</link><pubDate>Sun, 10 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8yhxet9/</guid><description>Collecting Parameter の特徴 巡回するオブジェクトの戻り値をベースに目的のデータを構築するのではなく、パラメータに渡したオブジェクトを使ってデータを構築する。
戻り値となるオブジェクトのインスタンス化を防ぐことができるので、コードの実行速度が上がる。 戻り値をベースにしたデータ構築よりも、より柔軟なタイミングでデータの構築が行える（例えば、メソッドの実行途中で結果を append できる）ようになり、コードを分割しやすくなる。 参考文献: 『パターン思考リファクタリング入門』 第10章 累積処理
Collecting Parameter を使わない場合の実装例 public String extractText() { StringBuilder results = new StringBuilder(); Node node = null; while ((node = nodeList.next()) != null) { results.append(node.toString()); // 戻り値をベースにしたデータ構築 } return results.toString(); } Collecting Parameter を使う場合の実装例 public String extractText() { StringBuilder results = new StringBuilder(); Node node = null; while ((node = nodeList.next()) != null) { node.getText(results); // パラメータをベースにデータ構築 } return results.</description></item></channel></rss>