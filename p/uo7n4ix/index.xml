<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PowerShell のメモ on まくろぐ</title><link>https://maku.blog/p/uo7n4ix/</link><description>Recent content in PowerShell のメモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 08 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/uo7n4ix/index.xml" rel="self" type="application/rss+xml"/><item><title>PowerShell のプロファイルを作成して独自コマンドを定義する ($profile)</title><link>https://maku.blog/p/v7bkitw/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v7bkitw/</guid><description>プロファイルとは PowerShell は起動時に $PROFILE のパスに格納されたプロファイルファイルを読み込むようになっています。 このファイルで関数の定義や初期化処理を行うことで、PowerShell を便利に使えるようになります。 $PROFILE には次のようなパスが格納されています。
PS C:\&amp;gt; $profile C:\Users\maku\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1 プロファイルの作成 デフォルトでは $PROFILE が示すファイルは存在しない可能性があるので、New-Item コマンドレットなどを使って、エディタで開く前にファイルを生成しておく必要があります。
プロファイルを作成してエディタで開く New-Item -Path $profile -ItemType file -Force notepad $profile このファイルを作成したあとに新しく PowerShell を開こうとすると、実行ポリシー 関連のセキュリティエラーが発生します。 これは、デフォルトで ps1 ファイルの実行が許可されていないからです。
セキュリティエラー . : ファイル C:\Users\maku\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1 を読み込めません。 ファイル C:\Users\maku\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1 はデジタル署名されていません。 このスクリプトは現在のシステムでは実行できません。 スクリプトの実行および実行ポリシーの設定の詳細については、「about_Execution_Policies」(https://go.microsoft.com/fwlink/?LinkID=135170) を参照してください。 現在の実行ポリシーの一覧は、Get-ExecutionPolicy コマンドレットで確認できます。
PS C:\&amp;gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- --------------- MachinePolicy Undefined UserPolicy Undefined Process Undefined CurrentUser Undefined LocalMachine AllSigned カレントユーザーによるスクリプトの実行を許可するには、次のように Set-ExecutionPolicy コマンドレットを実行します。
PS C:\&amp;gt; Set-ExecutionPolicy RemoteSigned -Scope CurrentUser ここで指定している RemoteSigned ポリシーは、「インターネット上の署名されたスクリプト」および「ローカルコンピューター上のスクリプト」の実行を許可するポリシーです。</description></item><item><title>PowerShell で環境変数を扱う</title><link>https://maku.blog/p/jodtbr8/</link><pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jodtbr8/</guid><description>環境変数の値を参照する PowerShell スクリプトの中から環境変数の値を取得するには、$env:変数名 を参照します。
sample.ps1 echo $env:USERPROFILE 環境変数が設定されているかどうかを調べる 環境変数が定義されているかどうかを調べるには、以下のような条件分岐を使用します。
sample.ps1 if ($env:HOME -eq $null) { Write-Host &amp;#39;HOME is not set&amp;#39; } if ($env:HOME -ne $null) { Write-Host &amp;#39;HOME is set&amp;#39; } 値が空である場合も「定義されていない」とみなしたいのであれば、IsNullOrEmpty() でチェックします。
if ([string]::IsNullOrEmpty($env:HOME)) { Write-Host &amp;#39;HOME is not set&amp;#39; exit }</description></item><item><title>PowerShell: 現在の日時を ISO 8601 (YYYY-MM-DD) フォーマットで取得する (Get-Date)</title><link>https://maku.blog/p/9a9n6se/</link><pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9a9n6se/</guid><description>PowerShell の Get-Date コマンドレットを使用すると、現在の日時を表す文字列を取得することができます。
Format、UFormat パラメータで日時の書式を指定する Format Get-Date の Format パラメータを指定することで、任意の書式で日時文字列を取得することができます。
PS&amp;gt; Get-Date -Format &amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34; 2020-03-19 15:23:09 PS&amp;gt; Get-Date -Format &amp;#34;yyyy-MM-ddTHH:mm:ssK&amp;#34; # ISO 8601 2020-03-19T15:23:09+09:00 UFormat UFormat パラメータを使うと、もう少しシンプルに記述できたりします（指定できる記号の一覧はこちら）。
PS&amp;gt; Get-Date -UFormat &amp;#34;%F %T&amp;#34; 2020-03-19 15:26:42 PS&amp;gt; Get-Date -UFormat &amp;#34;%Y-%m-%d %H:%M:%S&amp;#34; # 同上 2020-03-19 15:26:42 PS&amp;gt; Get-Date -UFormat &amp;#34;%FT%T%Z&amp;#34; # ISO 8601 2020-03-19T15:26:42+09 DateTime オブジェクトの ToString メソッドを使用する Get-Date で先に DateTime オブジェクトを取得しておいて、ToString 関数で日時を表す文字列に変換するという方法もあります。
PS&amp;gt; (Get-Date).ToString(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;) 2020-03-19 15:11:37 この方法を使うと、DateTime オブジェクトで日時データを編集してから文字列に変換することができます。 例えば、次の例では、現在から 10 日後の日時を取得しています。</description></item><item><title>PowerShell: バッチファイルから PowerShell を呼び出して結果を変数に格納する</title><link>https://maku.blog/p/372dx46/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/372dx46/</guid><description>Linux や mac では、外部コマンドをバッククォート () で囲んでやるだけで実行結果を取得できますが、バッチファイルで同じようなことをするには FOR /F` コマンドを使用します。 本来は、コマンドの出力結果を一行ずつ処理するためのコマンドですが、次のようにすれば、コマンドの実行結果を一行だけ変数に格納できます。
FOR /F &amp;#34;usebackq delims=&amp;#34; %%A IN (`外部コマンド`) DO set 変数名=%%A FOR ループのパラメータの意味 /F: コマンドの出力結果をループ処理する usebackq: バッククォートで囲まれた文字列全体を外部コマンドとみなす delims=: コマンド実行結果にスペースが含まれていても分割せずに取得（ここではデリミタ文字をなくしている） 上記の 外部コマンド のところで、powershell コマンドを実行すれば、PowerShell で実行した結果をバッチファイル内の変数で受け取ることができます。
例えば、次のバッチファイル (next-month.bat) では、1か月後の日時を PowerShell で求めて、その結果をバッチファイル内の next_month 変数に取得しています。
next-month.bat @echo off setlocal FOR /F &amp;#34;usebackq delims=&amp;#34; %%A IN (`powershell &amp;#34;(Get-Date).AddMonths(1).ToString(&amp;#39;yyyy-MM-dd&amp;#39;)&amp;#34;`) DO set next_month=%%A echo %next_month% 次のように PowerShell で実行するコマンドを分離しておくと見やすいかもしれません。 ps_command 変数の内容を置き換えるだけで、別のコマンドに対応できます。
set ps_command=`powershell &amp;#34;(Get-Date).AddMonths(1).ToString(&amp;#39;yyyy-MM-dd&amp;#39;)&amp;#34;` FOR /F &amp;#34;usebackq delims=&amp;#34; %%A IN (%ps_command%) DO set result=%%A echo %result% 実行結果 C:\&amp;gt; next-month 2020-04-19</description></item></channel></rss>