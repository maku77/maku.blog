<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>チャットボットの作り方 on まくろぐ</title><link>https://maku.blog/p/k43zbd8/</link><description>Recent content in チャットボットの作り方 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 19 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/k43zbd8/index.xml" rel="self" type="application/rss+xml"/><item><title>よいチャットボットとは？ボットを作成するときのベストプラクティス</title><link>https://maku.blog/p/o2nq2qa/</link><pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2nq2qa/</guid><description>とある事情によりチャットボットを作ろうという話になっています。 まずは、チャットボットってどんなことに気を付けて作ればよいかを調べたので、ポイントになりそうなことをまとめておきます。
下記の Microsoft が提供している Bot Framework のドキュメントがとても参考になりました。
参考: Principles of bot design - Bot Service | Microsoft Docs
チャットボットの知識は、今流行りのスマートスピーカー（Amazon Alexa や Google Home）などのスキルを作成する際にも応用がききそうです。 音声入力による会話は、チャットの特殊形態（キーボードやモニタがないときの手段）と考えることができるので、チャットボットの基本原則を押さえておくことはきっと参考になります。
チャットボットが目指すべきこと こだわるべき事 少ないステップで簡単に問題を解決できること 他の手段よりもチャットボットを使ったほうが速く、簡単で、よりよい結果を得られること ユーザが**使いたい環境（クライアント）**で動作すること ユーザがボットの存在に気付けること。それを使って何をすればよいのか気付けること 何より大切なのはユーザーエクスペリエンスです。 めっちゃ賢い AI を使っているかどうかではなく、ユーザがやりたいことを素早く、簡単に行えるかが重要です。
こだわらなくてよい事 機械学習は必須ではない。めっちゃ賢いボットは必須ではない。 完璧に自然言語を理解して会話できる必要はない。 ボイス対応により必ず UX が改善されるわけではない。ボイスを嫌うユーザはいるし、ノイズの多い環境では使えない。 大切なのは技術力とかクールさとかではなく、ユーザのやりたいことができることです。
最初の挨拶は「自然言語」か「メニュー選択」か？ どんな話しかけにも反応できるボットは存在しません（少なくとも現在は）。 ユーザは、ボットが何をできるのか知らないので、できることの選択肢を表示してあげるとよいです。
選択肢が少なければボタンを並べて、それを押すだけで会話を進められるようにすると、ユーザの入力の手間を大幅に削減することができます。 できることがたくさんあるのであれば、選択肢として「ヘルプ」ボタンを配置して、より詳しい使い方を提示してあげましょう。
図: 最初のメッセージの例 一般的に、自由回答形式の質問 (open-ended question) はユーザーの返答を予測できないので、選択回答形式の質問 (closed-ended question) を使用した方がボットの設計者にとっても望ましいといえます。 見栄を張ってどんな会話でもできる賢いボットを作ろうとするのではなく、できることを明確に示して上げたほうがユーザにとっても使いやすいボットができるでしょう。
プライバシーポリシーの表示 ユーザが「個人情報保護に関する方針と利用規約」(Privacy policy and terms of use) にアクセスできるようにしておくのが望ましいです。 特に、チャットボットサービスを介して個人情報を収集するのであれば、このような表示は必須になります。</description></item><item><title>チャットボット (1-1) Bot Builder SDK とは</title><link>https://maku.blog/p/tzaeb9x/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tzaeb9x/</guid><description>Microsoft の Azure は Chatbot サービスを作成する機能を提供しています。 Microsoft が提供している Bot Framework は、この Chatbot サービスを作成するとき、あるいは Chatbot を使用するクライアントを作成するときに使用するツール群（あるいは仕組み）やそれらを取り巻く環境の総称です。
Microsoft Bot Framework ボットのサーバを実装するためのライブラリは、Bot Builder SDK という名前で提供されています。 現状では、ボットは Node.js と .NET による開発が想定されているため、Bot Builder SDK も Node.js と .NET 用のものが提供されています（2019年3月現在、Python と Java 版が preview リリースされているようです）。
Bot Builder SDK (for Node.js) Bot Builder SDK (for .Net) Bot Builder サンプルコード集 Node.js と .NET のどちらを使って開発するかに迷ったら、非同期処理を前提にして設計されている Node.js 版を選択するのがよいでしょう。
Node.js の Bot Builder SDK は、NPM パッケージとして公開されているため、npm コマンドを使って簡単にインストールすることができます。</description></item><item><title>チャットボット (1-2) Bot Builder SDK で Echo ボットを作成する</title><link>https://maku.blog/p/you6q5r/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/you6q5r/</guid><description>ここでは、Microsoft の Bot Builder SDK を使ったボット作成のファーストステップとして、チャットクライアントから入力されたテキストをそのままオウム返しするだけの Echo ボットを作成します。 言語としては JavaScript (Node.js) を使用することにします。
ここで作成するのはボットの本体（サービス側）で、クライアントとしては Microsoft が提供している Bot Framework Emulator を使用します。
Bot Builder SDK をインストールする Node.js 版の Bot Builder SDK（botbuilder パッケージ）は、npm コマンドを使ってインストールすることができます。 パッケージの依存関係を管理するための package.json ファイルも、npm init コマンドで作成しておきます。
$ mkdir mybot $ cd mybot $ npm init -y $ npm install --save botbuilder@4.x Bot Service のインタフェースは REST API として提供することが定められているのですが、Bot Builder SDK には REST API サーバを作成する機能は含まれていません。 そこで、REST API サーバを作成するための restify パッケージも一緒にインストールしておきます（express などでも実装できると思いますが、リファレンス実装では restify が使用されています）。</description></item><item><title>チャットボット (2-1) Azure でボットをホストするための Web App Bot リソースを作成する</title><link>https://maku.blog/p/tttou4o/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tttou4o/</guid><description>Web App Bot リソースを作成する 作成したボットプログラムは、Azure 上の Web App Bot リソース上で動作させることができます。 このリソースのことを特にボットサービスと呼んだりします。
Azure ポータル にログインし、下記のように辿ることで Web App Bot リソースの作成画面を表示できます。
＋リソースの作成 AI + Machine Learning Web App Bot 下記のような Web App Bot リソースの設定画面が表示されるので、1 つずつ入力していきます。
ボット名 任意のボット名称。後から自由に変更することができるので、自分のわかりやすい名前を付けておけば OK です。例: maku-bot サブスクリプション 月額の請求先となるサブスクリプションを選択します。最初の Azure トライアル期間であれば、Free Trial などを選択できるはずです。 リソースグループ この Web App Bot リソースを所属させるリソースグループを選択します。存在しない場合は 新規作成 のリンクをクリックして新しく作成します。 場所 リソースグループの場所を選択。ここでは、地理的に近い Japan East を選択してます。 価格レベル チャンネルに応じたメッセージ制限解除のためのプラン設定です。 スタンダードチャンネル（Skype、Cortana、Teams、Facebook、Slack などの一般的なクライアント）とのやりとりは無制限なので、通常は F0 の無料プランを選択しておけば OK です。 一方で、プレミアムチャンネル（ユーザ独自のチャンネルや、Web ページ埋め込みチャットボットなど）と多くのメッセージをやりとりする予定がある場合は、有料の S1 プランを選択する必要があります。 無料の F0 だと 1 か月に 10,000 メッセージまでの制限があります。 （参考: Standard channels と Premium channels について） アプリ名 ボットサービスのエンドポイント URL となる XXX.</description></item><item><title>チャットボット (2-2) Web App Bot で生成されたボットのコードを編集する</title><link>https://maku.blog/p/bpqkm2o/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bpqkm2o/</guid><description>チャットボットのソースコードをダウンロードする 下記のページの手順に従い、Azure ポータル上で Web App Bot のリソースを作成すると、自動的に Echo Bot のテンプレートコードが生成されているはずです（選択したテンプレートの種類によって変わりますが、ここでは Node.js 版の Echo Bot テンプレートを指定しているとします）。
Azure でボットをホストするための Web App Bot リソースを作成する ボットプログラムを作成する場合は、基本的にはこのテンプレートコードをベースにして修正を行っていくのがよいでしょう。 自動生成されたコードは、Azure ポータルから下記のように辿ると ZIP アーカイブでダウロードすることができます。
すべてのリソース を選択 対象の Web アプリボット リソースを選択（下記の例では maku-bot） ボット管理 の ビルド を選択 ボットのソースコードをダウンロードする のボタンをクリック 図: ボットコードをダウンロード bot ファイルの復号化・暗号化 botFileSecret とは ダウンロードした ZIP アーカイブの中には、ボットサーバの設定ファイルである .bot ファイルが含まれています。
このファイルは、ローカルでボットサーバを立ち上げたり、エミュレータからそのサーバに接続するときの設定ファイルとして使用するのですが、自動生成された .bot ファイルは、接続情報などの値が暗号化されています。 .bot ファイルの復号化、および暗号化に使用されているキーのことを botFileSecret と呼びます。
ボットサーバやエミュレータを正しく起動するためには、この botFileSecret を使って .bot ファイルをあらかじめ復号化しておくか、環境変数などでキーを設定しておく必要があります。
.bot ファイルを復号化した場合は、Azure 上の Web App Bot サービスにデプロイする前に、忘れずに暗号化しておく必要があります。</description></item><item><title>チャットボット (2-3) Azure の Web App Bot リソースにボットをデプロイする</title><link>https://maku.blog/p/gxm9shf/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gxm9shf/</guid><description>まず前提として、下記の手順により、Azure 上に Web App Bot リソースが作成済みであることとします。 ここに、ローカルで作成したボットをデプロイすることになります。
Azure でボットをホストするための Web App Bot リソースを作成する Web ブラウザでデプロイする方法（KUDU の Zip Deploy UI） プロジェクトのファイルを ZIP ファイルとしてアーカイブし、Zip Deploy UI という Web ページにドラッグ＆ドロップでデプロイする方法です。 この Web サイトには、下記のような URL でアクセスできます。 &amp;lt;app_name&amp;gt; の部分は、自分のボットアプリ名に置き換えてください。
https://&amp;lt;app_name&amp;gt;.scm.azurewebsites.net/ZipDeployUI 図: Web App Bot の Zip Deploy UI 左上に表示されるロゴからも分かるように、Azure の Web App サービスでは、Kudu というデプロイエンジンが使われているようですね。
この /wwwroot ディレクトリの内容が表示されている画面で、エクスプローラ領域に ZIP ファイルをドラッグ＆ドロップすると、ZIP ファイル内のファイルがまとめて /wwwroot にアップロードされます。
図: ZIP ファイルのドラッグ＆ドロップでデプロイ ボットプログラムのエントリポイントとなる bot.js ファイルを編集してから ZIP 化し、デプロイすることで、ボットの動作が変わることを確認できると思います。</description></item><item><title>チャットボット: Azure ポータルで生成されるボットのテンプレートコードを解読＆リファクタしてみる</title><link>https://maku.blog/p/iob68qa/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iob68qa/</guid><description>Azure が生成するテンプレートコードを理解する 下記の手順に従って Azure ポータル上で Web App Bot リソースを作成すると、ボットプログラムのテンプレートとして index.js や bot.js などのコードが自動生成されます。
Azure でボットをホストするための Web App Bot リソースを作成する ボットサーバのエントリポイントとなる index.js には、設定情報の読み取りと Web サーバの立ち上げ処理が記述されており、bot.js の方にはボットの応答処理を記述するようになっています。
つまり、基本的にボットの作成者は bot.js の方にボットのコア部分を実装していけばよいのですが、LUIS や QnA Maker などのサービスと連携する場合は、それぞれの初期化処理が必要であり、結局のところ index.js 側の実装に関してもある程度理解しておく必要があります。
Azure ポータルで自動生成される index.js は決して理解しやすいものではないので（少なくとも記述時点では）、ここでは index.js の内容を理解する目的と、わかりやすくリファクタする目的を兼ねて、ボットのベースとなるコードを作成していきます。
最終的には Azure が生成するテンプレートコードと同様の振る舞いになることを想定しています（少なくとも、環境変数の名前などは合わせておいた方がよいです）。
全体の流れ ボットプログラムのエントリポイントとなる index.js では、大まかに下記のような処理を行います。
.env ファイルを読み込み、環境変数の情報とマージする 1 の情報を基に、.bot ファイルを読み込む 2 の情報を基に、ボットサーバーを立ち上げる Azure ポータルで生成されるテンプレートコードでは、上記の処理をすべて index.js の中で行っているのですが、ここでは設定の読み込み部分と、ボットサーバの立ち上げ部分を明確に分離してみます。
config.js: 環境変数や .env ファイルの情報を基に、.bot ファイルの設定を読み込む。 index.js: 上記の設定情報を基にボットサーバを立ち上げる。 という感じにします。</description></item><item><title>チャットボット: MS Bot Framework の .bot ファイルで接続情報を管理する</title><link>https://maku.blog/p/8choj4w/</link><pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8choj4w/</guid><description>エミュレータのための .bot ファイル Bot Framework Emulator は、自分自身（チャットクライアント）が接続するボットサーバのアドレスを .bot ファイルから取得します。
.bot ファイルの中には、&amp;quot;type&amp;quot;: &amp;quot;endpoint&amp;quot; というエンドポイント定義が 1 つ以上記述されており、ここにはボットプログラムのアドレスが記述されています。 エミュレータの設定で、どのエンドポイント設定を使用するかを切り替えることで、実際に接続するボットを使い分けることができます。 典型的には、開発時にローカルホスト上で動作させたボットサーバに接続するための development と、実稼働用に Azure 上で動作させたボットサーバに接続するための production というエンドポイントを定義します。
図: エミュレータ上でのエンドポイント切り替え ボットプログラムのための .bot ファイル .bot ファイルは、ボットプログラムからも利用されます（こちらの方がメイン）。
.bot ファイルには、LUIS や QnA Maker のサービスを利用するためのエンドポイント情報（アドレスやエンドポイントキー）が定義されており、ボットプログラムはこれらの情報を使って各サービスの API を利用します。 こららの情報は、ボット自体がローカルホスト上で動作していても、Azure 上で動作していても同様に利用されます。
また、ここでもボット自体の endpoint エントリが参照され、各種チャンネル（チャットクライアント）がボットにアクセスするときの認証処理のために使用されます。 このあたりの処理は、Bot Builder SDK を使ってボット実装を行っていれば、Adapter クラスとして抽象化されるため、特に意識せずに実装することができます。
.bot ファイルに LUIS や QnA Maker の接続設定を記述する .bot ファイルは XML ファイルなので、フォーマットさえ理解すればテキストエディタなどで編集してしまうことはできますが、エンドポイントキー部分の復号化・暗号化が必要だったりして面倒です。 Bot Framework Emulator には、.bot ファイルの内容を GUI で編集する機能が付いているのでこの機能を使うのがよいでしょう。</description></item><item><title>チャットボット: LUIS や QnA Maker サービスへの接続情報を .bot ファイルから取得する</title><link>https://maku.blog/p/o2bqajv/</link><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2bqajv/</guid><description>参考: MS Bot Framework の .bot ファイルで接続情報を管理する ここで作るもの こちらの実装 では、最初のステップとしてボットサーバ自体 (Azure Web Apps) のエンドポイント情報を .bot ファイルから取得する実装を行いました (config.js)。 ここでは、さらに、LUIS サービスや QnA Maker サービスを利用することを想定し、これらの情報も .bot ファイルから取得できるように拡張します。
使用イメージとしては、下記のようにしてそれぞれの接続情報を簡単に読み込めるようにします。
const config = require(&amp;#39;./config.js&amp;#39;); const LUIS_APP_NAME = &amp;#39;maku-luis-sample&amp;#39;; const QNA_APP_NAME = &amp;#39;maku-qna-sample&amp;#39;; const botEndpoint = config.loadBotEndpoint(); // ボット自体への接続情報 const luisEndpoint = config.loadLuisEndpoint(LUIS_APP_NAME); // LUIS への接続情報 const qnaEndpoint = config.loadQnaEndpoint(QNA_APP_NAME); // QnA Maker への接続情報 単一のオブジェクトとしてまとめて取得するように実装することもできるのですが、分かりやすさのために、3 つの情報に分けて取得するようにしています。 LUIS や QnA Maker は、複数のアプリ（ナレッジベース）を同時に使用する可能性があるので、アプリ名を指定して接続情報を取得できるようにしています。
取得した情報は、次のように BotBuilder SDK が提供するクラスへの入力として使用することを想定しています。</description></item><item><title>チャットボット: 作成したチャットボットを LINE に接続する</title><link>https://maku.blog/p/asuzg7k/</link><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/asuzg7k/</guid><description>LINE に Messaging API チャネルを作成する 自作したチャットボットアプリを LINE から「友だち」として見えるようにするには、まず LINE 側に「プロバイダー」を作成し、そこに「Messaging API チャネル」を追加する必要があります。 この Messaging API チャネルは、LINE アプリから「友だち」として見える単位だと考えればよいでしょう。
LINE に開発者として登録する LINE のプロバイダー登録作業などは、下記の LINE Developer Console から行うことができます。 初めてアクセスする場合は、開発者としての登録を求められるので、LINE アカウントでログインして開発者情報を入力してください。
LINE Developer Console プロバイダーを新規作成する LINE に開発者登録できたら、新規プロバイダー作成 のボタンを押して、プロバイダーを作成します。
Messaging API チャネルを追加する プロバイダーの作成が終わったら、そこに Messaging API チャネル を追加します。
チャネルの作成時には、アプリアイコンやアプリ名を自由に登録することができます。 アプリ名は一度設定すると 7 日間は変更できないようなので慎重に決めましょう（アイコンは 1 時間経てば変更できます）。
下のように、プロバイダー上に Messaging API チャネルが追加されていれば OK です。
スマホの LINE に友達登録する Messaging API のチャネルを選択し、チャネル基本設定 タブを見ると、LINE アプリ用の QR コードが見つかります。</description></item><item><title>チャットボット: 作成したチャットボットを Slack に接続する</title><link>https://maku.blog/p/rtxqceq/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rtxqceq/</guid><description>Slack に Bot Framework で作成したボットを接続する 図: ボットとのダイレクトメッセージによる会話 Microsoft Azure 上に作成したボットアプリを Slack に接続するには、下記の Bot Service 公式ドキュメントで説明されている手順に従ってください。
（日本語）ボットを Slack に接続する - Bot Service ｜ Microsoft Docs （英語）Connect a bot to Slack - Bot Service ｜ Microsoft Docs 接続のおおまかな手順は下記のような感じです。
Slack アプリを作成する（何らかのワークスペースに所属させる形で作成する） Slack アプリにボット用のユーザーを登録する Azure ポータルから、Web アプリボットのチャンネルとして Slack を追加（Slack アプリ側の Client ID、Client Secret、Verification Token をコピペすれば OK） この作業が終わると、ボット（アプリ）が Slack のワークスペースに参加している状態になります。 その時点ではどのチャンネルにも参加していませんが、ダイレクトメッセージを使って一対一でボットと会話することができます。
特定のチャンネルで会話している最中に @ボット名 と話かけると、そのチャンネルにボットを招待することができます。 チャンネルにボットが参加すると、後はそのチャンネルに対してつぶやくだけでボットが反応するようになります。
わかりにくいところの補足 図入りで説明されているので、特に迷うことはないと思いますが、Microsoft の Bot チームのドキュメント通りにはうまくいかない部分があるので若干補足しておきます。</description></item><item><title>チャットボット: Chatdown（.chat ファイル）を使ってボットの会話をデザインする</title><link>https://maku.blog/p/a6yzskr/</link><pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a6yzskr/</guid><description>Chatdown フォーマットとは Chatdown フォーマットは、会話の設計をテキストベースで行うことを意図したフォーマットです。 拡張子は .chat で、下記のような感じで会話例を記述していきます。
sample.chat user=Joe bot=LulaBot bot: Hi! user: yo! bot: [Typing][Delay=3000] Greetings! What would you like to do? * update - You can update your account * List - You can list your data * help - you can get help user: I need the bot framework logo. 上記のように、チャットボットがタイプ中であることや、応答までのディレイなどもデザインすることができます。 Markdown 形式で書式設定できるようになっているのが Chatdown という名前の由来ですね。
Bot Framework Emulator で会話を再現する Bot Framework Emulator で会話ファイルを読み込むと、チャット UI 上で会話を再現することができます。 ただし、Emulator が読み込むことのできるファイルは .</description></item><item><title>チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する</title><link>https://maku.blog/p/mgujykj/</link><pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mgujykj/</guid><description>Bot Builder SDK (Node.js) の botbuilder-core パッケージには、ActivityHandler という、ボットのイベントハンドラ部分の実装を簡略化するためのライブラリが含まれています。 ボットの世界では、「Activity」はひとつのメッセージの処理単位のことを示しています。 この Activity をうまくハンドルするためのクラスだから ActivityHandler という名前が付けられているんですね。
ここでは、独自のボットクラス (MyBot) を、ActivityHandler を利用せずに実装した場合と、利用して実装した場合で比較してみたいと思います。
ActivityHandler を使わない場合 例えば、下記のように BotFrameworkAdapter で受信したイベントの処理を MyBot.onTurn() に委譲するとします。
mybot.js const myBot = new MyBot(); const adapter = new BotFrameworkAdapter({}); const server = require(&amp;#39;restify&amp;#39;).createServer(); server.post(&amp;#39;/api/messages&amp;#39;, (req, res) =&amp;gt; { adapter.processActivity(req, res, async (context) =&amp;gt; { await myBot.onTurn(context); // あとは MyBot に丸投げ }); }); このイベントは、ユーザからメッセージを送られたときだけでなく、ユーザがチャットに参加したとき (ConversationUpdate) などにも発生するため、MyBot.onTurn() の実装の中でアクティビティタイプを見て分岐処理を行わなければなりません。
class MyBot { constructor() { // .</description></item><item><title>チャットボット: ユーザーの参加／離脱のイベントをハンドルする</title><link>https://maku.blog/p/onctywi/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/onctywi/</guid><description>Bot Builder SDK の ActivityHandler を使って、ユーザーが会話に参加したこと、離脱したことをハンドルする方法を説明します。 ActivityHandler を使ったボット実装の基本に関しては下記を参照してください。
チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する 下記は、ユーザーが新しく会話に参加したときに、ボットから挨拶するように実装した例です。 ユーザー参加のイベントをハンドルするには、ActivityHandler#onMembersAdded() で、イベントハンドラを登録します。
mybot.js const { ActivityHandler, BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); // ボット実装 class MyBot extends ActivityHandler { constructor() { super(); this.onMessage(this.handleMessage); this.onMembersAdded(this.handleMembersAdded); } async handleMessage(context, next) { const name = context.activity.from.name; const utterance = context.activity.text; await context.sendActivity(`${name}さんは、${utterance}と言いました。`); await next(); } async handleMembersAdded(context, next) { const members = context.activity.membersAdded; for (let i = 0; i &amp;lt; members.length; ++i) { const m = members[i]; if (m.</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (Storage)</title><link>https://maku.blog/p/3fnyk44/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3fnyk44/</guid><description>ボットは基本的にステートレスで動作するので、ユーザとの会話のコンテキストを把握するには、ステートの管理を明示的に行う必要があります。 Bot Builder SDK にはそのためのユーティリティクラスが用意されています。 ここでは、Node.js の botbuilder パッケージを使って説明します。
Storage インタフェース botbuilder パッケージに含まれている Storage インタフェースは、抽象化されたストレージに JSON オブジェクトを保存するための API を定義しています。 write、read、delete の 3 つの API のみなのでとてもシンプルです。
write メソッド JSON オブジェクトをストレージに保存するための API です。 オブジェクトを保存するときには、名前（キー）を付けて、キー＆バリューの形のオブジェクトとして保存します。 下記の例では、保存したい state オブジェクトに、botState という名前を付けて保存しています。
state.topic = &amp;#39;someTopic&amp;#39;; await storage.write({ &amp;#39;botState&amp;#39;: state }); read メソッド ストレージに保存されたオブジェクトを読み出すための API です。 読み出したいオブジェクトの名前を配列で渡すと、オブジェクトの連想配列が返ってきます。 下記の例では、botState という名前で保存されたオブジェクトを、state 変数に取り出しています。
const items = await storage.read([&amp;#39;botState&amp;#39;]); const state = items[&amp;#39;botState&amp;#39;] || {}; delete メソッド ストレージに保存されたオブジェクトを削除するための API です。 削除したいオブジェクトの名前を配列で渡します。</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (BotState)</title><link>https://maku.blog/p/6wtzzq4/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6wtzzq4/</guid><description>BotState クラス Bot Builder SDK の BotState クラス は、ボットとの会話内の特定のコンテキストにおける状態を保持するためのクラスです。
というと難しいですが、簡単に言うと、会話ごとの状態保存や、ユーザーごとの状態保存を行うための便利クラスです。
BotState クラスには次のようなサブクラスが定義されています。
ConversationState クラス &amp;hellip; 会話ごとの状態を保存する UserState クラス &amp;hellip; ユーザーごとの状態を保存する PrivateConversationState クラス &amp;hellip; 会話ごとのユーザごとの状態を保存する これらのクラスは、内部で Storage オブジェクトを利用します。
≪生成コード&amp;#x1F4D6;≫ Storage がグローバルに状態保存を行っていたのに対し、BotState はネームスペースを考慮して状態保存を行うものだと考えることができます。 実際に、ConversationState クラスや UserState クラスの実装を覗いてみると、getStorageKey() というメソッドでストレージ用の保存キーを作成しており、それぞれ次のように構成しています。
ConversationState が使用する保存キー ${ channelId }/conversations/${ conversationId }/${ this.namespace } UserState が使用する保存キー ${ channelId }/users/${ userId }/${ this.namespace } PrivateConversationState が使用するキー ${ channelId }/conversations/${ conversationId }/users/${ userId }/${ this.</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (1) ダイアログの基本</title><link>https://maku.blog/p/w36evii/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w36evii/</guid><description>Dialog を使わない会話管理 Bot Builder SDK の UserState や ConversationState を使う と、ユーザーや会話ごとの状態管理を行うことできるため、複数回のやりとりが必要な会話を実現することができます。
例えば、下記のような会話ができるボットを実装してみます。
User: こんにちは Bot: あなたの名前は？ User: まく Bot: こんにちは まく さん User: おやすみなさい Bot: また来てね まく さん 次のボット実装は、UserState クラスを使って、pos という名前のプロパティを作成し、会話がどこまで進んでいるかを管理しています。
mybot.js const { ActivityHandler, UserState } = require(&amp;#39;botbuilder&amp;#39;); class MyBot extends ActivityHandler { constructor(storage) { super(); this._createStateObjects(storage); this.onMessage(async (context, next) =&amp;gt; { const prop = await this.nameProp.get(context, { pos: &amp;#39;init&amp;#39; }); // プロパティの &amp;#39;pos&amp;#39; により処理を分岐させる if (prop.pos === &amp;#39;init&amp;#39;) { prop.</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (2) スタック管理</title><link>https://maku.blog/p/6arjar6/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6arjar6/</guid><description>ダイアログの基本 で説明したように、Dialog クラスを使用した会話フローでは、ユーザーからメッセージを受け取るたびに DialogContext#continueDialog() を呼び出すことで、1 ステップずつ処理を進めていきます。 ダイアログには、スタック構造で会話を管理する仕組みがあり、次のようなメソッドを使って、ダイアログの起動（スタックに積む）、ダイアログの終了（スタックから降ろす）という操作を行うことが可能です。
DialogContext#beginDialog(&amp;quot;ID&amp;quot;) &amp;hellip; ダイアログを開始する（スタックに積む） DialogContext#endDialog() &amp;hellip; アクティブなダイアログを終了する（スタックから降ろす） DialogContext#replaceDialog(&amp;quot;ID&amp;quot;) &amp;hellip; アクティブなダイアログを別のダイアログに置き換える（スタックの一番上を入れ替え） DialogContext#cancelAllDialog() &amp;hellip; すべてのダイアログを終了する（スタックをクリア） ここでは、RootDialog と GreetDialog という名前の 2 つのダイアログクラス作成し、RootDialog から GreetDialog を起動してダイアログのスタックを積むような実装を行ってみます。
図: ダイアログ遷移のイメージ 下記は、実際のチャットクライアントの表示例です。 右側のバーで示すように、 最初に RootDialog による選択肢が表示され、次に GreetDialog の処理に遷移し、最後に RootDialog に戻ってくるという流れです。
図: チャットのイメージ 下記は、最初に起動される RootDialog クラスの実装です。 前回の説明 で使用した DialogBot クラスを使って RootDialog を起動することを想定しています。 ウォーターフォールダイアログの最初のステップ (_step1) として、ユーザーに選択肢を提示し、「挨拶する」を選んだ場合に、GreetDialog を新たに起動するようにしています。
dialogs/rootDialog.js const { ChoiceFactory, ChoicePrompt, ComponentDialog, ListStyle, WaterfallDialog, } = require(&amp;#39;botbuilder-dialogs&amp;#39;); const { GreetDialog } = require(&amp;#39;.</description></item><item><title>チャットボット: Bot Builder SDK で画像やリストなどのリッチなメッセージを送る (MessageFactory)</title><link>https://maku.blog/p/q7vw95i/</link><pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7vw95i/</guid><description>Activity オブジェクトと MessageFactory Bot Builder SDK によるボット実装において、ユーザーにメッセージを送るには TurnContext クラス の sendActivity() メソッドを使用します。 下記は、単純なテキストメッセージを送る例です。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); sendActivity() の第一引数には、このように文字列を渡すことができますが、その名の通り Activity オブジェクトを渡すこともできるようになっています。 Activity オブジェクトを使うと、単純なテキストよりもリッチな形式で表示を行うことができます（どう表示されるかは各チャンネルの実装によりますが）。
Activity インタフェースは botframework-schema モジュール で定義されていますが、このインタフェースを意識してオブジェクトを作成することはあまりありません。 というのも、いろいろな用途の Activity オブジェクトを生成するためのファクトリーである MessageFactory クラス が用意されているからです。
例えば、MessageFactory#text() は単純なテキストメッセージを送るための Activity オブジェクトを生成します。
// const { MessageFactory } = require(&amp;#39;botbuilder&amp;#39;); const msg = MessageFactory.text(&amp;#39;Hello!&amp;#39;); await context.sendActivity(msg); これは実は下記のようにするのと同じです。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); TurnContext#sendActivity() に直接文字列を渡した場合は、内部で前者のような MessageFactory.text() による Activity 生成が行われています。 単純なテキストを送るだけであれば、sendActivity('Hello') としてしまうのが早いでしょう。
MessageFactory でリッチなメッセージを作成する MessageFactory が提供するファクトリメソッドを使って、リッチなメッセージを送る例をいくつか紹介します。 ここでは、Bot Framework Emulator の表示例を載せておきます。</description></item><item><title>チャットボット: 独自のミドルウェアを作成してログを記録する</title><link>https://maku.blog/p/fn3amda/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fn3amda/</guid><description>ミドルウェアとは Bot Framework において、クライアントから受信したメッセージはアダプターを介してボットに届けられますが、アダプターにミドルウェアを設定しておくことで、メッセージがボットに届く前に割り込んで処理を行うことができます。
Adapter → Middleware1 → Middleware2 → Middleware3 → ... → YourBot ミドルウェアは上記のように複数登録することができ、登録された順に呼び出されていきます。 アダプターにミドルウェアを追加するには、BotFrameworkAdapter#use() メソッドを使用します。
ミドルウェアの追加 const { BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); const adpater = new BotFrameworkAdapter(endpoint); adapter.use(new Middleware1()); adapter.use(new Middleware2()); adapter.use(new Middleware3()); ミドルウェアを実装する 独自のミドルウェアを作成するには、Middleware インタフェース が提供する onTurn メソッドを実装します。
ここでは、ユーザーの入力をコンソールに出力するだけの ConsoleLogger というミドルウェアクラスを実装してみます。
middlewares/consoleLogger.js exports.ConsoleLogger = class ConsoleLogger { async onTurn(context, next) { if (context.activity.type === &amp;#34;message&amp;#34;) { console.log(context.activity.text); } await next(); // Invoke a next middleware } }; とても簡単ですね。 あと、onTurn() を抜ける前に忘れずに next() を呼び出して、後続のミドルウェアが正しく呼び出されるようにしておく必要があります。</description></item><item><title>チャットボット: 独自のミドルウェアを作成して禁止ワードを拒否するようにする</title><link>https://maku.blog/p/gt9g2na/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gt9g2na/</guid><description>前回の記事 では、チャットボットに独自のミドルウェアを追加して、ユーザー入力をログ出力できるようにしました。 今回は、ユーザーが NG ワードを入力したときに、警告を表示して処理を中断するようなミドルウェアを作成してみます。
その名も NgWordMiddleware です！
middlewares/NgWordMiddleware.js const NG_WORDS = /アホ|まぬけ|バカ/; exports.NgWordMiddleware = class NgWordMiddleware { async onTurn(context, next) { if (context.activity.type === &amp;#39;message&amp;#39;) { const line = context.activity.text; if (NG_WORDS.test(line)) { await context.sendActivity(&amp;#39;そんなこと言っちゃダメ&amp;#39;); return; } } await next(); // Invoke a next middleware } }; 上記の例では、NG_WORDS 定数に、禁止語句を正規表現の形で登録しています。 ユーザーが入力したテキストに、禁止語句が含まれていたら、「そんなこと言っちゃダメ」と返事して処理を進めないようにします（next() を呼び出さないことで後続の処理を打ち切る）。
このミドルウェアは、下記のようにアダプターに追加することで有効化できます。
// const { NgWordMiddleware } = require(&amp;#39;./middlewares/ngWordMiddleware.js&amp;#39;); const adapter = new BotFrameworkAdapter(botEndpoint); adapter.use(new NgWordMiddleware()); この例では、単純に禁止語句が含まれているかだけをチェックしているので、「バカルディ」と入力した場合にも弾かれてしまいます。 このあたりは工夫して処理しなきゃですね。</description></item><item><title>Bot Framework: Web チャットの表示をカスタマイズする</title><link>https://maku.blog/p/oitn3a3/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oitn3a3/</guid><description>Microsoft Bot Framework を使ってウェブサイト上にチャットボットを配置したときの表示のカスタマイズ方法です。 次のように、ボットやユーザーのアイコンを設定することができます。
このようなカスタマイズ表示を行うには、Azure portal 上の Web App Bot リソースの Channels タブから選択できる、Direct Line チャネルを使う必要があります。 Web Chat というチャネルを使うと、iframe タグで簡単にチャットウィンドウを埋め込むことができるのですが、そちらではあまりカスタマイズができないようです。
図: Direct Line チャネルのキーを確認 下記はチャットウィンドウをカスタマイズして表示するサンプルコードです。 Bot Framework が提供している WebChat.renderWebChat() 関数を呼び出すと、実際にチャットウィンドウが表示されるのですが、このときに styleOptions パラメータを指定することで表示方法をカスタマイズすることができます。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.botframework.com/botframework-webchat/latest/webchat.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; * { margin: 0; } #webchat { height: 100vh; width: 100vw; background: gray; border: solid 5px #f37; box-sizing: border-box; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;webchat&amp;#34; role=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const TOKEN = &amp;#39;HpJB2ofxzsA.</description></item></channel></rss>