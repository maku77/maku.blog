<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android プログラミングのメモ on まくろぐ</title><link>https://maku.blog/p/5398aih/</link><description>Recent content in Android プログラミングのメモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 25 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/5398aih/index.xml" rel="self" type="application/rss+xml"/><item><title>Android アプリのテンプレートコード（空っぽのフラグメント）</title><link>https://maku.blog/p/vdnv5dm/</link><pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vdnv5dm/</guid><description>Android のアプリを作るときは、大体まっさらな Activity + Fragment の組み合わせで作り始めるんですが、そのようなクリーンなテンプレートコード（土台）を作るのが意外と大変だったりするので、ここにメモしておきます。
図: 空っぽの Android アプリ 下記は、Android TV アプリ用のテンプレートです。
maku77/Template-AndroidTv: Template of Android TV App 主なコードを抜粋。
app/src/main/java/com/example/myapp/MainActivity.kt package com.example.myapp import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import androidx.fragment.app.commit // androidx.fragment:fragment-ktx class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) showMainFragment() } private fun showMainFragment() { supportFragmentManager.commit { add(R.id.fragment_container, MainFragment.newInstance()) //addToBackStack(null) // 戻るキー用にスタック } } } app/src/main/java/com/example/myapp/MainFragment.kt package com.example.myapp import androidx.fragment.app.Fragment class MainFragment : Fragment(R.layout.fragment_main) { companion object { fun newInstance() = MainFragment() } } app/src/main/AndroidManifest.</description></item><item><title>Android開発: ContraintLayout で配置されたビューの実際のサイズを取得する</title><link>https://maku.blog/p/khqpnjf/</link><pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/khqpnjf/</guid><description>ConstraintLayout で配置したビューは、周囲のビューとの位置関係で位置やサイズなどが決まるため、実際に内部的なレイアウトが終了するまでは、ビューのサイズ情報などが取得できなかったりします（0 になります）。
View.doOnLayout() などで、レイアウト完了するのを待ってからサイズを取得すればうまくいきます。 これは、TransitionManager などでレイアウトを切り替えた直後なども同様です。
// レイアウト変更＆アニメーション開始 TransitionManager.beginDelayedTransition(constraintLayout) constraintSet.applyTo(constraintLayout) // この直後にレイアウト情報取得してもうまく取得できない val w = myView.width val h = myView.height myView.doOnLayout { // このタイミングであればうまく取得できる val w = it.width val h = it.height }</description></item><item><title>Android開発: ダイアログ表示時の背景の暗転（ディミング）を防ぐ</title><link>https://maku.blog/p/voanw2h/</link><pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/voanw2h/</guid><description>Android でダイアログを表示するときに DialogFragment クラスなどを使用すると、デフォルトではダイアログの後ろは暗くなって、下の UI がうっすらと見える状態になります。 このような効果を抑制して、背景が明るいままにするには、ウィンドウから FLAG_DIM_BEHIND フラグをクリアします。
class MyDialogFragment : DialogFragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // ダイアログの中身を独自レイアウトにする return inflater.inflate(R.layout.my_dialog, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) disableBackgroundDimming() } /** ダイアログの背景が暗くなるのを防ぐ */ private fun disableBackgroundDimming() { dialog?.window?.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND) } }</description></item><item><title>Androidメモ: RecyclerView にアニメーションを追加する方法</title><link>https://maku.blog/p/8avcr5h/</link><pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8avcr5h/</guid><description>Android の RecyclerView にリスト表示する各要素を、左や右からスライドインさせながら表示する方法を説明します。
RecyclerView へのアニメーション追加方法 RecyclerView の各要素をアニメーションさせるには、下記のような方法があります。
カスタム ItemAnimator を作成してセットする方法 LayoutAnimation をセットする方法（RecyclerView だけでなく、すべての ViewGroup に適用できます） 1 の方法を使うと、アイテムの追加・削除に応じたアニメ―ションを定義できるので、柔軟なカスタマイズが可能になりますが、2 の方法であれば、アニメーションの定義だけを行えばよいので簡単です。 ここでは、シンプルな 2 の方法を説明します。
アニメーションの定義は、XML 形式のリソースファイルで行います。 ディレクトリ名やファイル名は任意ですが、通常は res/anim/xxx.xml のような名前にし、コードの中から R.anim.xxx と参照できるようにします。
要素を左からスライドインさせる 下記の res/anim/slide_from_left.xml リソースでは、画面内の要素をどのように表示するかを定義しています。
res/anim/slide_from_left.xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layoutAnimation xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; android:animation=&amp;#34;@android:anim/slide_in_left&amp;#34; android:delay=&amp;#34;10%&amp;#34; android:animationOrder=&amp;#34;normal&amp;#34; /&amp;gt; 各属性の説明です。
android:animation=&amp;quot;@android:anim/slide_in_left&amp;quot; 個々の要素がどのようにアニメーションするかを指定します。ここでは、Android にあらかじめ定義されている slide_in_left を指定しています。 android:delay=&amp;quot;10%&amp;quot; 1 つ前の要素のアニメーションが何％まで完了してから、次の要素のアニメーションを開始するかを指定します。100% と指定すると、各要素のアニメーションが完全に終了してから次の要素のアニメーションが開始されるため、すべての要素が表示されるまでに非常に時間がかかります。 android:animationOrder=&amp;quot;normal&amp;quot; 要素がどのような順番で表示されていくかを指定します。normal、reverse、random などを指定できます。 ここでは、個々の要素のアニメーション方法として、Android 付属の @android:anim/slide_in_left を使っていますが、これは次のように定義されています。
@android/anim/slide_in_left（抜粋） &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;set xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; &amp;lt;translate android:fromXDelta=&amp;#34;-50%p&amp;#34; android:toXDelta=&amp;#34;0&amp;#34; android:duration=&amp;#34;@android:integer/config_mediumAnimTime&amp;#34;/&amp;gt; &amp;lt;alpha android:fromAlpha=&amp;#34;0.</description></item><item><title>Android開発: ShapeDrawable で基本図形を描く</title><link>https://maku.blog/p/qj8p3eq/</link><pubDate>Sun, 03 Aug 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qj8p3eq/</guid><description>矩形の描画 private ShapeDrawable mDrawable = new ShapeDrawable(); private void draw(Canvas canvas) { mDrawable.setBounds(100, 100, 200, 200); mDrawable.getPaint().setColor(Color.YELLOW); mDrawable.draw(canvas); } 円、楕円の描画 private ShapeDrawable mDrawable = new ShapeDrawable(new OvalShape()); private void draw(Canvas canvas) { mDrawable.setBounds(100, 100, 200, 200); mDrawable.getPaint().setColor(Color.YELLOW); mDrawable.draw(canvas); }</description></item><item><title>Android開発: TextureView に関するメモ</title><link>https://maku.blog/p/2udtaq5/</link><pubDate>Thu, 24 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2udtaq5/</guid><description> 少ない数の Canvas#drawRect() や Canvas#drawText() をするなら、SurfaceView よりも描画が速い。ある程度たくさん描画すると、SurfaceView に負ける。さらにたくさん描画すると同じくらいになる。 ベンチマークを Xperia Tablet Z で取ると次のような感じ。 Rect(x100),Text(x100): SurfaceView 60fps, TextureView 80fps Rect(x500),Text(x500): SurfaceView 32fps, TextureView 27fps Rect(x1000),Text(x1000); SurfaceView 15fps, TextureView 15fps lockCanvas() ～ unlockCanvasAndPost() の中では毎回全体を描き直す必要がある。前回の描画情報が保持されることが保証されないため（TextureView#lockCanvas() の Javadoc を参照）。 SurfaceTextureListener#onSurfaceTextureDestroyed() は通常 return true するように実装する。 画面回転すると強制終了したりする（SurfaceView のときは大丈夫だった）。</description></item><item><title>Android開発: Handler.post した Runnable タスクがメインスレッドで実行される仕組み</title><link>https://maku.blog/p/9ne93oc/</link><pubDate>Mon, 08 Aug 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9ne93oc/</guid><description>Android プログラムで UI 操作を行う場合は、その処理はアプリのメインスレッドから行わなければいけません（Android に限らずほとんどの OS で同じような感じです）。 Activity の onCreate メソッドなどを呼び出しているのがそのアプリのメインスレッドであり、Android ではイコール UI スレッドです。 タイマー処理などで、UI を更新する場合はこのメインスレッドから行う必要があり、新しく立ち上げた別のスレッドから UI を更新することはできません。
このようなケースで利用できるのが android.os.Handler クラスです。 Handler#post メソッドに Runnable オブジェクトを渡すと、最終的にその Handler オブジェクトを生成したスレッドで Runnable オブジェクトの run メソッドが実行されるようになっています。 つまり、Handler オブジェクトを Application のメインスレッドから（例えば Activity のフィールドとして）生成しておけば、そこに post した Runnable タスクは、メインスレッドで実行されることが保証されます。
Handler#post メソッドは、内部的にはスレッドローカルな Looper に結び付けられた MessageQueue オブジェクトに処理をキューイングしています。 Handler オブジェクトをメインスレッドから生成すれば、メインスレッド上の MessageQueue と結び付けられ、その MessageQueue が Looper によってメインスレッド上で処理されるという流れになっています。
別の言い方をすれば、メインスレッドの MessageQueue に対して、Runnable タスクを投入するためのインタフェースとなるのが Handler オブジェクトというわけです。</description></item><item><title>Android開発: LowMemoryKiller の動きのメモ</title><link>https://maku.blog/p/7s4vnax/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7s4vnax/</guid><description>Android の lowmemorykiller では、最もメモリを使っていて、oom_adj の値が大きいものが殺されます。
oom_adj の値は、/proc/&amp;lt;Process ID&amp;gt;/oom_adj に書かれた値です。 本来は Linux の oom (Out of memory) killer が使うファイルですが、Android の lowmemorykiller もこのファイルを使っています。
oom_adj の値は -16～15 をとり、小さいほど殺されにくくなります。デフォルトは 0 です。 ただし、oom_adj に OOM_DISABLE (-17) を設定すると、lowmemorykiller の対象外になるようです。
oom_adj の値を確認したり、強引に変更したい場合はこんな感じ。
# cat /proc/1234/oom_adj 0 # echo -16 &amp;gt; /proc/1234/oom_adj</description></item><item><title>Android開発: レイアウトの種類まとめ</title><link>https://maku.blog/p/64zojt6/</link><pubDate>Mon, 10 Jan 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/64zojt6/</guid><description> FrameLayout ウィジェットを左上に１つだけ配置する。 FrameLayout の中で複数の View を配置した場合は、最後に表示したものが上に重ねて表示される。 LinearLayout 水平か、垂直に一直線にウィジェットを並べる。 水平: android:orientation=&amp;quot;horizontal&amp;quot; 垂直: android:orientation=&amp;quot;vertical&amp;quot; ConstraintLayout フラットなビュー階層を持つ大きくて複雑なレイアウトを作成する。 RelativeLayout より柔軟。 LinearLayout を組み合わせてレイアウトを入れ子構造にするとパフォーマンスが悪くなるが、ConstraintLayout ひとつでフラットにビューを配置すると効率的な描画が可能。 TableLayout HTML の TABLE 要素のようにウィジェットを並べる。 RelativeLayout 他のウィジェットとの相対的な位置関係で配置する。 参照されるウィジェットは、参照するウィジェットよりも先に定義されていなければならない。 AbsoluteLayout（非推奨） 絶対座標でウィジェットを配置する。 それぞれの Layout を入れ子にして、その中にウィジェットを配置していくことで複雑なレイアウトを作成することができます。
&amp;lt;LinearLayout ...&amp;gt; &amp;lt;LinearLayout ...&amp;gt; ... &amp;lt;/LinearLayout&amp;gt; &amp;lt;LinearLayout ...&amp;gt; ... &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt;</description></item><item><title>Android開発: 3種類のタイムスタンプの使い分け</title><link>https://maku.blog/p/sfvqxtr/</link><pubDate>Tue, 09 Nov 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sfvqxtr/</guid><description>Android において long 型のタイムスタンプを取得する方法には、以下の 3 種類があり、それぞれ意味が異なるため、用途に応じて使い分ける必要があります。
System. currentTimeMillis() Epoch (1970-01-01) を基準にしたシステムタイムまでの経過ミリ秒。 ユーザがシステムの現在時刻を変更すると、過去にジャンプしたりするので、タイムスタンプベースのタイマーなどに使用するべきではない。時計の UI を表示するときに使用する。 android.os.SystemClock. elapsedRealtime() Android 端末をブートしてからの経過ミリ秒。uptimeMillis() とは異なり、スリープ中にもカウントされる。 AlarmManager はスリープ中の時間もカウントして発火するので、内部で elapsedRealtime() ベースのタイマを使用する。これは、AlarmManager のタイプで ELAPSED_REALTIME (ELAPSED_REALTIME_WAKEUP) を指定した場合の振る舞いで、RTC (RTC_WAKEUP) を指定すれば、System.currentTimeMillis() ベースのタイマで発火するように指定することもできる。 android.os.SystemClock. uptimeMillis() Android 端末をブートしてからの経過ミリ秒。スリープ中にはカウントされない。 タイムスタンプベースのタイマーに使用できる。例えば Handler クラスは、uptimeMillis() ベースのタイマを使用して非同期コールバックを発火している。 AlarmManager Handler.
postAtTime Handler.
sendMessageAtTime System.currentTimeMillis
UTC（システム時刻設定で変化） ○
RTC(_WAKEUP) × × SystemClock.elapsedRealtime
ブートからの経過時間（スリープ時間含む） ○
ELAPSED_REALTIME(_WAKEUP) × × SystemClock.uptimeMillis
ブートからの経過時間（スリープ時間含まず） ×
（スリープ時カウントできないため） ○ ○</description></item></channel></rss>