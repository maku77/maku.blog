<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScriptの環境/設定について on まくろぐ</title><link>https://maku.blog/p/tx6md39/</link><description>Recent content in TypeScriptの環境/設定について on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 02 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/tx6md39/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScriptの環境: tsconfig.json の基本</title><link>https://maku.blog/p/27m3brm/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/27m3brm/</guid><description>tsconfig.json があれば TypeScript プロジェクト tsconfig.json は TypeScript の設定ファイルであり、このファイルが置かれたディレクトリが TypeScript プロジェクトのルートディレクトリだとみなされます。 tsconfig.json の記述内容は空っぽ（{} の2文字）でも正しい設定ファイルであり、その場合は、すべてデフォルトの設定値で動作することになります。
TypeScript のトランスパイラである tsc コマンドを実行すると、カレントディレクトリにある tsconfig.json が読み込まれてトランスパイラの動作設定が行われます。 tsconfig.json が見つからない場合は、親ディレクトリを上りながらファイルを探します。 つまり、tsc コマンドは TypeScript のプロジェクト内であれば、どのディレクトリからでも実行できます。
変換対象とするファイルを指定する (files/include/exclude) 最も大切な設定は、TypeScript のトランスパイラがどのファイルを変換対象とみなすかの設定です。 入力ファイルの指定は、設定ファイルの最上位プロパティとして指定する files、include、exclude プロパティを使って行います。
ファイル名を 1 つずつ指定する (files) tsconfig.json { &amp;#34;files&amp;#34;: [ &amp;#34;index.ts&amp;#34;, &amp;#34;module1.ts&amp;#34;, &amp;#34;module2.ts&amp;#34; ] } files プロパティを使って、変換対象の TypeScript ファイルを 1 ファイルずつ指定することができます。
ファイル名のパターン（グロブ）で指定する (include) tsconfig.json { &amp;#34;includes&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;exclude&amp;#34;: [ &amp;#34;node_modules&amp;#34;, &amp;#34;**/*.spec.ts&amp;#34; ] } include プロパティを使用すると、ファイルグロブを使って変換対象とするファイルを指定できます。 ファイルグロブは、下記のようなワイルドカードを使ってファイル名をパターン指定する仕組みです。
** は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータも含みます） * は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータは含みません） ?</description></item><item><title>TypeScriptの環境: Visual Studio Code で TypeScript の開発環境を構築する</title><link>https://maku.blog/p/ak7u3h3/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ak7u3h3/</guid><description>はじめに TypeScript は Microsoft が開発している言語で、同じく Microsoft が開発している IDE である Visual Studio Code（以下 VS Code）が TypeScript コードの編集に適しています。
VS Code による TypeScript の開発環境を構築するには、下記をインストールする必要があります。
Visual Studio Code Node.js（npm コマンド） TypeScript（tsc コマンド) 開発環境をインストールする Visual Studio Code のインストール VS Code は下記からインストーラーをダウンロードしてインストールできます。
Download Visual Studio Code TypeScript のソースコード (.ts) ファイルは、単純なテキストエディタでも編集できますが、この VS Code を使って編集すると、プロパティ名の自動補完などができて効率的に開発を行えます。
コマンドラインから code と入力して、VS Code を起動できるようになれば OK です。 VS Code をインストールしたのに code コマンドが認識されない場合は、こちらの記事 を参考にしてパスを通してください。
Node.js のインストール TypeScript のトランスパイラである tsc コマンドは、Node.js のパッケージとして提供されているため、先に Node.js をインストールしておく必要があります。 Node.js は下記からインストーラーをダウンロードしてインストールできます。</description></item><item><title>TypeScript プロジェクトに ESLint を導入する</title><link>https://maku.blog/p/xz9iry9/</link><pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xz9iry9/</guid><description>ESLint とは ESLint は JavaScript/TypeScript 向けの Lint ツール（静的解析ツール）です。 プロジェクト内のソースコードに対して eslint コマンドを実行することで、コーディングルールに従っていない部分や、不具合の原因になりそうな部分を検出してくれます。
☝️ eslint vs tslint もともと TypeScript 用には tslint という Lint ツールが提供されていましたが、Microsoft の TypeScript チームが eslint への統合を 公式に発表 してから（2019年以降）は、TypeScript においても eslint が事実上の標準 Lint ツールとなっています。参考: TypeScript の ESLint 対応プロジェクト ESLint のインストール eslint コマンドは npm でインストールできます。 TypeScript プロジェクトのディレクトリ内で、次のように開発用にインストールすることが推奨されています（package.json は作成済みだと想定します）。
ESLint のインストール $ npm install eslint --save-dev ESLint の初期設定 eslint コマンドを実行するためには、設定ファイル .eslintrc.{js,yml,json} を作成しておく必要があります。
設定ファイルの生成 $ npx eslint --init 上記のように実行すると、ウィザード形式でどのような用途に使用するかを質問されるので、順番に答えていくだけで設定ファイルを生成できます。 最後にその構成に必要なモジュールをまとめてインストールできます。 ここでは、eslint v7.26.0 における表示例を示しています。</description></item><item><title>ESLint の設定ファイル (.eslintrc) の各プロパティの意味を理解する</title><link>https://maku.blog/p/j6iu7it/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6iu7it/</guid><description>何を説明するか 下記は、TypeScript を使った React アプリ実装用に用意した ESLint 設定ファイル (.eslint.yml) の例です。 トップレベルのプロパティとして、env や extends などがありますが、これらが何を意味しているかをざっと説明します。
.eslint.yml（例） root: true env: browser: true es2021: true parser: &amp;#39;@typescript-eslint/parser&amp;#39; parserOptions: ecmaVersion: 2021 project: ./tsconfig.json plugins: - react - react-hooks - &amp;#39;@typescript-eslint&amp;#39; extends: - eslint:recommended - plugin:react/recommended - plugin:react-hooks/recommended - plugin:@typescript-eslint/recommended - plugin:@typescript-eslint/recommended-requiring-type-checking rules: react/react-in-jsx-scope: off 各プロパティの説明 root: true ESLint は、実行時のカレントディレクトリを起点にして、上位のディレクトリの設定ファイル (.eslintrc.*) を探していきます。 root: true の指定があると、この検索の振る舞いをそこで停止できます。 プロジェクトのトップディレクトリに置く .eslintrc.* には、この指定をしておくとよいです。
env: 実行環境の指示 どのようなグローバルオブジェクトを宣言なしで参照可能にするかを ESLint に知らせるための設定です。 例えば、Web ブラウザ上で動作させる JavaScript コードであれば browser、Node.</description></item><item><title>ESLint + Prettier の設定方法まとめ</title><link>https://maku.blog/p/yfow6dk/</link><pubDate>Sun, 23 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yfow6dk/</guid><description>ここでは、とにかく混乱しがちな ESLint + Prettier の設定方法をまとめておきます。 まず、基本的な構成として、TypeScript (with React) の Lint をかけられるようにして、必要に応じて Airbnb スタイル を追加で設定する、という流れにしたいと思います。
TypeScript プロジェクトの準備 前提条件として、TypeScript (+ React) のプロジェクト自体は作成済みとします。 何も準備できていなければ、Next.js の create-next-app コマンドを使うと簡単に作成できます（typescript および @types/node、@types/react、@types/react-dom などの型情報が導入された状態のプロジェクトが作成されます）。
2 つやり方あるけど、大体中身は同じ # テンプレートを使う方法 $ create-next-app myapp --example with-typescript # typescript オプションを使う方法 $ create-next-app myapp --typescript 参考 Next.js で HelloWorld（プロジェクト作成からサーバー起動まで） Next.js のプロジェクトを TypeScript 化する Prettier + ESLint の基本設定 (for TypeScript with React) 必要なパッケージのインストール # Prettier 本体 $ yarn add --dev --exact prettier # ESLint 本体 $ yarn add --dev eslint # ESLint 用のプラグインおよび共有設定 $ yarn add --dev @typescript-eslint/eslint-plugin $ yarn add --dev @typescript-eslint/parser $ yarn add --dev eslint-plugin-react $ yarn add --dev eslint-plugin-react-hooks $ yarn add --dev eslint-config-prettier # npm スクリプトの並列実行用 $ yarn add --dev npm-run-all npm の場合 # Prettier 本体 $ npm install prettier --save-dev --save-exact # ESLint 本体 $ npm install eslint --save-dev # ESLint 用のプラグインおよび共有設定 $ npm install @typescript-eslint/eslint-plugin --save-dev $ npm install @typescript-eslint/parser --save-dev $ npm install eslint-plugin-react --save-dev $ npm install eslint-plugin-react-hooks --save-dev $ npm install eslint-config-prettier --save-dev # npm スクリプトの並列実行用 $ npm install npm-run-all --save-dev .</description></item><item><title>ESLint (4) ESLint の設定方法まとめ (for Next.js 11)</title><link>https://maku.blog/p/dexgg8o/</link><pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dexgg8o/</guid><description>Next.js 11 が ESLint を組み込みサポート Next.js 11 で ESLint を Next.js が組み込みでサポートしました。 これで、create-next-app で新規作成するアプリでは、ESLint に関してもゼロコンフィグで next eslint とするだけで実行できるようになります。
ただ、ESLint には色々な共有設定 (config) があるわけで、Next.js がデフォルトで設定してくれているもの以外（TypeScript や Prettier 関連）は自分で設定する必要があります。 ここでは、Next.js 11 がデフォルトで提供する .eslintrc にそれらの設定を追加します。
Next.js 11 デフォルトの ESLint 設定 Next.js 11 が生成する .eslintrc ファイルは次のようなシンプルなものです。
.eslintrc { &amp;#34;extends&amp;#34;: [&amp;#34;next&amp;#34;, &amp;#34;next/core-web-vitals&amp;#34;] } 問題はこれらがどのような共有設定を含んでいるかですが、eslint-config-next のコードを見ると、次のような感じになっています。
module.exports = { extends: [ &amp;#39;plugin:react/recommended&amp;#39;, &amp;#39;plugin:react-hooks/recommended&amp;#39;, &amp;#39;plugin:@next/next/recommended&amp;#39;, ], // ... } React 系の共有設定はここに含まれているので、&amp;quot;extends&amp;quot;: [&amp;quot;next&amp;quot;] だけでカバーできそうです。 公式ドキュメントの ESLint - Base Configuration にも同様の説明が書かれています。 逆に、TypeScript 関連や、Prettier 関連の共有設定は自分で追加しなければいけません。</description></item><item><title>Vite で複数の TypeScript ファイルやリソースファイルを 1 つの JavaScript ライブラリとしてバンドルする</title><link>https://maku.blog/p/59mfj7b/</link><pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/59mfj7b/</guid><description>何をするか 図: 複数の .ts/.css/.svg ファイルを 1 つの JavaScript ファイルに結合 Vite は TypeScript ビルドや、開発用サーバー、バンドリングなどの機能を備えた統合的なフロントエンド開発ツールです。 ここでは、Vite で複数の TypeScript ファイルを 1 つの JavaScript ファイルの形にビルドしてみます（この作業をバンドルと呼びます）。 用途としては、複数の Web サイトから &amp;lt;script&amp;gt; 要素で読み込み可能な JavaScript ライブラリを作成することを想定しています。 画像ファイルやスタイルシート (CSS) などのリソースファイルも、JavaScript に埋め込む形でバンドルできます。
Vite プロジェクトの作成 npm create コマンドを使って Vite のプロジェクトを作成します。 純粋な TypeScript ファイルをビルドするだけであれば、vanilla-ts というテンプレートを使用できます（--template オプションを指定せずにウィザード形式で選択することもできます）。
Vite プロジェクト (myscript) を生成する $ npm create vite@latest myscript -- --template vanilla-ts $ cd myscript 次のようなファイルが生成されます。
myscript/ +-- .gitignore +-- index.html # &amp;lt;script&amp;gt; 要素による表示の確認用 +-- package.json +-- tsconfig.</description></item><item><title>Jest で TypeScript コードのユニットテストを記述する</title><link>https://maku.blog/p/9xxpe4t/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9xxpe4t/</guid><description>Jest とは Jest は Facebook が公開した JavaScript 用のシンプルなテストフレームワークで、Node.js 環境で実行することができます。
Jest · 🃏 Delightful JavaScript Testing Jest は下記のような特徴を持っています。
ゼロコンフィグで使い始められる（設定ファイルなしで実行可能） テストを並列実行するので高速 コードカバレッジレポートの出力を標準搭載 わかりやすいマッチャー表現 (expect ～ toBe、toContain など、自然な文章として読める） TypeScript に対応（ts-jest を利用） Jest 用のテストコードは、次のようなコードジェネレーターでも採用されており、利用者は増え続けています（2022 年現在）。
create-react-app &amp;hellip; React アプリのジェネレーター cdk init app &amp;hellip; AWS のインフラ生成コードのジェネレーター Jest のインストール Jest 本体の jest モジュールをインストールします。 TypeScript を使用する場合は、Jest ライブラリの型情報である @types/jest と、Jest 用の TypeScript プロセッサ (ts-jest) もインストールする必要があります。 これらはすべてテスト時のみ使用する NPM モジュールなので、devDependencies としてインストールします。
Jest 本体と TypeScript 関連モジュールをインストール ### npm の場合 $ npm install --save-dev jest @types/jest ts-jest ### yarn の場合 $ yarn add --dev jest @types/jest ts-jest package.</description></item><item><title>TypeScript コードを Prettier で自動整形する</title><link>https://maku.blog/p/au8iu6u/</link><pubDate>Wed, 26 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/au8iu6u/</guid><description>Prettier とは？ Prettier は、TypeScript や JavaScript などのソースコードを自動フォーマットするためのツールです。 HTML や CSS など様々なファイルに対応していますが、主に TypeScript や JavaScript のフォーマッターとして使用されています。 実際にどのようにフォーマットされるかは、Playground のページ で試すことができます。
特徴と思想 Prettier の一番の特徴は、Opinionated（独断的な） コードフォーマッターであることを標榜していることです。 これは、ユーザーに自由なカスタマイズを許さず、「Prettier 自身が定義しているスタイルに強制的にフォーマットするよ」ということです（セミコロンの有無など最低限の設定はできます）。 これにより、コーディングスタイルに関する 不毛な議論を避ける ことができ、プロジェクト内のコーディングスタイルを簡単に統一することができます。
もちろん、自分がベストだと思っているスタイルでフォーマットすることはできなくなるかもしれませんが、そんな些細なことよりも、アプリケーション（成果物）を作り上げることに集中すべきだという考え方です。
Prettier がやらないこと Prettier はあくまでコードのフォーマットのみを行います。 コードの意味を解析して危険な部分（潜在的バグ）を検出してくれたりはしないので、そういったことを行いたい場合は、他の静的解析ツール（ESLint など）を使う必要があります。 ESLint にもコードフォーマット機能がありますが、フォーマッターとしては Prettier が優れており、「Prettier による整形 ＋ ESLint による静的解析」という形で組み合わせて使うのが一般的です。
あと、import 文のソートなど、一見やってくれてもよさそうなフォーマットもしてくれなかったりします。 これは、その import 順序がロジック的に意味を持っていたりする場合に、Prettier が判断できないからです。 このように、いろいろと想像と異なるフォーマット結果になることがありますが、そこにはちゃんと理由があります（参考: Rationale）。 あまり気にせずにそんなものだと考えるのがよいです。 ちなみに、ESLint の方には import 文のソートを行うプラグイン (eslint-plugin-import) があります。
Prettier をインストールする Prettier は npm で簡単にインストールすることができます。 TypeScript のプロジェクトは作成済み で、package.json がすでに存在すると想定します。
### yarn の場合 $ yarn add prettier --dev --exact ### npm の場合 $ npm install prettier --save-dev --save-exact Prettier は、パッチバージョンが上がるだけで、出力結果に微妙な差分が生まれる可能性があります。 そのため、インストール時のオプションとして --save-exact を指定することで、明確なバージョンを package.</description></item><item><title>webpack と TypeScript を組み合わせて使用する</title><link>https://maku.blog/p/ucnv6en/</link><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ucnv6en/</guid><description>はじめに TypeScript は JavaScript コードに型付けすることができる優れたトランスパイラですが、変換後の .js ファイル群をまとめる（バンドルする）機能は備えていません。 また、モダンな Web サイトを構築するときは、CSS Modules や Sass/Less/Stylus といった仕組みを使用するのが常套手段となっています。
そのため、Web サイト用の .js ファイルを TypeScript を使って作成する場合、webpack などのバンドルツールを組み合わせて使用する必要があります。
TypeScript &amp;hellip; .ts ファイルから .js ファイルへの変換 webpack &amp;hellip; Web サイト用の各種リソースをバンドルする バンドルツールには様々なものがありますが、大きなシェアを占めているのは webpack なので（2020年現在）、ここでは TypeScript と webpack を組み合わせて使用する方法を説明します。
☝️ webpack は必要なくなる？ ES Module の仕組みにより、Web ブラウザからモジュール化された .js ファイルをインポートすることが可能になりつつあります。 しかし、Web サイトの最終的なデプロイ時には、各種リソースを最適化（minify など）する必要があるため、まだまだ webpack などのバンドルツールが必要です。 関連パッケージのインストール TypeScript のインストール プロジェクト用のディレクトリと package.json を作成し、TypeScript をインストールします。
$ mkdir myapp &amp;amp;&amp;amp; cd $_ $ npm init -y $ npm install --save-dev typescript webpack のインストール webpack 関連のパッケージをインストールします。</description></item><item><title>TypeScriptの環境/設定: 厳格な型チェックを有効にする (strict)</title><link>https://maku.blog/p/7b9432m/</link><pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7b9432m/</guid><description>厳格モードに関するオプション TypeScript の設定ファイル (tsconfig.json) には、厳格な型チェックを有効にするための strict オプションが用意されています。
プロパティ名 デフォルト値 説明 strict false Enable all strict type checking options. コンパイル時の様々な厳格な型チェック機能を有効にします。 tsconfig.json の記述例 { &amp;#34;include&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;ES2015&amp;#34;, &amp;#34;module&amp;#34;: &amp;#34;commonjs&amp;#34;, &amp;#34;allowJs&amp;#34;: true, &amp;#34;outDir&amp;#34;: &amp;#34;./build&amp;#34;, &amp;#34;strict&amp;#34;: true /* Enable all strict type-checking options. */ } } 上記の例では、tsconfig.json で strict オプションを有効にしていますが、tsc コマンドのオプションで --strict と直接指定する方法もあります。
$ tsc --strict 実は、strict オプションは、下記のようなオプション群をまとめて true にするためのオプションです。
プロパティ名 デフォルト値 説明 noImplicitAny false Raise error on expressions and declarations with an implied any type.</description></item><item><title>TypeScriptの環境: tsc-watch で ts ファイルの変更監視＆アプリの再起動を自動化する</title><link>https://maku.blog/p/nxzsnkf/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nxzsnkf/</guid><description>TypeScript の監視と JavaScript の監視の両立 tsc --watch コマンドを使うと、TypeScript (.ts) ファイルの変更を監視して自動的に tsc （トランスパイル）を実行してくれるようになります。 nodemon コマンドを使うと、JavaScript (.js) ファイルの変更を監視して自動的に node コマンドを再起動してくれるようになります。
これらを組みあわせれば、TypeScript (.ts) ファイルの変更時に、自動的に Node.js アプリを再起動できそうな気がしますが、一連のコマンドとしてこれら 2 つを組み合わせて実行するのにはみんな苦労しているようです（もちろんコマンドシェルを 2 つ立ち上げればできますが）。
そこで便利なのが tsc-watch コマンド です。
tsc-watch パッケージでまるごと解決 tsc-watch という NPM パッケージ（コマンド）を使用すると、TypeScript の変更監視と Node アプリの再起動の連動を簡単に行えるようになります。 まず、必要なパッケージを下記のようにインストールします。 nodemon は使わなくて済むので、ここでは依存パッケージとして typescript と tsc-watch をインストールしておきます。 --save-dev オプションを付加して、package.json の devDependencies に登録するのを忘れないようにしましょう。
$ npm install --save-dev typescript $ npm install --save-dev tsc-watch tsc-watch コマンドはほとんど tsc --watch のラッパーなので、そのまま実行すると、TypeScript ファイルの変更を監視してトランスパイルを実行するという動作になります。 これだけの用途であれば tsc コマンドで十分なのですが、tsc-watch コマンドに追加されている --onSuccess オプションを使うと、トランスパイル後に任意の追加コマンドを実行することができます。 この追加コマンドとして npm start などを実行するように設定しておけば、TypeScript のトランスパイル後に Node.</description></item><item><title>TypeScriptの環境: 既存の JavaScript プロジェクトを TypeScript に乗り換える</title><link>https://maku.blog/p/3eccb2t/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3eccb2t/</guid><description>TypeScript プロジェクトへの移行は簡単！ TypeScript の構文は、JavaScript のコードとの互換性を考慮して仕様が決められているため、既存の JavaScript プロジェクトを簡単に TypeScript プロジェクトに移行することができます。 後述するように設定をうまく行えば、JavaScript ファイルの拡張子を .ts に変える必要すらありません。
TypeScript の構文を使わないと意味がないのでは？と思うかもしれませんが、TypeScript のトランスパイラ (tsc) には、強力な静的解析の仕組みが備わっているため、この機能を既存の JavaScript ファイルに適用するだけでも TypeScript を導入する価値があります。
ここでは、tsc コマンドは下記のようにグローバルにインストールしてあることを前提とします。
$ npm install -g typescript おすすめのディレクトリ構成 既存の JavaScript コードを TypeScript トランスパイラ (tsc) の変換対象にする場合は、入力ファイルとなる .js ファイルと、生成される .js ファイルのディレクトリを明確に区別しておくべきです。 そうしておかないと、どのファイルが自分が作成したファイルで、どのファイルが自動生成されたファイルなのか分かりにくくなってしまいます。
ここでは、既存の JavaScript プロジェクトのソースコード (.js) を、下記のように src ディレクトリに格納します。 このディレクトリには、最終的に .js ファイルと .ts ファイルが混在していても構いません。
project/ +-- tsconfig.js （設定ファイル） +-- build/ （出力用ディレクトリ） +-- src/ （入力用ディレクトリ） +-- main.js +-- module1.js +-- module2.js 上記では、src ディレクトリの直下に .</description></item></channel></rss>