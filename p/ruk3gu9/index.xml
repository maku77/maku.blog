<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux メモ on まくろぐ</title><link>https://maku.blog/p/ruk3gu9/</link><description>Recent content in Linux メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 16 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/ruk3gu9/index.xml" rel="self" type="application/rss+xml"/><item><title>Linuxコマンド: ip コマンドの使い方</title><link>https://maku.blog/p/p7q7n4i/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p7q7n4i/</guid><description>apt で ip コマンドをインストールする ip コマンドは APT の iproute2 パッケージに含まれています。 Docker の Ubuntu コンテナなどで ip コマンドが見つからない場合は、次のようにインストールできます。
$ apt update # パッケージリストの更新 $ apt install -y iproute2 iproute2 パッケージには、ip コマンド以外にもいろいろなコマンドが含まれています（参考: iproute2 に含まれるファイルのリスト ─ Debian / archlinux）。
arpd - userspace arp daemon bridge - show / manipulate bridge addresses and devices devlink - Devlink tool ip - show / manipulate routing, devices, policy routing and tunnels lnstat - unified linux network statistics nstat - network statistics tools routef - flush routes routel - list routes with pretty output format rtacct - network statistics tools rtmon - listens to and monitors RTnetlink rtstat - unified linux network statistics ss - another utility to investigate sockets tc - show / manipulate traffic control settings tipc - a TIPC configuration and management tool サブコマンドのヘルプを表示する ip &amp;lt;サブコマンド名&amp;gt; help で各サブコマンドのヘルプを表示できます。</description></item><item><title>Linuxメモ: Bluetooth 関連コマンドのメモ (hciconfig, bluetoothctl)</title><link>https://maku.blog/p/ter3doz/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ter3doz/</guid><description>Bluetooth デバイスの情報を表示する (hciconfig) hciconfig は、Bluetooth デバイスの情報表示や設定を行うためのコマンドです。 HCI プロトコルで Bluetooth コントローラーと通信します。 hciconfig コマンドが見つからない場合は、bluez パッケージをインストールします。
Ubuntu への bluez パッケージのインストール $ apt update &amp;amp;&amp;amp; apt install -y bluez Bluetooth のデバイス名には hci0 や hci1 といった名前が付けられ、hciconfig コマンドでそれらの一覧を表示することができます。 次の実行例は、Raspberry Pi 4 に USB Bluetooth ドングルを接続した状態で hciconfig コマンドを実行したときの結果です（アドレスは一部伏せてます）。
$ hciconfig hci1: Type: Primary Bus: USB BD Address: 00:E0:4C:XX:XX:XX ACL MTU: 1021:6 SCO MTU: 255:12 UP RUNNING RX bytes:2186 acl:0 sco:0 events:105 errors:0 TX bytes:12322 acl:0 sco:0 commands:105 errors:0 hci0: Type: Primary Bus: UART BD Address: DC:A6:32:XX:XX:XX ACL MTU: 1021:8 SCO MTU: 64:1 UP RUNNING RX bytes:1514 acl:0 sco:0 events:90 errors:0 TX bytes:2061 acl:0 sco:0 commands:90 errors:0 USB ドングルの Bluetooth デバイスが hci1 (Bus: USB)、Raspberry Pi 4 組み込みの Bluetooth デバイスが hci0 (Bus: UART) として認識されているのが分かります。 hciconfig コマンドに -a (--all) オプションをつけて実行すると、詳細情報を表示できます。</description></item><item><title>Linuxコマンド: ssh-id-copy で SSH の公開鍵をリモートホストに登録する</title><link>https://maku.blog/p/2mzbmw8/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2mzbmw8/</guid><description>ssh-id-copy とは SSH で公開鍵認証方式を使ってリモートホストに接続するには、リモートホスト側の ~/.ssh/authorized_keys ファイルに公開鍵を書き込んでおく必要がありますが、ssh-copy-id コマンドを使うと、この作業を一撃で済ますことができます。 ssh-copy-id コマンドは Linux 環境であれば標準でインストールされているはずです。
前提条件として、パスワード認証で SSH 接続できる状態にはしておく必要があります。
（必要があれば）鍵ファイルの作成 (ssh-keygen) 接続元のマシンに次のような秘密鍵＆公開鍵のペアが存在しないときは、ssh-keygen コマンドなどで作成しておきます。
~/.ssh/id_rsa &amp;hellip; 秘密鍵 ~/.ssh/id_rsa.pub &amp;hellip; 公開鍵（これをリモートホストに登録します） 秘密鍵と公開鍵を生成する $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/Users/maku/.ssh/id_rsa): （このパスでよければ Enter） Enter passphrase (empty for no passphrase): （鍵のパスワードを入力） Enter same passphrase again: （パスワードを再入力） Your identification has been saved in /Users/maku/.ssh/id_rsa. Your public key has been saved in /Users/maku/.</description></item><item><title>Linuxメモ: Netplan で Ubuntu のネットワーク設定を行う</title><link>https://maku.blog/p/7q3dnx8/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7q3dnx8/</guid><description>Netplan とは Netplan は Linux のネットワーク設定を簡潔な YAML ファイルで行う仕組みで、Ubuntu 18.04 以降（正確には 17 以降）で採用されています。 昔の Ubuntu/Debian で使用されていた /etc/network/interfaces という設定ファイルはもう使われていません。
実際のネットワーク管理は、バックエンドで動作する NetworkManager や systemd-networkd といったネットワークデーモンが行うのですが、Netplan は YAML 設定ファイルの内容を適切な形に変換して、これらのネットワークデーモンに渡してくれます。 つまり、バックエンドでどのようなネットワークデーモンが動いているかを意識せずに、統一されたわかりやすい YAML ファイルでネットワーク設定を行うことができます。
Netplan は次のように振る舞います。
システム起動時に Netplan が設定ファイル (/etc/netplan/*.yaml) を読み込んで、各ネットワークデーモン用の設定値を /run 以下へ書き出す 各ネットワークデーモンが渡された情報に基づいてネットワーク設定を行う 図: netplan.io のサイトより バックエンドのネットワークデーモンとして何を使うかは、設定ファイルの renderer 部分で指定できるようになっていますが、デフォルトでは次のように動作します。
Wifi や 無線 WAN/LTE の設定 &amp;hellip; NetworkManager に渡される それ以外のネットワーク（有線LANなど）の設定 &amp;hellip; networkd に渡される よって、通常はどのネットワークデーモンを使うかを明示する必要はありません。
設定ファイルの読み込まれる順序 Netplan はすべての /etc/netplan/*.yaml ファイルを読み込みます。 複数のファイルが存在する場合は、ファイル名のアルファベット順に読み込まれ、後に読み込まれたファイルの設定値が優先的に使用されます。 例えば、</description></item><item><title>Raspberry Pi に Ubuntu 20.04 を入れて WiFi 接続できるようにする</title><link>https://maku.blog/p/n9kv7gq/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9kv7gq/</guid><description>ひょんなことから、Ubuntu Server の入った Raspberry Pi 4 が必要になったので、セットアップ手順をメモしておきます。 なんか昔より簡単にインストールできるようになっててビックリしました。
何をするか？ ここでは、Raspberry Pi 4 Model B に Ubuntu 20.04 をインストールして、Wi-Fi 経由の SSH ログインができるところまでセットアップします。 なお、有線 LAN では一度も接続せずに Wi-Fi 接続できるようにします。 ただし、初期設定のために HDMI でのディスプレイ出力は必要になります。
準備するもの Raspberry Pi 4 （たぶん別のバージョンでもOK） SD カードに OS をインストールするための PC HDMI ケーブルとディスプレイと USB キーボード SD カードに OS をインストール 公式の Raspberry Pi Imager というソフトウェアを使うと、ものすごく簡単に SD カードに各種 OS をインストールできます。 Raspberry Pi Imager を起動したら、次のようにポチポチやっていくだけでインストール完了です。
Operating System の項目で、Other general purpose OS → Ubuntu → Ubuntu Server 20.</description></item><item><title>Linuxコマンド: date コマンドの使い方</title><link>https://maku.blog/p/ucnv5ck/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ucnv5ck/</guid><description>Linux や macOS に搭載されている date コマンドの使い方のメモです。
日時をフォーマットして出力する $ date +&amp;#39;%Y-%m-%d&amp;#39; 2021-02-23 $ date +&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39; 2021-02-23 01:08:51 Linux と macOS の date コマンドの違い Linux と macOS では、標準でインストールされている date コマンドが次のように異なります。
Linux &amp;hellip; GUN/Linux 系の date コマンド macOS &amp;hellip; BSD 系の date コマンド そのため、-d オプションと -v オプションの使い方に次のような違いがあります。
1 カ月前の日付を調べる $ date -d &amp;#39;-1 month&amp;#39; # GNU/Linux $ date -d &amp;#39;1 month ago&amp;#39; # GNU/Linux $ date -v-1m # macOS 1 日前の日付を調べる $ date -d &amp;#39;-1 day&amp;#39; # GNU/Linux $ date -v-1d # macOS</description></item><item><title>Linuxコマンド: curl コマンドの使い方メモ</title><link>https://maku.blog/p/phdp2do/</link><pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/phdp2do/</guid><description>昔は curl コマンドは Linux 用のコマンドという認識でしたが、Windows 10 には標準搭載されるようになりました。
curl コマンドでファイルをダウンロードする curl コマンドはデフォルトではダウンロードしたファイルを標準出力に出力します。 -o（小文字のオー）オプションや、-O（大文字のオー）オプションを指定することで、ファイルに保存することができます。
指定したファイル名で保存 (-o) $ curl -L http://example.com/sample.zip -o sample.zip （相対パスで指定）（この場合は -O のが早い） $ curl -L http://example.com/sample.zip -o /tmp/sample.zip （絶対パスで指定） ダウンロード元と同じファイル名で保存 (-O) $ curl -L -O http://example.com/sample.zip curl コマンドで POST リクエストを送信する curl コマンドは、ファイルのダウンロードだけではなく、POST コマンドの送信にも使用できます。 REST API を提供する Web アプリのテストなどに利用できます。
$ curl http://localhost:3000/books -d {} ちなみに、wget コマンドの場合は次のように POST リクエストを送信できます。。
$ wget http://localhost:3000/books --post-data=&amp;#39;{}&amp;#39; -O -</description></item><item><title>Linuxコマンド: rsync コマンドで2つのディレクトリを同期する</title><link>https://maku.blog/p/c3s7wyx/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c3s7wyx/</guid><description>（Windows の場合は、WinSCP をコマンドラインで利用すると同じようなことを実現できます）。
rsync でディレクトリごとコピーする rsync コマンドを使って、src ディレクトリの内容を dst ディレクトリにコピーするには下記のように実行します。
例: src ディレクトリを dst ディレクトリにコピー $ rsync -av src/ dst # src ディレクトリの「中身」を dst ディレクトリ内へコピー $ rsync -av src dst # src ディレクトリを dst ディレクトリ内へコピー -a オプションは、パーミッションやタイムスタンプなどの情報を維持しつつ、ディレクトリを再帰的にコピーする指定をまとめて行うための archive オプションです。 -v オプションは転送情報などを出力する verbose オプションです。
上記例のように、ソースディレクトリの 最後にスラッシュをつけるかつけないかで意味が変わってくる ので注意してください。 2番目のように実行すると、結果として ./dst/src というディレクトリが作成されることになります。
コピー元にないファイルを削除する (&amp;ndash;delete) rsync コマンドはデフォルトでは、コピー先ディレクトリのファイルを削除することはありません。 コピー元 (src) に存在しないファイルを、コピー先 (dst) から削除したいときは、明示的に --delete オプションを付けて実行します。 つまり、2つのディレクトリを同じ内容にしたい（同期したい）のであれば、--delete オプションを付けて実行する必要があります。
例: src の内容を dst に同期させる（src に存在しないファイルは dst から削除する） $ rsync -av --delete src/ dst 指定した拡張子のファイルだけコピーする (&amp;ndash;include) 特定の種類のファイル（png ファイルなど）だけをコピーしたいときは、--include オプションと --exclude を組み合わせて以下のような感じで指定します。</description></item><item><title>Linuxコマンド: scp コマンドでファイルやディレクトリを転送する</title><link>https://maku.blog/p/buvv4fz/</link><pubDate>Sat, 09 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/buvv4fz/</guid><description>ここでは、scp を使ったファイル転送の方法を示していますが、ディレクトリ単位のファイルコピーやバックアップを行いたい場合は、rsync コマンドを使用したほうが効率的です。
ファイル送信 $ scp &amp;lt;localFile&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteFile&amp;gt; ファイル受信 $ scp &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteFile&amp;gt; &amp;lt;localFile&amp;gt; 例: リモートのホームディレクトリ内のファイルを取得 $ scp maku@maku.example.com:hello.txt hello.txt remoteFile の指定は、ホームディレクトリからの相対パスで OK です。
ディレクトリ送信 $ scp -r &amp;lt;localDir&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteDir&amp;gt; ディレクトリ受信 $ scp -r &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteDir&amp;gt; &amp;lt;localDir&amp;gt; 例: ホームディレクトリの sample ディレクトリを丸ごとダウンロード $ scp -r maku@maku.example.com:sample .</description></item><item><title>Linuxメモ: apt (apt-get) コマンドの使い方メモ</title><link>https://maku.blog/p/rdq2cnx/</link><pubDate>Tue, 21 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq2cnx/</guid><description>apt と dpkg の違い Debian/Ubuntu 系 Linux のパッケージ管理には apt (apt-get) コマンドを使いますが、 Low-Level なパッケージ管理コマンドとして dpkg コマンドも備えています。
参考: DebianPackageManagement - Debian Wiki 参考: AptCLI - Debian Wiki dpkg コマンドは純粋にシステムにパッケージをインストールする部分のみを担うため、インターネットからパッケージをダウンロードしたり、依存関係を自動解決したりする仕組みは備えていません。 そこで、apt は dpkg をラップする形でこれらの機能を提供します。
dpkg &amp;hellip; Debian/Ubuntu にパッケージをインストールする仕組み apt &amp;hellip; パッケージの依存関係を解決してダウンロードし、パッケージをインストールする仕組み（ただし、インストールには内部的に dpkg が使われる） apt と apt-get の違い 2016 年にリリースされた Ubuntu 16.04 の頃から、apt-get コマンドの代わりに apt コマンドが使われるようになりました。 2020 年にリリースされた Ubuntu 20.04 でも apt-get、apt-cache コマンドは使用可能ですが、今後は主に apt コマンドを使っていくことになりそうです。
apt はもともと Linux Mint ユーザーによって作られたコマンドで、これまで apt-get や apt-cache などに散らばっていたコマンド群を整理して使いやすくしています。</description></item><item><title>Linuxメモ: デバイスドライバ作成の雑多メモ</title><link>https://maku.blog/p/tm4iwbq/</link><pubDate>Wed, 08 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tm4iwbq/</guid><description> デバイスドライバは kernel 空間で動作するプログラムで、kernel の機能を使って実装することができる。一方、通常のプログラムはユーザランドで動作する。 デバイスドライバは kernel 自体に組み込んでしまう方法と、ローダブルモジュールとして動的にロード (insmod)、アンロード (rmmod) できるようにする方法がある。 ユーザランドで動作する普通のプログラムが、デバイスドライバの機能を使うには、デバイスファイルを介してアクセスする。 デバイスファイルの操作は、open、close、read、write のような基本的なファイル操作関数を使用する。</description></item><item><title>Linuxコマンド: テンポラリディレクトリを作成する (mktemp)</title><link>https://maku.blog/p/oo32y2x/</link><pubDate>Thu, 30 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oo32y2x/</guid><description>mktemp コマンドを使用して、一時ディレクトリを作成することができます。
$ mktemp -d /tmp/tmp.LE04SMiEzq mktemp コマンドは、作成したファイルやディレクトリのパスを表示するので、シェルスクリプト内で以下のようにすれば、そのパスを変数に格納することができます。
tempdir=`mktemp -d`</description></item><item><title>Linuxコマンド: ディレクトリのサイズを調べる (du)</title><link>https://maku.blog/p/95pkhzc/</link><pubDate>Wed, 29 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/95pkhzc/</guid><description>du コマンドを使って、ディレクトリ内のファイルの合計サイズを調べることができます。
$ du -hs mydir 685M mydir 各オプションは次のような効果があります。
-h (--human-readable) &amp;hellip; 人に読みやすい単位でサイズ表示します（例: 1K、234M、2G） -s (--summarize) &amp;hellip; 合計サイズのみを表示します サイズ部分だけを表示したい場合は、cut コマンドで 1 番目のフィールドを切り出してしまうのが手っ取り早いです。
$ du -hs mydir | cut -f1 685M</description></item><item><title>Linuxコマンド: ファイルの MIME メディアタイプを調べる (file)</title><link>https://maku.blog/p/6i7dvxj/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6i7dvxj/</guid><description>file コマンドに -i オプションを付けて実行すると、そのファイルの MIME タイプを調べることができます。
$ file -i sample.txt sample.txt: text/plain; charset=us-ascii</description></item><item><title>Linuxコマンド: ファイルの内容を8進数や16進数でダンプする (od)</title><link>https://maku.blog/p/cw7ekxc/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cw7ekxc/</guid><description>od コマンドの基本（8 進数でダンプする） od (octal dump) コマンドを使用すると、ファイルの内容を 8 進数や 16 進数でダンプすることができます。
ファイル内容を 8 進数でダンプする $ od sample.jar | head -5 0000000 045520 002003 000024 000010 000010 122216 037257 000000 0000020 000000 000000 000000 000000 000000 000024 000000 042515 0000040 040524 044455 043116 046457 047101 043111 051505 027124 0000060 043115 106505 005313 030302 042420 001767 103771 040374 0000100 072502 121341 133273 020473 145340 106255 044315 007207 先頭のカラムはアドレスを示しています。
アドレスの後ろからは、6 文字ずつに区切って 8 進数のデータが並びます。 8 進数では 1 文字が 3 ビットなので、6 文字で最大 18 ビットを示すことができますが、od コマンドの出力では、その内の 16 ビット（= 2 バイト）を使用しています。 頭の 2 ビットは必ず 0 でパディングされているので、各カラムの先頭の数字は 0 か 1 になります（アスキーコードのテキストなら必ず 0 でしょう）。</description></item><item><title>Linuxメモ: デバイスドライバのライセンスについて</title><link>https://maku.blog/p/89tt5ie/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/89tt5ie/</guid><description>デバイスドライバを Linux カーネルに直接取り込む（静的リンクする）場合は GPL になります。 Linux カーネル自体が GPL なので、ドライバも GPL になるということです。 このようなドライバはランレベル 1 でロードされます。
カーネルモジュール（ローダブルモジュール）としてドライバを動的にロードする場合は、ライセンスは開発者が決めることができます。 通常はランレベル 3 になった時点で、insmod や modprobe コマンドでロードします。
カーネルモジュールとして作成するドライバのライセンスは、 コードの中で以下のように MODULE_LICENSE マクロを使用して指定します。
MODULE_LICENSE(&amp;#34;Dual BSD/GPL&amp;#34;); ライセンスは以下のものから選択することができます。
GPL GPL v2 GPL and additional rights Dual BSD/GPL Dual MIT/GPL Dual MPL/GPL Proprietary # default</description></item><item><title>Linuxメモ: syslog のログの保存先の設定</title><link>https://maku.blog/p/rm78k9i/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rm78k9i/</guid><description>/etc/syslog.conf に以下のように記述されていれば、debug レベルのログは /var/log/debug に、info, notice, warn レベルのログは /var/log/messages に記録されます。
*.=debug; \ auth,authpriv.none;\ news.none;mail.none -/var/log/debug *.=info;*.=notice;*.=warn;\ auth,authpriv.none;\ cron,daemon.none;\ mail,news.none -/var/log/messages</description></item><item><title>Linuxコマンド: パッチファイルを作成・適用する (diff, patch)</title><link>https://maku.blog/p/nyehhfd/</link><pubDate>Fri, 11 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nyehhfd/</guid><description>パッチの基本 (diff/patch) パッチファイルの作成 sample.cpp #include &amp;lt;iostraem&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;AAA&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } ew/sample.cpp #include &amp;lt;iostraem&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;BBB&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 例えば、上記のような sample.cpp の内容を new/sample.cpp に変更するためのパッチファイルを作成するには、次のように diff コマンドを実行します。
$ diff -u sample.cpp new/sample.cpp &amp;gt; sample.patch -u オプションは unified diff 形式で差分を出力することを示しています（他の形式でも出力可能ですが、patch 用のパッチファイルを作成するときは、ほとんどの場合 unified diff 形式が使用されるようです）。
これで、次のようなパッチファイルが生成されます。
sample.patch --- sample.cpp 2007-05-11 20:36:13.265625000 +0900 +++ new/sample.cpp 2007-05-11 20:26:31.875000000 +0900 @@ -1,6 +1,6 @@ #include &amp;lt;iostraem&amp;gt; int main() { - std::cout &amp;lt;&amp;lt; &amp;#34;AAA&amp;#34; &amp;lt;&amp;lt; std::endl; + std::cout &amp;lt;&amp;lt; &amp;#34;BBB&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 差分を表示している各行の 1 文字目は次のような意味を持っています。</description></item></channel></rss>