<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux ネットワーク関連メモ on まくろぐ</title><link>https://maku.blog/p/iodgqna/</link><description>Recent content in Linux ネットワーク関連メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 28 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/iodgqna/index.xml" rel="self" type="application/rss+xml"/><item><title>Linuxコマンド: curl コマンドのチートシート</title><link>https://maku.blog/p/2sv4bqw/</link><pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2sv4bqw/</guid><description>コマンド 説明 curl --help all 詳細なヘルプを表示 curl https://example.com GET リクエスト curl -i https://example.com レスポンスヘッダーも表示 curl -I https://example.com レスポンスヘッダーだけ表示 curl -v https://example.com 冗長表示（リクエストとレスポンスのヘッダーを確認可能） curl -H &amp;quot;Authorization: Bearer TOKEN&amp;quot; https://example.com リクエストヘッダーの指定 curl -b &amp;quot;cookie1=value1; cookie2=value2&amp;quot; http://example.com クッキーの指定 curl -A &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&amp;quot; http://example.com ユーザーエージェントの指定 curl -L http://example.com リダイレクト (302) レスポンスを自動処理 curl -O https://example.com/file.txt ファイルのダウンロード（同名で保存） curl -o hoge.txt https://example.com/file.txt ファイルのダウンロード（別名で保存） curl -# -O http://example.com/largefile.zip ダウンロードの進捗を表示 curl -r 0-100 http://example.com/file.txt -o partial.</description></item><item><title>Linuxコマンド: ポートを開いているプロセスを調べる (lsof)</title><link>https://maku.blog/p/i7zokcv/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i7zokcv/</guid><description>迷ったらとりあえずコレ 次のように実行すると、TCP でポートを開いて LISTEN 状態になっているプロセスのコマンド名や PID の一覧を表示できます。
開いている TCP ポートの一覧を表示 $ lsof -i tcp -s tcp:listen -P COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ControlCe 604 maku 24u IPv4 0xbf4647db74c55935 0t0 TCP *:7000 (LISTEN) ControlCe 604 maku 25u IPv6 0x27a96e6374c5592c 0t0 TCP *:7000 (LISTEN) ControlCe 604 maku 26u IPv4 0xbf46527374c55935 0t0 TCP *:5000 (LISTEN) ControlCe 604 maku 27u IPv6 0x27a9756374c5592c 0t0 TCP *:5000 (LISTEN) deno 8572 maku 14u IPv4 0xbc6a127374c55935 0t0 TCP *:8000 (LISTEN) hugo 10971 maku 6u IPv4 0xbcba127374c55935 0t0 TCP localhost:50001 (LISTEN) hugo 10975 maku 6u IPv4 0xbd35a81374c55935 0t0 TCP localhost:50002 (LISTEN) ruby 52070 maku 9u IPv4 0xbf461d7b74c55935 0t0 TCP localhost:4000 (LISTEN) ruby 52070 maku 12u IPv4 0xbd38681374c55935 0t0 TCP localhost:35729 (LISTEN) node 65924 maku 38u IPv6 0x27a9356374c5592c 0t0 TCP localhost:5173 (LISTEN) Dropbox 68519 maku 114u IPv4 0xbc67e81374c55935 0t0 TCP *:17500 (LISTEN) Dropbox 68519 maku 115u IPv6 0x27a8836374c5592c 0t0 TCP *:17500 (LISTEN) サーバー系の開発をしていると、開いているポートがどんどん増えていくので、次のような ports エイリアスを定義しておくと便利です。</description></item><item><title>Linuxコマンド: TCP/TDP ポートの通信状態を確認する (ss)</title><link>https://maku.blog/p/sg2m6wm/</link><pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sg2m6wm/</guid><description>関連コマンド: ip コマンド
ss コマンドとは Linux の ss コマンド (socket statistics) は、TCP ポートや UDP ポートの通信状態を確認するためのコマンドで、過去に使われていた net-tools パッケージの netstat コマンドの後継です。 Cent OS 7 ではデフォルトで ss コマンドが採用されています。
APT の iproute2 パッケージをインストールすると、ss コマンドを使用できるようになります。
ss コマンドのインストール $ apt update # パッケージリストの更新 $ apt install -y iproute2 iptable2 パッケージをインストールすると、一緒に ip コマンド などもインストールされます。
ss サブコマンド コマンド 説明 対応する旧コマンド ss -nat TCP ポートの通信状態を確認 netstat -nat ss -nlt LISTEN（待ち受け）状態の TCP ポートを確認 netstat -nlt ss -nau UDP ポートの通信状態を確認UDP ソケットの State カラムは UNCONN と表示される netstat -nau</description></item><item><title>Linuxコマンド: ip コマンドの使い方</title><link>https://maku.blog/p/p7q7n4i/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p7q7n4i/</guid><description>関連コマンド: ss コマンド
ip コマンドとは Linux の ip コマンドを使うと、ネットワークデバイスやルーティングテーブル、ARP テーブルなどの確認・設定を行うことができます。 過去に net-tools パッケージで提供されていた、ifconfig、route、arp、netstat コマンドは deprecated（非推奨）扱いになっています。
ip コマンドをインストールする ip コマンドは APT の iproute2 パッケージに含まれています。 Docker の Ubuntu コンテナなどで ip コマンドが見つからない場合は、次のようにインストールできます。
$ apt update # パッケージリストの更新 $ apt install -y iproute2 iproute2 パッケージには、ip コマンド以外にもいろいろなコマンドが含まれています（参考: iproute2 に含まれるファイルのリスト ─ Debian / archlinux）。
iproute2 のインストールで使えるようになるコマンド arpd - userspace arp daemon
bridge - show / manipulate bridge addresses and devices
devlink - Devlink tool
ip - show / manipulate routing, devices, policy routing and tunnels</description></item><item><title>Linuxメモ: Bluetooth 関連コマンドのメモ (hciconfig, bluetoothctl)</title><link>https://maku.blog/p/ter3doz/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ter3doz/</guid><description>Bluetooth デバイスの情報を表示する (hciconfig) hciconfig は、Bluetooth デバイスの情報表示や設定を行うためのコマンドです。 HCI プロトコルで Bluetooth コントローラーと通信します。 hciconfig コマンドが見つからない場合は、bluez パッケージをインストールします。
Ubuntu への bluez パッケージのインストール $ apt update &amp;amp;&amp;amp; apt install -y bluez Bluetooth のデバイス名には hci0 や hci1 といった名前が付けられ、hciconfig コマンドでそれらの一覧を表示することができます。 次の実行例は、Raspberry Pi 4 に USB Bluetooth ドングルを接続した状態で hciconfig コマンドを実行したときの結果です（アドレスは一部伏せてます）。
$ hciconfig hci1: Type: Primary Bus: USB BD Address: 00:E0:4C:XX:XX:XX ACL MTU: 1021:6 SCO MTU: 255:12 UP RUNNING RX bytes:2186 acl:0 sco:0 events:105 errors:0 TX bytes:12322 acl:0 sco:0 commands:105 errors:0 hci0: Type: Primary Bus: UART BD Address: DC:A6:32:XX:XX:XX ACL MTU: 1021:8 SCO MTU: 64:1 UP RUNNING RX bytes:1514 acl:0 sco:0 events:90 errors:0 TX bytes:2061 acl:0 sco:0 commands:90 errors:0 USB ドングルの Bluetooth デバイスが hci1 (Bus: USB)、Raspberry Pi 4 組み込みの Bluetooth デバイスが hci0 (Bus: UART) として認識されているのが分かります。 hciconfig コマンドに -a (--all) オプションをつけて実行すると、詳細情報を表示できます。</description></item><item><title>Linuxメモ: Netplan で Ubuntu のネットワーク設定を行う</title><link>https://maku.blog/p/7q3dnx8/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7q3dnx8/</guid><description>Netplan とは Netplan は Linux のネットワーク設定を簡潔な YAML ファイルで行う仕組みで、Ubuntu 18.04 以降（正確には 17 以降）で採用されています。 昔の Ubuntu/Debian で使用されていた /etc/network/interfaces という設定ファイルはもう使われていません。
実際のネットワーク管理は、バックエンドで動作する NetworkManager や systemd-networkd といったネットワークデーモンが行うのですが、Netplan は YAML 設定ファイルの内容を適切な形に変換して、これらのネットワークデーモンに渡してくれます。 つまり、バックエンドでどのようなネットワークデーモンが動いているかを意識せずに、統一されたわかりやすい YAML ファイルでネットワーク設定を行うことができます。
Netplan は次のように振る舞います。
システム起動時に Netplan が設定ファイル (/etc/netplan/*.yaml) を読み込んで、各ネットワークデーモン用の設定値を /run 以下へ書き出す 各ネットワークデーモンが渡された情報に基づいてネットワーク設定を行う 図: netplan.io のサイトより バックエンドのネットワークデーモンとして何を使うかは、設定ファイルの renderer 部分で指定できるようになっていますが、デフォルトでは次のように動作します。
Wifi や 無線 WAN/LTE の設定 &amp;hellip; NetworkManager に渡される それ以外のネットワーク（有線LANなど）の設定 &amp;hellip; networkd に渡される よって、通常はどのネットワークデーモンを使うかを明示する必要はありません。
設定ファイルの読み込まれる順序 Netplan はすべての /etc/netplan/*.yaml ファイルを読み込みます。 複数のファイルが存在する場合は、ファイル名のアルファベット順に読み込まれ、後に読み込まれたファイルの設定値が優先的に使用されます。 例えば、
/etc/netplan/50-cloud-init.yaml /etc/netplan/99-custom.yaml というファイルがある場合、50-cloud-init.yaml で設定された値は 99-custom.yaml の設定値によって上書きされます。</description></item><item><title>Raspberry Pi に Ubuntu 20.04 を入れて WiFi 接続できるようにする</title><link>https://maku.blog/p/n9kv7gq/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9kv7gq/</guid><description>ひょんなことから、Ubuntu Server の入った Raspberry Pi 4 が必要になったので、セットアップ手順をメモしておきます。 なんか昔より簡単にインストールできるようになっててビックリしました。
何をするか？ ここでは、Raspberry Pi 4 Model B に Ubuntu 20.04 をインストールして、Wi-Fi 経由の SSH ログインができるところまでセットアップします。 なお、有線 LAN では一度も接続せずに Wi-Fi 接続できるようにします。 ただし、初期設定のために HDMI でのディスプレイ出力は必要になります。
準備するもの Raspberry Pi 4 （たぶん別のバージョンでもOK） SD カードに OS をインストールするための PC HDMI ケーブルとディスプレイと USB キーボード SD カードに OS をインストール 公式の Raspberry Pi Imager というソフトウェアを使うと、ものすごく簡単に SD カードに各種 OS をインストールできます。 Raspberry Pi Imager を起動したら、次のようにポチポチやっていくだけでインストール完了です。
Operating System の項目で、Other general purpose OS → Ubuntu → Ubuntu Server 20.</description></item><item><title>Linuxコマンド: curl コマンドの使用例（GET/POST リクエスト、ファイルのダウンロード）</title><link>https://maku.blog/p/phdp2do/</link><pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/phdp2do/</guid><description>curl コマンドは URL を指定してサーバー上のリソースにアクセスするためのコマンドで、Web API のテストや、ファイルのダウンロードに使用できます。 昔は curl コマンドは Linux 用のコマンドという認識でしたが、Windows 10 には標準搭載されるようになりました。 curl は様々なプロトコルで通信できますが、主に HTTP/HTTPS が使用されます。
参考: curl コマンドのチートシート curl コマンドでファイルをダウンロードする curl コマンドはデフォルトではダウンロードしたファイルを標準出力に出力します。 -o（小文字のオー）オプションや、-O（大文字のオー）オプションを指定することで、ファイルに保存する ことができます。 同時に -L オプションを指定しておくと、リダイレクトレスポンスを自動処理してくれます。
ダウンロード元と同名で保存 (-O) sample.zip という名前で保存 $ curl -L -O http://example.com/sample.zip 別名で保存 (-o) # カレントディレクトリに foo.zip という名前で保存 $ curl -L -o foo.zip http://example.com/sample.zip # 保存先を絶対パスで指定することも可能 $ curl -L -o /tmp/foo.zip http://example.com/sample.zip curl コマンドで GET/POST リクエストを送信する REST API などのテストに curl コマンドを利用できます。
GET リクエスト 特にオプションを指定しなければ、HTTP の GET リクエストが送信されます。</description></item><item><title>Linuxコマンド: rsync コマンドで2つのディレクトリを同期する</title><link>https://maku.blog/p/c3s7wyx/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c3s7wyx/</guid><description>（Windows の場合は、WinSCP をコマンドラインで利用すると同じようなことを実現できます）。
rsync でディレクトリごとコピーする rsync コマンドを使って、src ディレクトリの内容を dst ディレクトリにコピーするには下記のように実行します。
例: src ディレクトリを dst ディレクトリにコピー $ rsync -av src/ dst # src ディレクトリの「中身」を dst ディレクトリ内へコピー $ rsync -av src dst # src ディレクトリを dst ディレクトリ内へコピー -a オプションは、パーミッションやタイムスタンプなどの情報を維持しつつ、ディレクトリを再帰的にコピーする指定をまとめて行うための archive オプションです。 -v オプションは転送情報などを出力する verbose オプションです。
上記例のように、ソースディレクトリの 最後にスラッシュをつけるかつけないかで意味が変わってくる ので注意してください。 2番目のように実行すると、結果として ./dst/src というディレクトリが作成されることになります。
コピー元にないファイルを削除する (&amp;ndash;delete) rsync コマンドはデフォルトでは、コピー先ディレクトリのファイルを削除することはありません。 コピー元 (src) に存在しないファイルを、コピー先 (dst) から削除したいときは、明示的に --delete オプションを付けて実行します。 つまり、2つのディレクトリを同じ内容にしたい（同期したい）のであれば、--delete オプションを付けて実行する必要があります。
例: src の内容を dst に同期させる（src に存在しないファイルは dst から削除する） $ rsync -av --delete src/ dst 指定した拡張子のファイルだけコピーする (&amp;ndash;include) 特定の種類のファイル（png ファイルなど）だけをコピーしたいときは、--include オプションと --exclude を組み合わせて以下のような感じで指定します。</description></item><item><title>Linuxコマンド: scp コマンドでファイルやディレクトリを転送する</title><link>https://maku.blog/p/buvv4fz/</link><pubDate>Sat, 09 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/buvv4fz/</guid><description>ここでは、scp を使ったファイル転送の方法を示していますが、ディレクトリ単位のファイルコピーやバックアップを行いたい場合は、rsync コマンドを使用したほうが効率的です。
ファイル送信 $ scp &amp;lt;localFile&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteFile&amp;gt; ファイル受信 $ scp &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteFile&amp;gt; &amp;lt;localFile&amp;gt; 例: リモートのホームディレクトリ内のファイルを取得 $ scp maku@maku.example.com:hello.txt hello.txt remoteFile の指定は、ホームディレクトリからの相対パスで OK です。
ディレクトリ送信 $ scp -r &amp;lt;localDir&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteDir&amp;gt; ディレクトリ受信 $ scp -r &amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;remoteDir&amp;gt; &amp;lt;localDir&amp;gt; 例: ホームディレクトリの sample ディレクトリを丸ごとダウンロード $ scp -r maku@maku.example.com:sample .</description></item></channel></rss>