<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.proto ファイルの書き方 on まくろぐ</title><link>https://maku.blog/p/yakoi7q/</link><description>Recent content in .proto ファイルの書き方 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 14 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/yakoi7q/index.xml" rel="self" type="application/rss+xml"/><item><title>protobuf (.proto) ファイルのコーディングスタイル</title><link>https://maku.blog/p/esbs9o5/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/esbs9o5/</guid><description>.proto ファイルでメッセージやサービスを定義するときのコーディング規約をまとめておきます。 Google が Style Guide として指針をまとめていますが、プロジェクト内に既に .proto ファイルがある場合は、一貫性を保つように記述するのがよいとされています。
.proto ファイルの例 syntax = &amp;#34;proto3&amp;#34;;package endpoints.examples.bookstore;option java_multiple_files = true;option java_outer_classname = &amp;#34;BookstoreProto&amp;#34;;option java_package = &amp;#34;com.google.endpoints.examples.bookstore&amp;#34;;import &amp;#34;google/protobuf/empty.proto&amp;#34;;service Bookstore { rpc ListShelves(google.protobuf.Empty) returns (ListShelvesResponse) {} rpc CreateShelf(CreateShelfRequest) returns (Shelf) {} rpc GetShelf(GetShelfRequest) returns (Shelf) {} rpc DeleteShelf(DeleteShelfRequest) returns (google.protobuf.Empty) {} rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) {} rpc CreateBook(CreateBookRequest) returns (Book) {} rpc GetBook(GetBookRequest) returns (Book) {} rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) {}}message Shelf { int64 id = 1; string theme = 2;}message Book { int64 id = 1; string author = 2; string title = 3;}enum FooBar { FOO_BAR_UNSPECIFIED = 0; FOO_BAR_FIRST_VALUE = 1; FOO_BAR_SECOND_VALUE = 2;} 全般 1 行は 80 文字 まで インデントはスペース 2 文字 文字列リテラルは ダブルクォート で囲む（例: &amp;quot;Hoge&amp;quot;） ファイル構造 .</description></item><item><title>.proto の文法: メッセージ型 (message)</title><link>https://maku.blog/p/7h3hu8k/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7h3hu8k/</guid><description>メッセージ型とは Protocol Buffers の メッセージ型 は、基本的なデータ構造を表すもので、.proto ファイルの中で message キーワードを使って定義します。 メッセージ型は、プログラミング言語でいうところの構造体に相当するものです。
message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3;}Go 言語のコードに変換した場合の例 変換コマンド $ protoc --go_out=. --go_opt=Msample.proto=message sample.proto sample.pb.go（抜粋） type SearchRequest struct { // ... Query string `protobuf:&amp;#34;bytes,1,opt,name=query,proto3&amp;#34; json:&amp;#34;query,omitempty&amp;#34;` PageNumber int32 `protobuf:&amp;#34;varint,2,opt,name=page_number,json=pageNumber,proto3&amp;#34; json:&amp;#34;page_number,omitempty&amp;#34;` ResultPerPage int32 `protobuf:&amp;#34;varint,3,opt,name=result_per_page,json=resultPerPage,proto3&amp;#34; json:&amp;#34;result_per_page,omitempty&amp;#34;` } 自動生成されたコードの型情報には、.proto で明示的に定義したフィールド以外の情報も含まれています。 それらの情報は、各種 protobuf ライブラリが内部的に使用します。
上記の SearchRequest というメッセージ型は 3 つのフィールド（文字列 1 つと数値 2 つ）を持っています。 ここでは、protobuf が標準で用意している スカラー型 の string と int32 を使っていますが、他のメッセージ型や列挙型、マップ型などのフィールドとして定義することもできます。 このあたりは、一般的なプログラミング言語と同様です。 各フィールドの末尾には、フィールドを一意に特定する整数である フィールド番号 を割り当てる必要があります。</description></item><item><title>.proto の文法: フィールド番号について</title><link>https://maku.blog/p/w7xkvnb/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7xkvnb/</guid><description>Protocol Buffers の .proto ファイルの型定義では、各フィールドの末尾に フィールド番号 を割り当てておく必要があります。
フィールド番号の割り当て例 message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3;} = 記号が使われていますが、そのフィールドに値を代入しているわけではないので注意してください。 Protocol Buffers は、メッセージ送信用にデータをシリアライズ（バイナリ化）するとき、フィールド名の代わりにこのフィールド番号を使用します。 これにより、Protocol Buffers は効率的なデータ転送を実現しています。
フィールド番号は 1 以上の整数（最大値は 229-1 = 536,870,911）で、メッセージの定義内（同じ階層）で一意になっている必要があります。 必ずしも 1、2、3 のように連番で割り当てる必要はなく、ほぼ任意の数値を割り当てることができますが、19000 ～ 19999 の値は使えません。 これらは、Protocol Buffers ライブラリが内部実装用に予約している値です。 これらの不正な値を使用していると、protoc コマンドなどでコンパイルしようとしたときにエラーになります。
データをシリアライズするとき、フィールド番号 1～15 の数値は、わずか 1 バイトのデータに変換されるため、頻繁に使用するフィールドには 1～15 のフィールド番号を割り当てておくと効率的な通信を行えます。 とはいえ、フィールド番号が 16～2047 であっても、2 バイトのデータで表現できるので、シビアな通信速度が求められている環境でなければそれほど気にする必要はないでしょう。
一度割り当てたフィールド番号は、将来にわたって変更してはいけません。 なぜなら、過去のバージョンの .proto を使って実装されたアプリケーションは、古い .proto で割り当てられたフィールド番号で通信しようとするためです。 同じフィールド番号で異なるデータが送られてきたら、アプリケーションはうまく動作しなくなってしまいます。 .proto を更新して非推奨になったフィールドを削除するときは、フィールド番号やフィールド名を使いまわしてしまわないように、reserved キーワードを使って次のように定義しておきます。</description></item><item><title>.proto の文法: スカラー型の一覧</title><link>https://maku.blog/p/bi5jyer/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bi5jyer/</guid><description>Protocol Buffers の .proto ファイルの中で使用可能なスカラー型と、各言語の型の対応表です。 スカラー型は、メッセージ型 の各フィールドの型として使用できます。
protobuf C++ Java/Kotlin Go Dart double double double float64 double float float float float32 double int32 int32 int int32 int int64 int64 long int64 Int64 uint32 uint32 int uint32 int uint64 uint64 long uint64 Int64 sint32 int32 int int32 int sint64 int64 long int64 Int64 fixed32 uint32 int uint32 int fixed64 uint64 long uint64 Int64 sfixed32 int32 int int32 int sfixed64 int64 long int64 Int64 bool bool boolean bool bool string string String string String bytes string ByteString []byte List 次のような repeated フィールドは、配列やリスト（Golang ではスライス）に相当するコードに置き換えられます。</description></item><item><title>.proto の文法: oneof 型</title><link>https://maku.blog/p/vxixbp3/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vxixbp3/</guid><description>Protocol Buffers の oneof 型 は、定義したフィールドのうち、いずれか 1 つのフィールドのみに値が格納されていることを示す型です。 次の SampleMessage メッセージ型は、1 つの oneof 型フィールド test_oneof を持っています。
message SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; }}上記の oneof ブロックには name フィールドと sub_message フィールドが定義されていますが、これらのいずれかのフィールドに値が格納されることを示しています。 実際にどのフィールドに値が格納されているかを調べる方法は、各言語の protobuf ライブラリ実装によって異なります。 下記は C++ の例です。
SampleMessage message; message.set_name(&amp;#34;maku&amp;#34;); if (message.has_name()) { // ... } oneof のフィールドに値をセットすると、同じ oneof に含まれる他のフィールドの値はクリアされることに注意してください。</description></item><item><title>.proto の文法: 列挙型 (enum)</title><link>https://maku.blog/p/p5wjbwq/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p5wjbwq/</guid><description>列挙型とは Protocol Buffers の 列挙型 は、取り得る値が、あらかじめ定義された定数の中からのみ選択可能であることを示す型で、.proto ファイルの中で enum キーワードを使って定義します。 下記の例では、Corpus という列挙型を定義し、SearchRequest メッセージ型のフィールドとして使用しています。
sample.proto enum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7;}message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; Corpus corpus = 4;} .proto のコーディングスタイル では、すべての列挙値の名前には、型名に相当するプレフィックス を付けるべしとされています（上記の CORPUS_ の部分）。 型名が 3 語以上で構成されていたりして長い場合は、略称のプレフィックスが使われることもあるようです。
0 という値にマップされるものには、サフィックスとして _UNSPECIFIED を付けるよう推奨されています（上記の CORPUS_UNSPECIFIED）。 これは、コーディングスタイルという観点だけではなく、proto2 との互換性確保の理由もあります。</description></item><item><title>.proto の文法: 別の .proto ファイルをインポートする (import)</title><link>https://maku.blog/tech/network/grpc/syntax/import/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/tech/network/grpc/syntax/import/</guid><description>.proto ファイルをインポートする (import) Protocol Buffers の .proto 内で import ステートメントを使用すると、他の .proto ファイルの内容を取り込むことができます。 次の例では、main.proto から other.proto の内容をインポートして、OtherMessage というメッセージ型を参照しています。
proto/message/main.proto（インポートする側） syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;example.com/myapp/message&amp;#34;;import &amp;#34;message/other.proto&amp;#34;;message MainMessage { OtherMessage other = 1;} proto/message/other.proto（インポートされる側） syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;example.com/myapp/message&amp;#34;;message OtherMessage { string content = 1;} インポートのパスは、デフォルトでは protoc コマンドを実行したディレクトリからの相対パスで指定します。 起点となるディレクトリを変更したい場合は、protoc コマンドの --proto_path オプションで、.proto ファイルを配置したルートディレクトリを指定します。
.proto ファイルが proto ディレクトリ以下にある場合 $ protoc --go_out=. --go_opt=paths=source_relative --proto_path=proto message/main.proto 上記のように実行すると、proto/message/main.proto ファイル（およびそこからインポートされているファイル）を入力情報として、message/main.pb.go が生成されます。
参考: protoc コマンドで .</description></item></channel></rss>