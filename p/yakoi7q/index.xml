<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.proto ファイルの書き方 on まくろぐ</title><link>https://maku.blog/p/yakoi7q/</link><description>Recent content in .proto ファイルの書き方 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 16 Dec 2022 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/p/yakoi7q/index.xml" rel="self" type="application/rss+xml"/><item><title>protobuf (.proto) ファイルのコーディングスタイル</title><link>https://maku.blog/p/esbs9o5/</link><pubDate>Tue, 17 May 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/esbs9o5/</guid><description>.proto ファイルでメッセージやサービスを定義するときのコーディング規約をまとめておきます。 Google が Style Guide として指針をまとめていますが、プロジェクト内に既に .proto ファイルがある場合は、一貫性を保つように記述するのがよいとされています。
.proto ファイルの例 syntax = &amp;#34;proto3&amp;#34;; package endpoints.examples.bookstore; option java_multiple_files = true; option java_outer_classname = &amp;#34;BookstoreProto&amp;#34;; option java_package = &amp;#34;com.google.endpoints.examples.bookstore&amp;#34;; import &amp;#34;google/protobuf/empty.proto&amp;#34;; service Bookstore { rpc ListShelves(google.protobuf.Empty) returns (ListShelvesResponse) {} rpc CreateShelf(CreateShelfRequest) returns (Shelf) {} rpc GetShelf(GetShelfRequest) returns (Shelf) {} rpc DeleteShelf(DeleteShelfRequest) returns (google.protobuf.Empty) {} rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) {} rpc CreateBook(CreateBookRequest) returns (Book) {} rpc GetBook(GetBookRequest) returns (Book) {} rpc DeleteBook(DeleteBookRequest) returns (google.</description></item><item><title>.proto の文法: メッセージ型 (message)</title><link>https://maku.blog/p/7h3hu8k/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/7h3hu8k/</guid><description>メッセージ型とは Protocol Buffers の メッセージ型 は、基本的なデータ構造を表すもので、.proto ファイルの中で message キーワードを使って定義します。 メッセージ型は、プログラミング言語でいうところの構造体に相当するものです。
message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } Go 言語のコードに変換した場合の例 変換コマンド $ protoc --go_out=. --go_opt=Msample.proto=message sample.proto sample.pb.go（抜粋） type SearchRequest struct { // ... Query string `protobuf:&amp;#34;bytes,1,opt,name=query,proto3&amp;#34; json:&amp;#34;query,omitempty&amp;#34;` PageNumber int32 `protobuf:&amp;#34;varint,2,opt,name=page_number,json=pageNumber,proto3&amp;#34; json:&amp;#34;page_number,omitempty&amp;#34;` ResultPerPage int32 `protobuf:&amp;#34;varint,3,opt,name=result_per_page,json=resultPerPage,proto3&amp;#34; json:&amp;#34;result_per_page,omitempty&amp;#34;` } 自動生成されたコードの型情報には、.proto で明示的に定義したフィールド以外の情報も含まれています。 それらの情報は、各種 protobuf ライブラリが内部的に使用します。
上記の SearchRequest というメッセージ型は 3 つのフィールド（文字列 1 つと数値 2 つ）を持っています。 ここでは、protobuf が標準で用意している スカラー型 の string と int32 を使っていますが、他のメッセージ型や列挙型、マップ型などのフィールドとして定義することもできます。 このあたりは、一般的なプログラミング言語と同様です。 各フィールドの末尾には、フィールドを一意に特定する整数である フィールド番号 を割り当てる必要があります。</description></item><item><title>.proto の文法: フィールド番号について</title><link>https://maku.blog/p/w7xkvnb/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/w7xkvnb/</guid><description>フィールド番号の基本 Protocol Buffers の .proto ファイルの型定義では、各フィールドの末尾に フィールド番号 を割り当てておく必要があります。
フィールド番号の割り当て例 message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } = 記号が使われていますが、そのフィールドに値を代入しているわけではないので注意してください。 Protocol Buffers は、メッセージ送信用にデータをシリアライズ（バイナリ化）するとき、フィールド名の代わりにこのフィールド番号を使用します。 これにより、Protocol Buffers は効率的なデータ転送を実現しています。
フィールド番号は 1 以上の整数（最大値は 229-1 = 536,870,911）で、メッセージの定義内（同じ階層）で一意になっている必要があります。 必ずしも 1、2、3 のように連番で割り当てる必要はなく、ほぼ任意の数値を割り当てることができますが、19000 ～ 19999 の値は使えません。 これらは、Protocol Buffers ライブラリが内部実装用に予約している値です。 これらの不正な値を使用していると、protoc コマンドなどでコンパイルしようとしたときにエラーになります。
データをシリアライズするとき、フィールド番号 1～15 の数値は、わずか 1 バイトのデータに変換されるため、頻繁に使用するフィールドには 1～15 のフィールド番号を割り当てておくと効率的な通信を行えます。 とはいえ、フィールド番号が 16～2047 であっても、2 バイトのデータで表現できるので、シビアな通信速度が求められている環境でなければそれほど気にする必要はないでしょう。
reserved と deprecated reserved 一度割り当てたフィールド番号は、将来にわたって変更してはいけません。 なぜなら、過去のバージョンの .proto を使って実装されたアプリケーションは、古い .proto で割り当てられたフィールド番号で通信しようとするためです。 同じフィールド番号で異なるデータが送られてきたら、アプリケーションはうまく動作しなくなってしまいます。 .</description></item><item><title>.proto の文法: スカラー型の一覧</title><link>https://maku.blog/p/bi5jyer/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/bi5jyer/</guid><description>Protocol Buffers の .proto ファイルの中で使用可能なスカラー型と、各言語の型の対応表です。 スカラー型は、メッセージ型 の各フィールドの型として使用できます。
protobuf C++ Java/Kotlin Go Dart double double double float64 double float float float float32 double int32 int32 int int32 int int64 int64 long int64 Int64 uint32 uint32 int uint32 int uint64 uint64 long uint64 Int64 sint32 int32 int int32 int sint64 int64 long int64 Int64 fixed32 uint32 int uint32 int fixed64 uint64 long uint64 Int64 sfixed32 int32 int int32 int sfixed64 int64 long int64 Int64 bool bool boolean bool bool string string String string String bytes string ByteString []byte List 次のような repeated フィールドは、配列やリスト（Golang ではスライス）に相当するコードに置き換えられます。</description></item><item><title>.proto の文法: repeated ラベル（フィールドを配列にする）</title><link>https://maku.blog/p/b2q2jmh/</link><pubDate>Fri, 16 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/b2q2jmh/</guid><description>Protocol Buffers (protobuf) のフィールドを配列／リスト扱いにするには、.proto ファイルのフィールド定義の先頭に repeated ラベルを付加します。 次の FindBookResponse メッセージ型は、Book 配列のフィールドを持っています。
books.proto（抜粋） message FindBookResponse { repeated Book books = 1; } message Book { string title = 1; } repeated ラベルを付けたフィールドの名前は複数形にしましょう（上記例の場合は books）。
Protocol Buffers では repeated を連続させた多次元配列は定義できませんが、任意のメッセージ型に repeated を付けることはできるので、そのメッセージ型の中に repeated フィールドを配置すれば、多次元配列と同様のデータを表現することができます。
repeated ラベルは、oneof フィールドに付加することはできません。
参考: .proto の文法: oneof 型</description></item><item><title>.proto の文法: optional ラベル（フィールドを省略可能にする）</title><link>https://maku.blog/p/sp9q7o5/</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/sp9q7o5/</guid><description>.proto のフィールドを省略可能にする (option) Protocol Buffers（.proto ファイル）のフィールド定義で optional というラベルを付けると、そのフィールドへの値のセットがオプショナルであることを示すことができます。 optional ラベルは、protoc コンパイラの v3.15.0 以降で使用できます。
sample.proto syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/maku77/myapp/pb&amp;#34;; message SampleMessage { string message = 1; // 通常のフィールド optional string description = 2; // 省略可能なフィールド } 例えば、上記のような .proto ファイルから、次のように Golang コードを生成すると、
$ protoc --go_out=. --go_opt=paths=source_relative sample.proto 次のような SampleMessage 型のコードが生成されます。
sample.pb.go type SampleMessage struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Message string `protobuf:&amp;#34;bytes,1,opt,name=message,proto3&amp;#34; json:&amp;#34;message,omitempty&amp;#34;` // 通常のフィールド Description *string `protobuf:&amp;#34;bytes,2,opt,name=description,proto3,oneof&amp;#34; json:&amp;#34;description,omitempty&amp;#34;` // 省略可能なフィールド } Golang の場合は、オプショナルな string フィールドは、*string として表現されるようですね。</description></item><item><title>.proto の文法: oneof 型</title><link>https://maku.blog/p/vxixbp3/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/vxixbp3/</guid><description>Protocol Buffers の oneof 型 は、定義したフィールドのうち、いずれか 1 つのフィールドのみに値が格納されていることを示す型です。 次の SampleMessage メッセージ型は、1 つの oneof 型フィールド status を持っています。
message SampleMessage { string content = 1; oneof status { int32 status_code = 2; string status_name = 3; } } 上記の oneof ブロックには status_code フィールドと status_name フィールドが定義されていますが、これらのいずれかのフィールドに値が格納されることを示しています。 実際にどのフィールドに値が格納されているかを調べる方法は、各言語の protobuf ライブラリ実装によって異なります。 下記は C++ の例です。
SampleMessage message; message.set_status_code(123); if (message.has_status_code()) { // ... } oneof のフィールドに値をセットすると、同じ oneof に含まれる他のフィールドの値はクリアされることに注意してください。
oneof フィールドに、repeated ラベル や optional ラベル を設定することはできません。</description></item><item><title>.proto の文法: マップ型 (map)</title><link>https://maku.blog/p/xpbnycm/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/xpbnycm/</guid><description>Protocol Buffers でマップ型のフィールドを定義するには、map&amp;lt;key_type, value_type&amp;gt; という形式で型を指定します。 次の SampleMessage メッセージ型は、string 型のキーと Project 型の値を持つマップフィールドを定義しています。
sample.proto（map 型フィールドの例） message SampleMessage { // ... map&amp;lt;string, Project&amp;gt; projects = 3; } message Project { // ... } キーの型 (key_type) には、整数あるいは文字列 を指定することができます。 浮動小数点数 (float, double) やバイトデータ (bytes) を key_type にすることはできません。
値の型 (value_type) としては、ほぼすべての型 を指定できますが、マップ型だけは value_type にすることはできません。 つまり、マップのマップは表現できないことになるのですが、value_type として他のメッセージ型を持たせることができるので（上記の例では Project）、実際にはほぼ同様の情報を表現できます。
あと、あまり困ることはないでしょうが、Protocol Buffers ではマップの配列（リスト）は表現できません（つまり、repeated map&amp;lt;xxx, yyy&amp;gt; とはできません）。</description></item><item><title>.proto の文法: 列挙型 (enum)</title><link>https://maku.blog/p/p5wjbwq/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/p5wjbwq/</guid><description>列挙型とは Protocol Buffers の 列挙型 は、取り得る値が、あらかじめ定義された定数の中からのみ選択可能であることを示す型で、.proto ファイルの中で enum キーワードを使って定義します。 列挙型は、ひとことで言うと、複数の定数をグルーピングする機能です。 下記の例では、Corpus という列挙型を定義し、SearchRequest メッセージ型のフィールドとして使用しています。
sample.proto enum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7; } message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; Corpus corpus = 4; } .proto のコーディングスタイル では、すべての列挙値の名前には、型名に相当するプレフィックス を付けるべしとされています（上記の CORPUS_ の部分）。 型名が 3 語以上で構成されていたりして長い場合は、略称のプレフィックスが使われることもあるようです。</description></item><item><title>.proto の文法: 別の .proto ファイルをインポートする (import)</title><link>https://maku.blog/p/e8yeofc/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/e8yeofc/</guid><description>.proto ファイルをインポートする (import) Protocol Buffers の .proto 内で import ステートメントを使用すると、他の .proto ファイルの内容を取り込むことができます。 次の例では、main.proto から other.proto の内容をインポートして、OtherMessage というメッセージ型を参照しています。
proto/message/main.proto（インポートする側） syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/maku77/myapp/message&amp;#34;; import &amp;#34;message/other.proto&amp;#34;; message MainMessage { OtherMessage other = 1; } proto/message/other.proto（インポートされる側） syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/maku77/myapp/message&amp;#34;; message OtherMessage { string content = 1; } インポートのパスは、デフォルトでは protoc コマンドを実行したディレクトリからの相対パスで指定します。 起点となるディレクトリを変更したい場合は、protoc コマンドの --proto_path オプションで、.proto ファイルを配置したルートディレクトリを指定します。
.proto ファイルが proto ディレクトリ以下にある場合 $ protoc --go_out=. --go_opt=paths=source_relative --proto_path=proto message/main.proto 上記のように実行すると、proto/message/main.proto ファイル（およびそこからインポートされているファイル）を入力情報として、message/main.</description></item><item><title>.proto の文法: サービス型 (service)</title><link>https://maku.blog/p/napwb4e/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/napwb4e/</guid><description>Protoco Buffers の サービス型 は、クライアントとサーバー間の通信方法 (RPC メソッド群) を定義するための型で、.proto ファイルの中で service キーワードを使って定義します。
次の例では、Echo メソッドを持つ EchoService サービス型を定義しています。
// Echo メソッドを持つ EchoService の定義 service EchoService { rpc Echo (EchoRequest) returns (EchoResponse); } // Echo に送るリクエストメッセージの定義 message EchoRequest { string message = 1; optional string payload = 2; } // Echo が返すレスポンスメッセージの定義 message EchoResponse { string message = 1; } 引数と戻り値の方には、上記のように単一のメッセージ型を指定します。 スカラー型を指定することはできないので、単一の値を渡したいときも、独自のメッセージ型を用意する必要があります。 慣例として、引数の型には Request、戻り値の型には Response というサフィックスを付けます。
引数や戻り値が存在しない場合は、Google が用意している google.protobuf.Empty 型を使用することができます。
import &amp;#34;google/protobuf/empty.proto&amp;#34;; service HelloService { rpc Hello(google.</description></item></channel></rss>