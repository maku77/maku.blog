<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>雑多な技術メモ on まくろぐ</title><link>https://maku.blog/p/e58h5in/</link><description>Recent content in 雑多な技術メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 24 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/e58h5in/index.xml" rel="self" type="application/rss+xml"/><item><title>IGDB API でゲーム情報のデータベースにアクセスしてみる</title><link>https://maku.blog/p/mu7gqya/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mu7gqya/</guid><description>IGDB は、世の中の（ビデオ）ゲームの情報をデータベースとして集約しようとしている壮大なプロジェクトで、現在 Twitch が運営しています。 この情報には IGDB API という Web API でアクセスできるようになっていて、簡単に試す程度なら無料で利用できます。 ちょっと試してみたのでメモに残しておきます。 とりあえず、curl コマンドで API のレスポンスを確認するところまで。
大まかには、Twitch developers console でアプリクライアントを登録し、アクセストークンを発行して API を叩く、という流れになります。
Twitch アカウントを登録する IGDB API を使うには、Twitch developers コンソールでアプリケーション（クライアント）の登録が必要です。 このサイトにサインインするには、Twitch のアカウントが必要 なので、下記から作成します。 すでに Twitch アカウントを持っている場合は、そのまま使えます。
Twitch Developers - Login さらに、API を使用する場合は、さらに二段階認証の設定が必須になっているので、次のような感じでたどって設定しておきます。 メールアドレスや電話番号を登録すれば二段階認証を有効化できます。
Twitch - 設定 - セキュリティとプライバシー アプリケーションを登録してクライアント ID とシークレットを発行する Twitch developers コンソール の アプリ管理画面 でアプリを登録すると、クライアント ID とシークレットキーを取得できます。
アプリケーションを登録 ボタンをクリック 名前: 適当な名前を入力（グローバルに一意な名前じゃないといけないっぽい） OAuthのリダイレクトURL: 決まっていないなら http://localhost:3000 などを入力しておけば OK カテゴリー: プルダウンから適当に選択（Website Integration など） 作成 ボタンを押して完了 作成されたアプリの 管理 ボタンをクリック 新しい秘密 ボタンを押してクライアントシークレットを発行 上記の手順で、IGDB API を呼び出すためのクライアント ID とシークレットを確認できます。</description></item><item><title>JUnit のテストケースを一時的に無効にする（@Ignore/@Disabledアノテーション）</title><link>https://maku.blog/p/ow3zskd/</link><pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ow3zskd/</guid><description>JUnit で特定のテストケース（クラスや関数）を一時的に無効にしておきたい場合は、次のようなアノテーションをクラスや関数に付けます。
JUnit4 の場合: @Ignore アノテーション (org.junit.Ignore) JUnit5 の場合: @Disabled アノテーション (org.junit.jupiter.api.Disabled) Java の場合 // import org.junit.Ignore; // import org.junit.Test; public class MyClassTest { @Test @Ignore public void testSomething() { // ... } } Kotlin の場合 // import org.junit.Ignore // import org.junit.Test class MyClassTest { @Test @Ignore fun testSomething() { // ... } } @Ignore (@Disabled) に文字列パラメータを渡すと、なぜそのテストを無効にしているのかを示すことができます。
@Ignore(&amp;#34;HogeHogeのパラメータを整理中&amp;#34;) @Test fun testSomething() { // .</description></item><item><title>npm run スクリプト実行時の ERR! 出力を抑制する (npm run --silent)</title><link>https://maku.blog/p/epm9ipy/</link><pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/epm9ipy/</guid><description>npm run コマンドを使うと、package.json に定義されているスクリプトを実行することができるのですが、そこで実行したコマンドがエラー終了（exit 1 など）すると、npm run の実行自体もエラー扱いとなり、下記のようにエラー情報がたくさん出力されます。
$ npm run test &amp;gt; myapp@1.0.0 test C:\myapp &amp;gt; echo &amp;#34;Error: no test specified&amp;#34; &amp;amp;&amp;amp; exit 1 &amp;#34;Error: no test specified&amp;#34; npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! myapp@1.0.0 test: `echo &amp;#34;Error: no test specified&amp;#34; &amp;amp;&amp;amp; exit 1` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the myapp@1.0.0 test script. npm ERR! This is probably not a problem with npm.</description></item><item><title>npm でインストール済みのモジュールを簡潔にリスト表示する</title><link>https://maku.blog/p/nuvbg6k/</link><pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nuvbg6k/</guid><description>npm list (ls) コマンドは NPM (Node Package Manager) でインストールしたパッケージの一覧を表示するコマンドですが、デフォルトでは依存モジュールをすべてツリー構造で表示するので、出力が大量になります。
インストールパッケージの一覧を表示 $ npm ls myapp@1.0.0 D:\y\gitwork\myapp +-- textlint@11.6.3 | +-- @textlint/ast-node-types@4.2.5 | +-- @textlint/ast-traverse@2.1.7 | | `-- @textlint/ast-node-types@4.2.5 deduped | +-- @textlint/feature-flag@3.1.6 | | `-- map-like@2.0.0 deduped | +-- @textlint/fixer-formatter@3.1.13 | | +-- @textlint/module-interop@1.0.2 deduped | | +-- @textlint/types@1.3.1 deduped ... なが～い出力 ... 次のように --depth オプションを付けると、トップレベルのモジュール名だけを簡潔に表示することができます。
$ npm ls --depth=0 myapp@1.0.0 D:\y\gitwork\myapp +-- textlint@11.6.3 +-- textlint-rule-preset-ja-technical-writing@3.1.3 `-- textlint-rule-web-plus-db@1.1.5 グローバルにインストールしたモジュールを表示するときも同様です。</description></item><item><title>ソフトウェアアーキテクトが考えること</title><link>https://maku.blog/p/x2b2gw3/</link><pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x2b2gw3/</guid><description>ソフトウェアアーキテクチャとは アーキテクチャとは「要求と設計の橋渡し」である ─『オブジェクト開発の神髄』より
外部から見える特性 構成要素 構成要素間の関係 アーキテクトが考えること 何をもとにシステムを設計するか 部品をどのように組み立てるか システムをどのように動作保証するか パフォーマンス アーキテクチャドライバとは アーキテクチャを決定する要件のことを「アーキテクチャドライバ」といいます。 つまり、アーキテクチャドライバはアーキテクチャ設計のためのインプットとなります。 アーキテクチャドライバには以下の３つの要素があります。
制約（最重要。変更できないものだから） ビジネス制約 技術制約 品質特性 Performance 性能 Modifiability 変更容易性 Usability ユーザビリティ Availability 可用性 Security セキュリティ Testability テスト容易性 主な機能要件（重要性としては一番低い。ほとんどの場合、制約にかかわらず実現できるので） アーキテクチャドライバはステークホルダーとのコミュニケーションの道具であり、このアーキテクチャドライバの作成（文章作成）を行うのがアーキテクトの最初の仕事です。
アーキテクチャ設計のステップ アーキテクチャ要件抽出 アーキテクチャドライバの作成（要求を要件として分類する。上の３つの要素） ステークホルダーと仕様優先度レビュー アーキテクチャドライバに基づくシステムの分割 ソフトウェアアーキテクチャレビュー アーキテクチャドキュメント ソフトウェアは様々な視点で捉えられ、これをビュー (View) と呼びます。 アーキテクチャドキュメントはビューの集合と相互作用の説明で構成されます。
アーキテクトが作成すべき図の例 パッケージ図 パッケージ間の依存関係 それぞれのパッケージに何が配置されるか ソースコードやライブラリの物理構造 コンポーネント図 配置図 物理的なハードウェアやソフトウェアの配置 実行環境を表すノードとの接続関係など アーキテクチャパターン アーキテクチャパターンとは、「アーキテクチャの要素と要素間の関係を使い方の制約と共に特定したもの」です。 ─出展『Principles of software architecture』。</description></item><item><title>UnitTest メモ: ユニットテストの網羅レベルの種類 (C0/C1/C2)</title><link>https://maku.blog/p/aet7iu7/</link><pubDate>Fri, 04 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aet7iu7/</guid><description> C0 &amp;hellip; 「命令網羅」 全ての処理が正しく実行される C1 &amp;hellip; 「分岐網羅」 全ての条件が正しく実行される C2 &amp;hellip; 「条件網羅」 全ての組み合わせの経路が実行される</description></item><item><title>電子署名と電子証明書の基礎</title><link>https://maku.blog/p/fzwyf7z/</link><pubDate>Fri, 28 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fzwyf7z/</guid><description>電子署名（デジタル署名）(digital signature) 「電子署名」とは、データに付加され、そのデータが本当に作成者が作ったのかを確認するためのものです。 別の言い方をすると、受け取ったデータが第三者によって作られた偽物でないことを確認するための印です。
以下のような手順で、データが偽物でないか確認します。
データ送信側の「電子署名の作成」手順 送信するデータのメッセージダイジェストを求める。 メッセージダイジェストを非公開鍵 (private key) で暗号化し、「電子署名」とする。 データ受信側の「電子署名の確認」手順 受信した「データ」のメッセージダイジェストを求める。 受信した「電子署名」を「送信者の公開鍵」で復号化し、メッセージダイジェストに戻す。 1 と 2 のメッセージダイジェストが等しければ、本人が作成したデータだと分かる。 上記の手順からも分かるように、一般的に「電子署名」の仕組みには、公開鍵暗号方式が用いられます。 問題は、公開鍵 (public key) が偽物である場合に、なりすましができてしまうことです。 そこで、公開鍵が本物であるかを証明するための、「電子証明書」が必要になってきます。
電子証明書（デジタル証明書) (digital certificate) 電子証明書とは？ 公開鍵が偽物であると、公開鍵暗号方式は意味をなさなくなるため、公開鍵の正当性を証明することが重要になってきます。 電子証明書は、ある公開鍵が本物であることを証明するためのものです。
電子証明書は、一般的には、ITU-T X.509 の標準フォーマット（拡張子 .cer）で作成されます。 X.509 で作成された電子証明書ファイル (.cer) には、公開鍵そのものに加え、公開鍵の作成者（証明書の申請者）の情報、有効期限などが含まれています。
電子証明書の発行 電子証明書は、公開鍵が本物であることを示すためのものですが、その電子証明書自体が本物であることを示すために、末尾に電子署名が付加されます。 その署名は、公開鍵を作成したユーザが行うこともあるし、信頼のおける第三者が行うこともあります。 通常は、信頼のおける第三者機関である認証局 (CA: Certificate Authority) が電子証明書への署名を行い、電子証明書の発行を行います。
電子証明書 (X.509) の構成 電子証明書は、下記のようなデータで構成されています。
+------------------------------------+---------------------------------+ | 公開鍵 + 作成者情報 + 有効期限など | ← これが本物だと示す CA の署名 | +------------------------------------+---------------------------------+ 認証局による電子証明書の発行の流れ 公開鍵の作成者が、身元情報と公開鍵を CA（認証局）へ提出する。 CA は 1 の情報を厳密に審査し、電子証明書（X.</description></item><item><title>XAMPP/Apache の DocumentRoot を設定する</title><link>https://maku.blog/p/6h47cno/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6h47cno/</guid><description>httpd.conf を編集 例えば、Mac OSX にインストールした XAMPP の Apache の場合は、/Applications/XAMPP/xamppfiles/etc/httpd.conf を編集します。
(1) DocumentRoot の変更 DocumentRoot &amp;#34;/Applications/XAMPP/xamppfiles/htdocs&amp;#34; ↓ DocumentRoot &amp;#34;/Users/maku/website/public_html&amp;#34; (2) 対応する Directory ディレクトリの変更 &amp;lt;Directory &amp;#34;/Applications/XAMPP/xamppfiles/htdocs&amp;#34;&amp;gt; ↓ &amp;lt;Directory &amp;#34;/Users/maku/website/public_html&amp;#34;&amp;gt; トラブルシューティング http://localhost/ にアクセスしたときに以下のようなエラーが出た場合は、DocumentRoot に設定したディレクトリのパーミッションを確認します。
Access forbidden! You don't have permission to access the requested directory. There is either no index document or the directory is read-protected. 例えば、DocumentRoot として、/aaa/bbb/ccc を設定した場合、/aaa、/aaa/bbb、/aaa/bbb/ccc 全てに read パーミッションがついている必要があります。
$ chmod 0755 /aaa $ chmod 0755 /aaa/bbb $ chmod 0755 /aaa/bbb/ccc</description></item><item><title>CPU のアーキテクチャ名と CPU 名の対応表</title><link>https://maku.blog/p/v7bxgmn/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v7bxgmn/</guid><description>Intel 系 CPU アーキテクチャ名 CPU名 i386 80386 i486 80486 i586 Pentium, MMX Pentium i686 Pentium Pro, Pentium II, Pentium III, Pentium 4 athlon Athlon, Athlon MP, Athlon XP x86_64 Opteron, Athlon64, Xeon (EM64T), Core, Core2Duo メモ x86 (IA-32) Intel 社の 8086 系のプロセッサの略称。（binary hacks より） x86_64 (AMD64) AMD が設計した x86 上位互換の 64 ビットプロセッサのアーキテクチャ。（binary hacks より）</description></item><item><title>暗号技術まとめ</title><link>https://maku.blog/p/6rn67mc/</link><pubDate>Tue, 20 Dec 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6rn67mc/</guid><description>昔の暗号 シーザー暗号 - 文字をずらすだけの最も古い暗号。ジュリアス・シーザー（ユリウス・カエサル）が作った。 共通鍵暗号 ブロック暗号 ブロック暗号というのは、共通鍵暗号の一種。 データを一定のブロックごとに暗号化する方式。 高速な暗号化処理を行える。
Triple DES - 1990年代。64 bit のブロック暗号 DES を 3 回繰り返す暗号化アルゴリズム。かつては米国政府標準暗号だった。 MISTY1 - 1990年代。三菱電機が開発した 128 bit 暗号鍵を持つ 64 bit ブロック暗号アルゴリズム。 CAST-128 - 64 bit ブロック暗号。 Camellia - 2000年代。128 bit ブロック暗号。NTT・三菱電機。 AES: Advanced Encryption Standard - 2000年代。128 bit ブロック暗号。 SEED - 128 bit ブロック暗号。 国際標準のブロック暗号 (ISO/IEC18033-3) は、Camellia、AES、SEED、CAST-128、MISTY1、Triple DES。
ストリーム暗号 MUGI MULTI-S01 SNOW 国際標準のストリーム暗号 (ISO/IEC18033-4) は、MUGI、MULTI-S01、SNOW。
公開鍵暗号 RSA RSA: Rivest - Shamir - Adleman - 大きな素数の素因数分解が難しいという根拠に基づいた暗号方式。 楕円曲線暗号 楕円曲線状での離散対数問題に基づいた公開鍵暗号方式。</description></item><item><title>画像処理メモ: 画像の 2 値化の閾値を求める方法いろいろ</title><link>https://maku.blog/p/uyp4geh/</link><pubDate>Fri, 25 May 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uyp4geh/</guid><description> 平均法（平均を取るだけ）← 使えない Pタイル法（物体・背景の面積が分かっている場合）← 自動ではない モード法（極小を求める）← グラフを滑らかにする必要がある 判別分析法（クラス間分散が最大となるところで２値化する）← Good</description></item></channel></rss>