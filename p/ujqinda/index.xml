<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>プログラミング on まくろぐ</title><link>https://maku.blog/p/ujqinda/</link><description>Recent content in プログラミング on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 09 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/ujqinda/index.xml" rel="self" type="application/rss+xml"/><item><title>プログラムでレインボーカラー（虹色）のグラデーションを作成するには</title><link>https://maku.blog/p/4cbbh6o/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4cbbh6o/</guid><description>とあるコーディングにおいて、色を滑らかに変化させる必要があったのでメモメモ。
RGB ではなく HSV で考える 何らかのプログラミング言語から虹色のグラデーションを作る必要がある場合、RGB の色空間で色調整を行うのは大変ですが、HSV の色空間で考えると簡単に表現することができます。
図: HSV 色空間 参考: HSV 色空間 - Wikipedia HSV はそれぞれ下記のような情報を表しており、
色相 (Hue): 0～360 彩度 (Saturation・Chroma): 0～1 明度 (Value・Brightness): 0～1 このうち、色相 (Hue) の値を 0～360 の間で変化させてやることでレインボーカラーを表現することができます。
プログラムのサンプル 図: 虹色グラデーションの描画 例えば、Android では、android.graphics.Color.HSVToColor() という関数を使用すると、HSV 色空間における値を、描画に使用するカラーデータに変換することができます。
下記の ColorGenerator クラスの nextColor() メソッドを連続して呼び出すと、徐々に変わっていく色をひとつずつ取り出すことができます。 やっていることは、メソッドの呼び出しごとに、色相 (Hue) の値を少しずつ変化させているだけです。 色相 (Hue) が、何度の nextColor() 呼び出しで一周するかは、コンストラクタの steps パラメータで指定できるようにしています。
ColorGenerator.kt class ColorGenerator(val steps: Int, initialHue: Float = 0.</description></item><item><title>private メソッドのユニットテストが書きたくなったら</title><link>https://maku.blog/p/nvetfsf/</link><pubDate>Thu, 16 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nvetfsf/</guid><description>private メソッドをテストすべきかどうかは色々意見がありますが、あるクラスの private メソッドの割合が、public メソッドに比べて非常に多くなった場合は、private メソッドのテストも書きたくなるかもしれません。
そのような場合は、クラス抽出のリファクタリングを考えるとよいです。 特定の処理がクラスとして抽出されれば、そのクラスを利用するインタフェースは public メソッドになるので、自然にテストを記述できるようになります。 もとのクラスの見通しもよくなり、一石二鳥です。
計算処理を担うようなメソッドはテストを記述するよい対象になりますが、private メソッドのままではテストが記述できません。 そのような場合は、public static なユーティリティメソッドに変更することで、テストを記述できるようにするとよいです。 そのメソッド内でフィールドにアクセスしないユーティリティメソッドになっていれば（ステートレス）、オブジェクトに副作用を与えることはないので、public メソッドにしても悪影響は出ません（カプセル化は崩れない）。
JxUnit のように private メソッドをテスト可能なフレームワークを使用するのもひとつの手です。 JxUnit は内部でリフレクションを利用して private メソッドのテストを可能にしています。</description></item></channel></rss>