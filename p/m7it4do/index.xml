<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React 雑多記事 on まくろぐ</title><link>https://maku.blog/p/m7it4do/</link><description>Recent content in React 雑多記事 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 18 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/m7it4do/index.xml" rel="self" type="application/rss+xml"/><item><title>React実装例: クリックで開閉可能なツリービューを作る</title><link>https://maku.blog/p/weow5dm/</link><pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/weow5dm/</guid><description>ここでは、React コンポーネントとして、開閉可能なツリービューを作ってみます。 コンポーネント名はツリーのノードを示す TreeNode です。
図: TreeNode コンポーネントの表示例 初期の表示内容としては、ルートの TreeNode を 1 つだけ配置し、そのラベルをクリックしたときに、子要素となる TreeNode を 3 つ生成して表示します。 実際のアプリケーションでは、このタイミングで GraphQL サーバーなどからデータを取得してツリー展開していく、といったことができると思います。
下記は TreeNode コンポーネントの実装です。
components/TreeNode.tsx import * as React from &amp;#39;react&amp;#39;; import styles from &amp;#39;./TreeNode.scss&amp;#39;; export const TreeNode: React.FC&amp;lt;{label: string}&amp;gt; = ({label}) =&amp;gt; { const [isOpen, setIsOpen] = React.useState(false); const [childNodes, setChildNodes] = React.useState(null); // チェックボックスのクリックで isOpen ステートを更新 const handleChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { setIsOpen(e.target.checked); } // isOpen ステートの変更を監視し、childNodes に子ノードとなる TreeNode をセットする React.</description></item><item><title>React アプリの中で D3.js を使ってチャートを描画する</title><link>https://maku.blog/p/j52iy4k/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j52iy4k/</guid><description>何をするか？ D3.js は、Web ブラウザ上で様々なデータをビジュアライズするためのデファクトスタンダードな描画ライブラリです。 ここでは、React (Next.js) アプリ内で、D3.js を使って簡単なチャートを描画してみます。
☝️ ほかの描画ライブラリ JavaScript による描画ライブラリには、他にも Chart.js や Mermaid.js などいろいろなものがあります。 Chart.js を使うと、折れ線グラフや散布図などを簡単に描画することができます。 Mermaid.js を使うと、独自フォーマットのテキストをもとにフローチャートなどを描画することができます。 これらの描画ライブラリは、D3.js と比べて簡単に使うことができますが、描画可能な図の種類は限られています。 一方、D3.js は高度なカスタマイズや自由度の高いデータの可視化が可能ですが、初学者にとってはやや学習コストが高くなっています。 D3.js のインストール NPM あるいは Yarn で、プロジェクトに D3.js の依存を追加します。 TypeScript を使用している場合は、D3.js 本体 (d3) に加え、型情報 (@types/d3) もインストールします。
D3.js のインストール（NPM の場合） $ npm install d3 $ npm install --save-dev @types/d3 D3.js のインストール（Yarn の場合） $ yarn add d3 $ yarn add --dev @types/d3 React コンポーネント内で D3.js を使う React アプリは作成済みであるとし、D3.js を使って描画を行うコンポーネントを新しく作成します。 次の HelloChart コンポーネントは、D3.</description></item><item><title>React で入力フォームの onChange イベントを IME ON のときに無視する</title><link>https://maku.blog/p/cv6fpx7/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cv6fpx7/</guid><description>何をするか？ React のテキスト入力フォーム（input コンポーネントや mui の TextField など）で onChange イベントハンドラーを設定すると、入力テキストが変化したときに任意の処理を行うことができます。 ただ、onChange イベントは IME での日本語変換中にも呼び出されてしまう ので、おそらく、想定しているよりも多く呼び出されてしまいます。 インクリメンタルサーチなどで、入力のたびに API 呼び出しをしているようなケースでは、この振る舞いは抑制しなければいけません。
ここでは、IME が ON になっているとき（つまり日本語変換中）に、onChange イベントを無視する実装例を紹介します。 このあたりの実装は、ブラウザごとの微妙な振る舞いの差（特に Esc キーで IME 入力をキャンセルした場合など）を考えると、結構複雑だったりします。
実装してみる React の input コンポーネントの onCompositionStart と onCompositionEnd イベントハンドラーを設定すると、IME を ON/OFF したタイミングを知ることができます。 そのタイミングで、isImeOn のようなフラグを制御すれば、必要に応じて onChange イベントを無視できるようになります。
// import { FC, useRef, useState } from &amp;#39;react&amp;#39; const SearchBox: FC = () =&amp;gt; { // 現在 IME ON（変換中）かどうかのフラグ const isImeOn = useRef(false) // 以前の入力テキスト（ブラウザごとの onChange の振る舞いの差異への対策） const [prevText, setPrevText] = useState(&amp;#39;&amp;#39;) // 入力テキストを処理する const handleChange = (text: string) =&amp;gt; { if (prevText === text) return if (text === &amp;#39;&amp;#39;) { // Chrome ではテキストクリア時に onCompositionEnd が呼ばれないことがある isImeOn.</description></item><item><title>React の props.children の型定義には ReactNode を使う</title><link>https://maku.blog/p/xenv4bh/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xenv4bh/</guid><description>children の型定義 TypeScript で React の関数コンポーネントを定義するときには、下記のような React.FC (React.FunctionComponent) を使用します。
type FC&amp;lt;P = {}&amp;gt; = FunctionComponent&amp;lt;P&amp;gt;; interface FunctionComponent&amp;lt;P = {}&amp;gt; { (props: PropsWithChildren&amp;lt;P&amp;gt;, context?: any): ReactElement&amp;lt;any, any&amp;gt; | null; propTypes?: WeakValidationMap&amp;lt;P&amp;gt; | undefined; contextTypes?: ValidationMap&amp;lt;any&amp;gt; | undefined; defaultProps?: Partial&amp;lt;P&amp;gt; | undefined; displayName?: string | undefined; } // ... type PropsWithChildren&amp;lt;P&amp;gt; = P &amp;amp; { children?: ReactNode | undefined }; FC の型パラメータ P は、上記のような PropsWithChildren 型にラップされるので、props の型定義をするときに明示的に children を含める必要はありません。 下記の ColorBox コンポーネントは、指定した背景色で子要素 (children) を表示します。</description></item><item><title>React の JSX 記述のコツ</title><link>https://maku.blog/p/xjv6gqy/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjv6gqy/</guid><description>React アプリケーションでは、コンポーネントの UI を JSX 構文を用いて記述します。 下記は、JSX コードを記述するときのポイントのまとめです。 通常の JavaScript コードとは異なる記述方法が必要になるため慣れが必要ですが、ここに挙げたポイントをおさえておけば大体対応できます。
JSX の最上位要素はひとつ JSX 要素を作成するとき、トップレベルの要素は 1 つだけにする必要があります。 次のコードでは、トップレベルに 2 つの p 要素が並んでいるのでエラーになります。
ダメな例 const MyComponent: React.FC = () =&amp;gt; { return ( &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; ) } これを解決するには、例えば次のようにルート要素として div を配置します。
return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ) もちろん、これはこれで動作するのですが、ルートに余計な div 要素が作られてしまうのを防ぎたいときは、次のように &amp;lt;&amp;gt;...&amp;lt;/&amp;gt; で囲います（これは &amp;lt;React.Fragment&amp;gt; の省略記法です）。
return ( &amp;lt;&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; ) 条件を満たすときのみ出力する 次のコードは、n &amp;gt; 0 を満たしたときに、後半の p 要素を表示します。
return &amp;lt;&amp;gt; {n &amp;gt; 0 &amp;amp;&amp;amp; &amp;lt;p&amp;gt;条件を満たしたよ&amp;lt;/p&amp;gt;} &amp;lt;/&amp;gt; JSX コードの中では、if や for といった値を返さない文 (statement) を記述することができません。 なので、出力を条件分岐させたいときは、この例のように、&amp;amp;&amp;amp; や || のような演算子を駆使する必要があります。</description></item><item><title>React Router でコンポーネントの表示・非表示を切り替える</title><link>https://maku.blog/p/nfxds8n/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nfxds8n/</guid><description>React の Router 系コンポーネント (BrowserRouter / HashRouter / MemoryRouter) を使用すると、論理的なパス管理によって React コンポーネントの表示の On/Off を切り替えることができます。 例えば、/users というパスでアクセスしたときには Users コンポーネントを表示し、/projects というパスでアクセスしたときには Projects コンポーネントを表示する、といったことを実現できます。
react-router-dom のインストール Router 系のコンポーネントは react-router-dom モジュールで提供されているので、まずはこれをインストールします。 TypeScript を使用する場合は、型定義ファイルも一緒にインストールしておきます。
$ npm install --save react-router-dom $ npm install --save-dev @types/react-router-dom BrowserRouter による表示切り替え 図: Router による表示切り替え 次の App コンポーネントでは、BrowserRouter コンポーネントを使って、Page1 と Page2 コンポーネントの表示を切り替えます。 Router 系のコンポーネントには、Router というエイリアス名を付けるのが慣例なのでそれに従います。 Router コンポーネントの下には、表示切り替え用のリンク要素として Link コンポーネントを配置し、表示要素として Route コンポーネントを配置します。
components/App.tsx import * as React from &amp;#39;react&amp;#39; import { BrowserRouter as Router, Link, Route } from &amp;#39;react-router-dom&amp;#39; // 子コンポーネントを適当に用意 const Page1: React.</description></item><item><title>React でモーダルダイアログを表示する (react-modal)</title><link>https://maku.blog/p/q6fnu29/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q6fnu29/</guid><description>react-modal パッケージが提供する ReactModal コンポーネントを使用すると、React アプリ内で簡単にモーダルダイアログを実現することができます。
上記は、設定 ボタンを押してモーダルな設定ダイアログを開いたときの表示例です。
react-modal のインストール ReactModal コンポーネントを使うために、react-modal パッケージと TypeScript の型定義ファイルをインストールします。
$ npm install --save react-modal $ npm install --save-dev @types/react-modal ReactModal コンポーネントを使用する ReactModal の使い方 ReactModal コンポーネントは、isOpen プロパティでダイアログの表示・非表示を制御するようになっています。
// import ReactModal from &amp;#39;react-modal&amp;#39;; &amp;lt;ReactModal isOpen={this.props.isOpen} onAfterOpen={this.handleOpen} onRequestClose={this.handleClose} style={this.customStyles} contentLabel=&amp;#34;Settings&amp;#34; &amp;gt; // ... フォームの内容などをここに記述 ... &amp;lt;/ReactModal&amp;gt; onAfterOpen でオープン時、onRequestClose でクローズ時のイベントをハンドルすることができます。 ReactModal は自分自身のダイアログを自動で閉じたりしないので、onRequestClose に設定したハンドラ内で、isOpen プロパティに渡す値を false に設定してダイアログを閉じる必要があります。 onRequestClose ハンドラは、Esc キーを押したときや、ダイアログ外の領域をクリックしたときなどに呼び出されます。
コンポーネントの作成 下記のサンプルコードは ReactModal を使ったコンポーネントの作成例です。 ここでは、ユーザー名を入力可能な設定ダイアログを想定しています。 React を使ったフォームの作成方法などは次の記事を参照してください。
参考: React コンポーネントでフォームの入力を処理する components/settingsDialog.</description></item><item><title>React コンポーネントに CSS スタイルを設定する</title><link>https://maku.blog/p/eu4cksy/</link><pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eu4cksy/</guid><description>React は Web サイトの View レイヤのコンポーネントを作るためのライブラリですが、CSS ファイルの扱い方は特に決められておらず、今でも多くの人が試行錯誤しています。 ここでは、React アプリにおける CSS の扱い方を、下記のように分類して順番に説明していきます。
従来通り HTML 起点でスタイルを読み込む方法 インラインスタイル CSS Modules CSS in JS ライブラリ HTML ファイルで読み込んだ CSS ファイルを参照する これは React を使わない従来の HTML/CSS のやり方に近い方法です。 HTML ファイル内の style 要素で定義した CSS クラスや、HTML から読み込んだ CSS ファイル内で定義した CSS クラスを React コンポーネントから使用します。
例えば、HTML ファイル内で次のようにスタイル定義されているとします。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;MyApp&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;style&amp;gt; .hello { color: blue; background: #aaccff; padding: 0.5em; font-weight: bolder; border-radius: 0.5em; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;index.</description></item></channel></rss>