<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GitHubメモ on まくろぐ</title><link>https://maku.blog/p/5q4fr3d/</link><description>Recent content in GitHubメモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 26 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/5q4fr3d/index.xml" rel="self" type="application/rss+xml"/><item><title>GitHub OAuth トークンを取得する (1) 処理の流れを理解する</title><link>https://maku.blog/p/ubkt3ai/</link><pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ubkt3ai/</guid><description>GitHub の OAuth トークンとは GitHub API を使って GitHub 上の情報（リポジトリ情報やユーザー情報）を取得するには、GitHub によって発行されるアクセストークンが必要です。 GitHub API ver.3 (REST API) ではアクセストークンを必要としない API もありましたが、GitHub API ver.4 (GraphQL API) では必ずアクセストークンが必要です。
アクセストークンにはいくつか種類があり、GitHub の Web サイト上で作成する パーソナルアクセストークン や、Web アプリの OAuth プロセスで取得する OAuth アクセストークン などがあります。 アクセストークンの取得方法は異なりますが、いずれも取得した後は同じように使用できます。
パーソナルアクセストークン : ユーザーが GitHub サイト上で作成 OAuth アクセストークン : Web アプリ内の OAuth プロセスで取得 通常、Web アプリから GitHub API を使用する場合は、後者の OAuth を使用してアクセストークンの取得を自動化します。 ここでは、GitHub の OAuth アクセストークン取得の流れを、実装コードを示しながら説明していきます。
GitHub の OAuth の流れ (Web application flow) Web アプリから OAuth トークンを取得するまでの流れはざっと次のような感じになります。</description></item><item><title>GitHub OAuth トークンを取得する (2) Azure Functions 経由で取得する</title><link>https://maku.blog/p/ar2bjs2/</link><pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ar2bjs2/</guid><description>何をするか？ ここでは、静的な Web サイト（の JavaScript) から、GitHub の OAuth トークンを取得できるようにしてみます。 この処理を実装すると、GitHub と連携した Web アプリを、GitHub Pages や Azure Static Web Apps などの、静的サイト用のホスティングサービス上で公開できるようになります。 汎用的な Web サーバー（VPSなど）でホスティングする場合と比べ、非常に安価に運用することができます。
前提知識として、下記の GitHub の OAuth トークン取得の流れを理解しているものとします。
参考: GitHub OAuth トークンを取得する (1) 処理の流れを理解する 静的な Web サイトから GitHub のアクセストークンを取得するときにネックになるのが、クロスオリジン通信 (CORS) の制約です。 また、GitHub のアクセストークンリクエストには、クライアントシークレット情報が必須であり（2020年、2021年現在）、これをクライアントサイドの JavaScript にハードコードするわけにはいきません。 よって、ブラウザ上で実行される JavaScript からは、実質アクセストークンの取得ができないので、何らかのバックエンドサーバーを介す形でアクセストークンを取得する必要があります。
バックエンドサーバーはどのようなものでも構わないのですが、ここではサーバーレス環境である Azure Functions を使ってアクセストークンの取得機能を実装します。
Azure Functions に関数を追加する Azure Functions に HTTP トリガーで起動する関数を追加し、GitHub の OAuth トークンを取得する処理を実装します。 まずは下記の記事を参考にして、Functions アプリ（プロジェクト）を作成してください。
参考: Azure Functions で簡単な関数を作ってみる 作成する関数の仕様は次のとおりとします。</description></item><item><title>Apollo Client で GitHub GraphQL API を使う (Node &amp; React)</title><link>https://maku.blog/p/qcp2cnx/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2cnx/</guid><description>Apollo Client とは Apollo パッケージは、GraphQL を使ったクライアントアプリやサーバーを作成するためのライブラリ群です。 クライアントアプリを作るためのライブラリは、Apollo Client として @apollo/client という NPM パッケージにまとめられています。
Web アプリのコンポーネントを作成するときは React がよく使われますが、Apollo は GraphQL を扱いやすくする React コンポーネント（ApolloProvider、Query、Mutation、Subscription）や React Hook 拡張（useQuery) などを提供しています。
ここでは、Apollo Client パッケージを使用して、
Node.js アプリ（コマンドラインアプリの JS）から GraphQL API の実行 React アプリ（Web サイトの JS）から GraphQL API の実行 を行ってみます。 呼び出す GraphQL API は何でもよいのですが、今回は GitHub GraphQL API を利用することにします。
Node パッケージのインストール Apollo Client Apollo Client 関連のパッケージとしては、@apollo/client と、それが使用する graphql をインストールします。
Apollo Client のインストール ### yarn の場合 $ yarn add @apollo/client graphql ### npm の場合 $ npm install @apollo/client graphql fetch ポリフィル Apollo クライアント内部の実装では、Web ブラウザの fetch API を利用しています。 React アプリから Apollo クライアントを利用する場合は問題ないのですが、コンソールで動作する Node.</description></item><item><title>GitHub Actions でコンテナイメージをビルドして Docker Hub へ push する</title><link>https://maku.blog/p/v9r8o5k/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v9r8o5k/</guid><description>何をするか？ Docker イメージを作成するための Dockerfile を GitHub のリポジトリで管理しているとします。 ここでは、GitHub Actions のワークフローを作成して、GitHub リポジトリにコードを push したときに次のような処理が自動で実行されるようにします。
Dockerfile を使ってイメージをビルド Docker Hub にイメージを push 前提条件として、Docker Hub のアカウントは作成済みとします。
Dockerfile の準備 GitHub のリポジトリを作成して、ルートディレクトリに次のような Dockerfile をコミット＆プッシュしておきます。
Dockerfile FROMalpine:3CMD [&amp;#34;echo&amp;#34;, &amp;#34;Hello World&amp;#34;] 上記のサンプルコードは、軽量の Alpine Linux で Hello World と出力するだけの Dockerfile ですが、もちろん好きなように記述していただいて構いません。
GitHub Actions の Secrets 情報を登録 GitHub Actions から Docker Hub にイメージをプッシュできるようにするため、GitHub リポジトリの Secrets 情報として、Docker Hub のユーザー名およびアクセストークンを登録しておきます。
Docker Hub のアクセストークンは次のように発行できます。
Docker Hub にサインイン 右上のユーザー名をクリックして、Account Settings を選択 Security → New Access Token と選択して、トークンの説明文を入力 Access Token description: Deploy hello world など適当に入力 Access permissions: 少なくとも Read, Write を付ける Generate ボタンを押して生成 これで、次のような感じのアクセストークンが発行されるので、どこかにコピーしておきます（後から確認することはできません）。</description></item><item><title>GitHub Actions で Hugo サイトをビルドして VPS サーバーに rsync デプロイする</title><link>https://maku.blog/p/un3gu8m/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/un3gu8m/</guid><description>何をするか？ Web サイトのコンテンツを GitHub で管理し、さくらの VPS や、お名前.com の VPS で Web サーバーを運用している場合、GitHub Actions でビルドとデプロイを自動化すると便利です。 ここでは、Web サイトのビルドに Hugo、VPS サーバーへのデプロイに rsync を使う前提で、次のような手順で自動化を進めていきます。
SSH 鍵を作成する（自動デプロイのためパスワードは設定しない） VPS 側に SSH 公開鍵を登録する GitHub Actions のシークレットとして SSH 秘密鍵を登録する GitHub Actions のワークフローを作成し、ビルド (Hugo) とデプロイ (rsync) を自動化する Web サイトのビルドには何を使ってもよいのですが、現時点でおそらく最速の静的サイトジェネレーターである Hugo を例にして説明しています。 GitHub Actions による自動化が完了すると、GitHub の main ブランチに Web サイトコンテンツを push するだけで、Hugo によるビルドと rsync による VPS へのデプロイが自動で行われるようになります。
SSH キーペアを作成して VPS へ公開鍵を登録する rsync コマンドで使用する SSH 鍵を ssh-keygen コマンドで作成しておきます。 GitHub Actions から rsync コマンドを実行するので、SSH 秘密鍵にはパスワードを設定しないようにします。 次の例では、github-actions / github-actions.</description></item><item><title>GitHub GraphQL のスキーマ情報を取得する</title><link>https://maku.blog/p/whv8it5/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whv8it5/</guid><description>GitHub API のサイトからダウンロードする方法 次のサイトから GitHub GraphQL API のスキーマ定義ファイル (schema.docs.graphql) をダウンロードすることができます。
パブリックスキーマ - GitHub Docs 例えば、このファイル内の Query オブジェクト (type Query) の定義を見ると、クエリのトップレベルにどのようなオブジェクト（フィールド）を指定できるかが分かります。
schema.docs.graphql typeQuery{...organization(login:String!):Organization...user(login:String!):User} 上記の場合、Query オブジェクト内に organization や user フィールドが定義されているので、クライアントアプリからクエリ要求を出すときに、次のような感じで指定できるということが分かります。
query{organization(login:&amp;#34;netflix&amp;#34;){namedescriptionavatarUrl}user(login:&amp;#34;octocat&amp;#34;){namecompanyurlavatarUrl}} スキーマ定義ファイル (.graphql) とクライアントアプリ側のクエリ定義 (query {...}) を組み合わせることで、TypeScript 用の型定義ファイルを自動生成することができます（クエリ要求の戻り値の型を定義できます）。 詳しくは、Apollo CLI などのコマンドラインツールを確認してください。
GraphQL サーバーから直接取得する方法 GitHub の GraphQL API サーバーに HTTP GET リクエストを送ることで、スキーマ定義を直接取得することができます。 パーソナルアクセストークンはこちら から生成してください。
$ token=&amp;lt;YOUR_PERSONAL_ACCESS_TOKEN&amp;gt; $ curl -H &amp;#34;Authorization: bearer $token&amp;#34; https://api.github.com/graphql 結果は圧縮された JSON テキストで返されます。 python -m json.</description></item><item><title>GitHub Pages で React Router を使った SPA サイトを動かす方法</title><link>https://maku.blog/p/9u8it5f/</link><pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9u8it5f/</guid><description>React Router などを使った SPA (Single Page Application) な Web サイトは、GitHub Pages でそのまま動作させようとしてもうまく動きません。 ここでは、その理由と、対応方法について説明します。
GitHub Pages で SPA サイトが動作しない理由 たとえば、React Router を使った Web サイトは、次のような URL を使って目的のコンテンツ (/book/123) を表示するようルーティングします。
https://yourname.github.io/repo-name/book/123 React Router を使ったアプリで、この URL を実際に処理するファイルは、
https://yourname.github.io/repo-name/index.html であり、そこに記述された JavaScript ファイル内で、URL の末尾の /book/123 という部分をルーティング用のパス文字列として処理します。 つまり、前述の URL の /book/123 という部分は、単なるアプリ用のデータであり、実際に存在するファイルを示しているわけではありません。
一方、GitHub Pages はそのような事情を知らないので、/book/123 という URL でアクセスしようとすると、/book/123/index.html というファイルを見つけようとして 404 エラー になってしまいます。
先頭ページ (/index.html) を開いた後で、JavaScript でルーティング（React の Link コンポーネントによる遷移）を行っている間はうまく動作するのですが、ページをリロードしたり、Web ブラウザのアドレスバーに URL を直接入力したりすると、やはり 404 エラーになってしまいます。 OAuth 認証を使用した Web サイトの場合は、リダイレクトによって指定された URL へのアクセスが必要になるため、これは大きな制約になります。</description></item><item><title>GitHub Pages で Jekyll による変換を無効化する（プッシュした HTML をそのまま表示する）</title><link>https://maku.blog/p/my8fmsy/</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/my8fmsy/</guid><description>GitHub プロジェクトの設定画面から、GitHub Pages を有効化すると、簡単にウェブサイトをホスティングすることができます。 デフォルトでは、リポジトリ内の Markdown ファイル (.md) が Jekyll によって HTML に変換されるのですが、直接 HTML ファイルをデプロイする場合は、この変換処理は無駄です。
そのような場合は、次のようにして Jekyll による変換を無効化できます。
リポジトリのルート（GitHub Pages のソースディレクトリ）に .nojekyll ファイルを置く これだけです。
Hugo などの静的 Web サイト生成ツールで作成したサイトをデプロイするような場合は、この設定を行っておくと、ファイルのプッシュ後に GitHub Pages に反映されるまでの時間がほんの少し早くなるかもしれません。
速度を気にしない場合はこの設定をする必要はありませんが、プッシュする Web サイトリソース内に、アンダースコア (_) で始まるファイルやディレクトリなどが含まれている場合は、この設定は必須になります。 なぜなら、Jekyll がアンダースコアで始まるファイルやディレクトリを取り除いてしまうからです。
GitHub Pages のソースブランチとして gh-pages ブランチを設定している場合は、そのブランチのルートに .nojekyll を配置しなければいけないことに注意してください。 ちなみに、GitHub Actions でデプロイするときに、peaceiris/actions-gh-pages を使っている場合は、自動的にデプロイ先のブランチ (gh-pages) に .nojekyll ファイルを作成してくれます。
- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:.</description></item><item><title>GitHub Actions で Web サイトをビルドして GitHub Pages へ公開する</title><link>https://maku.blog/p/5q3eq2c/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q3eq2c/</guid><description>何をするか？ GitHub Actions を使うと、GitHub で管理されている Web サイト用リソースの「ビルドとデプロイ」を簡単に自動化することができます。
ここでは、
npm run build による Web サイトのビルド ビルドされたリソースの GitHub Pages へのデプロイ（gh-pages ブランチ） を行う設定を行います。 最終的に、https://yourname.github.io/project名/ という URL で Web サイトが公開されます。
前提条件として、GitHub リポジトリに npm run build でビルド可能な Web サイト用リソースがコミットされているものとします。
☝️ 他のビルド方法は？ ここでは、npm run build による Web サイトのビルドを前提としましたが、例えば、Hugo によるビルドなどもほぼ同様に行えます。 GitHub Actions の設定 GitHub プロジェクトの Actions タブから、次のように新規ワークフローを作成します。
set up a workflow yourself をクリック main.yml の編集画面になるので、次のように入力して Start commit ボタンを押す .github/workflows/main.yml name:Build and deploy websiteon:push:branches:[master ]jobs:build:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v2- name:Setup Node.</description></item><item><title>Parcel でビルドした Web サイトが GitHub Pages で動作しないとき</title><link>https://maku.blog/p/m7jw8ju/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7jw8ju/</guid><description>React アプリを Parcel でビルドして GitHub Pages で公開しようとしたら、真っ白な画面になってしまったので対応方法のメモです。 原因は、トップページの index.html から読み込んでいる JavaScript ファイルのパスが、/index.js のように、ドメインルートからの相対パスになっていることでした。
GitHub Pages で公開する Web サイトの URL が、
https://yourname.github.io/ であれば問題ないのですが、
https://yourname.github.io/project名/ になっている場合は、読み込むファイルは /project名/index.js になっていないといけません。 これを解決するには、例えば、Parcel でビルドしているときは --public-url オプションを使って、次のように指定します。
$ parcel build src/index.html -d build --public-url &amp;#34;/project名/&amp;#34; こうすることで、トップページから /index.js というパスで参照していたものが /project名/index.js に変わってうまく動作するようになります。
npm run build で Web サイトのビルドを行っているのであれば、package.json 内のスクリプト定義で次のように記述しておけばよいでしょう。
package.json { // ... &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;parcel src/index.html --open&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;rm -rf build &amp;amp;&amp;amp; parcel build src/index.</description></item><item><title>GitHub GraphQL API の呼び出し回数制限 (rate limit) の情報を取得する</title><link>https://maku.blog/p/bqz7emt/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bqz7emt/</guid><description>GitHub API を使ったアプリケーションを作成するときは、API の呼び出し回数制限を意識した設計を行う必要があります。 GitHub API バージョン3 の REST API には、1 時間に 5000 リクエストまでという明確な呼び出し回数制限がありましたが、API バージョン4 の GraphQL API はそのクエリの性質上、ちょっと異なるコスト計算方法が採用されています。
GraphQL resource limitations | GitHub Developer Guide 正確な計算方法は上記のサイトに記述されていますが、簡単にいうと、GraphQL クエリの入れ子階層が深くなり、複雑になるほどコストがかかるという計算になっています。
ある GraphQL クエリが実際にどれだけのコストがかかるかは、下記のように rateLimit 情報を取得することで調べることができます。
query{rateLimit{limitcostremainingresetAt}search(query:&amp;#34;repo:electron/electron is:issue&amp;#34;,type:ISSUE,first:5){issueCountnodes{...onIssue{titlelabels(first:10){nodes{name}}}}}} 上記のクエリを実行すると、次のような感じの JSON レスポンスが返ってきます。
{ &amp;#34;data&amp;#34;: { &amp;#34;rateLimit&amp;#34;: { &amp;#34;limit&amp;#34;: 5000, &amp;#34;cost&amp;#34;: 1, &amp;#34;remaining&amp;#34;: 4999, &amp;#34;resetAt&amp;#34;: &amp;#34;2020-08-02T09:15:20Z&amp;#34; }, &amp;#34;search&amp;#34;: { &amp;#34;issueCount&amp;#34;: 13278, &amp;#34;nodes&amp;#34;: [ // ... ] } } } rateLimit の各プロパティの値は次のような意味を持っています。</description></item></channel></rss>