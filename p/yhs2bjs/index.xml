<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MongoDB 雑多メモ on まくろぐ</title><link>https://maku.blog/p/yhs2bjs/</link><description>Recent content in MongoDB 雑多メモ on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Fri, 02 Feb 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/p/yhs2bjs/index.xml" rel="self" type="application/rss+xml"/><item><title>MongoDB のインデックスについて</title><link>https://maku.blog/p/gii3wtb/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0900</pubDate><guid>https://maku.blog/p/gii3wtb/</guid><description>&lt;p>MongoDB で大量のデータを扱う場合、高速な検索を実現するためにインデックスを作成しておく必要があります。
インデックスの詳細は &lt;a href="https://www.mongodb.com/docs/manual/indexes/">公式ドキュメント&lt;/a> にありますが、ちょっとややこしいのでポイントだけまとめておきます。&lt;/p>
&lt;h2 id="インデックスがないとシーケンシャルサーチになる">インデックスがないとシーケンシャルサーチになる&lt;/h2>
&lt;p>MongoDB のフィールドのうち、デフォルトでインデックスが作成されるのは &lt;code>_id&lt;/code> フィールドだけです（削除もできません）。
インデックスが作成されていないフィールドを検索しようとすると、コレクション全体のシーケンシャルサーチ（線形探索）になるので、データ数が増えるごとに検索速度は遅くなっていきます。&lt;/p>
&lt;p>特定のフィールドに対するインデックスを作成すると、内部的に &lt;a href="https://ja.wikipedia.org/wiki/B%E6%9C%A8">B-tree（B 木）&lt;/a> 構造の逆引きデータが作られるので、そのフィールドの値での検索が高速になります。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">score フィールド用のインデックスを作成する&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createIndex&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">score&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">})&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>インデックス情報は昇順 (1: ascending) あるいは降順 (-1: descending) で並べられているため、値の完全一致だけではなく、大小比較による検索も高速に行えます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">score フィールドが 70 以上のドキュメントを検索&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">score&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$gte&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">70&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">})&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="複合インデックス-compound-indexes">複合インデックス (Compound Indexes)&lt;/h2>
&lt;p>複合インデックス (Compound Indexes) というのを作成しておくと、複数のフィールド値を指定した高速検索が可能になります。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">genre フィールドと price フィールドの複合インデックスを作成&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createIndex&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">genre&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">price&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">})&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>フィールド名の後ろの数値は、内部的にインデックスがどのような順序で保持されるかという sort order を示しており、&lt;strong>1&lt;/strong>（昇順: ascending）あるいは &lt;strong>-1&lt;/strong>（降順: descending）を指定します。
検索結果をソートしたい場合、この sort order 通りのソート順序であれば高速にソートされます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">複合インデックスを利用したソート&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({}).&lt;/span>&lt;span class="nx">sort&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">genre&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">price&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({}).&lt;/span>&lt;span class="nx">sort&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">genre&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">price&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">})&lt;/span> &lt;span class="c1">// 完全に逆順でも高速になる
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>複合インデックスによる検索は、すべてのフィールドを指定する必要はなく、途中までのフィールドの値を指定した場合も高速な検索が可能です。
このような仕様のため、複合インデックスにおけるフィールドの指定順序は重要です。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">複合インデックスを利用した検索&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 複合インデックスが使用される検索方法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">genre&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;RPG&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">price&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$gt&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">genre&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;RPG&amp;#34;&lt;/span> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 複合インデックスが使われない検索（フィールドの指定順序が間違っている）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">price&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$gt&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="nx">genre&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;RPG&amp;#34;&lt;/span> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">price&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$gt&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="p">})&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="テキストインデックス-text-indexes">テキストインデックス (Text Indexes)&lt;/h2>
&lt;p>インデックスには大まかに下記の 2 種類があります。&lt;/p>
&lt;ul>
&lt;li>通常のインデックス &amp;hellip; フィールド単位で完全一致、あるいは大小比較で高速検索&lt;/li>
&lt;li>テキストインデックス &amp;hellip; テキスト形式のフィールド内から部分文字列を高速検索&lt;/li>
&lt;/ul>
&lt;p>要するに、テキストの全文検索のようなことをやりたいときは、通常のインデックスではなく、テキストインデックスを作成する必要があります（参考: &lt;a href="https://www.mongodb.com/docs/manual/core/indexes/index-types/index-text/">Text Indexes — MongoDB Manual&lt;/a>）。&lt;/p></description></item><item><title>MongoDB Atlas で不用意なコレクションの削除を防ぐ（読み込み専用ユーザー）</title><link>https://maku.blog/p/tzpxtnm/</link><pubDate>Wed, 27 Dec 2023 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tzpxtnm/</guid><description>&lt;p>MongoDB の API は直感的でわかりやすいですが、開発中に手がすべって &lt;code>db.drop()&lt;/code> や &lt;code>collection.drop()&lt;/code> を実行してしまうと、データベースやコレクションが丸ごと削除されて悲しいことになります。
本番環境での運用時はもちろん、開発中もこのようなミスが起こらないように設定しておくと安心です。&lt;/p>
&lt;p>例えば、MongoDB 本家のサービスである MongoDB Atlas では、Database ユーザーごとに Role を設定して権限を絞ることができます。&lt;/p>
&lt;div class="xNote">
 &lt;span class="xNote_title">☝️ Database ユーザーとは&lt;/span>
 &lt;span class="xNote_body">MongoDB Atlas の Database ユーザーとは、Node.js アプリなどからサーバーに接続するときに接続文字列 (SRV URI) 内で指定するユーザーのことを示しています。
Atlas サービス自体のアカウントとは別ものなので注意してください。
Database ユーザーは複数作成することができ、用途ごとに Role を割り当てることができます。
例えば、バックアップ用の &lt;code>backup&lt;/code> ユーザーには読み込み権限だけを与えておいて、バックアップツールの実装では、このユーザーを接続 URI で指定するようにします。&lt;/span>
&lt;/div>
&lt;p>次の例では、ユーザー (&lt;code>readuser&lt;/code>) に、&lt;strong>&lt;code>Only read any database (readAnyDatabase)&lt;/code>&lt;/strong> という Role を設定して、データベースの読み込みだけを許可しています。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="border: solid #ccc 2px;" width="2159" height="1873" src="../../p/tzpxtnm/img-001.png" alt="/p/tzpxtnm/img-001.png" />
 &lt;figcaption>図: MongoDB Atlas のユーザー Role 設定&lt;/figcaption>
&lt;/figure>

&lt;p>これで、Node.js アプリなどから次のような URI で MongoDB Atlas に接続した場合は、データベースの読み込みだけが可能になります。&lt;/p>
&lt;pre tabindex="0">&lt;code>mongodb+srv://readuser:&amp;lt;password&amp;gt;@&amp;lt;cluster&amp;gt;.&amp;lt;random&amp;gt;.mongodb.net:55001/
&lt;/code>&lt;/pre>&lt;p>組み込みの Role としては以下が用意されていますが、一般的なアプリケーション用の Role であれば、Atlas admin (atlasAdmin) を選択する必要はありません。
コレクションへの書き込みが必要なバックエンド用であれば、&lt;strong>&lt;code>Read and write to any database (readWriteAnyDatabase)&lt;/code>&lt;/strong> という Role を選択します。&lt;/p></description></item><item><title>MongoDB の ObjectId について（Document の生成時間を調べる）</title><link>https://maku.blog/p/wdbr8dx/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/wdbr8dx/</guid><description>&lt;p>MongoDB の各 Document（RDB でいうレコード）は、それぞれ &lt;strong>&lt;code>_id&lt;/code>&lt;/strong> というプライマリキーとなるフィールドを持っています。
この値は、何も指定しないと、自動的に &lt;strong>&lt;code>ObjectId&lt;/code>&lt;/strong> オブジェクトが生成されて設定されます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">&amp;gt; db.mycollection.insert({value:100})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; db.mycollection.findOne()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{ &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;5265e358c76d2a2f8b870057&amp;#34;), &amp;#34;value&amp;#34; : 100 }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>この &lt;code>ObjectId&lt;/code> オブジェクトは &lt;a href="http://bsonspec.org/">BSON 形式&lt;/a> のオブジェクトで、内部的に以下のような値を保持しています。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>フィールド&lt;/th>
 &lt;th>サイズ&lt;/th>
 &lt;th>内容&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;b>Timestamp&lt;/b>&lt;/td>
 &lt;td>4 bytes&lt;/td>
 &lt;td>生成時間（秒）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;b>Machine ID&lt;/b>&lt;/td>
 &lt;td>3 bytes&lt;/td>
 &lt;td>マシン固有値&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;b>PID&lt;/b>&lt;/td>
 &lt;td>2 bytes&lt;/td>
 &lt;td>プロセス ID&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;b>Counter&lt;/b>&lt;/td>
 &lt;td>3 bytes&lt;/td>
 &lt;td>ランダム値から始まってインクリメントされる&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;code>ObjectId&lt;/code> オブジェクト内に含まれているタイムスタンプは、&lt;strong>&lt;code>getTimestamp()&lt;/code>&lt;/strong> メソッドによって取得できます。
これを利用すると、Document の &lt;code>_id&lt;/code> フィールドから、その Document が生成された時間を調べることができます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">&amp;gt; db.mycollection.findOne()._id.getTimestamp()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ISODate(&amp;#34;2013-10-22T02:30:48Z&amp;#34;)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;aside style="display: flex; border: thin dashed gray;">
&lt;div style="align-self: stretch; writing-mode: vertical-lr; text-align: center; letter-spacing: 0.2em; color: #666; border-right: thin dashed gray; padding: 0.4em 0; line-height: 1.5;">参考&lt;/div>
&lt;div style="align-self: center; padding: 0.6em 0; line-height: 1.2 !important;">&lt;ul>
&lt;li>&lt;a href="http://docs.mongodb.org/manual/reference/object-id/">ObjectId — MongoDB Manual&lt;/a>&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/aside></description></item></channel></rss>