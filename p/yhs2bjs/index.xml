<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MongoDB 雑多メモ on まくろぐ</title><link>https://maku.blog/p/yhs2bjs/</link><description>Recent content in MongoDB 雑多メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 02 Feb 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/p/yhs2bjs/index.xml" rel="self" type="application/rss+xml"/><item><title>MongoDB のインデックスについて</title><link>https://maku.blog/p/gii3wtb/</link><pubDate>Fri, 02 Feb 2024 00:00:00 +0900</pubDate><guid>https://maku.blog/p/gii3wtb/</guid><description>MongoDB で大量のデータを扱う場合、高速な検索を実現するためにインデックスを作成しておく必要があります。 インデックスの詳細は 公式ドキュメント にありますが、ちょっとややこしいのでポイントだけまとめておきます。
インデックスがないとシーケンシャルサーチになる MongoDB のフィールドのうち、デフォルトでインデックスが作成されるのは _id フィールドだけです（削除もできません）。 インデックスが作成されていないフィールドを検索しようとすると、コレクション全体のシーケンシャルサーチ（線形探索）になるので、データ数が増えるごとに検索速度は遅くなっていきます。
特定のフィールドに対するインデックスを作成すると、内部的に B-tree（B 木） 構造の逆引きデータが作られるので、そのフィールドの値での検索が高速になります。
score フィールド用のインデックスを作成する coll.createIndex({ score : 1 }) インデックス情報は昇順 (1: ascending) あるいは降順 (-1: descending) で並べられているため、値の完全一致だけではなく、大小比較による検索も高速に行えます。
score フィールドが 70 以上のドキュメントを検索 coll.find({ score: { $gte: 70 } }) 複合インデックス (Compound Indexes) 複合インデックス (Compound Indexes) というのを作成しておくと、複数のフィールド値を指定した高速検索が可能になります。
genre フィールドと price フィールドの複合インデックスを作成 coll.createIndex({ genre: 1, price: -1 }) フィールド名の後ろの数値は、内部的にインデックスがどのような順序で保持されるかという sort order を示しており、1（昇順: ascending）あるいは -1（降順: descending）を指定します。 検索結果をソートしたい場合、この sort order 通りのソート順序であれば高速にソートされます。
複合インデックスを利用したソート coll.find({}).sort({ genre: 1, price: -1 }) coll.</description></item><item><title>MongoDB Atlas で不用意なコレクションの削除を防ぐ（読み込み専用ユーザー）</title><link>https://maku.blog/p/tzpxtnm/</link><pubDate>Wed, 27 Dec 2023 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tzpxtnm/</guid><description>MongoDB の API は直感的でわかりやすいですが、開発中に手がすべって db.drop() や collection.drop() を実行してしまうと、データベースやコレクションが丸ごと削除されて悲しいことになります。 本番環境での運用時はもちろん、開発中もこのようなミスが起こらないように設定しておくと安心です。
例えば、MongoDB 本家のサービスである MongoDB Atlas では、Database ユーザーごとに Role を設定して権限を絞ることができます。
☝️ Database ユーザーとは MongoDB Atlas の Database ユーザーとは、Node.js アプリなどからサーバーに接続するときに接続文字列 (SRV URI) 内で指定するユーザーのことを示しています。 Atlas サービス自体のアカウントとは別ものなので注意してください。 Database ユーザーは複数作成することができ、用途ごとに Role を割り当てることができます。 例えば、バックアップ用の backup ユーザーには読み込み権限だけを与えておいて、バックアップツールの実装では、このユーザーを接続 URI で指定するようにします。 次の例では、ユーザー (readuser) に、Only read any database (readAnyDatabase) という Role を設定して、データベースの読み込みだけを許可しています。
図: MongoDB Atlas のユーザー Role 設定 これで、Node.js アプリなどから次のような URI で MongoDB Atlas に接続した場合は、データベースの読み込みだけが可能になります。
mongodb+srv://readuser:&amp;lt;password&amp;gt;@&amp;lt;cluster&amp;gt;.&amp;lt;random&amp;gt;.mongodb.net:55001/ 組み込みの Role としては以下が用意されていますが、一般的なアプリケーション用の Role であれば、Atlas admin (atlasAdmin) を選択する必要はありません。 コレクションへの書き込みが必要なバックエンド用であれば、Read and write to any database (readWriteAnyDatabase) という Role を選択します。</description></item><item><title>MongoDB の ObjectId について（Document の生成時間を調べる）</title><link>https://maku.blog/p/wdbr8dx/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/wdbr8dx/</guid><description>MongoDB の各 Document（RDB でいうレコード）は、それぞれ _id というプライマリキーとなるフィールドを持っています。 この値は、何も指定しないと、自動的に ObjectId オブジェクトが生成されて設定されます。
&amp;gt; db.mycollection.insert({value:100}) &amp;gt; db.mycollection.findOne() { &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;5265e358c76d2a2f8b870057&amp;#34;), &amp;#34;value&amp;#34; : 100 } この ObjectId オブジェクトは BSON 形式 のオブジェクトで、内部的に以下のような値を保持しています。
フィールド サイズ 内容 Timestamp 4 bytes 生成時間（秒） Machine ID 3 bytes マシン固有値 PID 2 bytes プロセス ID Counter 3 bytes ランダム値から始まってインクリメントされる ObjectId オブジェクト内に含まれているタイムスタンプは、getTimestamp() メソッドによって取得できます。 これを利用すると、Document の _id フィールドから、その Document が生成された時間を調べることができます。
&amp;gt; db.mycollection.findOne()._id.getTimestamp() ISODate(&amp;#34;2013-10-22T02:30:48Z&amp;#34;) 参考 ObjectId — MongoDB Manual</description></item></channel></rss>