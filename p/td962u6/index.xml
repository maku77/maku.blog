<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Svelte 関連メモ on まくろぐ</title><link>https://maku.blog/p/td962u6/</link><description>Recent content in Svelte 関連メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 30 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/td962u6/index.xml" rel="self" type="application/rss+xml"/><item><title>Svelte を始める (SvelteKit で Hello World）</title><link>https://maku.blog/p/qmy6cdh/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qmy6cdh/</guid><description>Svelte とは Svelte は、コンパイラベースの Web アプリケーションフレームワークです。 特殊なテンプレート言語を使ってコンポーネントを実装することで、高度に最適化された HTML/JavaScript/CSS を出力することができます。 React.js アプリなどは、クライアントサイド JavaScript から共通のライブラリを呼び出す形で動作しますが、Svelte はコンパイル後の最適化された JavaScript のみで動作するようになっており、最終的な成果物が非常にコンパクトになります。 独自のテンプレート構文を学ぶ必要はありますが、ユーザー操作に反応するコンポーネントを、少ないコードで記述できるよう工夫されています。
☝️ ライバル？の Astro との違い Svelte よりも後発のコンパイラベースの Web アプリフレームワークに Astro があります。 Astro は、ビルド時にほとんどの JavaScript コードを実行して、その時点で静的な HTML ファイルを生成するというアプローチをとっています。 最終的にデプロイするのは、HTML (+CSS) だけになるので、初期表示が爆速になるという考え方です。 一方、Svelte はあくまで最適化された JavaScript コードはクライアントサイドで動かすという考え方です。
完全に静的なサイトであれば Astro を使い、インタラクティブなサイトであれば Svelte を使う、という使い分けがよさそうです。
参考: Astro 関連メモ Svelte + SvelteKit プロジェクトの作成 Svelte のプロジェクトは次のように npm create svelte コマンドで簡単に作成できます。 ウィザード形式の質問に答えていくだけで、TypeScript や ESLint、Prettier の導入まで一気にやってくれます。
Svelte プロジェクト (myapp) の作成 $ npm create svelte@latest myapp .</description></item><item><title>Svelte 応用: インクリメンタルサーチによる頻繁な API 呼び出しを防ぐ debounce 処理</title><link>https://maku.blog/p/c3ckhdf/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c3ckhdf/</guid><description>debounce 処理とは Web アプリケーションにインクリメンタルサーチの機能を組み込む際、検索 API の頻繁な呼び出しが課題となることがあります。 たとえば、&amp;ldquo;abcde&amp;rdquo; というキーワードで検索したいときに、&amp;ldquo;a&amp;rdquo; → &amp;ldquo;ab&amp;rdquo; → &amp;ldquo;abc&amp;rdquo; のように 1 文字入力するたびに API 呼び出しが走ると検索サーバーに負荷がかかってしまいます。
このような場合に、最後のユーザー入力から一定時間待つ debounce 処理を入れます。 次の Svelte コンポーネントでは、入力エリアでキーボード入力するたびに handleKeyUp 関数を呼び出していますが、入力内容を query 変数に反映するのを 1 秒間待つようにしています。
debounce 処理 &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; let query = &amp;#39;&amp;#39;; // クエリ文字列（この値が変化したらサーチ API を呼び出す想定） let timeoutId: number; // debounce 処理用のタイマー ID const handleKeyUp = (event: KeyboardEvent) =&amp;gt; { // リアルタイムなユーザー入力テキスト const text: string = (event.target as HTMLInputElement).value; // query 変数への代入はユーザー入力が終わってから 1 秒後に行う（debounce 処理） clearTimeout(timeoutId); timeoutId = setTimeout(() =&amp;gt; { query = text; }, 1000); }; &amp;lt;/script&amp;gt; &amp;lt;input on:keyup={handleKeyUp} /&amp;gt; &amp;lt;p&amp;gt;query: {query}&amp;lt;/p&amp;gt; こうすることで、ユーザーが一連のテキストを入力し終わったタイミングで、一度だけ検索 API を呼び出すことができるようになります（もちろん、1 秒以上の間隔を上げずにキーボード入力がされた場合ですが）。</description></item><item><title>Svelte 応用: YAML ファイルをインポートして使う</title><link>https://maku.blog/p/umhwooq/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/umhwooq/</guid><description>Svelte で YAML ファイルをインポートして使う方法 Svelte (SvelteKit) には YAML ファイルを直接インポートして JavaScript オブジェクトして扱う仕組みはありませんが、raw インポートの仕組みを使えば、YAML ファイルを文字列データとしてそのまま読み込むことができます（これは SvelteKit がビルドに使っている Vite の仕組みです）。
YAML ファイルを文字列としてインポートする import gamesYaml from &amp;#39;$lib/assets/games.yaml?raw&amp;#39; このようにして読み込んだ YAML テキストを、Node.js の YAML ライブラリなどでパースすれば、YAML ファイルの内容を JavaScript オブジェクトとして扱うことができます。 ビルド時に処理を完結させることができるので、例えば、static-adapter を使った静的ビルド (SSG) が必要な環境でも利用できます。
実装例 YAML ファイルを扱うために js-yaml ライブラリを使うので、次のようにしてインストールしておきます。
js-yaml（およびその型ファイル）のインストール $ npm install --save-dev js-yaml @types/js-yaml サンプルの YAML ファイルとして、下記のようなゲームソフト情報を含んだ games.yaml を使います。 この YAML ファイルはビルド時にインポートするので、static ディレクトリではなく src ディレクトリのどこかに配置します（ここでは、lib/assets というディレクトリに配置しています）。
src/lib/assets/games.yaml - title: シャドウラン date: 1996-02-23 price: 7800 - title: トムキャットアレイ date: 1994-12-22 price: 7800 - title: 真・女神転生 date: 1994-02-25 次の Svelte コンポーネントでは、ビルド時に YAML ファイルを読み込んで、JavaScript オブジェクトと扱えるようにしていします。 実装には TypeScript を使っていますが、raw インポートした YAML ファイルからは型情報を推測してくれないようなので、自分で Game 型を定義しています。</description></item><item><title>Svelte 応用: JSON ファイルをインポートして使う</title><link>https://maku.blog/p/pzrza7m/</link><pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pzrza7m/</guid><description>Svelte (SvelteKit) アプリ内の Svelte コンポーネントや JavaScript/TypeScript ライブラリでは、JSON ファイルを import 文で簡単に読み込めるようになっています（正確には Vite の Static Asset Handling の仕組みを利用しています）。
ここでは、サンプルデータとして下記のようなゲームソフト情報を含んだ JSON ファイルを用意します。 この JSON ファイルはビルド時にインポートするので、static ディレクトリではなく src ディレクトリのどこかに配置します（ここでは、lib/assets というディレクトリに配置しています）。
src/lib/assets/games.json [ { &amp;#34;title&amp;#34;: &amp;#34;シャドウラン&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1996-02-23&amp;#34;, &amp;#34;price&amp;#34;: 7800 }, { &amp;#34;title&amp;#34;: &amp;#34;トムキャットアレイ&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1994-12-22&amp;#34;, &amp;#34;price&amp;#34;: 7800 }, { &amp;#34;title&amp;#34;: &amp;#34;真・女神転生&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1994-02-25&amp;#34; } ] このファイルを Svelte コンポーネントから直接インポートしてもよいのですが、次のように明示的に TypeScript の型情報を付加するライブラリでラップしておくと便利かもしれません。
src/lib/games.ts import rawJson from &amp;#39;$lib/assets/games.json&amp;#39;; /** ゲームソフトの情報 */ export type Game = { /** ゲームタイトル */ title: string; /** 発売日 */ date: string; /** 価格 */ price?</description></item><item><title>Svelte 応用: Svelte アプリを完全な静的サイトとしてビルドする (SSG: Static Site Generation)</title><link>https://maku.blog/p/4oudmxy/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4oudmxy/</guid><description>何をするか？ Svelte/SvelteKit を使ったプロジェクト全体を、完全な静的リソースの形にビルドする SSG (Static Site Genration) 機能の使い方について説明します。 AWS の S3 ストレージのようなファイルの配信機能しか持たないサービスで Web サイトをホスティングする場合、SSG によるビルドが必要になります。
ちなみに、Cloudflare Pages や Vercel のようなモダンなホスティングサービス上で Svelte アプリをビルドする場合は、このような設定は一切行わずにデプロイすることができます（ゼロコンフィグ）。 できればそういったサービスを使うことを推奨しますが、ここでは何らかの事情でそういった便利なサービスを使用できないケースを想定しています（会社のポリシーで S3 しか使えないなど）。
SvelteKit の SSG 設定 adapter-static のインストール SvelteKit の @sveltejs/adapter-static というモジュールが SSG 機能を提供しているので、まずはこのモジュールをインストールします。
adapter-static のインストール $ npm install --save-dev @sveltejs/adapter-static adapter-static の有効化 ビルド設定ファイル (svelte.config.js) で、adapter-static を使用するように設定します。 プロジェクトの初期状態では、次のような感じで adapter-auto というモジュールが使われるように設定されていると思います。
svelte.config.js（変更前） import adapter from &amp;#39;@sveltejs/adapter-auto&amp;#39;; import { vitePreprocess } from &amp;#39;@sveltejs/kit/vite&amp;#39;; /** @type {import(&amp;#39;@sveltejs/kit&amp;#39;).Config} */ const config = { preprocess: vitePreprocess(), kit: { adapter: adapter() } }; export default config; adapter-auto は、Vercel や Cloudflare Pages などのサービス上でビルドするときに使えるモジュールですが、SSG するときには使えないので、ここを adapter-static に置き換えてやります。</description></item><item><title>Svelte 応用: Svelte アプリから D3.js を使う</title><link>https://maku.blog/p/7acxmwo/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7acxmwo/</guid><description>何をするか？ Svelte を使用した Web アプリケーションの中から、SVG 描画ライブラリである D3.js を使用する方法を説明します。 Svelte のプロジェクトは、npm create svelte@latest コマンドなどで既に作成されていることを前提とします。
参考: Svelte を始める (SvelteKit で Hello World） D3.js のインストール Svelte はビルド時に実装コードをバニラ JS の形にコンパイルするので、D3.js (d3) などの外部ライブラリは devDependencies としてインストールすれば OK です。 TypeScript を使う場合は、型情報の @types/d3 も一緒にインストールしておきます。
d3 モジュールと型情報をインストール $ npm install --save-dev d3 @types/d3 D3.js による描画 ここでは、次のような簡単な棒グラフを Svelte アプリ内の D3.js で描画してみます。
D3.js による棒グラフの例 D3.js の d3.select() 関数は DOM 要素を参照するため、クライアントサイド JavaScript として実行しなければいけないことに注意してください。 具体的には、Svelte の onMount() コールバック内で呼び出すようにします。 直接 d3.select() 関数を呼び出してしまうと、ReferenceError: document is not defined のようなエラーが発生します。</description></item><item><title>Svelte 応用: Hamburger ボタンを作る</title><link>https://maku.blog/p/z5cwfjm/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z5cwfjm/</guid><description>Svelte コンポーネントによる Hamburger アイコンの実装例です。 ボタンをクリックすると open 変数の値が true になり、CSS アニメーションで×印に変化します。
図: Svelte コンポーネントによるハンバーガーアイコン src/lib/components/Hamburger.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let open = false; &amp;lt;/script&amp;gt; &amp;lt;button class:open on:click={() =&amp;gt; (open = !open)}&amp;gt; &amp;lt;svg width=&amp;#34;40&amp;#34; height=&amp;#34;40&amp;#34;&amp;gt; &amp;lt;line id=&amp;#34;top&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;10&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;line id=&amp;#34;middle&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;20&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;20&amp;#34; /&amp;gt; &amp;lt;line id=&amp;#34;bottom&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;30&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;30&amp;#34; /&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;style&amp;gt; button { display: inline-block; width: 40px; height: 40px; padding: 0; cursor: pointer; border: none; background: #333; box-shadow: inset 0 0 0 2px #cccccc; /* 内側に枠を付ける */ z-index: 20; /* （これは必要に応じて）他の要素より上に表示する */ } button:hover { background: #555; } svg line { stroke: currentColor; stroke-linecap: round; stroke-width: 3; stroke: #cccccc; transition: transform 0.</description></item><item><title>Svelte 応用: ページ遷移用のナビゲーションメニューを作成する</title><link>https://maku.blog/p/2nrgf2m/</link><pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2nrgf2m/</guid><description>Svelte サイト内でページ遷移を行うためのナビゲーションコンポーネントの作成例です。
現在の URL（パス）の取得方法 SvelteKit の $app/stores モジュールが提供する page ストアを利用すると、現在表示中のページの URL や、その一部であるパス情報を取得することができます。 この情報を利用することで、ナビゲーションコンポーネント内のカレントページに相当する項目をハイライト表示します（この URL 情報は、パンくずリストなどでも利用できます）。
現在のページのパス情報は、次のように $page.url.pathname 参照できます。
&amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;b&amp;gt;pathname = {$page.url.pathname}&amp;lt;/b&amp;gt; ページ遷移すると、pathname の値が、/ → /about → /blog のような感じで変化します。
Nav コンポーネントの実装例 次の Svelte コンポーネント (Nav) は、サイト内でページ遷移を行うためのボタンを表示します。 現在のページに相当するボタンには、赤色の下線を表示しています。
図: Nav コンポーネントの表示 src/lib/components/Nav.svelte &amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; const pages = [ { name: &amp;#39;Home&amp;#39;, path: &amp;#39;/&amp;#39; }, { name: &amp;#39;About&amp;#39;, path: &amp;#39;/about&amp;#39; }, { name: &amp;#39;Blog&amp;#39;, path: &amp;#39;/blog&amp;#39; } ]; &amp;lt;/script&amp;gt; &amp;lt;nav&amp;gt; {#each pages as p} {#if p.</description></item><item><title>Svelte 入門: 動的に class 属性を off/on する</title><link>https://maku.blog/p/x3vpkn4/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3vpkn4/</guid><description>HTML 要素の class 属性の値を動的に変化させることで、スタイルの切り替えをしたいことはよくあります。 ナビゲーションメニューで、現在表示しているページをハイライトするのは典型的な例です。
ここでは、ボタンを押すことで Off/On できる簡単なランプ (Lamp) コンポーネントを作ってみます。
図: class 属性の変更による表示切り替え Lamp.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; let active = false; // ランプの On/Off 状態 function toggle() { active = !active; } &amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;lamp {active ? &amp;#39;active&amp;#39; : &amp;#39;&amp;#39;}&amp;#34; /&amp;gt; &amp;lt;button on:click={toggle}&amp;gt; {#if active}OFF{:else}ON{/if} &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; align-items: center; gap: 0.5rem; } .lamp { display: inline-block; width: 30px; height: 30px; box-sizing: border-box; border: 4px ridge rgba(0, 0, 0, 0.</description></item><item><title>Svelte 入門: 複数のページで共通のレイアウトを定義する (+layout.svelte)</title><link>https://maku.blog/p/vwyvd5x/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vwyvd5x/</guid><description>レイアウトファイル (+layout.svelte) の基本 Svelte のフレームワークである SvelteKit は、複数のページで使用する共通レイアウトを定義するための仕組みを提供しています。 共通レイアウトを定義するのは簡単で、src/routes/+layout.svelte というファイルを作成するだけで、そのレイアウトが全ページ (src/routes/**/+page.svelte) に適用されます。
src/routes/&amp;#43;layout.svelte（共通レイアウト） &amp;lt;header&amp;gt; &amp;lt;h1&amp;gt;サイト名&amp;lt;/h1&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&amp;#34;main&amp;#34;&amp;gt; &amp;lt;slot /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; header { position: fixed; top: 0; left: 0; width: 100%; padding: 1rem 1.5rem; background-color: #333; color: #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); z-index: 1000; } h1 { margin: 0; } .main { margin: 7rem 2rem 4rem 2rem; } &amp;lt;/style&amp;gt; 各ページのコンテンツは、レイアウトファイル内の &amp;lt;slot /&amp;gt; 部分に展開されます（参考: スロットの仕組み）。
実際には SvelteKit で作成したアプリケーションは、最上位のページテンプレートとして src/app.</description></item><item><title>Svelte 入門: Svelte コンポーネントに子要素を渡せるようにする (&lt;slot />)</title><link>https://maku.blog/p/gcdawrj/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gcdawrj/</guid><description>スロットの基本 &amp;lt;slot /&amp;gt; Svelte コンポーネントを使用するときに子要素として渡した内容は、Svelte コンポーネントの中から &amp;lt;slot /&amp;gt; で参照することができます。 &amp;lt;slot /&amp;gt; の仕組みは、Vue.js や Astro でも採用されています（React.js では children prop で参照します）。
次の ExtLink コンポーネントは、外部サイトへのリンクを表示するコンポーネントの実装例です。
src/lib/ExtLink.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let href: string; &amp;lt;/script&amp;gt; &amp;lt;a {href} target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;&amp;lt;slot /&amp;gt;&amp;lt;/a&amp;gt; この ExtLink コンポーネントは次のように使用します。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import ExtLink from &amp;#39;$lib/ExtLink.svelte&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; &amp;lt;ExtLink href=&amp;#34;https://www.bing.com/&amp;#34;&amp;gt;Bing&amp;lt;/ExtLink&amp;gt; この例では、コンポーネント内の &amp;lt;slot /&amp;gt; という部分に Bing というテキストが展開されることになります。 よって、リンク部分は次のような HTML にコンパイルされます。
&amp;lt;a href=&amp;#34;https://www.bing.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;Bing&amp;lt;/a&amp;gt; 名前付きスロット &amp;lt;slot name=&amp;ldquo;name&amp;rdquo; /&amp;gt; 子要素を複数のパートに分けてコンポーネントに渡したいことがあります。 このような場合は、名前付きスロット という仕組みを使います。 次の Box コンポーネントは、3 つのスロットを受け取れるようにしています。</description></item></channel></rss>