<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Svelte 関連メモ on まくろぐ</title><link>https://maku.blog/p/td962u6/</link><description>Recent content in Svelte 関連メモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 04 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/td962u6/index.xml" rel="self" type="application/rss+xml"/><item><title>Svelte を始める (SvelteKit で Hello World）</title><link>https://maku.blog/p/qmy6cdh/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qmy6cdh/</guid><description>Svelte とは Svelte は、コンパイラベースの Web アプリケーションフレームワークです。 特殊なテンプレート言語を使ってコンポーネントを実装することで、高度に最適化された HTML/JavaScript/CSS を出力することができます。 React.js アプリなどは、クライアントサイド JavaScript から共通のライブラリを呼び出す形で動作しますが、Svelte はコンパイル後の最適化された JavaScript のみで動作するようになっており、最終的な成果物が非常にコンパクトになります。 独自のテンプレート構文を学ぶ必要はありますが、ユーザー操作に反応するコンポーネントを、少ないコードで記述できるよう工夫されています。
☝️ ライバル？の Astro との違い Svelte よりも後発のコンパイラベースの Web アプリフレームワークに Astro があります。 Astro は、ビルド時にほとんどの JavaScript コードを実行して、その時点で静的な HTML ファイルを生成するというアプローチをとっています。 最終的にデプロイするのは、HTML (+CSS) だけになるので、初期表示が爆速になるという考え方です。 一方、Svelte はあくまで最適化された JavaScript コードはクライアントサイドで動かすという考え方です。
完全に静的なサイトであれば Astro を使い、インタラクティブなサイトであれば Svelte を使う、という使い分けがよさそうです。
参考: Astro 関連メモ Svelte + SvelteKit プロジェクトの作成 Svelte のプロジェクトは次のように npm create svelte コマンドで簡単に作成できます。 ウィザード形式の質問に答えていくだけで、TypeScript や ESLint、Prettier の導入まで一気にやってくれます。
Svelte プロジェクト (myapp) の作成 $ npm create svelte@latest myapp .</description></item><item><title>Svelte 応用: Svelte アプリから D3.js を使う</title><link>https://maku.blog/p/7acxmwo/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7acxmwo/</guid><description>何をするか？ Svelte を使用した Web アプリケーションの中から、SVG 描画ライブラリである D3.js を使用する方法を説明します。 Svelte のプロジェクトは、npm create svelte@latest コマンドなどで既に作成されていることを前提とします。
参考: Svelte を始める (SvelteKit で Hello World） D3.js のインストール Svelte はビルド時に実装コードをバニラ JS の形にコンパイルするので、D3.js (d3) などの外部ライブラリは devDependencies としてインストールすれば OK です。 TypeScript を使う場合は、型情報の @types/d3 も一緒にインストールしておきます。
d3 モジュールと型情報をインストール $ npm install --save-dev d3 @types/d3 D3.js による描画 ここでは、次のような簡単な棒グラフを Svelte アプリ内の D3.js で描画してみます。
D3.js による棒グラフの例 D3.js の d3.select() 関数は DOM 要素を参照するため、クライアントサイド JavaScript として実行しなければいけないことに注意してください。 具体的には、Svelte の onMount() コールバック内で呼び出すようにします。 直接 d3.select() 関数を呼び出してしまうと、ReferenceError: document is not defined のようなエラーが発生します。</description></item><item><title>Svelte 応用: ページ遷移用のナビゲーションメニューを作成する</title><link>https://maku.blog/p/2nrgf2m/</link><pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2nrgf2m/</guid><description>Svelte サイト内でページ遷移を行うためのナビゲーションコンポーネントの作成例です。
現在の URL（パス）の取得方法 SvelteKit の $app/stores モジュールが提供する page ストアを利用すると、現在表示中のページの URL や、その一部であるパス情報を取得することができます。 この情報を利用することで、ナビゲーションコンポーネント内のカレントページに相当する項目をハイライト表示します（この URL 情報は、パンくずリストなどでも利用できます）。
現在のページのパス情報は、次のように $page.url.pathname 参照できます。
&amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;b&amp;gt;pathname = {$page.url.pathname}&amp;lt;/b&amp;gt; ページ遷移すると、pathname の値が、/ → /about → /blog のような感じで変化します。
Nav コンポーネントの実装例 次の Svelte コンポーネント (Nav) は、サイト内でページ遷移を行うためのボタンを表示します。 現在のページに相当するボタンには、赤色の下線を表示しています。
図: Nav コンポーネントの表示 src/lib/components/Nav.svelte &amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; const pages = [ { name: &amp;#39;Home&amp;#39;, path: &amp;#39;/&amp;#39; }, { name: &amp;#39;About&amp;#39;, path: &amp;#39;/about&amp;#39; }, { name: &amp;#39;Blog&amp;#39;, path: &amp;#39;/blog&amp;#39; } ]; &amp;lt;/script&amp;gt; &amp;lt;nav&amp;gt; {#each pages as p} {#if p.</description></item><item><title>Svelte 入門: 動的に class 属性を off/on する</title><link>https://maku.blog/p/x3vpkn4/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3vpkn4/</guid><description>HTML 要素の class 属性の値を動的に変化させることで、スタイルの切り替えをしたいことはよくあります。 ナビゲーションメニューで、現在表示しているページをハイライトするのは典型的な例です。
ここでは、ボタンを押すことで Off/On できる簡単なランプ (Lamp) コンポーネントを作ってみます。
図: class 属性の変更による表示切り替え Lamp.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; let active = false; // ランプの On/Off 状態 function toggle() { active = !active; } &amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;lamp {active ? &amp;#39;active&amp;#39; : &amp;#39;&amp;#39;}&amp;#34; /&amp;gt; &amp;lt;button on:click={toggle}&amp;gt; {#if active}OFF{:else}ON{/if} &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; align-items: center; gap: 0.5rem; } .lamp { display: inline-block; width: 30px; height: 30px; box-sizing: border-box; border: 4px ridge rgba(0, 0, 0, 0.</description></item><item><title>Svelte 入門: 複数のページで共通のレイアウトを定義する (+layout.svelte)</title><link>https://maku.blog/p/vwyvd5x/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vwyvd5x/</guid><description>レイアウトファイル (+layout.svelte) の基本 Svelte のフレームワークである SvelteKit は、複数のページで使用する共通レイアウトを定義するための仕組みを提供しています。 共通レイアウトを定義するのは簡単で、src/routes/+layout.svelte というファイルを作成するだけで、そのレイアウトが全ページ (src/routes/**/+page.svelte) に適用されます。
src/routes/&amp;#43;layout.svelte（共通レイアウト） &amp;lt;header&amp;gt; &amp;lt;h1&amp;gt;サイト名&amp;lt;/h1&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&amp;#34;main&amp;#34;&amp;gt; &amp;lt;slot /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; header { position: fixed; top: 0; left: 0; width: 100%; padding: 1rem 1.5rem; background-color: #333; color: #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); z-index: 1000; } h1 { margin: 0; } .main { margin: 7rem 2rem 4rem 2rem; } &amp;lt;/style&amp;gt; 各ページのコンテンツは、レイアウトファイル内の &amp;lt;slot /&amp;gt; 部分に展開されます（参考: スロットの仕組み）。
実際には SvelteKit で作成したアプリケーションは、最上位のページテンプレートとして src/app.</description></item><item><title>Svelte 入門: Svelte コンポーネントに子要素を渡せるようにする (&lt;slot />)</title><link>https://maku.blog/p/gcdawrj/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gcdawrj/</guid><description>スロットの基本 &amp;lt;slot /&amp;gt; Svelte コンポーネントを使用するときに子要素として渡した内容は、Svelte コンポーネントの中から &amp;lt;slot /&amp;gt; で参照することができます。 &amp;lt;slot /&amp;gt; の仕組みは、Vue.js や Astro でも採用されています（React.js では children prop で参照します）。
次の ExtLink コンポーネントは、外部サイトへのリンクを表示するコンポーネントの実装例です。
src/lib/ExtLink.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let href: string; &amp;lt;/script&amp;gt; &amp;lt;a {href} target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;&amp;lt;slot /&amp;gt;&amp;lt;/a&amp;gt; この ExtLink コンポーネントは次のように使用します。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import ExtLink from &amp;#39;$lib/ExtLink.svelte&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; &amp;lt;ExtLink href=&amp;#34;https://www.bing.com/&amp;#34;&amp;gt;Bing&amp;lt;/ExtLink&amp;gt; この例では、コンポーネント内の &amp;lt;slot /&amp;gt; という部分に Bing というテキストが展開されることになります。 よって、リンク部分は次のような HTML にコンパイルされます。
&amp;lt;a href=&amp;#34;https://www.bing.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;Bing&amp;lt;/a&amp;gt; 名前付きスロット &amp;lt;slot name=&amp;ldquo;name&amp;rdquo; /&amp;gt; 子要素を複数のパートに分けてコンポーネントに渡したいことがあります。 このような場合は、名前付きスロット という仕組みを使います。 次の Box コンポーネントは、3 つのスロットを受け取れるようにしています。</description></item></channel></rss>