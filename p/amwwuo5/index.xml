<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GraphQL スキーマ仕様 on まくろぐ</title><link>https://maku.blog/p/amwwuo5/</link><description>Recent content in GraphQL スキーマ仕様 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 24 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/amwwuo5/index.xml" rel="self" type="application/rss+xml"/><item><title>GraphQL スキーマ仕様: スキーマ定義の基本</title><link>https://maku.blog/p/5s5jvfz/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5s5jvfz/</guid><description>GraphQL スキーマとは GraphQL スキーマは、GraphQL API サーバーがどんなクエリを受け付けてくれるかを示すもので、GraphQL Schema Language という独自言語 (DSL) で記述します。 スキーマは型情報だけを定義したものであり、サーバーの実装ロジックは考慮しません（各型のデータを返すための具体的な実装は「リゾルバー」と呼ばれており、こちらはプログラミング言語に依存した実装を行います）。
GraphQL スキーマは、クライアントのニーズを把握して、クライアントファーストで考えるのがポイントです。 サーバーのバックエンドで使用する技術（RDB など）に影響されたスキーマ定義をしてはいけません。
☝️ .graphql vs .graphqls GraphQL スキーマドキュメントを独立したファイルとして作成する場合は、ファイルの拡張子を .graphqls あるいは .graphql とするのが一般的です。 .graphqls の方は「GraphQL のスキーマ」を表し、.graphql の方は「GraphQL のクエリドキュメント」を表すので明確に分けるべきだという主張もあります。 迷ったら、スキーマファイルには .graphqls を使っておけば間違いないと思います。 スキーマ定義のベストプラクティスに関しては、こちら にまとめています。
オブジェクト型 スキーマの中で基本的な要素となるのはオブジェクト型で、type キーワードを使って次のように定義します。
typeオブジェクト型の名前{フィールド名:型フィールド名:型フィールド名:型}これは、GraphQL クエリによって取得可能なデータの構造を表しています。 例えば、下記は書籍情報を表すオブジェクト型の例です。
typeBook{id:ID!year:Inttitle:String!authors:[String!]tags:[String!]!}Book オブジェクトが持つフィールドは、フィールド名: 型 という形式で定義します。 型には、スカラー型、列挙型、リスト、オブジェクト型などを指定できます。 オブジェクト型のフィールドとして、別のオブジェクト型を指定することができますが、末端のオブジェクト型はスカラー型のフィールドのみで構成されている必要があります。 すべての型は デフォルトで Nullable であり、Non-null なフィールドであることを示すためには、型名の末尾に ! を付ける必要があります。
上記の例の場合、各フィールドの定義は次のような意味を持ちます。
id: ID! id フィールドは ID 型（組み込みのスカラー型のひとつ）であり、null になることはない。 year: Int year フィールドは整数型であり、null になる可能性がある。 title: String!</description></item><item><title>GraphQL スキーマ仕様: ページネーション (pagination)</title><link>https://maku.blog/p/vuo4px3/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vuo4px3/</guid><description>ページネーションとは？ GraphQL API で数百件を超えるような大量のデータを取得できるようにする場合は、ページネーション処理を考慮した API 定義を行うのが一般的です。 ページネーションというのは、Google の検索結果にあるような「次へ」「前へ」というような機能のことです。 ページネーションをどう実装すべきかは、GraphQL の仕様として定義されているわけではないのですが、デファクトスタンダードな実装方法が確立されており、大きく次の 2 種類の実装方法があります。
オフセット・ページネーション (offset pagination) カーソル・ページネーション (cursor pagination) それぞれの方法を順に見ていきます。
オフセット・ページネーション (offset pagination) オフセット・ページネーションは、複数のデータを取得するときに、どの位置（オフセット）から取得するかを、ページやデータのインデックスで指定する方法です。
typeQuery{books(limit:Int!,page:Int!):[Book!]} クエリパラメーターの意味 limit &amp;hellip; いくつのデータを取得するか page &amp;hellip; どの位置から取得するか（絶対位置） オフセット・ページネーションは実装が簡単で使いやすいという利点がありますが、いくつかの問題があります。
DB アクセスのコスト問題（スケールしない） 例えば、上記のような books クエリが次のような SQL にマッピングされたとします。
SELECT*FROMbooksLIMIT100OFFSET500;クライアントは 100 件分のデータしか要求していませんが、RDB 側の処理としては、500 + 100 件分の読み出しが必要になります。 しかも厄介なことに、OFFSET が増加するごとに読み出し量が増えていくため、ページを進めていくたびにパフォーマンスが悪化していきます。 クラウド系の RDB サービスを使っている場合は、多額の料金を請求されることになります。
結果の一貫性を保てないことがある あるページを表示しているときに、バックグラウンドでレコードが追加されると、その次のページに移ったときに、同じレコードが表示される可能性があります。 逆にレコードが削除された場合は、次のページに移ったときに、表示されるべきレコードが飛ばされてしまったりします。 これは、表示位置を常に先頭レコードからのオフセットで指定していることが原因です。
結果の一貫性に関しては表示仕様で妥協することはできるかもしれませんが、1 つ目の DB アクセスのコスト問題は解決が難しく、多くの Public API では、次のカーソルベースのページネーションが採用されています。
カーソル・ページネーション (cursor pagination) カーソル・ページネーションでは、リスト内の項目を指し示す「カーソル」を使って取得するデータの位置を表現します。</description></item><item><title>GraphQL スキーマ仕様: ユニオン型 (Union types) を定義する</title><link>https://maku.blog/p/vqsyz9j/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vqsyz9j/</guid><description>GraphQL スキーマの ユニオン型 (Union types) は、複数の型のうち、いずれかの型であることを表現する型です。 典型的には、検索系のフィールドにおいて、様々な種類のデータを返す場合に使われます。 ユニオン型は、union キーワードを使って次のように定義します。
ユニオン型の定義 unionTaskOrTodo=Task|TodotypeQuery{search(term:String!):[TaskOrTodo!]} 下記は GitHub の GraphQL スキーマで定義されているユニオン型の例です。
GitHub API の union 型の例 &amp;#34;&amp;#34;&amp;#34; Used for return value of Repository.issueOrPullRequest. &amp;#34;&amp;#34;&amp;#34;unionIssueOrPullRequest=Issue|PullRequest&amp;#34;&amp;#34;&amp;#34; Types that can be inside a Milestone. &amp;#34;&amp;#34;&amp;#34;unionMilestoneItem=Issue|PullRequest GraphQL クエリにおいてユニオン型のフィールドを参照するときは、インラインフラグメント を使って、具体的な型ごとにフィールドを参照する必要があります。
ユニオン型のフィールドを参照するクエリ queryQueryRecentActivities{search(type:ISSUE,query:&amp;#34;repo:graphql/graphql-spec&amp;#34;,last:10){nodes{...onIssue{numbertitle}...onPullRequest{titlebaseRefName}}}} ユニオン型は、エラーを表現するためにも使用できます。 次の createBook は新しい書籍データを登録するための mutation ですが、登録に成功したときは Book オブジェクトを返し、失敗したときは各種エラーを表すオブジェクトを返します。</description></item><item><title>GraphQL スキーマ仕様: ミューテーションを定義する（データ更新 API）</title><link>https://maku.blog/p/pk9c9qs/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pk9c9qs/</guid><description>GraphQL API でサーバーサイドのデータを更新するには、ミューテーション操作 (mutation) を含むクエリを送信します。 このときどのようなミューテーションを行えるかは、GraphQL スキーマの中で、Mutation 型のフィールドとして定義します。
ミューテーションのスキーマを定義する 次の例では、書籍データを新規作成するための createBook ミューテーションと、削除するための deleteBook ミューテーションを定義しています。 フィールド名は変更内容を表す動詞で始めるのが一般的です。
GraphQL スキーマ定義 typeMutation{createBook(title:String!,author:String!):Book!deleteBook(id:ID!):Boolean!} 各フィールドにはパラメーター（上記の title など）を定義することができ、そのパラメーターの指定が必須である場合には、型名の末尾に ! を付けます (String!)。
ミューテーションが呼び出されたときの実際の処理内容は、GraphQL サーバー側のミューテーション・リゾルバーで実装します。 リゾルバーの実装方法は、各言語の GraphQL サーバーライブラリによって異なります。 例えば、下記は Golang の gqlgen パッケージを使った場合のリゾルバー実装の例です。
ミューテーション・リゾルバーの実装 // CreateBook is the resolver for the createBook field. func (r *mutationResolver) CreateBook( ctx context.Context, title string, author *string, ) (*model.Book, error) { id := uuid.NewString() book := &amp;amp;model.Book{ ID: id, Title: title, Author: author, } // 本当はこのあたりで DB などに book を追加 // if err := db.</description></item><item><title>GraphQL スキーマ仕様: 入力型 (input type) を定義する</title><link>https://maku.blog/p/nhhwqtu/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nhhwqtu/</guid><description>GraphQL スキーマで定義する 入力型 (input type) は、クエリ／ミューテーション要求時のフィールド引数にのみに使用できるオブジェクト型です。 入力型を使うと、複数のフィールド引数をひとつのオブジェクトにまとめることができます。
次の Mutation 型の createBook フィールドは、フィールド引数として CreateBookInput という入力型を使っています。
スキーマ定義 typeMutation{createBook(input:CreateBookInput!):Book} 入力型を定義するときは input キーワードを使用します（フィールド自体を表す型の定義には type キーワードを使用します。こちらは出力型と呼ばれたりします）。 フィールドの定義方法は type も input も同じです。
次のスキーマは、上記の createBook フィールドの型 (Book) と、その引数の型 (CreateBookInput) を定義しています。 type キーワードと input キーワードを使い分けていることに注意してください。
スキーマ定義 typeBook{id:ID!title:String!author:Stringyear:Int}inputCreateBookInput{title:String!author:Stringyear:Int} Book 型と CreateBookInput 型のフィールドはほとんど共通ですが、Book 型には GraphQL サーバー側で自動生成される id 情報が含まれています。
クライアントがミューテーション要求を送るときは、ミューテーション操作の変数経由で入力型のデータを渡します。
ミューテーションの実行 mutationCreateBook($input:CreateBookInput!){createBook(input:$input){idtitleauthoryear}} 実際に使用する変数値は、次のような JSON 形式のデータとして、上記ドキュメントと一緒に GraphQL サーバーに送ります。
variables {&amp;#34;input&amp;#34;:{&amp;#34;title&amp;#34;:&amp;#34;書籍タイトル&amp;#34;,&amp;#34;author&amp;#34;:&amp;#34;まく&amp;#34;}} ミューテーション操作の戻り値は、一般的には新規作成した（あるいは更新後の）オブジェクトの内容です。
上記ミューテーションのレスポンス { &amp;#34;data&amp;#34;: { &amp;#34;createBook&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;d3cn2sx&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;書籍タイトル&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;まく&amp;#34;, &amp;#34;year&amp;#34;: null } } } 上記の createBook フィールドの型（ミューテーション操作の戻り値）は Book 型でしたが、CreateBookPayload のような別の出力型を定義すれば、ミューテーション操作に関するメタ情報を含めることができます。 例えば、ミューテーション操作によって実際に追加されたデータの数などを戻り値として返すことができます。</description></item><item><title>GraphQL スキーマ仕様: 列挙型 (enum type) を定義する</title><link>https://maku.blog/p/isotm77/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/isotm77/</guid><description>列挙型の基本 GraphQL スキーマでは、enum キーワードを使って列挙型を定義することができます。 列挙型は、スカラー型と同様に単一の値を表しますが、とり得る値があらかじめ限定されています。 String や Int などの代わりに適切な列挙型を使えば、API の使い方が明確になり、クライアントによる誤用を防ぐことができます。
次の例では、Episode という名前の列挙型を定義しています。
GraphQL スキーマでの列挙型の定義 enumEpisode{NEWHOPEEMPIREJEDI} 列挙型は、フィールドのパラメーターの型として使用することができます。
typeQuery{hero(episode:Episode):Character}列挙型は、フィールドの型としても使用できます。
typeCharacter{name:String!appearsIn:[Episode]!}列挙型の使用例 列挙型の典型的な使用例として、ソート用のフィールド・パラメーターがあります。 下記は、GitHub の GraphQL スキーマで定義されている列挙型の例です。 GistOrder 入力型 のフィールドに、GistOrderField 列挙型が使われています。
GitHub の GraphQL スキーマ（抜粋） &amp;#34;&amp;#34;&amp;#34; Ordering options for gist connections &amp;#34;&amp;#34;&amp;#34;inputGistOrder{&amp;#34;&amp;#34;&amp;#34; The ordering direction. &amp;#34;&amp;#34;&amp;#34;direction:OrderDirection!&amp;#34;&amp;#34;&amp;#34; The field to order repositories by. &amp;#34;&amp;#34;&amp;#34;field:GistOrderField!}&amp;#34;&amp;#34;&amp;#34; Properties by which gist connections can be ordered. &amp;#34;&amp;#34;&amp;#34;enumGistOrderField{&amp;#34;&amp;#34;&amp;#34; Order gists by creation time &amp;#34;&amp;#34;&amp;#34;CREATED_AT&amp;#34;&amp;#34;&amp;#34; Order gists by push time &amp;#34;&amp;#34;&amp;#34;PUSHED_AT&amp;#34;&amp;#34;&amp;#34; Order gists by update time &amp;#34;&amp;#34;&amp;#34;UPDATED_AT} 意味はほとんど自明かと思いますが、Gist（コード断片）のリストを取得するときに、どのフィールドでソートして返して欲しいかを指定するのに使用します。 下記の GraphQL クエリを発行すると、自分（サインイン済みユーザー）が登録している Gist を、作成日時 (CREATED_AT) で降順ソート (DESC) された状態で取得できます。</description></item><item><title>GraphQL スキーマ仕様: 組み込みのスカラー型とカスタムスカラー型</title><link>https://maku.blog/p/tw75a7p/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tw75a7p/</guid><description>5 つの組み込みスカラー型 (Scalar types) GraphQL 仕様で定義されているスカラー型は次の 5 つで、これらを各オブジェクト型のフィールドの型や、フィールド引数の型として使用します。
型名 意味 Int 符号付き 32 ビット整数 Float 符号付き倍精度浮動小数点数 String 文字列（UTF-8 エンコーディング） Boolean true または false ID 一意の識別子。データ形式としては String と同様ですが、ID はリーダブル（意味のある単語）にはなっていないことを示唆します。ID は GraphQL サーバーとクライアントの間でオブジェクトの同一性を示すために使用します。 これ以外の型を使用したいときは、独自のオブジェクト型、スカラー型、列挙型を定義して使用します。
カスタムスカラー型 (Custom scalar types) スカラー型にフォーマット制約を設けたいときや、任意のクラスのインスタンスとして扱いたいときは、独自の カスタムスカラー型 を定義します。 例えば、日時や E メールアドレス、UUID、URI などは、カスタムスカラーを使うべき典型的なフィールドの例です。 カスタムスカラーは、スキーマドキュメント内で scalar キーワードを使って定義できます。
カスタムスカラー型の定義 &amp;#34;&amp;#34;&amp;#34;日時を表すスカラー型(ISO8601形式の文字列)&amp;#34;&amp;#34;&amp;#34;scalarDateTimetypeEvent{title:String!startAt:DateTime} ライブラリの実装によりますが、カスタムスカラー型をそのまま使おうとすると、単なる String 型として扱われます。 カスタムスカラー型のデータを GraphQL サーバー型でどのようにハンドルするかは、サーバーライブラリごとに実装方法が提供されています。 例えば、下記は Golang の gqlgen ライブラリにおけるカスタムスカラー型のドキュメントです。 実装例として、yes や no として送られてきた文字列データを、Golang の bool 型として参照できるようにする方法が紹介されています。</description></item><item><title>GraphQL スキーマ仕様: @deprecated ディレクティブで非推奨のフィールドを示す</title><link>https://maku.blog/p/bg9g8rc/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bg9g8rc/</guid><description>GraphQL スキーマ内のある型のフィールドや Enum 値が非推奨になったことを表すには、@deprecated ディレクティブを使用します。 reason 引数で非推奨とされた理由を記述することができるので、その文章中に代替となるフィールド名を記述しておくと親切です。
次の例では、email フィールドが非推奨 (deprecated) になり、代わりに emailAddress フィールドを参照して欲しいことを示しています。
typeUser{emailAddress:Stringemail:String@deprecated(reason:&amp;#34;Use &amp;#39;emailAddress&amp;#39;.&amp;#34;)}</description></item><item><title>GraphQL スキーマ仕様: インタフェース型 (interface type) を定義する</title><link>https://maku.blog/p/yp9mv5d/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yp9mv5d/</guid><description>GraphQL のインタフェース型は、複数の型が共通して持つフィールドを定義するための抽象型で、interface キーワードを使って定義します。 次の ScheduleItem インタフェースは、2 つのフィールド（id と title）を持つことを示しています。 インタフェースを実装する (imlements) 側の型は、必ず id と title フィールドを持つ必要があります。
スキーマ定義 # 共通のインタフェースを定義interfaceScheduleItem{id:ID!title:String!}# Task 型は必ず id と title フィールドを持つtypeTaskimplementsScheduleItem{id:ID!title:String!content:String}# Milestone 型は必ず id と title フィールドを持つtypeMilestoneimplementsScheduleItem{id:ID!title:String!date:DateTime}scalarDateTimetypeQuery{allItems():[ScheduleItem!]} 上記の Task 型と Milestone 型は、ScheduleItem というインタフェースを実装しています。 allItems クエリは、Task と Milestone を要素に持つリストを返すことを想定していますが、戻り値のリスト要素の型が ScheduleItem になっているため、必ず id と title フィールドが含まれることが保証されています。 クエリ内でリスト要素を参照するときは、次のように直接これらのフィールドを参照できます。
クエリ queryQueryAllItems{allItems{idtitle}} 一方、Task 型や Milestone 型にしか含まれないフィールドを取得したいときは、次のように インラインフラグメント (... on Xxx) の形で分岐させて参照する必要があります。
クエリ queryQueryAllItems{allItems{idtitle...onTask{content}...onMilestone{date}}} 複数のインタフェースを実装したいときは、次のように implements の後ろにインタフェース名を &amp;amp; で並べます。</description></item><item><title>GraphQL スキーマ仕様: 型やフィールドに説明文 (description) を記述する</title><link>https://maku.blog/p/c5pbs6p/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c5pbs6p/</guid><description>GraphQL スキーマで定義する型には、Python の docstring と同様のフォーマットで description というドキュメントを付加できます。 description は型の直前、あるいはフィールドの直前に、3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲む形で記述します。
description の記述例 &amp;#34;&amp;#34;&amp;#34; Represents an auto-merge request for a pull request &amp;#34;&amp;#34;&amp;#34;typeAutoMergeRequest{&amp;#34;&amp;#34;&amp;#34; The email address of the author of this auto-merge request. &amp;#34;&amp;#34;&amp;#34;authorEmail:String&amp;#34;&amp;#34;&amp;#34; The commit message of the auto-merge request. If a merge queue is required by the base branch, this value will be set by the merge queue when merging. &amp;#34;&amp;#34;&amp;#34;commitBody:String...} description の記述例 &amp;#34;&amp;#34;&amp;#34;The root query entry point for the API&amp;#34;&amp;#34;&amp;#34;typeQuery{&amp;#34;&amp;#34;&amp;#34;The current time in ISO UTC&amp;#34;&amp;#34;&amp;#34;currentTime:String} GraphQL スキーマ内の description はただのコメントではなく、その型のプロパティとして扱われ、GraphiQL などの各種ツールがその情報を参照して利用します。 GraphQL スキーマの型名やフィールド名だけで表現できる情報は限られているので、ほぼすべての型、フィールドに対して description を設定するのはよいプラクティスです。 下記は GitHub の GraphQL API のスキーマです。 description の記述方法の参考になります。</description></item></channel></rss>