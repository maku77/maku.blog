<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GraphQL スキーマ仕様 on まくろぐ</title><link>https://maku.blog/p/amwwuo5/</link><description>Recent content in GraphQL スキーマ仕様 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 24 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/amwwuo5/index.xml" rel="self" type="application/rss+xml"/><item><title>GraphQL スキーマ仕様: スキーマ定義の基本</title><link>https://maku.blog/p/5s5jvfz/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5s5jvfz/</guid><description>GraphQL スキーマとは GraphQL スキーマは、GraphQL API サーバーがどんなクエリを受け付けてくれるかを示すもので、GraphQL Schema Language という独自言語 (DSL) で記述します。 スキーマは型情報だけを定義したものであり、サーバーの実装ロジックは考慮しません（各型のデータを返すための具体的な実装は「リゾルバー」と呼ばれており、こちらはプログラミング言語に依存した実装を行います）。
GraphQL スキーマは、クライアントのニーズを把握して、クライアントファーストで考えるのがポイントです。 サーバーのバックエンドで使用する技術（RDB など）に影響されたスキーマ定義をしてはいけません。
☝️ .graphql vs .graphqls GraphQL スキーマドキュメントを独立したファイルとして作成する場合は、ファイルの拡張子を .graphqls あるいは .graphql とするのが一般的です。 .graphqls の方は「GraphQL のスキーマ」を表し、.graphql の方は「GraphQL のクエリドキュメント」を表すので明確に分けるべきだという主張もあります。 迷ったら、スキーマファイルには .graphqls を使っておけば間違いないと思います。 スキーマ定義のベストプラクティスに関しては、こちら にまとめています。
オブジェクト型 スキーマの中で基本的な要素となるのはオブジェクト型で、type キーワードを使って次のように定義します。
type オブジェクト型の名前 { フィールド名: 型 フィールド名: 型 フィールド名: 型 } これは、GraphQL クエリによって取得可能なデータの構造を表しています。 例えば、下記は書籍情報を表すオブジェクト型の例です。
type Book { id: ID! year: Int title: String! authors: [String!] tags: [String!]! } Book オブジェクトが持つフィールドは、フィールド名: 型 という形式で定義します。 型には、スカラー型、列挙型、リスト、オブジェクト型などを指定できます。 オブジェクト型のフィールドとして、別のオブジェクト型を指定することができますが、末端のオブジェクト型はスカラー型のフィールドのみで構成されている必要があります。 すべての型は デフォルトで Nullable であり、Non-null なフィールドであることを示すためには、型名の末尾に !</description></item><item><title>GraphQL スキーマ仕様: ページネーション (pagination)</title><link>https://maku.blog/p/vuo4px3/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vuo4px3/</guid><description>ページネーションとは？ GraphQL API で数百件を超えるような大量のデータを取得できるようにする場合は、ページネーション処理を考慮した API 定義を行うのが一般的です。 ページネーションというのは、Google の検索結果にあるような「次へ」「前へ」というような機能のことです。 ページネーションをどう実装すべきかは、GraphQL の仕様として定義されているわけではないのですが、デファクトスタンダードな実装方法が確立されており、大きく次の 2 種類の実装方法があります。
オフセット・ページネーション (offset pagination) カーソル・ページネーション (cursor pagination) それぞれの方法を順に見ていきます。
オフセット・ページネーション (offset pagination) オフセット・ページネーションは、複数のデータを取得するときに、どの位置（オフセット）から取得するかを、ページやデータのインデックスで指定する方法です。
type Query { books(limit: Int!, page: Int!): [Book!] } クエリパラメーターの意味 limit &amp;hellip; いくつのデータを取得するか page &amp;hellip; どの位置から取得するか（絶対位置） オフセット・ページネーションは実装が簡単で使いやすいという利点がありますが、いくつかの問題があります。
DB アクセスのコスト問題（スケールしない） 例えば、上記のような books クエリが次のような SQL にマッピングされたとします。
SELECT * FROM books LIMIT 100 OFFSET 500; クライアントは 100 件分のデータしか要求していませんが、RDB 側の処理としては、500 + 100 件分の読み出しが必要になります。 しかも厄介なことに、OFFSET が増加するごとに読み出し量が増えていくため、ページを進めていくたびにパフォーマンスが悪化していきます。 クラウド系の RDB サービスを使っている場合は、多額の料金を請求されることになります。
結果の一貫性を保てないことがある あるページを表示しているときに、バックグラウンドでレコードが追加されると、その次のページに移ったときに、同じレコードが表示される可能性があります。 逆にレコードが削除された場合は、次のページに移ったときに、表示されるべきレコードが飛ばされてしまったりします。 これは、表示位置を常に先頭レコードからのオフセットで指定していることが原因です。</description></item><item><title>GraphQL スキーマ仕様: ユニオン型 (Union types) を定義する</title><link>https://maku.blog/p/vqsyz9j/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vqsyz9j/</guid><description>ユニオン型を定義する GraphQL スキーマの ユニオン型 (Union types) は、複数の型のうち、いずれかの型であることを表現する型です。 典型的には、検索系のフィールドにおいて、様々な種類のデータを返す場合に使われます。 ユニオン型は、union キーワードを使って次のように定義します。
ユニオン型の定義 union TaskOrTodo = Task | Todo type Query { search(term: String!): [TaskOrTodo!] } 下記は GitHub の GraphQL スキーマで定義されているユニオン型の例です。
GitHub API の union 型の例 &amp;#34;&amp;#34;&amp;#34; Used for return value of Repository.issueOrPullRequest. &amp;#34;&amp;#34;&amp;#34; union IssueOrPullRequest = Issue | PullRequest &amp;#34;&amp;#34;&amp;#34; Types that can be inside a Milestone. &amp;#34;&amp;#34;&amp;#34; union MilestoneItem = Issue | PullRequest クエリでユニオン型を使う GraphQL クエリにおいてユニオン型のフィールドを参照するときは、インラインフラグメント を使って、具体的な型ごとにフィールドを参照する必要があります。
ユニオン型のフィールドを参照するクエリ query QueryRecentActivities { search(type: ISSUE, query: &amp;#34;repo:graphql/graphql-spec&amp;#34;, last: 10) { nodes { .</description></item><item><title>GraphQL スキーマ仕様: ミューテーションを定義する（データ更新 API）</title><link>https://maku.blog/p/pk9c9qs/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pk9c9qs/</guid><description>GraphQL API でサーバーサイドのデータを更新するには、ミューテーション操作 (mutation) を含むクエリを送信します。 このときどのようなミューテーションを行えるかは、GraphQL スキーマの中で、Mutation 型のフィールドとして定義します。
ミューテーションのスキーマを定義する 次の例では、書籍データを新規作成するための createBook ミューテーションと、削除するための deleteBook ミューテーションを定義しています。 フィールド名は変更内容を表す動詞で始めるのが一般的です。
GraphQL スキーマ定義 type Mutation { createBook(title: String!, author: String!): Book! deleteBook(id: ID!): Boolean! } 各フィールドにはパラメーター（上記の title など）を定義することができ、そのパラメーターの指定が必須である場合には、型名の末尾に ! を付けます (String!)。
ミューテーションが呼び出されたときの実際の処理内容は、GraphQL サーバー側のミューテーション・リゾルバーで実装します。 リゾルバーの実装方法は、各言語の GraphQL サーバーライブラリによって異なります。 例えば、下記は Golang の gqlgen パッケージを使った場合のリゾルバー実装の例です。
ミューテーション・リゾルバーの実装 // CreateBook is the resolver for the createBook field. func (r *mutationResolver) CreateBook( ctx context.Context, title string, author *string, ) (*model.Book, error) { id := uuid.</description></item><item><title>GraphQL スキーマ仕様: 入力型 (input type) を定義する</title><link>https://maku.blog/p/nhhwqtu/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nhhwqtu/</guid><description>GraphQL スキーマで定義する 入力型 (input type) は、クエリ／ミューテーション要求時のフィールド引数にのみに使用できるオブジェクト型です。 入力型を使うと、複数のフィールド引数をひとつのオブジェクトにまとめることができます。
次の Mutation 型の createBook フィールドは、フィールド引数として CreateBookInput という入力型を使っています。
スキーマ定義 type Mutation { createBook(input: CreateBookInput!): Book } 入力型を定義するときは input キーワードを使用します（フィールド自体を表す型の定義には type キーワードを使用します。こちらは出力型と呼ばれたりします）。 フィールドの定義方法は type も input も同じです。
次のスキーマは、上記の createBook フィールドの型 (Book) と、その引数の型 (CreateBookInput) を定義しています。 type キーワードと input キーワードを使い分けていることに注意してください。
スキーマ定義 type Book { id: ID! title: String! author: String year: Int } input CreateBookInput { title: String! author: String year: Int } Book 型と CreateBookInput 型のフィールドはほとんど共通ですが、Book 型には GraphQL サーバー側で自動生成される id 情報が含まれています。</description></item><item><title>GraphQL スキーマ仕様: 列挙型 (enum type) を定義する</title><link>https://maku.blog/p/isotm77/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/isotm77/</guid><description>列挙型の基本 GraphQL スキーマでは、enum キーワードを使って列挙型を定義することができます。 列挙型は、スカラー型と同様に単一の値を表しますが、とり得る値があらかじめ限定されています。 String や Int などの代わりに適切な列挙型を使えば、API の使い方が明確になり、クライアントによる誤用を防ぐことができます。
次の例では、Episode という名前の列挙型を定義しています。
GraphQL スキーマでの列挙型の定義 enum Episode { NEWHOPE EMPIRE JEDI } 列挙型は、フィールドのパラメーターの型として使用することができます。
type Query { hero(episode: Episode): Character } 列挙型は、フィールドの型としても使用できます。
type Character { name: String! appearsIn: [Episode]! } 列挙型の使用例 列挙型の典型的な使用例として、ソート用のフィールド・パラメーターがあります。 下記は、GitHub の GraphQL スキーマで定義されている列挙型の例です。 GistOrder 入力型 のフィールドに、GistOrderField 列挙型が使われています。
GitHub の GraphQL スキーマ（抜粋） &amp;#34;&amp;#34;&amp;#34; Ordering options for gist connections &amp;#34;&amp;#34;&amp;#34; input GistOrder { &amp;#34;&amp;#34;&amp;#34; The ordering direction. &amp;#34;&amp;#34;&amp;#34; direction: OrderDirection! &amp;#34;&amp;#34;&amp;#34; The field to order repositories by.</description></item><item><title>GraphQL スキーマ仕様: 組み込みのスカラー型とカスタムスカラー型</title><link>https://maku.blog/p/tw75a7p/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tw75a7p/</guid><description>5 つの組み込みスカラー型 (Scalar types) GraphQL 仕様で定義されているスカラー型は次の 5 つで、これらを各オブジェクト型のフィールドの型や、フィールド引数の型として使用します。
型名 意味 Int 符号付き 32 ビット整数 Float 符号付き倍精度浮動小数点数 String 文字列（UTF-8 エンコーディング） Boolean true または false ID 一意の識別子。データ形式としては String と同様ですが、ID はリーダブル（意味のある単語）にはなっていないことを示唆します。ID は GraphQL サーバーとクライアントの間でオブジェクトの同一性を示すために使用します。 これ以外の型を使用したいときは、独自のオブジェクト型、スカラー型、列挙型を定義して使用します。
カスタムスカラー型 (Custom scalar types) スカラー型にフォーマット制約を設けたいときや、任意のクラスのインスタンスとして扱いたいときは、独自の カスタムスカラー型 を定義します。 例えば、日時や E メールアドレス、UUID、URI などは、カスタムスカラーを使うべき典型的なフィールドの例です。 カスタムスカラーは、スキーマドキュメント内で scalar キーワードを使って定義できます。
カスタムスカラー型の定義 &amp;#34;&amp;#34;&amp;#34; 日時を表すスカラー型 (ISO 8601 形式の文字列) &amp;#34;&amp;#34;&amp;#34; scalar DateTime type Event { title: String! startAt: DateTime } ライブラリの実装によりますが、カスタムスカラー型をそのまま使おうとすると、単なる String 型として扱われます。 カスタムスカラー型のデータを GraphQL サーバー型でどのようにハンドルするかは、サーバーライブラリごとに実装方法が提供されています。 例えば、下記は Golang の gqlgen ライブラリにおけるカスタムスカラー型のドキュメントです。 実装例として、yes や no として送られてきた文字列データを、Golang の bool 型として参照できるようにする方法が紹介されています。</description></item><item><title>GraphQL スキーマ仕様: @deprecated ディレクティブで非推奨のフィールドを示す</title><link>https://maku.blog/p/bg9g8rc/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bg9g8rc/</guid><description>GraphQL スキーマ内のある型のフィールドや Enum 値が非推奨になったことを表すには、@deprecated ディレクティブを使用します。 reason 引数で非推奨とされた理由を記述することができるので、その文章中に代替となるフィールド名を記述しておくと親切です。
次の例では、email フィールドが非推奨 (deprecated) になり、代わりに emailAddress フィールドを参照して欲しいことを示しています。
type User { emailAddress: String email: String @deprecated(reason: &amp;#34;Use &amp;#39;emailAddress&amp;#39;.&amp;#34;) }</description></item><item><title>GraphQL スキーマ仕様: インタフェース型 (interface type) を定義する</title><link>https://maku.blog/p/yp9mv5d/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yp9mv5d/</guid><description>インタフェース型を定義する GraphQL のインタフェース型は、複数の型が共通して持つフィールドを定義するための抽象型で、interface キーワードを使って定義します。 次の ScheduleItem インタフェースは、2 つのフィールド（id と title）を持つことを示しています。
スキーマ定義 # 共通のインタフェースを定義 interface ScheduleItem { id: ID! title: String! } インタフェースを実装する (imlements) 側の型は、必ず id と title フィールドを持つ必要があります。 次の Task オブジェクト型と Milestone オブジェクト型は、ScheduleItem というインタフェースを実装しています。
スキーマ定義（続き） # Task 型は必ず id と title フィールドを持つ type Task implements ScheduleItem { id: ID! title: String! content: String } # Milestone 型は必ず id と title フィールドを持つ type Milestone implements ScheduleItem { id: ID! title: String! date: DateTime } scalar DateTime type Query { allItems(): [ScheduleItem!</description></item><item><title>GraphQL スキーマ仕様: 型やフィールドに説明文 (description) を記述する</title><link>https://maku.blog/p/c5pbs6p/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c5pbs6p/</guid><description>GraphQL スキーマで定義する型には、Python の docstring と同様のフォーマットで description というドキュメントを付加できます。 description は型の直前、あるいはフィールドの直前に、3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲む形で記述します。
description の記述例 &amp;#34;&amp;#34;&amp;#34; Represents an auto-merge request for a pull request &amp;#34;&amp;#34;&amp;#34; type AutoMergeRequest { &amp;#34;&amp;#34;&amp;#34; The email address of the author of this auto-merge request. &amp;#34;&amp;#34;&amp;#34; authorEmail: String &amp;#34;&amp;#34;&amp;#34; The commit message of the auto-merge request. If a merge queue is required by the base branch, this value will be set by the merge queue when merging. &amp;#34;&amp;#34;&amp;#34; commitBody: String .</description></item></channel></rss>