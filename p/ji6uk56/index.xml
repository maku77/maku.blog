<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>プロコンのメモ on まくろぐ</title><link>https://maku.blog/p/ji6uk56/</link><description>Recent content in プロコンのメモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 31 Aug 2013 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/p/ji6uk56/index.xml" rel="self" type="application/rss+xml"/><item><title>プロコンメモ: At Coder - Typical DP Contest</title><link>https://maku.blog/p/o7ghox9/</link><pubDate>Sat, 31 Aug 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/o7ghox9/</guid><description>問題: https://tdpc.contest.atcoder.jp/assignments
Typical DP Contest: 問題 (A) コンテスト - 解答メモ 問題: https://tdpc.contest.atcoder.jp/tasks/tdpc_contest
取り得る得点の配列を dp[] として、0 問解くごとに、,どの得点を取り得るかの情報をアップデートしていけば OK です。 初期状態は、0 問解いたときに取り得る得点は 0 点だけなので、dp[0] = True として、あとは False に初期化しておきます。
a.py #!/usr/bin/python2.7 import sys def read_line(): return sys.stdin.readline().strip() def read_int(): return int(sys.stdin.readline()) def read_ints(): return [int(x) for x in sys.stdin.readline().split()] def solve(): # Read a problem N = read_int() P = read_ints() # Solve a problem dp = [False] * (sum(P) + 1) dp[0] = True for p in P: for i in reversed(range(len(dp))): if dp[i]: dp[i + p] = True return dp.</description></item><item><title>プロコンメモ: f(x) &lt;= a を満たす最大の整数 x を求める</title><link>https://maku.blog/p/kdxkan4/</link><pubDate>Sat, 27 Apr 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/kdxkan4/</guid><description>例えば、\( f(x) = x^3 + 2x^2 + 500000 \le 10^7 \) を満たす最大の整数 \( x \) を求めるには、以下のように二分探索で探すと高速に求められます。 二分探索は、大小関係をもとに絞り込みを行うため、\( f(x) \) は単調増加でなければいけません。
#!/usr/bin/env python def max_x(left, right, func, expect): while right - left &amp;gt; 1: mid = (left + right) // 2 if func(mid) &amp;lt;= expect: left = mid else: right = mid return left def f(x): return x**3 + 2 * x**2 + 500000 EXPECTATION = 10**7 x = max_x(0, 100000, f, EXPECTATION) print(&amp;#39;f({}) = {} &amp;lt; {} &amp;lt; {}&amp;#39;.</description></item><item><title>プロコンメモ: Dynamic Programming (2) Top-down DP から Bottom-up DP へ</title><link>https://maku.blog/p/gycxxxm/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/gycxxxm/</guid><description>DP では、問題を解くアプローチとして、大きく分けて
Top-down approach Bottom-up approach の 2 つのアプローチがあります。
Top-down DP の考え方 Top-down DP の方は、n 番目の値を求めたいときに、それに必要なより小さな値を再帰で求めます。 例えば、10 番目のフィボナッチ数 fib(10) を Top-down で求める場合、
fib(10) を求めるには fib(9) と fib(8) が必要だ（再帰呼び出し） fib(9) を求めるには fib(8) と fib(7) が必要だ（再帰呼び出し） &amp;hellip; 繰り返し &amp;hellip; fib(3) を求めるには fib(2) と fib(1) が必要だ（再帰呼び出し） fib(2) の答えは 1 である fib(1) の答えは 1 である と考えていきます。
Top-down DP によるフィボナッチ関数 #!/usr/bin/env python memo = {} def fib(n): if n in memo: return memo[n] if n &amp;lt;= 2: memo[n] = 1 else: memo[n] = fib(n-2) + fib(n-1) return memo[n] print(fib(2000)) # RuntimeError: maximum recursion depth exceeded in comparison Top-down DP で問題の答えを求める場合、直感的な記述ができる反面、明らかな欠点があります。 それは、関数呼び出しにかかるコストです。また、再帰関数の呼び出し数には限界があるため、あまり大きな値を求めることができないという欠点もあります。</description></item><item><title>プロコンメモ: Dynamic Programming (1) メモ化による高速化 (memoization)</title><link>https://maku.blog/p/pxw2pe2/</link><pubDate>Wed, 17 Apr 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/pxw2pe2/</guid><description>メモ化 (Memoization) ある関数が同じ引数で 2 回以上呼ばれる場合は、最初に返した値を記憶しておくことで、高速に結果を返すことができるようになります。 この手法を メモ化 (memoization) といいます。
例えば、以下のようなフィボナッチ関数 (fibonacci) を考えます。
Python def fib(n): if n &amp;lt;= 2: return 1 else: return fib(n - 2) + fib(n - 1) このような再帰による実装は、同じ引数での自分自身の呼び出しを何度も発生させてしまいます。 フィボナッチ数列の第 7 項を求めようとすると、以下のように指数関数的に呼び出し回数が増えていきます。
f(7) | +---------+---------+ | | f(5) + f(6) | | +----+----+ +----+----+ | | | | f(3) + f(4) f(4) + f(5) | | | | +-+-+ +-+-+ +-+-+ +-+-+ | | | | | | | | f(1)+f(2) f(2)+f(3) f(2)+f(3) f(3)+f(4) fib(1) &amp;hellip; 呼び出し回数 1 回 fib(5) &amp;hellip; 呼び出し回数 9 回 fib(10) &amp;hellip; 呼び出し回数 109 回 fib(20) &amp;hellip; 呼び出し回数 13529 回 fib(30) &amp;hellip; 呼び出し回数 1664079 回 fib(35) を求めようとすると、6 秒以上かかります。</description></item><item><title>プロコンメモ: C++ で標準入力から vector&lt;int> を作る技</title><link>https://maku.blog/p/qzxqy3m/</link><pubDate>Mon, 16 Apr 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/qzxqy3m/</guid><description>C++ で標準入力 cin から数値を読み込みながら vector&amp;lt;int&amp;gt; に詰めて行くとき、push_back() を使うと、以下のようにテンポラリ変数が必要になってしまいます。
vector&amp;lt;int&amp;gt; v; int temp; for (int i=0; i&amp;lt;N; ++i) { cin &amp;gt;&amp;gt; temp; v.push_back(temp); } 読み出す回数が N 回、のように決まっているのであれば、vector のサイズを先に初期化してしまうことで、インデックスを使って格納していくことができます。
vector&amp;lt;int&amp;gt; v(N); for (int i=0; i&amp;lt;N; ++i) cin &amp;gt;&amp;gt; v[i];</description></item><item><title>プロコンメモ: C++ で vector&lt;pair&lt;int, int> > をソートするテクニック</title><link>https://maku.blog/p/k3evguf/</link><pubDate>Sat, 24 Mar 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/k3evguf/</guid><description>下記のような pair&amp;lt;int, int&amp;gt; の格納された vector があるとします。
vector&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; v; これを単純にソートすると、first メンバが等しい場合は、second メンバの値を元に昇順ソートされます。
sort(v.begin(), v.end()); ここで、second メンバに関してだけ逆順（降順）にソートしたい場合はどうすればよいでしょうか？ すぐに思いつくのは、比較関数を用意して以下のように実装することです。
#include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;utility&amp;gt; // pair, make_pair #include &amp;lt;vector&amp;gt; using namespace std; bool comp(const pair&amp;lt;int, int&amp;gt;&amp;amp; a, const pair&amp;lt;int, int&amp;gt;&amp;amp; b) { if (a.first == b.first) { return a.second &amp;gt; b.second; // descending order } return a.first &amp;lt; b.first; // ascending order } int main() { vector&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; v; v.</description></item><item><title>プロコンメモ: 2 つの数値を連結した数値を作る (123 + 456 → 123456)</title><link>https://maku.blog/p/3bhhjxu/</link><pubDate>Fri, 16 Mar 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/3bhhjxu/</guid><description>たとえば、123 と 456 という数字を連結して、123456 という数字を作りたい場合、以下のように数値計算だけで求めるのが効率的です。 引数 left の値を、「right の桁数+1」分だけ 10 倍してやって、right と足し合わせているだけです。
c&amp;#43;&amp;#43; /* * Concatnate numbers as they are strings. * Both two numbers must not be negative (i.e. 0 or larger). * * e.g.) concat_num(100, 200) =&amp;gt; 100200 */ int concat_num(int left, int right) { int r = 10; while (r &amp;lt;= right) r *= 10; return (left * r) + right; } 以下のように、連結文字列を生成して再度数値に戻す方法は、数値だけで計算するよりも数十倍時間がかかってしまいます。
// NOT good (slower) int concat_num_BAD(int a, int b) { char buf[128]; snprintf(buf, sizeof(buf), &amp;#34;%d%d&amp;#34;, a, b); return atoi(buf); } テストコード int main() { cout &amp;lt;&amp;lt; concat_num(0, 0) &amp;lt;&amp;lt; &amp;#34; = 0&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(1, 1) &amp;lt;&amp;lt; &amp;#34; = 11&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(123, 0) &amp;lt;&amp;lt; &amp;#34; = 1230&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(0, 123) &amp;lt;&amp;lt; &amp;#34; = 123&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(300, 100) &amp;lt;&amp;lt; &amp;#34; = 300100&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(777, 999) &amp;lt;&amp;lt; &amp;#34; = 777999&amp;#34; &amp;lt;&amp;lt; endl; }</description></item></channel></rss>