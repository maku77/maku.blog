<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Next.js のプリレンダリングとルーティング on まくろぐ</title><link>https://maku.blog/p/3o3fq3d/</link><description>Recent content in Next.js のプリレンダリングとルーティング on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 05 May 2021 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/p/3o3fq3d/index.xml" rel="self" type="application/rss+xml"/><item><title>Next.js のプリレンダリング機能を使用する (getStaticProps)</title><link>https://maku.blog/p/iv4agnt/</link><pubDate>Tue, 04 May 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/iv4agnt/</guid><description>Pre-rendering とは ブログの記事一覧ページなどを生成する場合、なんらかの API で取得した値をもとにページのコンテンツを生成する必要があります。 例えば、次のように取得した値を使ってページを生成することになります。
Web API で取得した値 データベースのクエリ結果 ローカルファイルの内容や、ファイルの一覧情報 Next.js には、Web サイトのビルド時や、Web サーバーへのアクセス時にこういった API を呼び出して、HTML コンテンツを生成する Pre-rendering 機能が備わっています。 Pre-rendering 機能は次の 2 種類があり、どちらか一方を使うこともできますし、両方を組み合わせて使うこともできます。
SSG: Static Generation（静的サイトジェネレーション） Web サイトのビルド時に HTML ファイルを生成します。Web サーバーは静的な HTML ファイルを返すだけでよいので、パフォーマンスが非常に高くなります。すべてのページを事前に列挙できるのであれば、できるだけこの SSG を使って静的に HTML 生成してしまうことが推奨されています。静的な HTML ファイルをホスト可能なサーバー（GitHub Pages など）があれば、Web サイトを公開できます。 SSR: Server-side Rendering（サーバーサイドレンダリング） クライアントが Web サーバーにアクセスしたときに、サーバーサイドで動的に HTML を生成します。この仕組みを使うと、日々増減するデータを扱いやすくなりますが、Web サーバーとして Next.js サーバーを稼働させておく必要があります。感覚的には、PHP サーバーなどが動作しているイメージに近いです。 ちなみに、純粋に React.js のみを使用した場合とはどう違うのでしょうか？ React.js 自体には Pre-rendering 機能は備わっておらず、主に SPA (Single Page Application) を作成するライブラリとして使用されています。 React.js のみを使って上記の例のような記事一覧ページを生成する場合、Web ブラウザ上で JavaScript を実行してコンテンツを動的に生成する必要があります。 これを SSG や SSR と区別するために、CSR: Client-side rendering（クライアントサイドレンダリング） と呼びます。</description></item><item><title>Next.js のダイナミックルーティング機能を利用する (getStaticPaths, getStaticProps, getServerSideProps)</title><link>https://maku.blog/p/rdq3ep2/</link><pubDate>Wed, 05 May 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/rdq3ep2/</guid><description>ダイナミックルーティングとは Next.js では、pages/books/[id].tsx のようなファイル名でページを作成すると、1 つのファイルで、
/books/001 /books/002 /books/003 のようなパス (URL) によるアクセスをハンドルできます。 これを ダイナミックルーティング (Dynamic Routes) 機能と呼びます。
Next.js のページコンポーネント (/pages/xxx.tsx) は、そのページのエントリポイント（ルートコンポーネント）となるため、通常の React コンポーネントとは違って、上位のコンポーネントから props 情報を渡すことができません。 そこで Next.js では、ページコンポーネントの実装ファイル内で getStaticProps という関数を定義することで、ページコンポーネントに渡す props 情報を生成できるようにしています。 getStaticProps 内では、上記のような URL パラメータ情報（/books/[id] の id の部分の値）を取り出して、それを元に props 情報を生成できます。 この仕組みによって、Next.js のページコンポーネントは、1 つの .tsx ファイルで、複数のページ (.html) を生成できるようになっています。
ダイナミックルーティングの実装（SSG の場合） 静的ジェネレーション (SSG: Static Generation)、つまり Web サイトのビルド時にすべての HTML ファイルを生成してしまうには、あらかじめどのようなパラメーター（上記の例では id）でのアクセスが行われるかを把握した上で、各ページの内容を生成する必要があります。 これを実現するには、ページコンポーネントの実装ファイル (pages/*.tsx) で、次のような async 関数を実装して export します。
getStaticPaths 関数 URL のパラメーター部分（上記の例では id）で指定可能な値を返すように実装します。言い換えると、プリビルドすべきページの一覧情報を Next.</description></item><item><title>Next.js でローカル開発時 (next dev) のみ有効なデバッグページを作成する (getStaticProps)</title><link>https://maku.blog/p/3vbr2bm/</link><pubDate>Mon, 09 May 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/3vbr2bm/</guid><description>何をするか？ Next.js アプリを作っていると、開発中にだけ表示したいデバッグ用のページを作りたくなることがよくあります。 ここでは、ローカルサーバー (next dev) での開発中のみ有効になるデバッグページの作り方を説明します。
デバッグページの作成 Next.js の各ページのビルド時には、必要に応じてデータフェッチなどを行うための getStaticProps 関数が呼び出されます（参考: Next.js のプリレンダリング機能を使用する (getStaticProps)）。
この関数の戻り値として、notFound プロパティ を true にしたオブジェクトを返すと、そのページがないものとして扱うことができます（404 Not Found になる）。
export const getStaticProps: GetStaticProps = () =&amp;gt; { // ... return { // Return the default 404 page with a status code of 404. notFound: true } } この仕組みを利用して次のように実装すれば、ローカルサーバーでの開発中のみ表示可能なデバッグページを作ることができます。 ローカルサーバー (next dev) で実行されているかどうかは、環境変数 process.env.NODE_ENV の値で判断できます（参考: Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV)）。
src/pages/debug/info.tsx import { GetStaticProps, NextPage } from &amp;#39;next&amp;#39; type EmptyProps = { [key: string]: never } /** * デバッグページのビルド時の前処理。 * 開発サーバー (next dev) での実行時のみ、このページが存在するようにします。 * 本番サーバー (next start) での実行時は、404 Not Found になります。 */ export const getStaticProps: GetStaticProps&amp;lt;EmptyProps&amp;gt; = () =&amp;gt; { const isLocalDev = process.</description></item><item><title>Next.js でブラウザ履歴で戻るボタンを表示する (router.back)</title><link>https://maku.blog/p/m4dmu4c/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/m4dmu4c/</guid><description>Next.js の next/router モジュールが提供する NextRouter オブジェクトの back メソッド を呼び出すと、ブラウザの履歴に従って 1 つ前のページに遷移することができます。 つまり、ブラウザの「戻る」ボタンを押した場合と同じ振る舞いをします。 NextRouter オブジェクトは、useRouter フックで取得することができます。
次の BackButton コンポーネントはシンプルな「戻る」ボタンを表示し、クリック時に NextRouter#back() を呼び出します。
図: 戻るボタン（標準の button 版） components/BackButton.tsx import { FC } from &amp;#39;react&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; export const BackButton: FC = () =&amp;gt; { const router = useRouter() return ( &amp;lt;button alia-label=&amp;#34;戻る&amp;#34; type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; router.back()}&amp;gt; 戻る &amp;lt;/button&amp;gt; ) } 上の例では、素の button コンポーネントを使っていますが、mui (Material-UI) などの UI ライブラリを使えばリッチなボタンを表示できます。
図: 戻るボタン（mui 版） components/BackButton.</description></item><item><title>Next.js のページコンポーネントが Client と Server どちらで実行されているか調べる (isServer, isClient, NoSsr)</title><link>https://maku.blog/p/m7is4dn/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/m7is4dn/</guid><description>Next.js のページコンポネント (src/pages/*.tsx) の関数は、静的な HTML ファイルを生成するためにビルド時にも実行されます（参考: Next.js のプリレンダリング機能を使用する）。 従来の React による SPA アプリはクライアントサイド JavaScript でしか実行されないので、同じような感覚で実装していると振る舞いの違いでハマることがあります。 例えば、ページコンポーネントから次のように window オブジェクトを参照しようとすると、Next.js によるプリレンダリング時にエラーになります。 これは、window オブジェクトは、Web ブラウザ上で JavaScript を実行しているときにしか存在しないからです。
src/pages/hello.tsx import { FC } from &amp;#39;react&amp;#39; const HelloPage: FC = () =&amp;gt; { console.log(window.location) // ReferenceError: window is not defined return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; } 逆に言うと、実行時に window オブジェクトが存在しているかどうかを調べることによって、ページコンポーネント内のコードが、どのタイミングで実行されているかを判別できます。
const isClient = () =&amp;gt; typeof window !== &amp;#39;undefined&amp;#39; // const isServer = () =&amp;gt; typeof window === &amp;#39;undefined&amp;#39; const HelloPage: FC = () =&amp;gt; { if (isClient()) { console.</description></item><item><title>Next.js でハッシュフラグメントを扱う（useHash カスタムフック）</title><link>https://maku.blog/p/k2ahpw5/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/k2ahpw5/</guid><description>ハッシュフラグメントとは URL のハッシュフラグメントというのは、下記のような URL の末尾の # 以降の部分を指します。
https://examle.com/sample#AAA 似たようなものにクエリパラメーター（?key=val のみたいなの）もありますが、ハッシュフラグメントは HTTP リクエスト時に、その文字列（上記の例では AAA）がサーバーに送られないという違いがあります。 つまり、ハッシュフラグメントの値は、クライアントサイドで使用することが意図されています。
useHash フックの実装 下記の useHash 関数は、Next.js でハッシュフラグメントを簡単に扱えるようにするカスタムフックの例です。 useState フックと同じ感覚で使えるように、ハッシュフラグメントの現在値と、設定用の関数をペアで返します。
src/libs/useHash.ts import { useCallback } from &amp;#39;react&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; /** * URL のハッシュフラグメント部分を扱うためのフックです。 * * 次のようにすると、`hash` 変数に URL の `#` 以降の値が格納されます。 * URL の `#` 以降の値を変更したいときは、`setHash` 関数を使用します。 * * ``` * const [hash, setHash] = useHash() * ``` */ export function useHash(): [string, (newHash: string) =&amp;gt; void] { const router = useRouter() const hash = extractHash(router.</description></item><item><title>Next.js のコンポーネント内でクエリ文字列を取得する (next/router, useRouter)</title><link>https://maku.blog/p/r7fou3a/</link><pubDate>Sun, 27 Jun 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/r7fou3a/</guid><description>クエリ文字列とは https://example.com/todos?sortby=title&amp;amp;order=asc URL のクエリ文字列（クエリパラメーター）というのは、上記のような URL の末尾の ? 以降の、sortby=title&amp;amp;order=asc の部分のことを指します。 この部分を参照する方法としては、主に次の 2 種類の方法があります。
クライアントサイド JS &amp;hellip; useRouter フックを使う サーバーサイド JS &amp;hellip; getServerSideProps に渡されるパラメーターを使う クライアントサイド JS からクエリパラメーターを参照する (router.query) Next.js の useRouter フック を使うと、上記のようなクエリパラメーター部分を簡単に抽出することができます。 次の例では、クエリパラメーターとして渡された sortby と order の値を取得しています。 値が省略された場合は、それぞれの値は undefined になります。
src/pages/todos.tsx import { NextPage } from &amp;#39;next&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; const TodosPage: NextPage = () =&amp;gt; { const router = useRouter() const { sortby, order } = router.query console.</description></item><item><title>Next.js でサーバーサイドで JSON や YAML ファイルを読み込む (fs.readFileSync)</title><link>https://maku.blog/p/iz8fnu3/</link><pubDate>Sun, 09 May 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/iz8fnu3/</guid><description>何をするか？ Next.js アプリのページコンポーネントの getStaticProps / getServerSideProps 関数や、API ルート (pages/api/*.ts) の handler 関数は、クライアントからのアクセス時やビルド時に、サーバーサイドで呼び出されます。 つまり、これらの関数の中では、Node.js の fs モジュールを使った（サーバー上の）ローカルファイルの読み込みが可能です。
ここでは、例として、
ページコンポーネントの getStaticProps 関数から JSON ファイルを読み込む方法 API ルートの handler 関数から YAML ファイルを読み込む方法 を紹介します。
JSON ファイルを読み込む（in getStaticProps 関数） 使用する JSON ファイル サンプルデータとして次のような JSON ファイルをプロジェクト内に配置します。
src/data/games.json [ { &amp;#34;id&amp;#34;: &amp;#34;dq1&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;dq2&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト2&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;dq3&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト3&amp;#34; } ] JSON ファイルを読み込む 次のコードでは、getStaticProps 関数の中で src/data/games.json ファイルを読み込んで、ページコンポーネントに渡す props データを作成しています。
src/pages/games.tsx import * as fs from &amp;#39;fs&amp;#39; import * as path from &amp;#39;path&amp;#39; import { GetStaticProps, NextPage } from &amp;#39;next&amp;#39; type Game = { id: string, title: string } type PageProps = { games: Game[] } export const getStaticProps: GetStaticProps&amp;lt;PageProps&amp;gt; = async (context) =&amp;gt; { // JSON ファイルを読み込む const jsonPath = path.</description></item></channel></rss>