<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技術系のメモ on まくろぐ</title><link>https://maku.blog/p/3ftx6b2/</link><description>Recent content in 技術系のメモ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 06 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/3ftx6b2/index.xml" rel="self" type="application/rss+xml"/><item><title>NPM パッケージを作るときの package.json ファイルの書き方に関してのメモ</title><link>https://maku.blog/p/ryq6it6/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ryq6it6/</guid><description>name, version フィールド name と version フィールドは、パッケージを公開するつもりがないなら指定する必要はありません。
description フィールド description プロパティは、ユーザーがこのパッケージを探しやすくするための説明文で、npm search を実行したときに表示されます。
パッケージ対象外にするファイル (.npmignore / .gitignore) NPM パッケージを作るときに、.npmignore に書かれたファイルはパッケージングされなくなります。 .npmignore ファイルがない場合は、.gitignore ファイルが代わりに参照されます。 これらの設定にかかわらず、下記のファイルは必ずパッケージングされます。
package.json
README（大文字小文字と拡張子は問わない）
CHANGES / CHANGELOG / HISTORY（大文字小文字と拡張子は問わない）
LICENSE / LICENCE（大文字小文字と拡張子は問わない）
NOTICE（大文字小文字と拡張子は問わない）
main フィールドで指定されたファイル
bin フィールド NPM パッケージで何らかの実行コマンドを提供したいときは、bin フィールドを使用します。 例えば、mycommand コマンドを提供するときは次のように記述します。
{ // ... &amp;#34;bin&amp;#34;: { &amp;#34;mycommand&amp;#34;: &amp;#34;./cli.js&amp;#34; } } 単独のコマンドをインストールするための NPM パッケージを作る場合は、bin フィールドのコマンド名を省略して次のように記述できます。</description></item><item><title>macOS で不要なファイルを削除してストレージ容量を確保する</title><link>https://maku.blog/p/ygpw6dk/</link><pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ygpw6dk/</guid><description>macOS のストレージ容量が足りなくなってきたときのために、各種キャッシュの削除方法などをまとめておきます。
Homebrew (brew) 関連 古いバージョンの削除 brew コマンドでいろいろコマンドをインストールしていると、古いバージョンのモジュールが /usr/local/Cellar ディレクトリの中にどんどん増えていきます。 brea cleanup コマンドで、古いモジュールを削除できます。
# ドライラン（何が削除されて、何MBくらい減らせるか確認） $ brew cleanup -n # 実際に削除 $ brew cleanup 各モジュールでどのようなバージョンがインストールされているかは、次のように確認することができます。
$ brea ls-versions ... libxext 1.3.4 libxrender 0.9.10 libyaml 0.1.6_1 0.2.5 0.1.7 ... ダウンロードキャッシュの削除 Homebrew のダウンロードキャッシュが格納されているディレクトリは次のコマンドで確認できます。
$ brew --cache /Users/maku/Library/Caches/Homebrew 次のようにしてキャッシュディレクトリごとまとめて削除できます。
$ rm -rf `brew --cache` ライブラリフォルダ内のキャッシュを削除 $ rm -rf ~/Library/Caches/* Ruby 関連 gem # インストールされている Gem のバージョン一覧 $ gem list # 古いバージョンの削除（ドライラン） $ gem cleanup --dryrun # 古いバージョンの削除（実行） $ gem cleanup</description></item><item><title>macOS のスポットライトのインデックス処理を停止・開始する</title><link>https://maku.blog/p/j5gr3dn/</link><pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j5gr3dn/</guid><description>macOS の mdutil コマンドを使用すると、スポットライトのインデックス設定を変更することができます。
インデックス処理の現在の設定を調べる $ sudo mdutil -a -s /: Indexing enabled. /System/Volumes/Data: Indexing enabled. /Volumes/SD_card: Indexing and searching disabled. インデックス処理を無効化する $ sudo mdutil -a -i off インデックス処理を有効化する $ sudo mdutil -a -i on インデックスを削除して再生成 $ sudo mdutil -a -E</description></item><item><title>JavaScript で任意のテキストをクリップボードにコピーする</title><link>https://maku.blog/p/buk5i2o/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/buk5i2o/</guid><description>copyToClipboard 関数 次の copyToClipboard 関数を使うと、引数で指定したテキストを OS のクリップボードにコピーすることができます。
function copyToClipboard(text){ // テキストコピー用の一時要素を作成 const pre = document.createElement(&amp;#39;pre&amp;#39;); // テキストを選択可能にしてテキストセット pre.style.webkitUserSelect = &amp;#39;auto&amp;#39;; pre.style.userSelect = &amp;#39;auto&amp;#39;; pre.textContent = text; // 要素を追加、選択してクリップボードにコピー document.body.appendChild(pre); document.getSelection().selectAllChildren(pre); const result = document.execCommand(&amp;#39;copy&amp;#39;); // 要素を削除 document.body.removeChild(pre); return result; } JavaScript からクリップボードにテキストをコピーするときは、任意の HTML 要素のテキストを選択して、document.execCommand('copy') を実行するという流れになります。 そのため、上記の関数では、テキスト選択用の一時的な pre 要素を作成しています。
使用例 例えば次のようにすると、ボタンを押したときにクリップボードにテキストをコピーできます。
クリップボードにコピー ← 実際に動作します
function copyToClipboard(text){ const pre = document.createElement('pre'); pre.style.webkitUserSelect = 'auto'; pre.style.userSelect = 'auto'; pre.</description></item><item><title>JavaScript で現在のページの URL の構成要素を取得する (window.location)</title><link>https://maku.blog/p/j6iu6gs/</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6iu6gs/</guid><description>Web サイト上で実行される JavaScript から window.location を参照すると、カレントページの URL の構成要素をパーツごとに取得することができます。
JavaScript const loc = window.location; console.log(&amp;#39;location.href = &amp;#39; + loc.href); console.log(&amp;#39;location.origin = &amp;#39; + loc.origin); console.log(&amp;#39;location.host = &amp;#39; + loc.host); console.log(&amp;#39;location.protocol = &amp;#39; + loc.protocol); console.log(&amp;#39;location.hostname = &amp;#39; + loc.hostname); console.log(&amp;#39;location.port = &amp;#39; + loc.port); console.log(&amp;#39;location.pathname = &amp;#39; + loc.pathname); console.log(&amp;#39;location.search = &amp;#39; + loc.search); console.log(&amp;#39;location.hash = &amp;#39; + loc.hash); 例えば、次のようなアドレスにアクセスした場合は、
https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose 次のような結果を取得することができます。
location.href = https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose location.origin = https://example.com:8042 location.host = example.</description></item><item><title>お名前.com の共用サーバーを Let's Encrypt で SSL 対応</title><link>https://maku.blog/p/s46j9sq/</link><pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s46j9sq/</guid><description>Chrome で https に対応していない Web サイトにアクセスすると、アドレスバーに「保護されていない通信」という警告が出るようになりました。 Web サーバーの管理者は、https (SSL) への対応がほぼ必須になっています。 ここでは、お名前.com の共用サーバー（SD-11、SD-12 プランなど）で、SSL を有効にし、http によるアクセスがあったときに https なアドレスにリダイレクトする設定方法を説明します。
Let&amp;rsquo;s Encrypt による SSL 対応 お名前.com の共用サーバーで Web サイトを運用している場合は、下記のコントロールパネルからポチポチやるだけで、簡単に SSL (https) によるアクセスを有効にすることができます。
共用サーバーSD コントロールパネル https://cp.rentalserver.jp/ 自前の Web サーバで SSL 設定を行おうとすると、証明書の発行手続きや設定などが結構面倒ですが、このコンパネからポチポチやれば 1 分で設定完了です。 無料証明書で有名な Let&amp;rsquo;s Encrypt のサービスに対応しているので、無料で SSL 対応することができます。
http アクセスを https にリダイレクトする 数時間待って、無事 SSL の設定が反映されると、https:// によるウェブサイトへのアクセスが可能になります。 ただし、そのままだと古い http:// のサイトも残ったままです。
ここでは、Web サーバー (Apache) の設定ファイルである .htaccess を修正（なければ新規作成）することで http から https へのリダイレクト設定を行います。 ここでは、下記のような手順で修正することにしましょう。</description></item><item><title>WinSCP をコマンドラインから利用して2つのディレクトリを同期する</title><link>https://maku.blog/p/eqrmt6x/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eqrmt6x/</guid><description>WinSCP のインストール WinSCP の本体は下記のサイトからダウンロードできます。
WinSCP :: Official Site :: Download ここでは、コマンドラインから winscp.exe を使用しますので、インストーラを使ってインストールするときに、カスタムインストールを選択し、インストールディレクトリを環境変数(%PATH%)に追加を選択してください。
winscp コマンドでリモートホストへディレクトリをコピーする ローカルディレクトリの内容を、リモートにあるディレクトリへ同期させるには、次のように winscp.exe の /synchronize オプションを使用します。
winscp [mysession] /synchronize [local_directory] [remote_directory] 例えば、example.com というホストに、ユーザ名 user で接続してローカルの website ディレクトリ内のファイルを user のホームディレクトリの public_html ディレクトリに同期させるには次のようにします。
例: ローカルの website をリモートの public_html へ winscp user@example.com /synchronize &amp;#34;C:\Users\maku\website&amp;#34; &amp;#34;/user/maku/public_html&amp;#34; 参考 WinSCP のドキュメント (Command-line Options)</description></item><item><title>ソフトウェアアーキテクトが考えること</title><link>https://maku.blog/p/x2b2gw3/</link><pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x2b2gw3/</guid><description>ソフトウェアアーキテクチャとは アーキテクチャとは「要求と設計の橋渡し」である ─『オブジェクト開発の神髄』より
外部から見える特性 構成要素 構成要素間の関係 アーキテクトが考えること 何をもとにシステムを設計するか 部品をどのように組み立てるか システムをどのように動作保証するか パフォーマンス アーキテクチャドライバとは アーキテクチャを決定する要件のことを「アーキテクチャドライバ」といいます。 つまり、アーキテクチャドライバはアーキテクチャ設計のためのインプットとなります。 アーキテクチャドライバには以下の３つの要素があります。
制約（最重要。変更できないものだから） ビジネス制約 技術制約 品質特性 Performance 性能 Modifiability 変更容易性 Usability ユーザビリティ Availability 可用性 Security セキュリティ Testability テスト容易性 主な機能要件（重要性としては一番低い。ほとんどの場合、制約にかかわらず実現できるので） アーキテクチャドライバはステークホルダーとのコミュニケーションの道具であり、このアーキテクチャドライバの作成（文章作成）を行うのがアーキテクトの最初の仕事です。
アーキテクチャ設計のステップ アーキテクチャ要件抽出 アーキテクチャドライバの作成（要求を要件として分類する。上の３つの要素） ステークホルダーと仕様優先度レビュー アーキテクチャドライバに基づくシステムの分割 ソフトウェアアーキテクチャレビュー アーキテクチャドキュメント ソフトウェアは様々な視点で捉えられ、これをビュー (View) と呼びます。 アーキテクチャドキュメントはビューの集合と相互作用の説明で構成されます。
アーキテクトが作成すべき図の例 パッケージ図 パッケージ間の依存関係 それぞれのパッケージに何が配置されるか ソースコードやライブラリの物理構造 コンポーネント図 配置図 物理的なハードウェアやソフトウェアの配置 実行環境を表すノードとの接続関係など アーキテクチャパターン アーキテクチャパターンとは、「アーキテクチャの要素と要素間の関係を使い方の制約と共に特定したもの」です。 ─出展『Principles of software architecture』。</description></item><item><title>macOS で JAVA_HOME に設定すべきパスを調べる（java_home コマンド）</title><link>https://maku.blog/p/7jkgzd4/</link><pubDate>Sat, 19 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7jkgzd4/</guid><description>複数の JDK がインストールされている場合にバージョンを切り替えて java (javac) コマンドを使用するには、JAVA_HOME 環境変数を設定します。 JAVA_HOME に設定すべきパスは、java_home コマンドで調べることができます。 下記は、Apple の JDK1.6、Oracle の JDK1.8 がインストールされている場合の出力例です。
$ /usr/libexec/java_home -v 1.6 /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home $ /usr/libexec/java_home -v 1.8 /Library/Java/JavaVirtualMachines/jdk1.8.0_11.jdk/Contents/Home 普段使用する JDK バージョンは、下記のように .bash_profile で設定しておけばよいでしょう。
~/.bash_profile # JDK 1.6 を使用する場合 export JAVA_HOME=$(/usr/libexec/java_home -v 1.6) # JDK 1.8 を使用する場合（デフォルト） export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</description></item><item><title>Node.js で Evernote API を使用する（evernote モジュールインストールする）</title><link>https://maku.blog/p/ti537g4/</link><pubDate>Mon, 11 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ti537g4/</guid><description>Evernote API を使用するには、API キーの取得と、Sandbox 用アカウントの作成を行っておく必要があります。
API キーの取得: http://dev.evernote.com/#apikey Sandbox 用アカウントの作成: https://sandbox.evernote.com Node.js から Evernote API を使用するために、evernote モジュールをインストールします。
$ npm install evernote 下記のようにして、evernote モジュールをロードできれば準備完了です。
var Evernote = require(&amp;#39;evernote&amp;#39;).Evernote; console.log(Evernote.EDAM_VERSION_MAJOR); console.log(Evernote.EDAM_VERSION_MINOR);</description></item><item><title>HTTP ヘッダに関するメモ</title><link>https://maku.blog/p/3kkchub/</link><pubDate>Sat, 15 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3kkchub/</guid><description>プロキシ経由時の「リクエスト行」の URI について プロキシサーバを介する場合は、リクエスト行に絶対アドレス指定で URI を指定する必要があります。 これは、リクエストを受け取ったプロキシサーバが、リクエストの転送先サーバを判断するためです。
Client ｜ ｜ GET http://target.example.com/index.html HTTP/1.1 ▽ Proxy server ｜ ｜ GET /index.html HTTP/1.1 ▽ target.example.com HTTP1.1 の Host 指定 HTTP1.1 では、メッセージヘッダに Host: の指定が必須です。これはバーチャルホストの機能を実現するためです。 HTTP1.0 を使う場合は、Host: の指定は必要ありません。
HTTP のメッセージヘッダの種類 HTTP のメッセージヘッダには、大きく分けて、
End-to-End Hop-by-Hop の 2 種類があります。</description></item><item><title>電子署名と電子証明書の基礎</title><link>https://maku.blog/p/fzwyf7z/</link><pubDate>Fri, 28 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fzwyf7z/</guid><description>電子署名（デジタル署名）(digital signature) 「電子署名」とは、データに付加され、そのデータが本当に作成者が作ったのかを確認するためのものです。 別の言い方をすると、受け取ったデータが第三者によって作られた偽物でないことを確認するための印です。
以下のような手順で、データが偽物でないか確認します。
データ送信側の「電子署名の作成」手順 送信するデータのメッセージダイジェストを求める。 メッセージダイジェストを非公開鍵 (private key) で暗号化し、「電子署名」とする。 データ受信側の「電子署名の確認」手順 受信した「データ」のメッセージダイジェストを求める。 受信した「電子署名」を「送信者の公開鍵」で復号化し、メッセージダイジェストに戻す。 1 と 2 のメッセージダイジェストが等しければ、本人が作成したデータだと分かる。 上記の手順からも分かるように、一般的に「電子署名」の仕組みには、公開鍵暗号方式が用いられます。 問題は、公開鍵 (public key) が偽物である場合に、なりすましができてしまうことです。 そこで、公開鍵が本物であるかを証明するための、「電子証明書」が必要になってきます。
電子証明書（デジタル証明書) (digital certificate) 電子証明書とは？ 公開鍵が偽物であると、公開鍵暗号方式は意味をなさなくなるため、公開鍵の正当性を証明することが重要になってきます。 電子証明書は、ある公開鍵が本物であることを証明するためのものです。
電子証明書は、一般的には、ITU-T X.509 の標準フォーマット（拡張子 .cer）で作成されます。 X.509 で作成された電子証明書ファイル (.cer) には、公開鍵そのものに加え、公開鍵の作成者（証明書の申請者）の情報、有効期限などが含まれています。
電子証明書の発行 電子証明書は、公開鍵が本物であることを示すためのものですが、その電子証明書自体が本物であることを示すために、末尾に電子署名が付加されます。 その署名は、公開鍵を作成したユーザが行うこともあるし、信頼のおける第三者が行うこともあります。 通常は、信頼のおける第三者機関である認証局 (CA: Certificate Authority) が電子証明書への署名を行い、電子証明書の発行を行います。
電子証明書 (X.509) の構成 電子証明書は、下記のようなデータで構成されています。
+------------------------------------+---------------------------------+ | 公開鍵 + 作成者情報 + 有効期限など | ← これが本物だと示す CA の署名 | +------------------------------------+---------------------------------+ 認証局による電子証明書の発行の流れ 公開鍵の作成者が、身元情報と公開鍵を CA（認証局）へ提出する。 CA は 1 の情報を厳密に審査し、電子証明書（X.</description></item><item><title>XAMPP/Apache の DocumentRoot を設定する</title><link>https://maku.blog/p/6h47cno/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6h47cno/</guid><description>httpd.conf を編集 例えば、Mac OSX にインストールした XAMPP の Apache の場合は、/Applications/XAMPP/xamppfiles/etc/httpd.conf を編集します。
(1) DocumentRoot の変更 DocumentRoot &amp;#34;/Applications/XAMPP/xamppfiles/htdocs&amp;#34; ↓ DocumentRoot &amp;#34;/Users/maku/website/public_html&amp;#34; (2) 対応する Directory ディレクトリの変更 &amp;lt;Directory &amp;#34;/Applications/XAMPP/xamppfiles/htdocs&amp;#34;&amp;gt; ↓ &amp;lt;Directory &amp;#34;/Users/maku/website/public_html&amp;#34;&amp;gt; トラブルシューティング http://localhost/ にアクセスしたときに以下のようなエラーが出た場合は、DocumentRoot として設定した、ディレクトリのパーミッションを確認します。
Access forbidden! You don't have permission to access the requested directory. There is either no index document or the directory is read-protected. 例えば、DocumentRoot として、/aaa/bbb/ccc を設定した場合、/aaa、/aaa/bbb、/aaa/bbb/ccc 全てに read パーミッションがついている必要があります。
$ chmod 0755 /aaa $ chmod 0755 /aaa/bbb $ chmod 0755 /aaa/bbb/ccc</description></item><item><title>Unicode、フォント関連用語</title><link>https://maku.blog/p/hrhozs9/</link><pubDate>Tue, 24 Apr 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hrhozs9/</guid><description> Unicode.org の Unicode 関連用語集 用語まとめ font family Arial とか Courier とか。 font face font family に、Italic とか Bold とかの区別を加えたもの（ノーマルなものは Regular）。 font collection 複数の face を 1 つのファイルに含んだもの。 glyph 文字を描画したときの形。フォントファイルは、ビットマップで glyph を持つこともあるし、ベクターデータで glyph を持つこともある。 ligature 合字。２文字以上をくっつくて１文字を表現したもの。 character map (charmap) 特定の encoding の文字コードを、glyph index にマッピングするための情報。１つの Font face は複数の charmap を含んでいることが多い。Mac 用の charmap、Unicode（Windows）の charmap など。 スクリプト スクリプト（書体）は言語の文字情報を表す記号の集まりです。スクリプトの例には、ラテン文字、アラビア文字、漢字、ギリシャ文字があります（参考: http://unicode.org/reports/tr24/ ）。</description></item><item><title>CPU のアーキテクチャ名と CPU 名の対応表</title><link>https://maku.blog/p/v7bxgmn/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v7bxgmn/</guid><description>Intel 系 CPU アーキテクチャ名 CPU名 i386 80386 i486 80486 i586 Pentium, MMX Pentium i686 Pentium Pro, Pentium II, Pentium III, Pentium 4 athlon Athlon, Athlon MP, Athlon XP x86_64 Opteron, Athlon64, Xeon (EM64T), Core, Core2Duo メモ x86 (IA-32) &amp;ndash; Intel 社の 8086 系のプロセッサの略称。（binary hacks より） x86_64 (AMD64) &amp;ndash; AMD が設計した x86 上位互換の 64 ビットプロセッサのアーキテクチャ。（binary hacks より）</description></item><item><title>syslog のログの保存先の設定</title><link>https://maku.blog/p/rm78k9i/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rm78k9i/</guid><description>/etc/syslog.conf に以下のように記述されていれば、debug レベルのログは /var/log/debug に、info, notice, warn レベルのログは /var/log/messages に記録されます。
*.=debug; \ auth,authpriv.none;\ news.none;mail.none -/var/log/debug *.=info;*.=notice;*.=warn;\ auth,authpriv.none;\ cron,daemon.none;\ mail,news.none -/var/log/messages</description></item><item><title>ネットワークトラブルの調査手順</title><link>https://maku.blog/p/eecgkww/</link><pubDate>Sun, 10 Oct 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eecgkww/</guid><description>ネットワークトラブルはホストに近いところからチェックしていくのがセオリーです。 ソフトウェア的要因よりも、ハードウェア的要因の方を先に調べるのがよいです。
ハードウェア的要因 ケーブルの断線 NIC の故障 電源の故障 ポートの接触不良 機器の熱暴走 ソフトウェア的要因 IP アドレスの設定ミス デフォルトゲートウェイの設定ミス VLAN の設定ミス ルーティングテーブルの不具合 サーバアプリケーションの設定ミス／不具合 参考: NETWORKWORLD - May 2007
ping による調査 あるホストに ping が通らないときは、以下の順番で ping を通す確認をしていきます。 テスト結果は正常時の結果と比べなければ意味がないので、正常時の tracert 結果などを定期的にとっておくことが重要です。
ループバックアドレスに対して ping TCP/IP モジュールの異常の可能性 ホストの IP アドレスへ ping OS が NIC を認識していない可能性 同じスイッチに接続された別の PC へ ping スイッチのポート、ケーブルの故障 VLAN の設定ミス、接続ミス スイッチ自体には IP アドレスは設定されないので、別の PC に ping することで、スイッチまでの接続を確認する。 ルータに ping ルータのダウン、アドレス設定ミス ルータの別のポートへ ping ルーティングプロセスの異常 インタフェースの設定ミス ルータは複数のネットワークにつながっているので、別のネットワーク用のポートにも ping する必要がある。 異なるネットワークの PC へ ping tracert で、通信不能ネットワークを切り分け ターゲットホストに ping ターゲットホストのダウン アプリケーソンレベルの確認 参考: NETWORKWORLD - May 2007</description></item><item><title>暗号技術まとめ</title><link>https://maku.blog/p/6rn67mc/</link><pubDate>Tue, 20 Dec 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6rn67mc/</guid><description>昔の暗号 シーザー暗号 - 文字をずらすだけの最も古い暗号。ジュリアス・シーザー（ユリウス・カエサル）が作った。 共通鍵暗号 ブロック暗号 ブロック暗号というのは、共通鍵暗号の一種。 データを一定のブロックごとに暗号化する方式。 高速な暗号化処理を行える。
Triple DES - 1990年代。64 bit のブロック暗号 DES を 3 回繰り返す暗号化アルゴリズム。かつては米国政府標準暗号だった。 MISTY1 - 1990年代。三菱電機が開発した 128 bit 暗号鍵を持つ 64 bit ブロック暗号アルゴリズム。 CAST-128 - 64 bit ブロック暗号。 Camellia - 2000年代。128 bit ブロック暗号。NTT・三菱電機。 AES: Advanced Encryption Standard - 2000年代。128 bit ブロック暗号。 SEED - 128 bit ブロック暗号。 国際標準のブロック暗号 (ISO/IEC18033-3) は、Camellia、AES、SEED、CAST-128、MISTY1、Triple DES。
ストリーム暗号 MUGI MULTI-S01 SNOW 国際標準のストリーム暗号 (ISO/IEC18033-4) は、MUGI、MULTI-S01、SNOW。
公開鍵暗号 RSA RSA: Rivest - Shamir - Adleman - 大きな素数の素因数分解が難しいという根拠に基づいた暗号方式。 楕円曲線暗号 楕円曲線状での離散対数問題に基づいた公開鍵暗号方式。</description></item><item><title>IETF によるプロトコル標準化の流れ</title><link>https://maku.blog/p/44o4a9p/</link><pubDate>Wed, 01 Oct 2003 00:00:00 +0000</pubDate><guid>https://maku.blog/p/44o4a9p/</guid><description>プロトタイプが普及する 独自バージョンが作られるようになる IETF (Internet Engineering Task Force) の援助で Working group が作られる Working group は「インターネットドラフト」としてプロトコルを文書化する IETF の IESG (Internet Engineering Steering Group) に提出する 実験期間を経て、IESG によって RFC 番号が割り当てられ、修正などをして「実験 RFC」として公表される 実際の運用によるテストを経て、IESG が「提案標準」として認定する IESG が「ドラフト標準」に推薦する プロトコルに STD 番号が割り当てられ、RFC に加えて STD となる 上記の流れで最低でも 10 ヵ月以上はかかる。</description></item><item><title>画像の2値化の閾値を求める方法いろいろ</title><link>https://maku.blog/p/uyp4geh/</link><pubDate>Fri, 25 May 2001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uyp4geh/</guid><description> 平均法（平均を取るだけ）← 使えない Pタイル法（物体・背景の面積が分かっている場合）← 自動ではない モード法（極小を求める）← グラフを滑らかにする必要がある 判別分析法（クラス間分散が最大となるところで２値化する）← Good</description></item></channel></rss>