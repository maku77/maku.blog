<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Next.js アプリの環境構築 on まくろぐ</title><link>https://maku.blog/p/3o2ep2c/</link><description>Recent content in Next.js アプリの環境構築 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 04 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/3o2ep2c/index.xml" rel="self" type="application/rss+xml"/><item><title>Next.js で HelloWorld（プロジェクト作成からサーバー起動まで）</title><link>https://maku.blog/p/ubmu3bj/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ubmu3bj/</guid><description>Next.js とは Next.js は、React.js アプリ開発に必要なアレコレを詰め込んだパッケージです。 React.js を素の状態で導入すると、他にもいろいろなツールやライブラリを組み合わせていくことになるのですが、Next.js を使うとモダンな Web アプリ開発に必要なものが一気に揃えられます。
React.js は基本的に SPA（シングルページアプリ）を想定していますが、Next.js では複数ページによる構成や、サーバーサイドレンダリングなどをサポートしています。 これは、Next.js が単なる React.js 用のコンポーネントライブラリでないことを示しています。
Next.js には次のような特徴があります。
ゼロコンフィグ: 何も設定しなくても、最初から開発サーバーの立ち上げ、プロダクト用ビルドを行えるようになっています。これらは、最適なパフォーマンスが出るようメンテナンスが続けられています。カスタマイズしたいときも、複雑怪奇な webpack.config.js を作成する必要はなく、next.config.js による最小限の設定で済みます。できれば何も設定しないのが理想です。 SSR/SSG によるプリレンダリング: React.js はクライアントサイドで JavaScript を実行する CSR (Client Side Rendering) で動作しますが、Next.js は SSR (Server Side Rendering) や SSG (Static Site Generation) をサポートしています。これは、一般的な Node.js の API を利用してページを構築できることを意味します。開発元の Vercel は、パフォーマンスの面から SSG を推奨しています。 TypeScript をサポート: いまどきの Web アプリ開発では TypeScript はほぼ必須なので、標準サポートはうれしいです。空の tsconfig.js を置くだけで、TypeScript 対応は完了です（設定は自動で行われます）。 ファイルベースのルーティング: pages ディレクトリ以下の構成をそのままルーティング用のリンク名として使うことができます。例えば、pages/xxx/yyy.js は、/xxx/yyy というリンク名にマッピングされます。React Router によるルーティング設定が面倒だと感じている人にとってはうれしいかもしれません。 部分的な高速リロード (Fast Refresh): Next.</description></item><item><title>Next.js のプロジェクトを TypeScript 化する</title><link>https://maku.blog/p/ny9fmty/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ny9fmty/</guid><description>何をするか？ create-next-app コマンドで Next.js プロジェクトを生成するときに --typescript (--ts) オプションをつけて実行すると、TypeScript 対応したプロジェクトを生成することができます。
$ npx create-next-app myapp --typescript # ただ、こっちのテンプレートを使う方法の方が若干洗練されてる気はする $ npx create-next-app myapp --example with-typescript また、Next.js は既存の JavaScript プロジェクトを TypeScript 化する機能も備えています。 ここから先は、その方法を説明します。
参考 Next.js で HelloWorld TypeScript 環境の導入 Next.js は、プロジェクトのルートに tsconfig.json ファイルがあると、自動的に TypeScript モードで動作するようになります。 次のようにして、空の tsconfig.json ファイルを作成し、TypeScript 用のパッケージをインストールします。
$ touch tsconfig.json $ npm install typescript @types/node @types/react --save-dev なんと、これだけで Next.js プロジェクトへの TypeScript 導入は完了です。 お手軽〜
自動生成される設定ファイルを見ておく 上記のステップで、TypeScript の設定ファイル (tsconfig.json) に何も記述していないことに気づいたかもしれません。 実は、Next.js のビルド（next dev や next build）を実行すると、自動的に設定ファイルの内容を更新してくれるようになっています。</description></item><item><title>Next.js アプリのソースコードを GitHub で管理する</title><link>https://maku.blog/p/xjw8it5/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjw8it5/</guid><description>Next.js のプロジェクトは、create-next-app コマンドで作成済みであるとします。
参考: Next.js で HelloWorld create-next-app コマンドで Next.js アプリを新規作成すると、アプリのトップディレクトリに、Git リポジトリ (.git/) が自動的に生成されます。 git log コマンドを実行すると、初回のコミットがすでに生成されていることがわかります。
$ git log commit 4607ecdd2f3f9f3d0d4c86442463c3b86856e88a (HEAD -&amp;gt; main) Author: maku &amp;lt;maku@example.com&amp;gt; Date: Sun Apr 18 23:28:22 2021 +0900 Initial commit from Create Next App この Next.js アプリを GitHub で管理したいときは、以下の手順で GitHub リポジトリと結びつけます。
GitHub 上に 新規リポジトリを追加 します リポジトリ名は create-next-app で指定したアプリ名と合わせましょう。 Initialize this repository with: の項目では、README.txt の作成にはチェックを入れないでください。リポジトリファイル (.git) はすでに create-next-app によって生成されているので、GitHub 側のリポジトリは空の状態で作成する必要があります。 既存の Next.js アプリを上記の GitHub リポジトリに結びつけます $ cd myapp $ git remote add origin https://github.</description></item><item><title>Next.js アプリを GitHub Actions でビルドして GitHub Pages で公開する</title><link>https://maku.blog/p/au8ju6g/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/au8ju6g/</guid><description>何をするか？ ここでは、Next.js アプリを次のような構成でホスティング（Web サイトとして公開）できるようにします。
create-next-app で作成した Next.js アプリのコードを GitHub で管理する main ブランチにプッシュ（マージ）したら GitHub Actions で下記を実行 Next.js アプリをビルド (npm run build, npm run export) GitHub Pages にデプロイ つまり、この設定が終わると、GitHub に Next.js アプリのコードをプッシュするだけで、自動的にビルドされて、Web サイトに反映されるようになります。
GitHub リポジトリの準備 空の GitHub リポジトリを作成し、そこに create-next-app で作成した Next.js アプリをプッシュします。 リポジトリ名は、最終的な Web サイトのアドレスをどうしたいかで、次のように作り分けます。
ユーザーサイト（あるいは Organization サイト） 公開 URL: https://&amp;lt;username&amp;gt;.github.io/ 作成するリポジトリ名: &amp;lt;username&amp;gt;.github.io プロジェクトサイト 公開 URL: https://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository&amp;gt;/ 作成するリポジトリ名: &amp;lt;repository&amp;gt; ここでは、プロジェクトサイトとして myapp というリポジトリを作成した場合の例で説明していきます。
$ npx create-next-app myapp $ cd myapp $ git remote add origin https://github.</description></item><item><title>Next.js アプリを Vercel で公開する</title><link>https://maku.blog/p/j6ht5fq/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6ht5fq/</guid><description>Vercel とは？ Vercel は Next.js を開発している企業であり、同名の Vercel というサービスを提供しています。
Vercel - Develop. Preview. Ship. For the best frontend teams Vercel サービスは Next.js アプリのホスティングに特化しており、GitHub などのリポジトリと連携させることにより、ビルドから Next.js サーバーによるホスティングまでを簡単に自動化することができます（実際には、Vercel サービスは、Next.js 以外で作成した Web サイト、例えば、Hugo で作成したブログなどのホスティングにも対応しています）。
Next.js アプリで SSR (Server-side Rendering) や API ルートなどの機能を使用している場合は、Next.js サーバー上で Web サイトをホスティングする必要があるのですが、現状そのような環境をサーバーレスなサービスとして提供しているのは Vercel のみです（一応 Serverless Next.js という AWS Lambda で動かすものもあったりしますが）。
Next.js の開発サーバー (next dev) で何らかのアプリをローカルで動かせているのであれば、Vercel を使って、ほぼそのままの形でネット上に公開することができます。 小規模な Web サイトであれば無料で動かせますし、とっても簡単なので、一度試してみるとよいです。
Vercel で Next.js アプリを公開する ここでは、GitHub にプッシュした Next.js アプリを Vercel を使って公開してみます。 まずは、下記を参考にして、GitHub に何らかの Next.</description></item><item><title>Vercel のウェブサイトに独自ドメインを割り当てる</title><link>https://maku.blog/p/9vakw8i/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9vakw8i/</guid><description>Vercel で公開している Web サイトに、お名前.com で取得した独自ドメインを割り当てる方法を説明します。 Vercel 上での Next.js アプリ公開までの手順は、下記の記事を参考にしてください。
参考: Next.js アプリを Vercel で公開する ここでは、独自ドメインを「お名前.com」で取得済みだと仮定しますが、別のレジストラで取得している場合もほぼ同様に設定できるはずです。 大きく分けて、次の 2 種類の設定方法があります。
Vercel の DNS サーバーを使う方法 Vercel 以外の DNS サーバーを使う方法 独自ドメインの「レジストラ」と「DNS サーバー」の関係については、下記の記事で簡単にまとめていますので参考にしてください。 後述の設定で何をしているのかが分かりやすくなると思います。
ドメイン管理と DNS 管理の違いを理解する Vercel の DNS サーバーを使う方法 お名前.com などのレジストラで独自ドメインを取得すると、そのドメインをどの DNS サーバーで運用するかという設定を行えるはずです。 次のように Vercel 側の DNS サーバー設定を行うと、お名前.com 側に設定すべき DNS サーバー名を確認できます。
(1) Vercel のサイト から対象アプリのページを開き、Settings → Domains と選択し、取得済みの独自ドメイン名を入力して Add ボタンを押してください。ここでは、例として example.com というドメインを管理するとします（ドメイン自体は「お名前.com」で取得したものです）。
図: Vercel に独自ドメインを設定する (2) example.com に加えて www.example.com もエイリアスとして設定するかというダイアログが出ますが、example.com だけでよければ、Add example.com を選択すれば　OK です。</description></item><item><title>Next.js で src からの相対パスで import できるようにする (tsconfig.json)</title><link>https://maku.blog/p/qgvamzc/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qgvamzc/</guid><description>何をするか？ Next.js (TypeScript) のプロジェクトで、src ディレクトリ以下の階層構造が深くなってくると、別のディレクトリのモジュールをインポートするときの相対パスがわかりにくくなってきます。
import { sleep } from &amp;#39;../../../../../utils/timeUtil&amp;#39; このような場合は、次に説明するような tsconfig.json の設定をしておくと、シンプルなパスでインポートできるようになります。
compilerOptions.paths プロパティ (module alias) tsconfig.json の compilerOptions.paths プロパティ（と baseUrl プロパティ）を設定すると、特定のパスに配置されたモジュール（.ts ファイル）を、エイリアス名（ここでは @）を使って参照できるようになります。
tsconfig.json { &amp;#34;compilerOptions&amp;#34;: { // ... &amp;#34;baseUrl&amp;#34;: &amp;#34;.&amp;#34;, &amp;#34;paths&amp;#34;: { &amp;#34;@/*&amp;#34;: [&amp;#34;./src/*&amp;#34;] } } } 上記のように設定すると、プロジェクトルートの src ディレクトリ以下のモジュールを、どの階層にあるコードからでも、@/moduleName という名前で参照できるようになります。 例えば、src/utils/timeUtil.ts というモジュールをインポートするとき、これまでは、次のようにカレントディレクトリからの相対パスで指定しなければいけなかったところを、
import { sleep } from &amp;#39;../../../../../utils/timeUtil&amp;#39; 次のように src ディレクトリを示すエイリアス名 @ を使って指定できるようになります。
import { sleep } from &amp;#39;@/utils/timeUtil&amp;#39; ☝️ ワンポイント 上記のようなエイリアス名を使った場合でも正しくモジュールを参照できるのは、Next.js のビルドシステムが JavaScript へのトランスパイル時に本来のモジュールのパスに変換してくれるおかげです（おそらく webpack などによるバンドル時に処理されています）。 このあたりにも、Next.</description></item></channel></rss>