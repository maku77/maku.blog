<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScriptのモジュールの仕組みについて on まくろぐ</title><link>https://maku.blog/p/u53q2qi/</link><description>Recent content in TypeScriptのモジュールの仕組みについて on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 04 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/u53q2qi/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScriptでモジュールを作成する／インポートする (export, import)</title><link>https://maku.blog/p/fbu8k8j/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fbu8k8j/</guid><description>モジュールとは TypeScript で大きなプログラムを作成するときは、モジュールの仕組みを使って 複数のファイルに分割 していきます。 ファイルを分割することでコードを管理しやすくなるだけでなく、名前空間のコンテキストが分けられることになるので、 名前の衝突の問題も解決 することができます。
モジュールを作るのは簡単で、export キーワードを含む .ts ファイルを作ればそれがモジュールになります。 export キーワードでは、クラスやインタフェースをまるごと公開することもできるし、関数や変数の単位で公開することもできます。
export の使い方のポイントは、次のように、 クラスや変数を定義するときにプレフィックスとして付加する というところです。 基本的には、定義済みのオブジェクトを後から export するという使い方はしません。
export class &amp;hellip; export interface &amp;hellip; export const &amp;hellip; export let &amp;hellip; ここからは、具体的な export の使い方を見ていきます。
クラスやインタフェースの定義を export する 下記の lib/mylib.ts ファイルでは、MyInterface インタフェースと、MyClass クラスを公開しています。 それぞれの定義の前に export キーワードを付けるだけでよいので簡単ですね。
lib/mylib.ts export interface MyInterface { name: string; } export class MyClass implements MyInterface { constructor(public name: string) {} } 次の index.</description></item><item><title>TypeScriptのモジュールのインポートには import を使う</title><link>https://maku.blog/p/emdtiio/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/emdtiio/</guid><description>require ではなく import を使う TypeScript で型情報付きのモジュールをインポートするときは、ECMAScript 2015 の module 構文 で定義されている import を使うようにすると、VSCode などで型情報を使った補完がうまく効くようにになります。
これを使う // Good import * as mod from &amp;#39;mod&amp;#39;; 下記のように、Node.js で一般的に使用されていた CommonJS 形式の require を使ってもインポートできますが、any 型の変数を定義していることになるため、型情報を用いた補完が効きません。
これは使わない // NG const mod = require(&amp;#39;mod&amp;#39;); TypeScript でモジュールをインポートするときには、できるだけ import を使う ようにしましょう。
インポートの例（関数ベースのモジュール） Node.js のコアモジュール（os や path など）は、もともと TypeScript 用に作成されたものではありませんが、TypeScript 用の型情報が @types/node モジュールとして提供されています。
Node.js コアモジュールの型情報をインストール $ npm install --save-dev @types/node これで、Node.js のコアモジュールを下記のように型情報付きでインポートできるようになります。 これは、複数の関数を export する TypeScript モジュールをインポートする方法のよい例です。</description></item><item><title>TypeScriptで名前空間を定義する (namespace)</title><link>https://maku.blog/p/a3eh9w2/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a3eh9w2/</guid><description>namespace ではなくモジュールの仕組みを使うべし TypeScript では、namespace キーワードを使って名前空間を定義することができますが、通常はより柔軟性の高い モジュールの仕組み を使うようにしてください（といっても .ts ファイルを分けるだけですが）。
namespace を使うと、同じファイル内で階層化された名前空間を作ることができますが、あくまでその階層構造はグローバルに共有されています。 一方、モジュールの仕組みを使うと、ファイル単位で名前空間のコンテキストを分けることができます。 大きなプロジェクトであっても、適切な単位でモジュール（ファイル）を分割している限り、名前の衝突は本質的には発生しません。
とはいえ、これは namespace の記事なので、ここからは namespace の使い方の説明をします。
namespace による名前空間の定義 namespace による名前空間の定義は簡単で、namespace Xxx { ... } というブロックで囲むだけです。 次の例では、First と Second という名前空間を作成し、それぞれに同じ名前の Person というクラスを定義しています。
namespace First { export class Person { greet() { console.log(&amp;#39;First.Person&amp;#39;); } } } namespace Second { export class Person { greet() { console.log(&amp;#39;Second.Person&amp;#39;); } } } const p1 = new First.Person(); const p2 = new Second.Person(); p1.greet(); //=&amp;gt; First.</description></item></channel></rss>