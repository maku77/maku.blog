<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript の型／タイプアノテーション on まくろぐ</title><link>https://maku.blog/p/hrgu4dk/</link><description>Recent content in TypeScript の型／タイプアノテーション on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 08 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/p/hrgu4dk/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScriptの型: 基本型（プリミティブタイプ）の一覧</title><link>https://maku.blog/p/2uds9o4/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2uds9o4/</guid><description>プリミティブ型 (primitive types) 下記のプリミティブ型は、JavaScript が内部的な型情報として扱うものであり、TypeScript のタイプアノテーションでも同様に使用することができます。 型名がすべて小文字になっているのが特徴的です。
boolean（真偽値） let isDone: boolean = false; （true または false） number（数値） let decimal: number = 6; （10進数リテラル） let hex: number = 0xf00d; （16進数リテラル） let octal: number = 0o744; （8進数リテラル） let binary: number = 0b1010; （2進数リテラル） string（文字列） let name: string = 'Maku'; （シングルクォートとダブルクォートは同様） let msg: string = `Hello, ${name}`;（変数展開する場合はバッククォート） function（関数） function foo(): number { return 100; } let bar: () =&amp;gt; number = foo bigint（巨大整数） let x: bigint = 1n; （ES2020 移行） symbol（ユニークなシンボル） let sym: symbol = Symbol('key'); （ES2015 移行） undefined（変数が初期化されていないことを示す） オブジェクト型 (object) 上記の型以外は、JavaScript の世界ではすべて object 型とみなされます。 TypeScript のタイプアノテーションでは、変数に格納できる値の型をより明確に示すことができます。</description></item><item><title>TypeScriptの型: 変数の型指定（タイプアノテーション）の基本</title><link>https://maku.blog/p/ugyw5ee/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ugyw5ee/</guid><description>TypeScript の特徴は、変数の型を明示的に指定できることです。 この型指定のことを タイプアノテーション (Type annotation) と呼びます。
単純な変数のタイプアノテーション 下記は、文字列、数値、真偽値、配列のタイプアノテーションの例です。
let user: string = &amp;#39;まく&amp;#39;; let age: number = 14; let isActive: boolean = true; let titles: string[] = [&amp;#39;名前1&amp;#39;, &amp;#39;名前2&amp;#39;, &amp;#39;名前3&amp;#39;]; 指定した型と異なる型の値を代入しようとするとエラーになります。
let age: number = 14; age = &amp;#39;100歳&amp;#39;; エラーメッセージ Cannot assign to &amp;#39;age&amp;#39; because it is a constant. 配列や辞書、クラスなどの使い方は下記のページを参考にしてください。
配列を定義する (Array) 辞書型を定義する (Dictionary) クラス定義の基本 (class) 関数のタイプアノテーション 関数の型もアノテーションで示すことができます。
// 文字列を受け取り、何も返さない関数 let logger: (name: string) =&amp;gt; void; // 2つの数値を受け取り、真偽値を返す関数 let equal: (a: number, b: number) =&amp;gt; boolean; これらの変数には、パラメータと戻り値の型が等しく定義された関数のみ代入することができます。</description></item><item><title>TypeScriptの型: 値の型を typeof で調べる</title><link>https://maku.blog/p/ods6iv8/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ods6iv8/</guid><description>次のサンプルコードでは、それぞれの変数値の型情報を、JavaScript の typeof で調べています（ついでに、Object.prototype.toString.call でもう少し詳しい情報も表示）。
// ヘルパ関数 function printType(x: any) { console.log(`${typeof(x)} ${Object.prototype.toString.call(x)}`); } let booleanValue: boolean = true; printType(booleanValue); //=&amp;gt; boolean [object Boolean] let numberValue: number = 100; printType(numberValue); //=&amp;gt; number [object Number] let stringValue: string = &amp;#39;Hello&amp;#39;; printType(stringValue); //=&amp;gt; string [object String] function func(): number { return 100; } printType(func); //=&amp;gt; function [object Function] let undefinedValue: undefined = undefined; printType(undefinedValue); //=&amp;gt; undefined [object Undefined] let tupleValue: [string, number] = [&amp;#39;Hello&amp;#39;, 100]; printType(tupleValue); //=&amp;gt; object [object Array] let arrayValue: number[] = [1, 2, 3]; printType(arrayValue); //=&amp;gt; object [object Array] let nullValue: null = null; printType(nullValue); //=&amp;gt; object [object Null] let general: any = { name: &amp;#39;Mofu&amp;#39; }; printType(general); //=&amp;gt; object [object Object] let sym: symbol = Symbol(&amp;#39;key&amp;#39;); // ES2015 printType(sym); //=&amp;gt; symbol [object Symbol] let x: bigint = 1n; // ES2020 printType(x); //=&amp;gt; bigint [object BigInt] enum Color { Red, Green, Yellow }; // これは数値と同じ扱い printType(Color.</description></item><item><title>TypeScriptの型: 辞書型を定義する (Dictionary)</title><link>https://maku.blog/p/x3ocp9a/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3ocp9a/</guid><description>辞書オブジェクトを作成する JavaScript の配列は、もともと「キー＆値」を扱う連想配列として使用することができますが、TypeScript のタイプアノテーションを使うと、キーの型と値の型 を明示した辞書 (Dictionary) オブジェクトを作成することができます。
次の例では、文字列のキーと、数値の値を持つ辞書オブジェクトを作成しています。
// 辞書オブジェクトを作成する const userAges: { [name: string]: number } = {}; // 辞書オブジェクトを使用する userAges[&amp;#39;maku&amp;#39;] = 14; userAges[&amp;#39;hemu&amp;#39;] = 6; console.log(userAges[&amp;#39;maku&amp;#39;]); //=&amp;gt; 14 console.log(userAges[&amp;#39;hemu&amp;#39;]); //=&amp;gt; 6 間違った型のキーや値を格納しようとするとエラーになります。
userAges[14] = &amp;#39;maku&amp;#39;; // Error!! 辞書型のインタフェースを定義する 単純な辞書 上記の例では、辞書オブジェクトを生成するときに同時にその型を指定していましたが、あらかじめ辞書型を表すインタフェースだけを定義しておくこともできます。 次の UserAges インタフェースは、文字列型のキーと数値型の値を持つ、よくある辞書の定義例です。
// 辞書オブジェクトを作成する interface UserAges { [name: string]: number; } // 使用例 const userAges: UserAges = {}; userAges[&amp;#39;maku&amp;#39;] = 14; console.log(userAges[&amp;#39;maku&amp;#39;]); //=&amp;gt; 14 任意のオブジェクトを値にする辞書 次の UserDictionary インタフェースは、文字列型のキーと User 型の値を持つ辞書型を表しています。</description></item><item><title>TypeScriptの型: 配列を定義する (Array)</title><link>https://maku.blog/p/ttwoetd/</link><pubDate>Wed, 22 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ttwoetd/</guid><description>TypeScript で配列を定義するには、次のいずれかの方法を使います。
文字列配列を作成する const strArr: string[] = []; const strArr: Array&amp;lt;string&amp;gt; = []; ここでは初期値として空の配列 [] を代入しています。
const で変数を作成していますが、JavaScript の const は変数自体への代入を制限するだけなので、配列の内容を変更することは可能です。
const nums: number[] = []; nums.push(100); nums.push(200); nums.push(300); for (const x of nums) { console.log(x); } 実行結果 100 200 300 参考 TypeScript: タプルを定義する (Tuple types)</description></item><item><title>TypeScriptの型: タプルを定義する (Tuple types)</title><link>https://maku.blog/p/6uzqf4q/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6uzqf4q/</guid><description>タプルの基本 TypeScript のタプル型は、複数の値を保持することのできる型です。 [] 記号を使うところも配列によく似ていますが、それぞれの位置の要素の型を明示しておくことができます。
文字列と数値のタプルを定義する例 let vote: [string, number] vote = [&amp;#39;red&amp;#39;, 100]; // OK vote = [&amp;#39;green&amp;#39;, 200]; // OK vote = [&amp;#39;yellow&amp;#39;, 300]; // OK vote = [&amp;#39;AAA&amp;#39;, &amp;#39;BBB&amp;#39;]; // Error 上記の例では、2 つの値を保持するタプル型変数を定義していますが、3 つ以上の値を保持するタプルを定義することもできます。 配列と同様、タプルの各要素にはインデックスでアクセスできます。
let data: [string, number, number] data = [&amp;#39;maku&amp;#39;, 100, 5]; // インデックスで各要素を参照 console.log(data[0]); //=&amp;gt; maku console.log(data[1]); //=&amp;gt; 100 console.log(data[2]); //=&amp;gt; 5 // ループで各要素を取り出す for (const x of data) { console.log(x); } タプルによる多値関数 タプルを関数の戻り値として使用すると、複数の値を返す「多値関数」として扱うことができます。</description></item><item><title>TypeScriptの型: 関数を定義する (function)</title><link>https://maku.blog/p/tiwamzb/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tiwamzb/</guid><description>TypeScript の関数定義は JavaScript とほぼ同じですが、各パラメータと戻り値に型アノテーション付けることができます。
簡単な関数 次の indent 関数は、指定したレベルのインデント文字列（レベル数x2 の半角スペース）を返します。 TypeScript の型アノテーションで、number 型のパラメータと、string 型の戻り値を持つことを示しています。
function indent(level: number): string { return &amp;#39; &amp;#39;.repeat(level); } console.log(indent(0) + &amp;#39;AAA&amp;#39;); //=&amp;gt; &amp;#39;AAA&amp;#39; console.log(indent(1) + &amp;#39;BBB&amp;#39;); //=&amp;gt; &amp;#39; BBB&amp;#39; console.log(indent(2) + &amp;#39;CCC&amp;#39;); //=&amp;gt; &amp;#39; CCC&amp;#39; 関数オブジェクト 名前なしの関数オブジェクトやアロー関数を使用するときも同様に、パラメータや戻り値の型をアノテートできます。
const add = function(a: number, b: number) { return a + b; }; const sub = (a: number, b: number) =&amp;gt; { return a - b; }; console.log(add(1, 2)); //=&amp;gt; 3 console.</description></item><item><title>TypeScriptの型: インタフェースを定義する (interface)</title><link>https://maku.blog/p/5q5gs4f/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q5gs4f/</guid><description>プロパティを定義する 次の例では、2 つのプロパティ x、y を持つインタフェース Point を定義しています。
// Point インタフェースの定義 interface Point { x: number; y: number; } このインタフェースを使って、次のようにオブジェクトを生成することができます。 オブジェクトを生成するときには、インタフェースで定義されているすべてのプロパティに値を設定してやる必要があります。
// Point 型のオブジェクトを生成 const p: Point = { x: 10, y: 20 }; // 内容を出力してみる console.log(`x=${p.x}, y=${p.y}`); //=&amp;gt; x=10, y=20 Java などと異なり、TypeScript ではインタフェース定義さえあれば、上記のようにその型のオブジェクトを生成することができます（Java では厳密にはクラス定義がないとオブジェクトを生成できません）。 そのため、TypeScript では、interface キーワードを使ったインタフェース定義の頻度が高くなります。
TypeScript のインタフェースは、拡張に対してオープンであり、次のように後付けでプロパティを追加することができます。
interface Point { x: number; y: number; } // Point インタフェースにプロパティを追加 interface Point { z: number; } const p: Point = { x: 1, y: 2, z: 3 }; メソッドを定義する インタフェースでは、オブジェクトが持つべきメソッドを定義することができます。 次の Product インタフェースは、2 つのプロパティ name、price の他に、1 つのメソッド calcTotal() を持つ型を示しています。</description></item><item><title>TypeScriptの型: インタフェースのプロパティをオプショナルにする</title><link>https://maku.blog/p/rpfr5fr/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rpfr5fr/</guid><description>オプショナルプロパティの定義 TypeScript でインタフェースを定義するとき、プロパティ名の末尾に ? を付けると、そのプロパティをオプショナルプロパティとすることができます（関数のオプショナルパラメータと同様です）。
例えば、次の User インタフェースの age プロパティはオプショナルになっているため、User オブジェクトを生成するときに age プロパティの値を省略することができます。
interface User { name: string; age?: number; // age プロパティはオプショナル } const u1: User = { name: &amp;#39;Maku&amp;#39;, age: 5 }; // OK const u2: User = { name: &amp;#39;Maku&amp;#39; }; // OK console.log(u1.age); //=&amp;gt; 5 console.log(u2.age); //=&amp;gt; undefined インタフェースを定義せずに、変数の定義時に型情報を指定する場合も同様です。
let user: { name: string, age?: number }; user = { name: &amp;#39;Maku&amp;#39;, age: 5 }; // OK user = { name: &amp;#39;Maku&amp;#39; }; // OK user = { age: 5 }; // Error オプショナルなプロパティを定義する代わりに、特定の値（例えば -1）を、値がないことを示すために使用するという方法もありますが、プロパティ自体格納せずに undefined としておく方が分かりやすいでしょう。</description></item><item><title>TypeScriptの型: インタフェースのプロパティを読み取り専用にする (readonly)</title><link>https://maku.blog/p/p8ir2ai/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p8ir2ai/</guid><description>インタフェースのプロパティの前に、 readonly キーワードを付けると、そのプロパティは読み取り専用になり、オブジェクト生成時に格納した値を変更できなくなります。
次の Book インタフェースは 3 つのプロパティを持ちますが、そのうち id プロパティだけがリードオンリーとして定義されています。
interface Book { readonly id: string; // id プロパティはリードオンリー title: string; price: number; } 次の例では Book オブジェクトを作成した後で各プロパティの値を変更しようとしていますが、id プロパティを変更しようとしている部分でトランスパイルエラーになります。
const book: Book = { id: &amp;#39;001&amp;#39;, title: &amp;#39;TypeScript is Awesome&amp;#39;, price: 2300 }; book.id = &amp;#39;002&amp;#39;; // Error: リードオンリープロパティ book.title = &amp;#39;TypeScript is Horrible&amp;#39;; book.price = 800;</description></item><item><title>TypeScriptの型: インタフェースを結合する (交差型: Intersection types)</title><link>https://maku.blog/p/b4i46ah/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b4i46ah/</guid><description>2 つのインタフェースを &amp;amp; で結ぶと、両方のインタフェースを備えていることを示す新しい型 (交差型: Intersection type) を定義することができます。
interface Foo { foo(): void; } interface Bar { bar(): void; } // インタフェースの結合 type FooAndBar = Foo &amp;amp; Bar; 上記のように定義された FooAndBar インタフェースを実装するクラスは、Foo インタフェースと Bar インタフェースの両方を実装しなければいけません。
class Hoge implements FooAndBar { foo(): void { console.log(&amp;#39;foo!!&amp;#39;); } bar(): void { console.log(&amp;#39;bar!!&amp;#39;); } } const h = new Hoge(); h.foo(); h.bar(); ☝️ 共用体は OR、交差型は AND どちらかの型になることができること示す共用体 (union) が | （OR記号）で定義されるのに対し、両方の性質を持つ交差型 (intersection type) は &amp;amp;（AND記号）を使って定義されます。 意味が直感的に分かりやすいですね。</description></item><item><title>TypeScriptの型: クラス定義の基本 (class)</title><link>https://maku.blog/p/qhxet9n/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qhxet9n/</guid><description>TypeScript のクラスは、Java や Kotlin に似た文法で定義します。 インタフェースの定義に似ていますが、コンストラクタやメソッドを持つことができるという大きな違いがあります。
簡単なクラス 次の Greeter クラスは、1 つのプロパティ、1 つのコンストラクタ、1 つのメソッドを持っています。
class Greeter { // プロパティの定義（デフォルトで public） private name: string; // コンストラクタの定義 constructor(name: string) { this.name = name; } // メソッドの定義（デフォルトで public） greet() { console.log(`Hello, ${this.name}`); } } コンストラクタやメソッドの前に function というキーワードは必要ないことに注意してください。 プロパティやメソッドの可視性は デフォルトで public になるため、外部からアクセスできないようにするには、明示的に private と指定する必要があります。
クラスのインスタンスを生成するには、次のように new キーワードを使用します。
const greeter = new Greeter(&amp;#39;Maku&amp;#39;); greeter.greet(); //=&amp;gt; &amp;#39;Hello, Maku&amp;#39; プロパティ定義の省略 コンストラクタ (constructor()) のパラメータ名の前に、private や public といった可視性を指定すると、プロパティ定義とその値を設定するコードを省略することができます。
次のようなコードは、
class Book { private name: string; constructor(name: string) { this.</description></item><item><title>TypeScriptの型: クラスに static プロパティを定義する</title><link>https://maku.blog/p/2snuk25/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2snuk25/</guid><description>TypeScript のクラス内に、static（静的）なプロパティを定義するには、その名の通り static キーワードを付けるだけで済みます。
下記の例では、MyClass クラスの中に DEBUG という static プロパティを定義しています。 このプロパティを参照するときは、クラス名を前に付けて、MyClass.DEBUG と記述します。
class MyClass { static DEBUG: boolean = true; hello() { if (MyClass.DEBUG) { console.log(&amp;#39;hello!&amp;#39;); } } } const obj = new MyClass(); obj.hello(); static プロパティに、さらに readonly キーワードを付加することで、読み取り専用にすることができます（TypeScript 2.0 移行）。
static readonly DEBUG: boolean = true; 参考 TypeScript: クラス定数を定義する (static readonly)</description></item><item><title>TypeScriptの型: クラス定数を定義する (static readonly)</title><link>https://maku.blog/p/nky6cbb/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nky6cbb/</guid><description>static readonly プロパティを定義する TypeScript 2.0 移行では、クラス内の static プロパティに readonly キーワードを付けて読み取り専用であることを示すことができます。
class SiteInfo { // クラス定数の定義 static readonly FAQ_URL = &amp;#39;https://example.com/faq/&amp;#39;; } クラス定数を別ファイルから参照する このようなクラスをモジュールとして公開 (export) すれば、アプリ全体でそのクラス定数を共有できます。
（export側）siteInfo.ts export class SiteInfo { static readonly FAQ_URL = &amp;#39;https://example.com/faq/&amp;#39;; } （import側）index.ts import { SiteInfo } from &amp;#39;siteInfo&amp;#39;; console.log(SiteInfo.FAQ_URL); 配列をクラス定数にする (ReadonlyArray) readonly キーワードは、その変数への代入を禁止するだけなので、オブジェクト自体のセット系メソッドは呼び出せてしまいます。 配列に関しても各要素の値が変更できてしまうのは同様ですが、TypeScript にはそれを禁止するための ReadonlyArray&amp;lt;T&amp;gt; というジェネリッククラスが用意されています。
クラス定数として読み取り専用配列を定義 class Coordinates { static readonly ORIGIN: ReadonlyArray&amp;lt;number&amp;gt; = [0, 0]; } Coordinates.ORIGIN = [1, 1]; // Error (readonly により防止) Coordinates.</description></item><item><title>TypeScriptの型: リテラル型を定義する (Literal types)</title><link>https://maku.blog/p/6iuo8aj/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6iuo8aj/</guid><description>TypeScript のリテラル型は enum 型（列挙型）の制約を緩めたようなものです。 enum 型は 整数値 で値を保持しますが、リテラル型は 任意の型 で格納可能な値を定義します。
例えば、次のように定義した Answer 型は、その値として yes あるいは no という文字列のみ格納できるようになります。
// Answer というリテラル型を定義する type Answer = `yes` | `no`; // Answer 型の変数には &amp;#39;yes&amp;#39; か &amp;#39;no&amp;#39; のみ格納可能 let answer: Answer answer = &amp;#39;yes&amp;#39;; // OK answer = &amp;#39;no&amp;#39;; // OK answer = &amp;#39;maybe&amp;#39;; // Error answer = 100; // Error 参考 TypeScript: 列挙型を定義する (enum) TypeScript: タイプエイリアスを定義する (type)</description></item><item><title>TypeScriptの型: タイプエイリアスを定義する (type)</title><link>https://maku.blog/p/5zoqtmi/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5zoqtmi/</guid><description>TypeScript の タイプエイリアス (Type alias) を使用すると、既存の型を組み合わせて新たな型を定義することができます。
下記の例では、string 型と number 型の 2 つの値を保持する Person という型を定義しています。 タイプエイリアスの定義では、代入 (=) の構文を使用すること注意してください。
type Person = { name: string; age: number; }; let p: Person = { name: &amp;#39;Maku&amp;#39;, age: 14 }; console.log(p.name); console.log(p.age); Person 型の変数を初期化するときは、上記のように各プロパティの値を漏れなく明示する必要があります。 次のように、プロパティの指定に過不足があるとコンパイルエラーが発生します。
間違った例 let p1: Person = { name: &amp;#39;Maku&amp;#39; }; // プロパティが不足 let p2: Person = { name: &amp;#39;Maku&amp;#39;, age: 14, xxx: 20 }; // 未知のプロパティ エラーメッセージ sample.ts:6:5 - error TS2741: Property &amp;#39;age&amp;#39; is missing in type &amp;#39;{ name: string; }&amp;#39; but required in type &amp;#39;Person&amp;#39;.</description></item><item><title>TypeScriptの型: 共用体を定義する (Union types)</title><link>https://maku.blog/p/cdazjwv/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cdazjwv/</guid><description>共用体 (union) の基本 変数の型をタイプアノテーションで指定するときに、複数の型を | (or) でつなげて指定すると、それらのいずれの型の値でも格納できる 共用体 (union) となります。
例: 文字列と数値を格納できる変数 let a: string | number; a = &amp;#39;Hello&amp;#39;; // OK a = 123; // OK a = true; // NG 例: 文字列あるいは数値のパラメータをとる関数 function foo(value: string | number) { // ... } 共用体のタイプエイリアスを定義する ある種類の共用体を繰り返し使用する場合、タイプエイリアスを定義しておくと、何度も同じ記述をしなくて済みます。
// interface Context {}; type ContextOrString = Context | string; 定義したタイプエイリアスは、通常の型と同様に使用することができます。
function onMessage(context: ContextOrString) { // ... }</description></item><item><title>TypeScriptの型: 列挙型を定義する (enum)</title><link>https://maku.blog/p/fdjk4hh/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fdjk4hh/</guid><description>列挙型 (enum) の基本 TypeScript で列挙型を定義するには、enum キーワードを使用します。
enum Fruits { Apple, //= 0 Banana, //= 1 Orange //= 2 } console.log(Fruits.Apple); //=&amp;gt; 0 console.log(Fruits[Fruits.Apple]); //=&amp;gt; Apple デフォルトでは、各要素の値として先頭から順番に 0、1、2 という連番の 整数値 が内部的に割り当てられます（C 言語や Java と同様です）。 この値は任意の数値に変更することができます。
次の例は、ビットフラグとして使用することを想定した enum の定義例です。 各値が 2 のべき乗の値になっていることに注意してください。
enum OpenModes { Read = 1, Write = 2, Append = 4 } const mode = OpenModes.Read | OpenModes.Write; if ((mode &amp;amp; OpenModes.Write) == OpenModes.Write) { console.log(&amp;#39;Write フラグが指定されています&amp;#39;); } enum 値をインライン展開する (Constant enumeration) enum 定義を行うときに const キーワードを付加すると、その enum 値を使用した場所に値がハードコードされる形で展開されます（JavaScript のコードに変換するときに、0 や 1 といった値をインライン展開する）。</description></item><item><title>TypeScriptの型: 既存の JavaScript ライブラリに型情報を追加する（.d.ts ファイル）</title><link>https://maku.blog/p/s7wk5k3/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s7wk5k3/</guid><description>アンビエント宣言とは TypeScript の アンビエント宣言 (Ambient Declarations) を行うと、既存の JavaScript ライブラリに型情報を付加することができます。 この仕組みを利用すると、
サードパーティ製の JavaScript ライブラリ（npm パッケージ）や、自作の JavaScript ライブラリ（ただし TypeScript 化はしたくないもの）を TypeScript コードから使用する jQuery などのブラウザ上でロードされるライブラリを TypeScript コードから使用する といったことが可能になります。 ようするに、TypeScript トランスパイラに対して、このオブジェクトはこういう型のものとして外から提供されているので、型チェックエラーを出さないでね、と知らせることができます。
さらに、VisualStudio Code などのエディタを使用している場合は、アンビエント型宣言があることにより、エディタ上での補完入力ができるようになります。
アンビエント宣言 (declare) 参考: TypeScript - Declaration Reference どこか別の場所でロードされる予定の JavaScript モジュールに対して、自力で型情報を付けたい場合は declare キーワードを使用します。 例えば、jQuery はもともと JavaScript 用のライブラリなので、TypeScript 用の型情報は提供していませんが、次のように自力で型情報を付けることで、TypeScript コードから利用できるようになります（実際には、DefinitelyTyped プロジェクトが提供する @types/jquery を使用するのが簡単です）。
index.ts // $ という変数を参照できるようにする（実体は実行時に後付けで定義される予定） declare var $: any; // これで、$ という未定義の変数を参照してもエラーにならない $(&amp;#39;#id&amp;#39;).html(&amp;#39;Hello!&amp;#39;); この仕組みを使わずに、いきなり $ を参照してしまうと、そのような変数は定義されていないというエラーになってしまいます。 TypeScript トランスパイラは、declare によって付けられた型情報を正しいものと判断するため、この型情報は間違えないように指定する必要があります。 また、実行時にはそのオブジェクトの実体がどこかで生成されていなければいけません。</description></item><item><title>TypeScriptの型: 環境変数 (process.env) 用の型情報を定義する</title><link>https://maku.blog/p/r8iry9g/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r8iry9g/</guid><description>Node.js で環境変数を参照するためのオブジェクト process.env の型情報は、@types/node で次のように文字列型ディクショナリ Dict&amp;lt;string&amp;gt; として定義されています。
node_modules/@types/node/process.d.ts（抜粋） declare module &amp;#34;process&amp;#34; { global { var process: NodeJS.Process; namespace NodeJS { interface ProcessEnv extends Dict&amp;lt;string&amp;gt; {} //... } } export = process; } この型定義は @types/node モジュールをインストールするだけで簡単に使用できるようになるのですが、具体的なキー名（環境変数名）が定義されていないので、Visual Studio Code などで process.env 以降の入力補完が効きません。
VS Code 上で環境変数名を補完入力 できるようにするには、次のような型定義ファイル (globals.d.ts) をソースツリーのルートに作成します。
globals.d.ts declare namespace NodeJS { // 環境変数名の定義 interface ProcessEnv { /** 現在の Node.js 実行環境 */ readonly NODE_ENV: &amp;#39;development&amp;#39; | &amp;#39;production&amp;#39; | &amp;#39;test&amp;#39;; /** GitHub アクセストークン */ readonly MYAPP_GITHUB_TOKEN: string; } } 環境変数 NODE_ENV の値は、決められた 3 種類の値 (development/production/test) のいずれかであると定義しているので、それ以外の値と比較しようとしたときに警告してくれます。</description></item><item><title>TypeScriptの型: 既存の型をちょっと変えた型を作る（ユーティリティ型）</title><link>https://maku.blog/p/9t6gr3c/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9t6gr3c/</guid><description>ユーリティティ型とは？ TypeScript には、既存の型を加工して新しい型を生み出す ユーティリティ型 (Utility Types) というものが用意されています。 例えば、Partial を使用すると、ある型のプロパティをすべてオプショナルにした型を簡単に作ことができます。 以下、使いやすそうなユーティリティ型を紹介しておきます。
ユーティリティ型 概要 Omit 指定したプロパティを取り除く Pick 指定したプロパティだけ抽出する Partial 全プロパティをオプショナルにする Required 全プロパティを必須にする Readonly 全プロパティを readonly にする ユーティリティ関数の使用例 Omit / Pick &amp;hellip; プロパティを削除・抽出する Omit を使用すると、既存の型から指定したプロパティを取り除いた型を作成できます。 次の例では、Book 型から id プロパティを取り除いて、新しい NewBook 型を定義しています。
type Book = { id: string title: string price: number } type NewBook = Omit&amp;lt;Book, &amp;#39;id&amp;#39;&amp;gt; // 上記は以下と同様 // type NewBook = { // title: string // price: number // } // 使用例: 新しい書籍を登録する関数（id は自動生成する想定） function addBook(book: NewBook): Book { // .</description></item><item><title>TypeScript で undefined/null をうまく扱う (nullish coalescing (??), optional chaining (?.))</title><link>https://maku.blog/p/5oyaju5/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5oyaju5/</guid><description>Null 合体演算子 (??) ES2020 で Null 合体演算子 (Nullish Coalescing Operator) の ?? が導入されました。
☝️ nullish とは？ JavaScript において nullish とは、「undefined あるいは null」を示します。 coalescing には、「癒合、合体」という意味があります。 よって、nullish coalescing は、「null っぽかったら合体させるよ」という意味になります。 ?? 演算子を使うと、ある変数の値が undefined（あるいは null）だったときの代替となる値を指定することができます。 つまり、
A ?? B は、次のように記述するのと同等です。
A != undefined ? A : B 下記は、?? 演算子の振る舞いの一覧です。 ?? 演算子はあくまで undefined と null だけを判別するものであって、左側に偽となる値（false や空文字）をおいた場合は、その値がそのまま使われることに注意してください。
// 右側の値が（代わりに）使われるパターン const a = undefined ?? &amp;#39;default&amp;#39; //=&amp;gt; &amp;#39;default&amp;#39; const b = null ?? &amp;#39;default&amp;#39; //=&amp;gt; &amp;#39;default&amp;#39; // 左側の値が（そのまま）使われるパターン const c = &amp;#39;&amp;#39; ?</description></item><item><title>TypeScript: 2つの変数の値をスワップする</title><link>https://maku.blog/p/k8kw8it/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k8kw8it/</guid><description>TypeScript 独自の構文ではありませんが、ECMAScript 2015 (ES6) で導入された 分割代入 (Destructuring assignment) 構文 を使用すると、2 つ以上の変数を簡単に入れ替えることができます。
let a = 1; let b = 2; [a, b] = [b, a]; 参考: 配列の分割代入で複数の値を同時に代入する (Array destructuring) ｜ まくまくJavaScriptノート</description></item></channel></rss>