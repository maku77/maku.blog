<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Azure on まくろぐ</title><link>https://maku.blog/tags/azure/</link><description>Recent content in Azure on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 12 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/azure/index.xml" rel="self" type="application/rss+xml"/><item><title>Azure のストレージアカウントを作成する</title><link>https://maku.blog/p/7axgzfu/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7axgzfu/</guid><description>Table Storage などのストレージ系サービスを使用するには、Azure ポータル から ストレージアカウント を作成しておく必要があります。 このトレージアカウントは Table Storage 専用ではなく、様々なストレージサービス（BLOB、ファイル、キュー、テーブル）をまとめて扱うものです。
ストレージアカウント → 作成 のような感じで進めば作成用の画面が開くので、ストレージアカウント名などを入力します。 ストレージアカウント名は、Azure 内で一意（要するに世界中で一意）な名前を付ける必要があります。
選択項目によっては、料金が変わってくるものがあるので、情報アイコンの説明を見ながら、安いプランを選択していきます。 例えば、Table Storage のレプリケーションの種類別価格は次のようになっています（こちらから抜粋）。
図: Table Storage の月額 入力が終わったら、作成 のボタンを押して、しばらく待てばストレージアカウントが作成されます（1分くらいかかります）。</description></item><item><title>Azure DevOps で無料のプライベート Git リポジトリ (Repos) を使用する</title><link>https://maku.blog/p/qt5qyzu/</link><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qt5qyzu/</guid><description>Azure DevOps について GitHub は Microsoft によって買収されましたが、Azure ブランドの DevOps サービスでも Git リポジトリを扱う Repos という機能が提供されています。 GitHub は 2019 年から無制限に Private リポジトリを作成できるようになりましたが、Azure DevOps の方も無制限に Private リポジトリを作成することができ、5 ユーザーまでのコラボレーションが無料です（GitHub は 3 ユーザーまで）。 DevOps の Repos でも、GitHub のようにプルリクエストを使ったレビューを行えます。
さらに、DevOps には Pipelines という、継続的インテグレーション/継続的デリバリー (CI/CD) の機能も含まれており、こちらも毎月 1,800 分の実行まで無料で使用できます。 GitHub Actions なども同じような機能を提供する予定であり、これから Azure DevOps とどのような関係で進化していくのかわかりませんが、現状では Azure DevOps は魅力的な選択肢と言えそうです。
Azure DevOps の Git リポジトリ (Repos) を使用する DevOps で Git リポジトリを作成する場合、まずは DevOps のプロジェクトを作成し、その中に Git リポジトリを作成していくという構成になります。 1 つの DevOps プロジェクトには、いくつでも Git リポジトリを作成できます。</description></item><item><title>Azure Functions で簡単な関数を作ってみる</title><link>https://maku.blog/p/vgt5g7f/</link><pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgt5g7f/</guid><description>Azure Functions を使うと、Web API 的なものを、サーバーの存在を意識せずに作成することができます。 ここでは、最初のステップとして、HTTP リクエストで送ったメッセージをオウム返しするだけの簡単な関数を作ってみます。
Functions アプリを新規作成する 新しい Functions アプリを作成するには、Azure ポータルのリソースの作成画面 から、Functions App（関数アプリ） を選択します。 Azure のアカウントがない場合は先に作成する必要があります。
画面に従って入力していけば作成できますが、いくつかポイントがあるので説明しておきます。
基本タブ 関数アプリ名 &amp;hellip; 任意のアプリ名を付けることができますが、&amp;lt;アプリ名&amp;gt;.azurewebsites.net というアドレスが割り当てられるので、世界で一意な名前を指定する必要があります。 ランタイムスタック &amp;hellip; 関数の実装に使用する言語を選択します。JavaScript で記述するなら Node.js、C# で実装するなら .NET Core を選択しておきます。 ホスティングタブ プランの種類 &amp;hellip; 今回のテストのように、ときどき実行するだけなら 消費量（サーバーレス） を選択しておきます。App Service プラン は常時起動型の VM でホスティングするもので、ほとんど関数呼び出ししなくても月額数千円はかかってしまうので、最初は避けておくのが無難です。ただし、すでに他の Web サーバに App Service リソースを使用しているのであれば、そちらに相乗りしてホスティングすることが可能です。 最後に 作成 ボタンを押せば、数分で Functions のリソース作成が完了します。
Functions アプリに関数を追加する Functions リソースに新しい関数を追加するには、関数 → 追加 と選択します。 ここでは HTTP リクエストにより関数を実行するので、HTTP trigger を選択します。
関数名はデフォルトのままで HttpTrigger1、Authorization level はキーなしでリクエストできるように Anonymous を選択しておきます。</description></item><item><title>逆引き Azure CLI: Azure CLI（az コマンド）をインストールする</title><link>https://maku.blog/p/dwsog4p/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dwsog4p/</guid><description>Azure CLI をインストールすると、az コマンドを使用して、Azure の様々な機能を呼び出すことができるようになります。 Azure ポータル 上で実行できることは、ほとんど az コマンドでも実行できるようになっています。
Azure CLI は下記のサイトに従ってインストールします（インストーラを実行するだけです）。
Azure コマンドラインインターフェイス (CLI) 実際には、Azure ポータル上で実行してしまった方が手軽なことが多いのですが、スクリプトなどで処理を自動化したい場合は Azure CLI を使うことになります。</description></item><item><title>Azure Pipelines の使い方 (Hello World)</title><link>https://maku.blog/p/vxoctbs/</link><pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vxoctbs/</guid><description>ここでは、Azure Pipelines の Hello World として、任意の GitHub リポジトリへ git push したときのビルド処理を自動化してみます。 ビルド処理は、Hello World らしく、echo Hello, world! を実行するだけにしておきます。
DevOps organization を作成する Azure Pipelines は、Azure DevOps の中の 1 サービスであり、まず最初に Azure DevOps の organization（組織）を作成する必要があります。 Azure アカウント上でまだ DevOps organization を作成していない場合は、下記 URL にアクセスすることで作成することができます。
https://dev.azure.com/ DevOps organization の構成は次のようになっており、organization 以下に複数のプロジェクトを作成することができます。 各プロジェクトには、複数の Repos（Gitリポジトリ）や Pipelines (CI/CDの仕組み) を設定することができます。
+ Azure DevOps organization + Project - Repos (Gitリポジトリ） - Pipelines (CI/CDの仕組み) - Boards（かんばん、バックログ管理など） - ... + Project - Repos - Pipelines - Boards - .</description></item><item><title>逆引き Azure CLI: Azure にログインする (az login)</title><link>https://maku.blog/p/ejar7k8/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ejar7k8/</guid><description>az login コマンドを使って Azure にログインすると、Azure アカウントに紐づいた情報（サブスクリプション情報など）を取得できるようになります。
パラメータなしで実行してブラウザ上で認証することもできるし、コマンドラインからユーザ名とパスワードを指定することもできます。
ブラウザを起動して認証 $ az login ユーザー名をパラメータで指定 $ az login -u yourname@example.com Password: ******** ユーザー名とパスワードをパラメータで指定 $ az login -u yourname@example.com -p yourpass ログインが成功すると、az account show コマンドで、使用しているサブスクリプションの情報を確認できるようになります。
$ az account show { &amp;#34;environmentName&amp;#34;: &amp;#34;AzureCloud&amp;#34;, &amp;#34;homeTenantId&amp;#34;: &amp;#34;b431a0d2-3656-ed42-9497-c0dfd20ae040&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;343f3fd9-1f19-1d49-7b92-5f365bbc6fd6&amp;#34;, &amp;#34;isDefault&amp;#34;: true, &amp;#34;managedByTenants&amp;#34;: [], &amp;#34;name&amp;#34;: &amp;#34;従量課金&amp;#34;, &amp;#34;state&amp;#34;: &amp;#34;Enabled&amp;#34;, &amp;#34;tenantId&amp;#34;: &amp;#34;b431a0d2-3656-ed42-9497-c0dfd20ae040&amp;#34;, &amp;#34;user&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;yourname@example.com&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;user&amp;#34; } }</description></item><item><title>Azure Cosmos DB にアカウントを作って MongoDB API でアクセスする</title><link>https://maku.blog/p/cd9bg3x/</link><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cd9bg3x/</guid><description>Azure Cosmos DB と MongoDB API Azure Cosmos DB は、Microsoft の Azure 上に配置できるスケーラブルなデータベースで、SQL や MongoDB API など様々なインタフェースでアクセスできるようになっています。
MongoDB を使った既存のアプリケーションがある場合、接続先を Azure Cosmos DB アカウントのアドレスに変更するだけで、簡単にクラウド上のデータを扱えるようになります。 ローカルの MongoDB サーバ (mongod) に接続する代わりに、Azure Cosmos DB に接続するということです。
ここでは、MongoDB API（MongoDB シェル）による Azure Cosmos DB へのアクセスを試してみます。 まずは、Azure 上に Cosmos DB のリソースを作成します。
Azure Cosmos DB アカウントを作成する Azure ポータルへログインし、Azure Cosmos DB のページを開き、Azure Cosmos DB アカウントの作成 をクリックします。
次の画面では、アカウント名 や API の種類を設定します。
アカウント名 に入力した値は、下記のように接続 URI の一部として使われます。 よって、このアカウント名は世界中で一意である必要があります。
mongodb://＜アカウント名＞:＜キー＞@＜アカウント名＞.documents.azure.com:10255/?ssl=true&amp;amp;replicaSet=globaldb API の種類には、MongoDB API を指定してください。 各項目の入力が終わったら、確認と作成 を押して数分待つと、Azure Cosmos DB アカウントの作成が完了します。</description></item><item><title>Azure Pipelines で Hugo サイトのビルド＆デプロイ</title><link>https://maku.blog/p/kevcr7m/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kevcr7m/</guid><description>前提知識 Azure Pipelines の基本的な使い方は下記ページを参考にしてください。
Azure Pipelines の使い方 (Hello World) hugo deploy コマンドによる Hugo サイトのデプロイについては下記ページを参考にしてください。
hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする | まくまくHugo/Goノート 事前準備 ここでは、Azure Pipelines の設定の説明をしますので、下記の作成・準備は終わっているものとします。
Hugo コンテンツ用の Git リポジトリ Azure Repos や GitHub の Git リポジトリに、Hugo サイトのコンテンツをコミットしてください。 hugo deploy コマンドのための設定 Hugo の設定ファイル config.toml に、deployment.targets などの設定をしてください。 Azure Pipelines の作成 Azure DevOps のプロジェクト内に、上記の Git リポジトリと連携する Pipelines を作成してください。 Hugo 自動ビルド＆デプロイのための Azure Pipelines 設定 azure-pipelines.yml trigger: - master variables: hugo_version: &amp;#39;0.68.3&amp;#39; pool: vmImage: &amp;#39;ubuntu-latest&amp;#39; steps: - script: wget -O hugo.</description></item><item><title>逆引き Azure CLI: プロキシ環境下で Azure CLI (az) を使用する</title><link>https://maku.blog/p/7g9seub/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7g9seub/</guid><description>会社などのプロキシ環境下において az コマンドを実行する場合は、環境変数 https_proxy を設定しておきます。
Windows の場合 C:\&amp;gt; set https_proxy=http://proxy.example.com:8080 Linux/Mac の場合 $ export https_proxy=http://proxy.example.com:8080</description></item><item><title>Azure: Cosmos DB の SQL API をプロキシ経由で使用する</title><link>https://maku.blog/p/t8rfkjn/</link><pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t8rfkjn/</guid><description>参照するサンプルコード Azure の Cosmos DB を SQL API で操作するための最初の手順は下記のドキュメントに記載されています。
クイック スタート:Azure Cosmos DB SQL API アカウントを使用して Node.js アプリを構築する ここに Node.js 用のサンプルコードがあり、@azure/cosmos パッケージが提供する CosmosClient クラスを使用したコードになっています（昔のサンプルコードでは documentdb というライブラリを使用していたりしますが、今は Microsoft が提供する @azure/cosmos を使用すると完結なコードを記述できます）。
const CosmosClient = require(&amp;#39;@azure/cosmos&amp;#39;).CosmosClient; 基本的には、config.js ファイルに記述されたエンドポイントとキーを下記のような感じで設定すれば実行できるようになるのですが、
config.js var config = {}; config.endpoint = &amp;#39;https://your-cosmosdb.documents.azure.com:443/&amp;#39;; config.key = &amp;#39;9Hp4WSwgvggexAuGy4dKdl...snipped...lV9Nm44Pg8WVkH==&amp;#39;; 会社などのプロキシ環境内からだとうまく接続できず、次のような感じのエラーが発生すると思います。
$ node app.js Completed with error {&amp;#34;message&amp;#34;:&amp;#34;request to https://your-cosmosdb.documents.azure.com:443/dbs/FamilyDatabase failed, reason: connect ETIMEDOUT 123.34.56.78:443&amp;#34;,&amp;#34;type&amp;#34;:&amp;#34;system&amp;#34;,&amp;#34;errno&amp;#34;:&amp;#34;ETIMEDOUT&amp;#34;, &amp;#34;code&amp;#34;:&amp;#34;ETIMEDOUT&amp;#34;,&amp;#34;headers&amp;#34;:{&amp;#34;x-ms-throttle-retry-count&amp;#34;:0,&amp;#34;x-ms-throttle-retry-wait-time-ms&amp;#34;:0}} HTTPS_PROXY 環境変数を設定しても同様で効果がありません。
プロキシ経由で CosmosClient を使用する CosmosClient クラスでの Cosmos DB へのアクセスをプロキシ経由で行うには、コンストラクタのパラメータとして渡せる CosmosClientOptions の agent プロパティを設定します。 ここでは、エージェントとして proxy-agent モジュールを使用します。</description></item><item><title>Azure Pipelines の Pull Request 時の起動トリガ設定</title><link>https://maku.blog/p/i6549xd/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i6549xd/</guid><description>ビルドしない azure-pipelines.yml trigger: none # will disable CI builds entirely Azure Pipelines によるビルドを起動しないようにします。
trigger プロパティを省略すると、デフォルトですべてのブランチへのプッシュ時にビルドが走るので、ビルドしないようにするには、上記のように明示的に none 指定が必要です。 この設定を行うと、pr プロパティの設定（後述）も無効になります（Pull Request 時もビルドは実行されない）。
master ブランチへのプッシュ or マージでビルド？ azure-pipelines.yml trigger: - master 次のように複数のブランチをビルド対象とすることもできます。
trigger: - master - release このように記述すると、指定したブランチへのプッシュ or マージ時にのみ Pipelines が起動しそうに見えますが、この指定だけだと、 あらゆる Pull Request の作成時に Pipelines が起動します。 master ブランチや release ブランチをターゲットとしない Pull Request でもビルドが走ります。 なぜなら、Pull Request トリガの設定がデフォルトで次のようになっているからです。
pr: branches: include: - &amp;#39;*&amp;#39; このため、一連のステップにデプロイ処理まで組み込んでいると、レビュー用に Pull Request を上げただけでデプロイまで実行されてしまうという振る舞いになります。
Pull Request 時にビルドしない azure-pipelines.yml trigger: - master pr: none # no PR triggers 上記のように設定しておくと、Pull Request を作成したときには Pipelines は起動しなくなります。 つまり、master ブランチへのプッシュ or マージ時のみビルドが実行されます。</description></item><item><title>Azure Pipelines のビルド結果を GitHub にバッジ表示する</title><link>https://maku.blog/p/teq2cmv/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/teq2cmv/</guid><description>ステータスバッジとは ステータスバッジというのは、GitHub プロジェクトのトップページ (README.md) でよく見かける上のようなアイコンのことです。 ステータスバッジを貼り付けておくことで、最新のソースコードが正しくビルドできていることを一目で確認することができますし、ちゃんと開発しているんだということをアピールすることにもなります。
Azure Pipelines のビルド結果を示すステータスバッジは、下記のように簡単に追加することができます。
Azure Pipelines のステータスバッジを表示する ステータスバッジは、画像ファイルの URL の形で提供されているので、GitHub の README.md などにその URL を貼り付けるだけで OK です。
ステータスバッジの画像 URL を確認するには、Azure Pipelines のページを開き、右上のメニューアイコン → Status badge と選択します。
画像の URL と一緒に、Markdown ファイルに記述する場合のコード (Sample markdown) も表示してくれるので、GitHub のページに貼り付ける場合はそちらを使えばよいでしょう。 右側のコピーアイコンを押してクリップボードにコピーし、GitHub の README.md ファイルに次のような感じで貼り付ければ OK です。
これで、GitHub プロジェクトのトップページアクセスしたときに、次のようにステータスバッジが表示されるはずです。
ステータスバッジの画像が表示されないとき Azure DevOps にサインインしていない状態で、ステータスバッジが表示されない場合は、Pipelines の設定を確認してみてください。
上記のように、Disable anonymous access to badge という項目を OFF にすれば表示されるようになると思います。</description></item><item><title>Azure Storage で静的 Web サイトをホスティングする</title><link>https://maku.blog/p/gkardu9/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gkardu9/</guid><description>（Azure Storage による静的な Web サイトのホスティング機能は 2018 年末にリリース されました）
ストレージアカウントを作成する（まだ作成していない場合） Azure 上に静的な Web サイトをホスティングするためのストレージを作成するには、ストレージアカウントが必要です。 まだ作成していない場合は、下記の手順に従ってストレージアカウントを作成してください。 静的な Web サイトをホスティングする場合は、アカウントの種類 (Account kind) の項目で StorageV2（汎用v2） というのを選んで作成しておく必要があります。
→ Azure のストレージアカウントを作成する
静的な Web サイトを有効にする ストレージアカウントを作成したら、コンテンツのアップロード先である Azure ストレージコンテナーと、Web サイトの URL を生成します。 といっても、ストレージアカウントがあれば、Azure ポータル から数秒で自動作成できます。
ストレージアカウントのページを開き、設定 → 静的な Web サイト を選択します。 静的な Web サイト のスイッチを 有効 に切り替えて 保存 ボタンを押します。 これで、Web サイトをホスティングするための Azure ストレージコンテナー（BLOB を入れるコンテナー）が作成されます。 コンテナー名は自動的に $web になるようです。
同時に、Web サイトの URL も自動的に生成されます。
これが Web ブラウザからサイトにアクセスするときのアドレスになります。 あとは、コンテナーに HTML ファイルをアップロードするだけです。
Web サイトのコンテンツをアップロードする 作成されたコンテナー ($web) にコンテンツをアップロードするには、Azure CLI などのコマンドラインツールを使用します。 Azure ポータルのサイト上で BLOB リソースの項目からポチポチやってアップロードすることもできますが、自動化のことを考えると、コマンドラインツールを使った方がよいでしょう。</description></item><item><title>逆引き Azure CLI: ストレージアカウントのキーを確認する (storage account keys list)</title><link>https://maku.blog/p/3wk5vnw/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3wk5vnw/</guid><description>Azure ストレージアカウントのキー（鍵）情報を取得するには、Azure にログイン した状態で、以下のように実行します。
$ az storage account keys list --account-name ストレージアカウント名 [ { &amp;#34;keyName&amp;#34;: &amp;#34;key1&amp;#34;, &amp;#34;permissions&amp;#34;: &amp;#34;Full&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;7s+V+j4CcwDNHyTvx7/UXlgKN4HvFoUuIhOuzH1YLaBWgVTWQadQB2vFjRPTAv2aoGP2mpyQcMm4C+R55o3N9g==&amp;#34; }, { &amp;#34;keyName&amp;#34;: &amp;#34;key2&amp;#34;, &amp;#34;permissions&amp;#34;: &amp;#34;Full&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;+uzKfRt3rCP7RkNBXG93lqEqD7MLvgFQmKxudWHjYbDMUeFH0VmdMhN8V/6ChCwVANi6jaDL4ZKopfwV5RjY9g==&amp;#34; } ] このストレージアカウントキーは、az storage コマンドを使って Azure ストレージ上のデータを操作するときに必要になります。
参考 BLOB ストレージにファイルをアップロードする (storage blob upload)</description></item><item><title>逆引き Azure CLI: ストレージアカウントの接続文字列を確認する (storage account show-connection-string)</title><link>https://maku.blog/p/hquhjki/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/hquhjki/</guid><description>Azure CLI で Azure ストレージアカウントの接続文字列（アカウント名とキーがペアになったもの）を取得するには、az storage account show-connection-string コマンドを使用します。
このコマンドを実行する前に、az login で Azure にログイン しておく必要があります。
ストレージアカウントの接続文字列を取得 $ az storage account show-connection-string --name yourstorage { &amp;#34;connectionString&amp;#34;: &amp;#34;DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=yourstorage;AccountKey=7s+V+j4CcwDNHyTvxTAv2aoGP2mpyQcMm4C+R7/UXlgKN4HvFoUuIhOuzH1YLaBWgVTWQadQB2vFjRP55o3N9g==&amp;#34; } 参考 az storage account show-connection-string コマンド</description></item><item><title>逆引き Azure CLI: Azure ストレージの SAS トークンを生成する (storage container generate-sas)</title><link>https://maku.blog/p/n4yqdys/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n4yqdys/</guid><description>Azure ストレージの操作を行うとき、有効期限付きのアクセストークンである SAS トークン が必要になることがあります。 SAS トークンは、az storage container generate-sas コマンドで生成することができます。
実際は 1 行 $ az storage container generate-sas --name &amp;lt;BLOBコンテナー名&amp;gt; --expiry &amp;#34;2020-07-07T00:00:00Z&amp;#34; --permission acdlrw --connection-string &amp;lt;ストレージアカウントの接続文字列&amp;gt; ストレージアカウントの接続文字列さえあれば、特に Azure ログインしたりせずに生成できます。 接続文字列自体を Azure CLI で取得することもできます。
SAS トークン生成時に指定するオプションの詳細は下記のコマンドリファレンスを参照してください。
参考: az storage container generate-sas コマンド 実行に成功すると、次のような文字列が標準出力に出力されます。 これが SAS トークンです。
&amp;#34;se=2020-07-07T00%3A00%3A00Z&amp;amp;sp=racwdl&amp;amp;sv=2018-11-09&amp;amp;sr=c&amp;amp;sig=c7bapOBvLkHVlebBIEQFQc2bGd%2BjmfScqKCbkLUzzoo%3D&amp;#34; この SAS トークンは、AzCopy (azcopy) ツールなどで、BLOB ストレージにファイル転送したりするときに必要になります。
SAS トークンの生成には、有効期限を示す --expiry オプションの指定が必須になっています（なくてもトークンの生成には成功しますが、使用時に認証エラーになるようです。不親切）。 ここで指定する日時のフォーマットは、少しでも間違えると出力される SAS トークンの se パラメータが無効なものになってしまうので要注意です（こちらも生成時にはエラーになりません。不親切）。
生成される SAS トークンの最後には、このトークン自体の署名がついています。 これにより、SAS トークン内の有効期限 (se) などを部分的に改ざんしたりできないようになっています。</description></item><item><title>逆引き Azure CLI: BLOB ストレージにファイルをアップロードする (storage blob upload)</title><link>https://maku.blog/p/ptx36ue/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ptx36ue/</guid><description>Azure CLI を使ってストレージアカウント上に作成された、既存の BLOB コンテナにコンテンツをアップロードするには、az storage blob upload コマンドを使用します。 Azure ポータルのサイト上でポチポチやってアップロードすることもできますが、自動化のことを考えると、コマンドラインを使った方がよいでしょう。
書式 az storage blob upload --account-name &amp;lt;ストレージアカウント名&amp;gt; --account-key &amp;lt;キー&amp;gt; -c &amp;lt;コンテナ名&amp;gt; --file &amp;lt;ローカルファイル名&amp;gt; --name &amp;lt;アップロード後のファイル名&amp;gt; 実行例 $ az storage blob upload --account-name yourstorage --account-key vFjRP7s+V+j4CcwDNHyTvxT7/UXlgKN4HvFoUuIhOuzH1YLaBWgVTWQadQB2Av2aoGP2mpyQcMm4C+R55o3N9g== -c $web --file index.html --name index.html Finished[#############################################################] 100.0000% { &amp;#34;etag&amp;#34;: &amp;#34;\&amp;#34;0x8D7CA465578BC90\&amp;#34;&amp;#34;, &amp;#34;lastModified&amp;#34;: &amp;#34;2020-03-17T07:39:32+00:00&amp;#34; } アップロード時にストレージアカウントのキーを指定するので、あらかじめ az login で Azure にログインしておく必要はありません。
参考 逆引き Azure CLI: ストレージアカウントのキーを確認する (storage account keys list)</description></item><item><title>チャットボット (1-1) Bot Builder SDK とは</title><link>https://maku.blog/p/tzaeb9x/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tzaeb9x/</guid><description>Microsoft の Azure は Chatbot サービスを作成する機能を提供しています。 Microsoft が提供している Bot Framework は、この Chatbot サービスを作成するとき、あるいは Chatbot を使用するクライアントを作成するときに使用するツール群（あるいは仕組み）やそれらを取り巻く環境の総称です。
Microsoft Bot Framework ボットのサーバを実装するためのライブラリは、Bot Builder SDK という名前で提供されています。 現状では、ボットは Node.js と .NET による開発が想定されているため、Bot Builder SDK も Node.js と .NET 用のものが提供されています（2019年3月現在、Python と Java 版が preview リリースされているようです）。
Bot Builder SDK (for Node.js) Bot Builder SDK (for .Net) Bot Builder サンプルコード集 Node.js と .NET のどちらを使って開発するかに迷ったら、非同期処理を前提にして設計されている Node.js 版を選択するのがよいでしょう。
Node.js の Bot Builder SDK は、NPM パッケージとして公開されているため、npm コマンドを使って簡単にインストールすることができます。
$ mkdir mybot $ cd mybot $ npm init -y $ npm install --save botbuilder@4.</description></item><item><title>チャットボット (1-2) Bot Builder SDK で Echo ボットを作成する</title><link>https://maku.blog/p/you6q5r/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/you6q5r/</guid><description>ここでは、Microsoft の Bot Builder SDK を使ったボット作成のファーストステップとして、チャットクライアントから入力されたテキストをそのままオウム返しするだけの Echo ボットを作成します。 言語としては JavaScript (Node.js) を使用することにします。
ここで作成するのはボットの本体（サービス側）で、クライアントとしては Microsoft が提供している Bot Framework Emulator を使用します。
Bot Builder SDK をインストールする Node.js 版の Bot Builder SDK（botbuilder パッケージ）は、npm コマンドを使ってインストールすることができます。 パッケージの依存関係を管理するための package.json ファイルも、npm init コマンドで作成しておきます。
$ mkdir mybot $ cd mybot $ npm init -y $ npm install --save botbuilder@4.x Bot Service のインタフェースは REST API として提供することが定められているのですが、Bot Builder SDK には REST API サーバを作成する機能は含まれていません。 そこで、REST API サーバを作成するための restify パッケージも一緒にインストールしておきます（express などでも実装できると思いますが、リファレンス実装では restify が使用されています）。</description></item><item><title>チャットボット (2-1) Azure でボットをホストするための Web App Bot リソースを作成する</title><link>https://maku.blog/p/tttou4o/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tttou4o/</guid><description>Web App Bot リソースを作成する 作成したボットプログラムは、Azure 上の Web App Bot リソース上で動作させることができます。 このリソースのことを特にボットサービスと呼んだりします。
Azure ポータル にログインし、下記のように辿ることで Web App Bot リソースの作成画面を表示できます。
＋リソースの作成 AI + Machine Learning Web App Bot 下記のような Web App Bot リソースの設定画面が表示されるので、1 つずつ入力していきます。
ボット名 任意のボット名称。後から自由に変更することができるので、自分のわかりやすい名前を付けておけば OK です。例: maku-bot サブスクリプション 月額の請求先となるサブスクリプションを選択します。最初の Azure トライアル期間であれば、Free Trial などを選択できるはずです。 リソースグループ この Web App Bot リソースを所属させるリソースグループを選択します。存在しない場合は 新規作成 のリンクをクリックして新しく作成します。 場所 リソースグループの場所を選択。ここでは、地理的に近い Japan East を選択してます。 価格レベル チャンネルに応じたメッセージ制限解除のためのプラン設定です。 スタンダードチャンネル（Skype、Cortana、Teams、Facebook、Slack などの一般的なクライアント）とのやりとりは無制限なので、通常は F0 の無料プランを選択しておけば OK です。 一方で、プレミアムチャンネル（ユーザ独自のチャンネルや、Web ページ埋め込みチャットボットなど）と多くのメッセージをやりとりする予定がある場合は、有料の S1 プランを選択する必要があります。 無料の F0 だと 1 か月に 10,000 メッセージまでの制限があります。 （参考: Standard channels と Premium channels について） アプリ名 ボットサービスのエンドポイント URL となる XXX.</description></item><item><title>チャットボット (2-2) Web App Bot で生成されたボットのコードを編集する</title><link>https://maku.blog/p/bpqkm2o/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bpqkm2o/</guid><description>チャットボットのソースコードをダウンロードする 下記のページの手順に従い、Azure ポータル上で Web App Bot のリソースを作成すると、自動的に Echo Bot のテンプレートコードが生成されているはずです（選択したテンプレートの種類によって変わりますが、ここでは Node.js 版の Echo Bot テンプレートを指定しているとします）。
Azure でボットをホストするための Web App Bot リソースを作成する ボットプログラムを作成する場合は、基本的にはこのテンプレートコードをベースにして修正を行っていくのがよいでしょう。 自動生成されたコードは、Azure ポータルから下記のように辿ると ZIP アーカイブでダウロードすることができます。
すべてのリソース を選択 対象の Web アプリボット リソースを選択（下記の例では maku-bot） ボット管理 の ビルド を選択 ボットのソースコードをダウンロードする のボタンをクリック 図: ボットコードをダウンロード bot ファイルの復号化・暗号化 botFileSecret とは ダウンロードした ZIP アーカイブの中には、ボットサーバの設定ファイルである .bot ファイルが含まれています。
このファイルは、ローカルでボットサーバを立ち上げたり、エミュレータからそのサーバに接続するときの設定ファイルとして使用するのですが、自動生成された .bot ファイルは、接続情報などの値が暗号化されています。 .bot ファイルの復号化、および暗号化に使用されているキーのことを botFileSecret と呼びます。
ボットサーバやエミュレータを正しく起動するためには、この botFileSecret を使って .bot ファイルをあらかじめ復号化しておくか、環境変数などでキーを設定しておく必要があります。
.bot ファイルを復号化した場合は、Azure 上の Web App Bot サービスにデプロイする前に、忘れずに暗号化しておく必要があります。
botFileSecret の取得 初期の暗号化に使用されている botFileSecret は、Azure ポータルから下記のように辿ることで参照することができます。</description></item><item><title>チャットボット (2-3) Azure の Web App Bot リソースにボットをデプロイする</title><link>https://maku.blog/p/gxm9shf/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gxm9shf/</guid><description>まず前提として、下記の手順により、Azure 上に Web App Bot リソースが作成済みであることとします。 ここに、ローカルで作成したボットをデプロイすることになります。
Azure でボットをホストするための Web App Bot リソースを作成する Web ブラウザでデプロイする方法（KUDU の Zip Deploy UI） プロジェクトのファイルを ZIP ファイルとしてアーカイブし、Zip Deploy UI という Web ページにドラッグ＆ドロップでデプロイする方法です。 この Web サイトには、下記のような URL でアクセスできます。 &amp;lt;app_name&amp;gt; の部分は、自分のボットアプリ名に置き換えてください。
https://&amp;lt;app_name&amp;gt;.scm.azurewebsites.net/ZipDeployUI 図: Web App Bot の Zip Deploy UI 左上に表示されるロゴからも分かるように、Azure の Web App サービスでは、Kudu というデプロイエンジンが使われているようですね。
この /wwwroot ディレクトリの内容が表示されている画面で、エクスプローラ領域に ZIP ファイルをドラッグ＆ドロップすると、ZIP ファイル内のファイルがまとめて /wwwroot にアップロードされます。
図: ZIP ファイルのドラッグ＆ドロップでデプロイ ボットプログラムのエントリポイントとなる bot.js ファイルを編集してから ZIP 化し、デプロイすることで、ボットの動作が変わることを確認できると思います。
ZIP アーカイブ作成時の注意 ZIP ファイルの中身が展開された状態でデプロイされるので、ZIP の展開後に余計なディレクトリ階層ができないように ZIP アーカイブを作成してください。 具体的には、プロジェクトのディレクトリを ZIP 化するのではなく、プロジェクトのディレクトリ内のファイル群を ZIP 化します。 コマンドラインから ZIP アーカイブを作成するには、プロジェクトのルートディレクトリから下記のようにします。</description></item><item><title>チャットボット: Azure ポータルで生成されるボットのテンプレートコードを解読＆リファクタしてみる</title><link>https://maku.blog/p/iob68qa/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iob68qa/</guid><description>Azure が生成するテンプレートコードを理解する 下記の手順に従って Azure ポータル上で Web App Bot リソースを作成すると、ボットプログラムのテンプレートとして index.js や bot.js などのコードが自動生成されます。
Azure でボットをホストするための Web App Bot リソースを作成する ボットサーバのエントリポイントとなる index.js には、設定情報の読み取りと Web サーバの立ち上げ処理が記述されており、bot.js の方にはボットの応答処理を記述するようになっています。
つまり、基本的にボットの作成者は bot.js の方にボットのコア部分を実装していけばよいのですが、LUIS や QnA Maker などのサービスと連携する場合は、それぞれの初期化処理が必要であり、結局のところ index.js 側の実装に関してもある程度理解しておく必要があります。
Azure ポータルで自動生成される index.js は決して理解しやすいものではないので（少なくとも記述時点では）、ここでは index.js の内容を理解する目的と、わかりやすくリファクタする目的を兼ねて、ボットのベースとなるコードを作成していきます。
最終的には Azure が生成するテンプレートコードと同様の振る舞いになることを想定しています（少なくとも、環境変数の名前などは合わせておいた方がよいです）。
全体の流れ ボットプログラムのエントリポイントとなる index.js では、大まかに下記のような処理を行います。
.env ファイルを読み込み、環境変数の情報とマージする 1 の情報を基に、.bot ファイルを読み込む 2 の情報を基に、ボットサーバーを立ち上げる Azure ポータルで生成されるテンプレートコードでは、上記の処理をすべて index.js の中で行っているのですが、ここでは設定の読み込み部分と、ボットサーバの立ち上げ部分を明確に分離してみます。
config.js: 環境変数や .env ファイルの情報を基に、.bot ファイルの設定を読み込む。 index.js: 上記の設定情報を基にボットサーバを立ち上げる。 という感じにします。
ステップ(1) 環境変数あるいは .env ファイルの読み込み (config.</description></item><item><title>チャットボット: MS Bot Framework の .bot ファイルで接続情報を管理する</title><link>https://maku.blog/p/8choj4w/</link><pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8choj4w/</guid><description>エミュレータのための .bot ファイル Bot Framework Emulator は、自分自身（チャットクライアント）が接続するボットサーバのアドレスを .bot ファイルから取得します。
.bot ファイルの中には、&amp;quot;type&amp;quot;: &amp;quot;endpoint&amp;quot; というエンドポイント定義が 1 つ以上記述されており、ここにはボットプログラムのアドレスが記述されています。 エミュレータの設定で、どのエンドポイント設定を使用するかを切り替えることで、実際に接続するボットを使い分けることができます。 典型的には、開発時にローカルホスト上で動作させたボットサーバに接続するための development と、実稼働用に Azure 上で動作させたボットサーバに接続するための production というエンドポイントを定義します。
図: エミュレータ上でのエンドポイント切り替え ボットプログラムのための .bot ファイル .bot ファイルは、ボットプログラムからも利用されます（こちらの方がメイン）。
.bot ファイルには、LUIS や QnA Maker のサービスを利用するためのエンドポイント情報（アドレスやエンドポイントキー）が定義されており、ボットプログラムはこれらの情報を使って各サービスの API を利用します。 こららの情報は、ボット自体がローカルホスト上で動作していても、Azure 上で動作していても同様に利用されます。
また、ここでもボット自体の endpoint エントリが参照され、各種チャンネル（チャットクライアント）がボットにアクセスするときの認証処理のために使用されます。 このあたりの処理は、Bot Builder SDK を使ってボット実装を行っていれば、Adapter クラスとして抽象化されるため、特に意識せずに実装することができます。
.bot ファイルに LUIS や QnA Maker の接続設定を記述する .bot ファイルは XML ファイルなので、フォーマットさえ理解すればテキストエディタなどで編集してしまうことはできますが、エンドポイントキー部分の復号化・暗号化が必要だったりして面倒です。 Bot Framework Emulator には、.bot ファイルの内容を GUI で編集する機能が付いているのでこの機能を使うのがよいでしょう。
LUIS/QnA Maker サービスへの接続情報を設定する .bot ファイルをダブルクリックしてエミュレータを起動したら、左上の SERVICES の ＋ ボタンを押すことで各サービスの接続設定を行うことができます。</description></item><item><title>チャットボット: LUIS や QnA Maker サービスへの接続情報を .bot ファイルから取得する</title><link>https://maku.blog/p/o2bqajv/</link><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2bqajv/</guid><description>参考: MS Bot Framework の .bot ファイルで接続情報を管理する ここで作るもの こちらの実装 では、最初のステップとしてボットサーバ自体 (Azure Web Apps) のエンドポイント情報を .bot ファイルから取得する実装を行いました (config.js)。 ここでは、さらに、LUIS サービスや QnA Maker サービスを利用することを想定し、これらの情報も .bot ファイルから取得できるように拡張します。
使用イメージとしては、下記のようにしてそれぞれの接続情報を簡単に読み込めるようにします。
const config = require(&amp;#39;./config.js&amp;#39;); const LUIS_APP_NAME = &amp;#39;maku-luis-sample&amp;#39;; const QNA_APP_NAME = &amp;#39;maku-qna-sample&amp;#39;; const botEndpoint = config.loadBotEndpoint(); // ボット自体への接続情報 const luisEndpoint = config.loadLuisEndpoint(LUIS_APP_NAME); // LUIS への接続情報 const qnaEndpoint = config.loadQnaEndpoint(QNA_APP_NAME); // QnA Maker への接続情報 単一のオブジェクトとしてまとめて取得するように実装することもできるのですが、分かりやすさのために、3 つの情報に分けて取得するようにしています。 LUIS や QnA Maker は、複数のアプリ（ナレッジベース）を同時に使用する可能性があるので、アプリ名を指定して接続情報を取得できるようにしています。
取得した情報は、次のように BotBuilder SDK が提供するクラスへの入力として使用することを想定しています。</description></item><item><title>チャットボット: 作成したチャットボットを LINE に接続する</title><link>https://maku.blog/p/asuzg7k/</link><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/asuzg7k/</guid><description>LINE に Messaging API チャネルを作成する 自作したチャットボットアプリを LINE から「友だち」として見えるようにするには、まず LINE 側に「プロバイダー」を作成し、そこに「Messaging API チャネル」を追加する必要があります。 この Messaging API チャネルは、LINE アプリから「友だち」として見える単位だと考えればよいでしょう。
LINE に開発者として登録する LINE のプロバイダー登録作業などは、下記の LINE Developer Console から行うことができます。 初めてアクセスする場合は、開発者としての登録を求められるので、LINE アカウントでログインして開発者情報を入力してください。
LINE Developer Console プロバイダーを新規作成する LINE に開発者登録できたら、新規プロバイダー作成 のボタンを押して、プロバイダーを作成します。
Messaging API チャネルを追加する プロバイダーの作成が終わったら、そこに Messaging API チャネル を追加します。
チャネルの作成時には、アプリアイコンやアプリ名を自由に登録することができます。 アプリ名は一度設定すると 7 日間は変更できないようなので慎重に決めましょう（アイコンは 1 時間経てば変更できます）。
下のように、プロバイダー上に Messaging API チャネルが追加されていれば OK です。
スマホの LINE に友達登録する Messaging API のチャネルを選択し、チャネル基本設定 タブを見ると、LINE アプリ用の QR コードが見つかります。
この QR コードを LINE アプリのカメラで読み取ることで、チャットボットを友達追加することができます。
ただ、まだボットアプリ本体（自分で作成したボット実装）には接続していないので、話しかけても何も返答してくれません。 下記のようなテンプレートメッセージだけが表示されます。</description></item><item><title>チャットボット: 作成したチャットボットを Slack に接続する</title><link>https://maku.blog/p/rtxqceq/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rtxqceq/</guid><description>Slack に Bot Framework で作成したボットを接続する 図: ボットとのダイレクトメッセージによる会話 Microsoft Azure 上に作成したボットアプリを Slack に接続するには、下記の Bot Service 公式ドキュメントで説明されている手順に従ってください。
（日本語）ボットを Slack に接続する - Bot Service ｜ Microsoft Docs （英語）Connect a bot to Slack - Bot Service ｜ Microsoft Docs 接続のおおまかな手順は下記のような感じです。
Slack アプリを作成する（何らかのワークスペースに所属させる形で作成する） Slack アプリにボット用のユーザーを登録する Azure ポータルから、Web アプリボットのチャンネルとして Slack を追加（Slack アプリ側の Client ID、Client Secret、Verification Token をコピペすれば OK） この作業が終わると、ボット（アプリ）が Slack のワークスペースに参加している状態になります。 その時点ではどのチャンネルにも参加していませんが、ダイレクトメッセージを使って一対一でボットと会話することができます。
特定のチャンネルで会話している最中に @ボット名 と話かけると、そのチャンネルにボットを招待することができます。 チャンネルにボットが参加すると、後はそのチャンネルに対してつぶやくだけでボットが反応するようになります。
わかりにくいところの補足 図入りで説明されているので、特に迷うことはないと思いますが、Microsoft の Bot チームのドキュメント通りにはうまくいかない部分があるので若干補足しておきます。
ボットハンドル 「ボットのイベントをサブスクライブ」するという項目で、下記のような Request URL でボットハンドル (YourBotHandle) を指定するところがあります。</description></item><item><title>チャットボット: Chatdown（.chat ファイル）を使ってボットの会話をデザインする</title><link>https://maku.blog/p/a6yzskr/</link><pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a6yzskr/</guid><description>Chatdown フォーマットとは Chatdown フォーマットは、会話の設計をテキストベースで行うことを意図したフォーマットです。 拡張子は .chat で、下記のような感じで会話例を記述していきます。
sample.chat user=Joe bot=LulaBot bot: Hi! user: yo! bot: [Typing][Delay=3000] Greetings! What would you like to do? * update - You can update your account * List - You can list your data * help - you can get help user: I need the bot framework logo. 上記のように、チャットボットがタイプ中であることや、応答までのディレイなどもデザインすることができます。 Markdown 形式で書式設定できるようになっているのが Chatdown という名前の由来ですね。
Bot Framework Emulator で会話を再現する Bot Framework Emulator で会話ファイルを読み込むと、チャット UI 上で会話を再現することができます。 ただし、Emulator が読み込むことのできるファイルは .</description></item><item><title>チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する</title><link>https://maku.blog/p/mgujykj/</link><pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mgujykj/</guid><description>Bot Builder SDK (Node.js) の botbuilder-core パッケージには、ActivityHandler という、ボットのイベントハンドラ部分の実装を簡略化するためのライブラリが含まれています。 ボットの世界では、「Activity」はひとつのメッセージの処理単位のことを示しています。 この Activity をうまくハンドルするためのクラスだから ActivityHandler という名前が付けられているんですね。
ここでは、独自のボットクラス (MyBot) を、ActivityHandler を利用せずに実装した場合と、利用して実装した場合で比較してみたいと思います。
ActivityHandler を使わない場合 例えば、下記のように BotFrameworkAdapter で受信したイベントの処理を MyBot.onTurn() に委譲するとします。
mybot.js const myBot = new MyBot(); const adapter = new BotFrameworkAdapter({}); const server = require(&amp;#39;restify&amp;#39;).createServer(); server.post(&amp;#39;/api/messages&amp;#39;, (req, res) =&amp;gt; { adapter.processActivity(req, res, async (context) =&amp;gt; { await myBot.onTurn(context); // あとは MyBot に丸投げ }); }); このイベントは、ユーザからメッセージを送られたときだけでなく、ユーザがチャットに参加したとき (ConversationUpdate) などにも発生するため、MyBot.onTurn() の実装の中でアクティビティタイプを見て分岐処理を行わなければなりません。
class MyBot { constructor() { // ... } async onTurn(context) { if (context.</description></item><item><title>チャットボット: ユーザーの参加／離脱のイベントをハンドルする</title><link>https://maku.blog/p/onctywi/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/onctywi/</guid><description>Bot Builder SDK の ActivityHandler を使って、ユーザーが会話に参加したこと、離脱したことをハンドルする方法を説明します。 ActivityHandler を使ったボット実装の基本に関しては下記を参照してください。
チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する 下記は、ユーザーが新しく会話に参加したときに、ボットから挨拶するように実装した例です。 ユーザー参加のイベントをハンドルするには、ActivityHandler#onMembersAdded() で、イベントハンドラを登録します。
mybot.js const { ActivityHandler, BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); // ボット実装 class MyBot extends ActivityHandler { constructor() { super(); this.onMessage(this.handleMessage); this.onMembersAdded(this.handleMembersAdded); } async handleMessage(context, next) { const name = context.activity.from.name; const utterance = context.activity.text; await context.sendActivity(`${name}さんは、${utterance}と言いました。`); await next(); } async handleMembersAdded(context, next) { const members = context.activity.membersAdded; for (let i = 0; i &amp;lt; members.length; ++i) { const m = members[i]; if (m.</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (Storage)</title><link>https://maku.blog/p/3fnyk44/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3fnyk44/</guid><description>ボットは基本的にステートレスで動作するので、ユーザとの会話のコンテキストを把握するには、ステートの管理を明示的に行う必要があります。 Bot Builder SDK にはそのためのユーティリティクラスが用意されています。 ここでは、Node.js の botbuilder パッケージを使って説明します。
Storage インタフェース botbuilder パッケージに含まれている Storage インタフェースは、抽象化されたストレージに JSON オブジェクトを保存するための API を定義しています。 write、read、delete の 3 つの API のみなのでとてもシンプルです。
write メソッド JSON オブジェクトをストレージに保存するための API です。 オブジェクトを保存するときには、名前（キー）を付けて、キー＆バリューの形のオブジェクトとして保存します。 下記の例では、保存したい state オブジェクトに、botState という名前を付けて保存しています。
state.topic = &amp;#39;someTopic&amp;#39;; await storage.write({ &amp;#39;botState&amp;#39;: state }); read メソッド ストレージに保存されたオブジェクトを読み出すための API です。 読み出したいオブジェクトの名前を配列で渡すと、オブジェクトの連想配列が返ってきます。 下記の例では、botState という名前で保存されたオブジェクトを、state 変数に取り出しています。
const items = await storage.read([&amp;#39;botState&amp;#39;]); const state = items[&amp;#39;botState&amp;#39;] || {}; delete メソッド ストレージに保存されたオブジェクトを削除するための API です。 削除したいオブジェクトの名前を配列で渡します。</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (BotState)</title><link>https://maku.blog/p/6wtzzq4/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6wtzzq4/</guid><description>BotState クラス Bot Builder SDK の BotState クラス は、ボットとの会話内の特定のコンテキストにおける状態を保持するためのクラスです。
というと難しいですが、簡単に言うと、会話ごとの状態保存や、ユーザーごとの状態保存を行うための便利クラスです。
BotState クラスには次のようなサブクラスが定義されています。
ConversationState クラス &amp;hellip; 会話ごとの状態を保存する UserState クラス &amp;hellip; ユーザーごとの状態を保存する PrivateConversationState クラス &amp;hellip; 会話ごとのユーザごとの状態を保存する これらのクラスは、内部で Storage オブジェクトを利用します。
≪生成コード&amp;#x1F4D6;≫ Storage がグローバルに状態保存を行っていたのに対し、BotState はネームスペースを考慮して状態保存を行うものだと考えることができます。 実際に、ConversationState クラスや UserState クラスの実装を覗いてみると、getStorageKey() というメソッドでストレージ用の保存キーを作成しており、それぞれ次のように構成しています。
ConversationState が使用する保存キー ${ channelId }/conversations/${ conversationId }/${ this.namespace } UserState が使用する保存キー ${ channelId }/users/${ userId }/${ this.namespace } PrivateConversationState が使用するキー ${ channelId }/conversations/${ conversationId }/users/${ userId }/${ this.namespace } 実用的なボットの状態管理を行うには、Storage インタフェースをそのまま使うのではなく、ConversationState / UserState / PrivateConversationState などを使うことになるでしょう。</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (1) ダイアログの基本</title><link>https://maku.blog/p/w36evii/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w36evii/</guid><description>Dialog を使わない会話管理 Bot Builder SDK の UserState や ConversationState を使う と、ユーザーや会話ごとの状態管理を行うことできるため、複数回のやりとりが必要な会話を実現することができます。
例えば、下記のような会話ができるボットを実装してみます。
User: こんにちは Bot: あなたの名前は？ User: まく Bot: こんにちは まく さん User: おやすみなさい Bot: また来てね まく さん 次のボット実装は、UserState クラスを使って、pos という名前のプロパティを作成し、会話がどこまで進んでいるかを管理しています。
mybot.js const { ActivityHandler, UserState } = require(&amp;#39;botbuilder&amp;#39;); class MyBot extends ActivityHandler { constructor(storage) { super(); this._createStateObjects(storage); this.onMessage(async (context, next) =&amp;gt; { const prop = await this.nameProp.get(context, { pos: &amp;#39;init&amp;#39; }); // プロパティの &amp;#39;pos&amp;#39; により処理を分岐させる if (prop.pos === &amp;#39;init&amp;#39;) { prop.</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (2) スタック管理</title><link>https://maku.blog/p/6arjar6/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6arjar6/</guid><description>ダイアログの基本 で説明したように、Dialog クラスを使用した会話フローでは、ユーザーからメッセージを受け取るたびに DialogContext#continueDialog() を呼び出すことで、1 ステップずつ処理を進めていきます。 ダイアログには、スタック構造で会話を管理する仕組みがあり、次のようなメソッドを使って、ダイアログの起動（スタックに積む）、ダイアログの終了（スタックから降ろす）という操作を行うことが可能です。
DialogContext#beginDialog(&amp;quot;ID&amp;quot;) &amp;hellip; ダイアログを開始する（スタックに積む） DialogContext#endDialog() &amp;hellip; アクティブなダイアログを終了する（スタックから降ろす） DialogContext#replaceDialog(&amp;quot;ID&amp;quot;) &amp;hellip; アクティブなダイアログを別のダイアログに置き換える（スタックの一番上を入れ替え） DialogContext#cancelAllDialog() &amp;hellip; すべてのダイアログを終了する（スタックをクリア） ここでは、RootDialog と GreetDialog という名前の 2 つのダイアログクラス作成し、RootDialog から GreetDialog を起動してダイアログのスタックを積むような実装を行ってみます。
図: ダイアログ遷移のイメージ 下記は、実際のチャットクライアントの表示例です。 右側のバーで示すように、 最初に RootDialog による選択肢が表示され、次に GreetDialog の処理に遷移し、最後に RootDialog に戻ってくるという流れです。
図: チャットのイメージ 下記は、最初に起動される RootDialog クラスの実装です。 前回の説明 で使用した DialogBot クラスを使って RootDialog を起動することを想定しています。 ウォーターフォールダイアログの最初のステップ (_step1) として、ユーザーに選択肢を提示し、「挨拶する」を選んだ場合に、GreetDialog を新たに起動するようにしています。
dialogs/rootDialog.js const { ChoiceFactory, ChoicePrompt, ComponentDialog, ListStyle, WaterfallDialog, } = require(&amp;#39;botbuilder-dialogs&amp;#39;); const { GreetDialog } = require(&amp;#39;.</description></item><item><title>チャットボット: Bot Builder SDK で画像やリストなどのリッチなメッセージを送る (MessageFactory)</title><link>https://maku.blog/p/q7vw95i/</link><pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7vw95i/</guid><description>Activity オブジェクトと MessageFactory Bot Builder SDK によるボット実装において、ユーザーにメッセージを送るには TurnContext クラス の sendActivity() メソッドを使用します。 下記は、単純なテキストメッセージを送る例です。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); sendActivity() の第一引数には、このように文字列を渡すことができますが、その名の通り Activity オブジェクトを渡すこともできるようになっています。 Activity オブジェクトを使うと、単純なテキストよりもリッチな形式で表示を行うことができます（どう表示されるかは各チャンネルの実装によりますが）。
Activity インタフェースは botframework-schema モジュール で定義されていますが、このインタフェースを意識してオブジェクトを作成することはあまりありません。 というのも、いろいろな用途の Activity オブジェクトを生成するためのファクトリーである MessageFactory クラス が用意されているからです。
例えば、MessageFactory#text() は単純なテキストメッセージを送るための Activity オブジェクトを生成します。
// const { MessageFactory } = require(&amp;#39;botbuilder&amp;#39;); const msg = MessageFactory.text(&amp;#39;Hello!&amp;#39;); await context.sendActivity(msg); これは実は下記のようにするのと同じです。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); TurnContext#sendActivity() に直接文字列を渡した場合は、内部で前者のような MessageFactory.text() による Activity 生成が行われています。 単純なテキストを送るだけであれば、sendActivity('Hello') としてしまうのが早いでしょう。
MessageFactory でリッチなメッセージを作成する MessageFactory が提供するファクトリメソッドを使って、リッチなメッセージを送る例をいくつか紹介します。 ここでは、Bot Framework Emulator の表示例を載せておきます。
画像・動画を表示する &amp;ndash; contentUrl() const msg = MessageFactory.</description></item><item><title>チャットボット: 独自のミドルウェアを作成してログを記録する</title><link>https://maku.blog/p/fn3amda/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fn3amda/</guid><description>ミドルウェアとは Bot Framework において、クライアントから受信したメッセージはアダプターを介してボットに届けられますが、アダプターにミドルウェアを設定しておくことで、メッセージがボットに届く前に割り込んで処理を行うことができます。
Adapter → Middleware1 → Middleware2 → Middleware3 → ... → YourBot ミドルウェアは上記のように複数登録することができ、登録された順に呼び出されていきます。 アダプターにミドルウェアを追加するには、BotFrameworkAdapter#use() メソッドを使用します。
ミドルウェアの追加 const { BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); const adpater = new BotFrameworkAdapter(endpoint); adapter.use(new Middleware1()); adapter.use(new Middleware2()); adapter.use(new Middleware3()); ミドルウェアを実装する 独自のミドルウェアを作成するには、Middleware インタフェース が提供する onTurn メソッドを実装します。
ここでは、ユーザーの入力をコンソールに出力するだけの ConsoleLogger というミドルウェアクラスを実装してみます。
middlewares/consoleLogger.js exports.ConsoleLogger = class ConsoleLogger { async onTurn(context, next) { if (context.activity.type === &amp;#34;message&amp;#34;) { console.log(context.activity.text); } await next(); // Invoke a next middleware } }; とても簡単ですね。 あと、onTurn() を抜ける前に忘れずに next() を呼び出して、後続のミドルウェアが正しく呼び出されるようにしておく必要があります。</description></item><item><title>チャットボット: 独自のミドルウェアを作成して禁止ワードを拒否するようにする</title><link>https://maku.blog/p/gt9g2na/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gt9g2na/</guid><description>前回の記事 では、チャットボットに独自のミドルウェアを追加して、ユーザー入力をログ出力できるようにしました。 今回は、ユーザーが NG ワードを入力したときに、警告を表示して処理を中断するようなミドルウェアを作成してみます。
その名も NgWordMiddleware です！
middlewares/NgWordMiddleware.js const NG_WORDS = /アホ|まぬけ|バカ/; exports.NgWordMiddleware = class NgWordMiddleware { async onTurn(context, next) { if (context.activity.type === &amp;#39;message&amp;#39;) { const line = context.activity.text; if (NG_WORDS.test(line)) { await context.sendActivity(&amp;#39;そんなこと言っちゃダメ&amp;#39;); return; } } await next(); // Invoke a next middleware } }; 上記の例では、NG_WORDS 定数に、禁止語句を正規表現の形で登録しています。 ユーザーが入力したテキストに、禁止語句が含まれていたら、「そんなこと言っちゃダメ」と返事して処理を進めないようにします（next() を呼び出さないことで後続の処理を打ち切る）。
このミドルウェアは、下記のようにアダプターに追加することで有効化できます。
// const { NgWordMiddleware } = require(&amp;#39;./middlewares/ngWordMiddleware.js&amp;#39;); const adapter = new BotFrameworkAdapter(botEndpoint); adapter.use(new NgWordMiddleware()); この例では、単純に禁止語句が含まれているかだけをチェックしているので、「バカルディ」と入力した場合にも弾かれてしまいます。 このあたりは工夫して処理しなきゃですね。</description></item><item><title>LUIS (1) LUIS とは？</title><link>https://maku.blog/p/mkwnnsz/</link><pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mkwnnsz/</guid><description>LUIS でできること Microsoft が提供している LUIS (Language Understanding Intelligent Service) サービスを使用すると、自然言語による文章（発話テキスト）を、コンピュータが理解しやすい形式に翻訳することができます。 主にチャットボットのバックエンドとして使用されることが想定されているようです。
LUIS (Language Understanding) - Cognitive Services - Microsoft Azure LUIS - Endpoint API メインのクエリ用 REST API LUIS - Authoring API アプリ管理用の REST API LUIS は、入力した発話テキストをインテントとエンティティに分解します。
インテント … 意図、目的。ユーザが何をしたいのかを表す。 エンティティ … 文章の中のプレースホルダに当たる部分の値。求めているものや、条件などを示す部分。 例えば、下記のような入力テキストがあったとすると、
15時から4人で使える部屋はない？ LUIS は次のようなインテント＋エンティティの情報に翻訳します。
インテント: SearchMeetingRoom エンティティ: Time=15時、People=4人 チャットボットのプログラムは、この翻訳された情報を見て、「ミーティングルームを探す」処理を、パラメータ「15時」、「4人」で行えばよいことになります。 LUIS は上記のような翻訳処理を行うためのサービスなので、その先のミーティングルームの検索処理などは独自に実装する必要があります。
LUIS の Web サイト上では、このような発話例 (Utterance) と、インテント、エンティティの情報を登録していくことで、モデルの学習を進めることができます。
LUIS のモデルを公開する LUIS ポータル上で作成した自然言語解析のモデルを、Web API (REST API) の形で使用できるようにするには、下記のようなステップを踏みます（QnA Maker のサービスと同様の手順です）。
Azure ポータルの リソースの作成 から Language Understanding (LUIS) のリソースを作成する LUIS ポータルで LUIS アプリ（モデル）を作成する（上記で作成した Azure の LUIS リソース経由でアクセスできるよう関連付ける） LUIS ポータルでモデルを Publish して REST API として呼び出せるようにする 上記のようにしてナレッジベースを公開すれば、Node.</description></item><item><title>LUIS (2) LUIS のオーサリングキー、エンドポイントキーとは</title><link>https://maku.blog/p/mdyedwq/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mdyedwq/</guid><description>LUIS アプリで使用するキーの種類には、オーサリングキー (Authoring Key) とエンドポイントキー (Endpoint Key) の 2 種類があります。
オーサリングキー (Authoring Key) オーサリングキーは LUIS アカウントの作成時に自動的に作成される、無料のキーです。 オーサリングキーはリージョン内で共通であり、1 つだけ作成されます。 最初に作成されるので、スターターキー (Starter Key)、作成者キーとも呼ばれます。
オーサリングキーは、LUIS アカウントに結び付けられているので、LUIS 右上のアカウント名をクリックし、Settings を選択することで確認できるようになっています。
オーサリングキーは、LUIS アプリ自体の作成や、公開、コラボレーターの管理、バージョン管理などを行うときに必要になります。 つまり、あなたが作成する LUIS アプリの管理用のキーであり、LUIS の Web サイトで行えることほぼすべてをこのキーを使ったオーサリング API 経由で行えます。
LUIS ポータル上にログインして作業している間は、オーサリングキーの存在を意識しなくても LUIS アプリの管理を行うことができますが、Web API を使って LUIS アプリの管理作業を自動化したいときなどにオーサリングキーが必要になります。
作成した個々の LUIS アプリに対するクエリ実行のためにもオーサリングキーを使用できますが、これは実装中のテスト用途に限られます（権限の強いオーサリングキーを、公開アプリからのクエリ用途に使うのは避けるべきです）。 実運用でのクエリ実行は、後述のエンドポイントキーを使用します。
ちなみに、オーサリングキーは Microsoft のユーザアカウントごとに割り当てられるものです。 LUIS アプリのコラボレータとして登録されたユーザは、自分のオーサリングキーを使って LUIS アプリの管理を行います。
エンドポイントキー (Endpoint Key) 運用環境で LUIS アプリに対するクエリ実行を行うには、Azure の LUIS リソースとして作成されたエンドポイント URL とエンドポイントキーを使用します。 Azure ポータル にログインして、LUIS リソースを作成することでエンドポイントキーを取得できます。
Azure 上の LUIS リソースは、1 つのリソースグループに所属し、そのリソースグループは 1 つのサブスクリプションに所属します。 毎月の課金はサブスクリプションに対して行われます。 階層的には下記のような感じで LUIS リソースが配置されているイメージです。</description></item><item><title>LUIS (3) Node.js から LUIS の API を利用する</title><link>https://maku.blog/p/tewj3gs/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tewj3gs/</guid><description>LUIS API を呼び出すためのエンドポイント情報を調べる LUIS アプリの Publish REST API 経由で LUIS アプリによる発話解析を行うには、LUIS ポータル上で対象の LUIS アプリを Train し、Publish しておく必要があります（LUIS アプリというのは、いわゆる訓練されたモデルのことだと考えるとよいです）。
API 実行用のエンドポイント URL とキーを確認する Publish 処理が完了すると、エンドポイント URL と エンドポイントキー (Endpoint key) を使って、LUIS アプリに対してクエリ要求を投げることができるようになります。 テスト用途であれば、LUIS ポータル上で最初に作成される オーサリングキー (Authoring key) でもクエリを実行できますが、最終的なユーザ環境でのクエリ実行には Azure 上で作成したリソースに付けられたエンドポイント URL とエンドポイントキーのペアを使用する必要があります。
参考: オーサリングキー、エンドポイントキーとは LUIS の REST API を呼び出すための URL は、下記のような情報から構成されています（下記例の ID はデタラメです）。
Application ID: 5c548551-f6ba-4fc8-c695-529ac194317d Application version: 0.1 エンドポイントキー: ff824a1409f929c8e2a15301ccff431d Application ID と Application version は、MANAGE タブの Application Information のページで確認することができます。</description></item><item><title>LUIS (4) botbuilder-ai ライブラリを使って LUIS の API を利用する</title><link>https://maku.blog/p/dtwckb9/</link><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtwckb9/</guid><description>こちらの記事（Node.js から LUIS の API を利用する） では、自力で LUIS の REST API を呼び出すための URL を構築していました。 ここでは、botbuilder-ai パッケージを使用して、もっと手軽に LUIS の機能を呼び出してみます。
☝️ ワンポイント 残念ながら botbuilder-ai が提供している LuisRecognizer などのクラスは、チャットボットの実装に使用する TurnContext オブジェクトに依存した設計になっています。 そのため、単純なコンソールアプリケーションから botbuilder-ai パッケージを使用することは難しく、チャットボットの実装でしか利用できません。 LUIS のエンドポイント情報（接続情報）を確認しておく LUIS API を使用するには、下記のような LUIS アプリの APP ID やエンドポイント情報が必要です。
APP ID: c39eb4df-fbcf-224f-b8b7-a0ee445d11b3 エンドポイント: https://japaneast.api.cognitive.microsoft.com エンドポイントキー（サブスクリプションキー）: c9162c5c0b5edff5270feb6145618acb APP ID とエンドポイントキーは、LUIS ポータル から対象のアプリケーションを開き、下記のように確認できます。
APP ID: MANAGEタブ → Application Information エンドポイント: MANAGEタブ → Keys and Endpoints → Endpoint カラムの URL の前半部分。 エンドポイントキー: MANAGEタブ → Keys and Endpoints → Key 1 カラム LUIS のエンドポイントキーは、Azure ポータル に作成した LUIS リソース の キー の項目に表示されるものと同じです。 念のため、同一のものが表示されているか確認しておくとよいでしょう。</description></item><item><title>QnA Maker (1) QnA Maker とは？</title><link>https://maku.blog/p/2t6xrbm/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2t6xrbm/</guid><description>QnA Maker でできること Microsoft が提供している QnA Maker というサービスを使用すると、「質問(Q)と回答(A)」のペアデータを登録するだけで、自然言語での FAQ 検索を行うための API を使用できるようになります。 Microsoft が提供している一連の Cognitive Service のひとつとして位置づけられていて、主に FAQ 系のチャットボット (Bot) を手軽に作成するために使用されています。
QnA Maker QnA Maker Documentation QnA Maker REST API V4.0 QnAMaker class | Microsoft Docs 例えば、下記のような Q&amp;amp;A のペアを登録していくだけで、機械学習によって回答のモデルが自動生成されます。 QnA Maker では、このモデルのことをナレッジベース (Knowledge base) と呼んでいます。
Q. お店の営業時間を教えてください。 A. 営業時間は午前10時から午後6時までです。 実際にユーザが入力する質問文章は、登録した Q&amp;amp;A データの質問文と完全に一致する必要はありません。 QnA Maker がどの質問に近いかを判別して、対応する回答文（と一致度）を返してくれます。
ユーザ入力: 営業時間は？ QnA Makerの回答: 営業時間は午前10時から午後6時までです。 簡単に言ってしまえば、QnA Maker の API が提供する機能はこれだけです（データ管理用の API などもありますが）。 回答文を自動生成してくれるようなこともなく、返される文章は、Q&amp;amp;A データとして登録した回答文そのままです。 とはいえ、サクッと FAQ 系のサービスを作成するときには便利に使用できるサービスです。</description></item><item><title>QnA Maker (2) QnA Maker のサブスクリプションキー、エンドポイントキーとは</title><link>https://maku.blog/p/t6n6jc8/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t6n6jc8/</guid><description>サブスクリプションキー (Subscription Key) サブスクリプションキーは、QnA Maker アプリ自体の作成や編集を行うためのキーです。 後述のエンドポイントキーよりも厳重に管理しなければならないキーです。
このキーは、Azure ポータル上で QnA Maker のリソースを作成した際に生成されます。 QnA Maker アプリは、Azure 上にリソースを作ってからでないと作成できないため、QnA Maker アプリがすでに存在するのであれば、サブスクリプションキーも必ず存在することになります。
Azule の QnA Maker リソースに割り当てられたサブスクリプションキーは、Azure ポータルの QnA Maker リソースの Keys のページで確認することができます。
図: Azure ポータル上での QnA Maker のサブスクリプションキーの確認 LUIS の場合は、アプリ管理用のキーはオーサリングキーと呼んでいたりしますが、それの QnA Maker 版だと考えればよいです。 QnA Maker アプリの場合、このキーの管理は Azure ポータル上で管理されることになっており、Azure 上ではこのようなキーのことをサブスクリプションキーと呼んでいるんですね。 このあたりのチグハグ感に関しては こちらを参照。
エンドポイントキー (Endpoint Key) エンドポイントキーは、チャットアプリなどのユーザクライアント（Bot Framework では「チャンネル」と呼びます）が、QnA Maker に対してクエリを行うときに使用するキーです。 エンドポイントキーは、QnA Maker ポータルで対象となるナレッジベースを選択後、PUBLISH タブから Publish 処理を実行したとき、あるいは SETTING タブを選択することで確認することができます。
図: QnA Maker ポータル上での QnA Maker のエンドポイントキーの確認 チャットボットなどから QnA Maker を利用する場合、実運用時に設定する API アクセス用のキーは、こっちのエンドポイントキーです。</description></item><item><title>QnA Maker (3) Node.js から QnA Maker の API を利用する</title><link>https://maku.blog/p/rgnvp2r/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rgnvp2r/</guid><description>QnA Maker API を呼び出すためのエンドポイント情報を調べる QnA Maker ナレッジベースの Publish REST API を使用して QnA Maker のナレッジベースを使用するためには、QnA Maker ポータル上で対象のナレッジベースを Publish しておく必要があります。
Publish 処理が完了すると、ナレッジベースにアクセスするための Endpoint key が発行されます。
curl での QnA Maker API の呼び出しテスト 任意の質問文に対する回答文を得るには、REST API として下記のような HTTP POST リクエストを送ります。
curl -X POST https://xxx.azurewebsites.net/qnamaker/knowledgebases/＜ナレッジベースID＞/generateAnswer -H &amp;#34;Authorization: EndpointKey ＜上記で発行したキー＞&amp;#34; -H &amp;#34;Content-type: application/json&amp;#34; -d &amp;#34;{&amp;#39;question&amp;#39;:&amp;#39;&amp;lt;質問文&amp;gt;&amp;#39;}&amp;#34; Linux の curl コマンドを使用できる環境であれば、上記のように実行するだけで JSON 形式のレスポンスを確認することができます。
Node.js から QnA Maker の REST API を呼び出す Node.js から HTTP POST リクエストを送って JSON レスポンスを取得してみます。 HTTP リクエストを行うためのモジュールとして、ここでは request モジュールを使用します。 JavaScript ファイルを作成するディレクトリと同じディレクトリ内で、下記のようにインストールしておいてください。</description></item><item><title>QnA Maker (4) Python から QnA Maker の API を利用する</title><link>https://maku.blog/p/fwyi2fh/</link><pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fwyi2fh/</guid><description>QnA Maker は REST API を提供しているので、HTTP リクエストを発行できるプログラミング言語から簡単に制御することができます。 ここでは、Python に標準で付属している urllib.request モジュールを使って HTTP リクエストを発行し、QnA Maker にアクセスしてみます。
事前準備（アクセスキーの準備） REST API を使用するには、HTTP リクエストのヘッダ情報としてアクセスキーを付加する必要があります。 こちらの記事 を参考に、下記のどちらかのアクセスキーを確認しておいてください。
サブスクリプションキー (Subscription Key) &amp;hellip; 管理用 エンドポイントキー (Endpoint Key) &amp;hellip; クエリ用 アクセスキーは 9d16b3e6345489ad4a57a0755eb4f96a のような 16 進数文字列です。 QnA のクエリ実行だけであればエンドポイントキーの方を使えば大丈夫ですが、ナレッジベースの作成や更新などを行う場合は、サブスクリプションキーの方を使う必要があります。
QnA Maker の REST API を呼び出す Python ライブラリ REST API は HTTP リクエストを送るだけで使用できるので、ここでは自力で QnA Maker の API を使用するライブラリを作ってみます。
下記の QnaRequest クラスは、ナレッジベースの一覧を取得する getAllKnowledgeBases メソッドと、指定したナレッジベースの情報を取得する getKnowledgeBase メソッドを提供しています。 戻り値は JSON 形式のテキストです。
mylib/qna.py import urllib.request class QnaRequest: BASE_URL = &amp;#39;https://westus.</description></item><item><title>LUIS と QnA Maker でキーの管理方法が異なるのはなぜか？</title><link>https://maku.blog/p/8myms6s/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8myms6s/</guid><description>LUIS や QnA Maker サービスを利用するためのエンドポイントキーは、下記の 2 種類が提供されます。
実運用のためのキー: チャットクライアントなどからの、一般的な問い合わせを処理するためのキー。 管理用のキー: 各サービスの情報を取得したり、データを編集したりするためのキー。 LUIS も QnA Maker も便利なサービスなのですが、Azure リソースとの結びつけ方法や、キーの管理方法が異なっているため、最初はわけがわからなくなるかもしれません。 例えば、Azure ポータル上の RESOURCE MANAGEMENT / Keys のページで表示されるキー（サブスクリプションキー）が、LUIS の場合は実運用のためのキーであるのに対し、QnA Maker の場合は管理用のキー であったりします。
LUIS/QnA を使用する場合は、それぞれ、エンドポイントキーとしてどちらのキーを使用するかを間違えないようしなければいけません。
LUIS のサブスクリプションキー（実運用のためのキー）: Azure ポータルの LUIS リソースの Keys で表示されるもの LUIS のオーサリングキー（管理用のキー）: LUIS ポータルの Authoring Key で表示されるもの QnA Maker のエンドポイントキー（実運用のためのキー）: QnA Maker ポータルのプロファイル設定で表示されるもの QnA Maker のサブスクリプションキー（管理用のキー）: Azure ポータルの QnA Maker リソースの Keys で表示されるもの この時点で、キーの管理方法が QnA Maker と LUIS では完全に逆になっています。 Azure 上でのインタフェースは LUIS リソースと QnA Maker リソースで見た目が同じなので、混乱に拍車をかけています。</description></item><item><title>Azure 関連のアイコン集</title><link>https://maku.blog/p/bqodqji/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bqodqji/</guid><description>Azure 関連アイコンのダウンロード Microsoft Azure 関連のアイコンは下記のサイトからダウンロードできるようになっています。 PNG 形式や SVG 形式のファイルが入っているので、Azure 関連の構成図を作成するときに便利です。
Download Microsoft Azure, Cloud and Enterprise Symbol / Icon Set 例えばこーゆーアイコンがたくさん入っています。
アイコン 説明 Azure App Service - Web App Azure Cognitive Services Azure Cognitive Services - LUIS 全アイコンのリスト 上記のパッケージに含まれているアイコンを一覧表示できる HTML ファイルを用意しました。
icons.zip アーカイブを展開して、azure-icons/all_icons.html を開くと、下記のように全アイコンを一覧表示することができます。 ここから PowerPoint などにコピペして使うのも簡単です。</description></item><item><title>Azure リソースのプレフィックス名（省略名）</title><link>https://maku.blog/p/rcoz9o9/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rcoz9o9/</guid><description>Azure で何らかのリソースを作成するときは、リソース名のプレフィックス として、リソースの種類に応じた略称（cosmos- など）をつけることが多いのですが、この略称の指針が Microsoft Docs のサイトに書かれています。 リソース名をどうするかは意外と迷うところなので、こういった情報は地味に助かります。
Azure リソースの種類に推奨される省略形 - Cloud Adoption Framework | Microsoft Docs 例えば次のような感じで定義されています。
リソースの種類 プレフィックス リソースグループ rg- Cosmos DB アカウント cosmos- ストレージアカウント st- 静的 Web アプリ stapp- 関数アプリ func- また、リソース名全体の構成も次のような例で示されています。
図: Azure リソース名の構成（Microsoft Docs より） この辺りは開発チームによってルールが決められているかもしれませんが、まずはこの構成で間に合うか考えてみるとよいと思います。</description></item><item><title>MongoDB for VS Code で Azure Cosmos DB を操作する</title><link>https://maku.blog/p/dt3ahpw/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dt3ahpw/</guid><description>Cosmos DB インスタンスを MongoDB API アクセス用に作成 しておくと、さまざまな MongoDB 用のツールでデータベースにアクセスできるようになります。 ここでは、VS Code 用の拡張「MongoDB for VS Code」を使って、Cosmos DB を操作できるようにしてみます。 TypeScript を使って Web アプリを作成しているときは、エディタとして VS Code を使っていることが多いでしょうから、同じ環境上で Cosmos DB を操作できると開発が捗ります。
MongoDB for VS Code のインストール 図: MongoDB for VS Code のインストール MongoDB for VS Code は、VS Code の Extesions バー (Cmd/Ctrl + Shift + X) で MongoDB で検索すれば簡単にインストールできます。
VS Code から Cosmos DB (MongoDB) に接続する 接続文字列で簡単接続 MongoDB for VS Code をインストールすると、サイドバーに 葉っぱのアイコン が出てくるので、ここから MongoDB サーバーに接続することができます。 ちなみに、MongoDB が葉っぱアイコンを使うのは、それを使うことが「シンプルで自然であるから」らしいです（じゃあ水でもいいじゃん、とは言いますまい）。</description></item><item><title>Azure Functions に npm install で Node モジュールを追加する</title><link>https://maku.blog/p/9t7hs4e/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9t7hs4e/</guid><description>Azure Functions への npm install Azure Functions の関数を Node.js ランタイムで動かしている場合は、通常の Node.js アプリと同様に NPM パッケージを npm コマンドでインストールして使用することができます。 簡単なのは、Azure ポータル の Function App リソースの コンソール 画面から npm install を実行する方法です。
コンソールを開くと、Function App のルートディレクトリ（通常は D:\home\site\wwwroot）がカレントディレクトリになってプロンプトが表示されます。 ここから次のように package.json の作成と、Node モジュールのインストールを行うことができます。
D:\home\site\wwwroot&amp;gt; npm init -y D:\home\site\wwwroot&amp;gt; npm install node-fetch --save これで、この Functions プロジェクト内のすべての関数から、インストールした Node モジュールを使用できるようになります。
npm install を実行するディレクトリ Functions プロジェクトのディレクトリ階層は次のように、関数ごとにディレクトリが分かれています。
D:\home\site\wwwroot +-- host.json +-- MyFunc1 | +-- function.json | +-- index.js +-- MyFunc2 +-- function.json +-- index.</description></item><item><title>Azure Static Web Apps で静的ウェブサイトを作成する</title><link>https://maku.blog/p/vgt5fqy/</link><pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgt5fqy/</guid><description>Azure Static Web Apps とは 2020年5月に Azure Static Web Apps のプレビュー版が公開されました。 これまでは、Azure 上で静的なウェブサイトを作成する場合は、BLOB ストレージを使って HTML/JS ファイルなどをホストする方法がとられていましたが、今後は Static Web Apps のサービスが主流になりそうです。
参考: Azure Storage で静的 Web サイトをホスティングする Azure Static Web Apps は、サイトのビルドやデプロイに GitHub Actions を使うことを前提としているため、Web サイトのコンテンツを GitHub 上で管理することが強制されます。
GitHub Pages でも静的な Web サイトを作成できますが、Azure Static Web Apps を使うと Azure Functions などの API サービスと統合することができます。 静的 Web サイトといいつつも、より高度な Web アプリを作成することができそうです。
Azure Static Web Apps は、ベータ版のうちは無料で使えるようです。 そのうち従量課金に切り替わると思いますが、BLOB ストレージを使った場合の利用料金はめちゃ安だったので、こちらも安価な料金が設定されることを期待しています。
GitHub リポジトリの準備 下記のような簡単な HTML ファイルを作成して、GitHub リポジトリを新規作成 してコミットしておきます。</description></item><item><title>Azure Pipelinesメモ: azure-pipelines.yml から別の Yaml をインクルードする (template)</title><link>https://maku.blog/p/36h9xj9/</link><pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/36h9xj9/</guid><description>Template 機能 Azure Pipelines の Template 機能を使用すると、別の Yaml ファイルに記述したビルド設定をインクルードすることができます。
Templates - Azure Pipelines | Microsoft Docs 変数を渡して、部分的に内容を置き換えることができるので、「インクルード」ではなく「テンプレート」と呼んでいるみたいです。
単純に共通の steps を読み込んで使うこともできるし、逆にテンプレートファイルに対してパラメータで stepList を渡すということもできます。
使用例（steps の共通化） 例えば、別の Yaml ファイル（テンプレート）に記述した steps 定義を、azure-pipelines.yml から読み込むとします。 テンプレートファイルには次のような感じで、ルートに steps 要素を記述します。
common-steps.yml（テンプレート） steps: - task: NodeTool@0 inputs: versionSpec: &amp;#39;10.x&amp;#39; displayName: &amp;#39;Install Node.js&amp;#39; - task: Npm@1 inputs: command: &amp;#39;ci&amp;#39; displayName: &amp;#39;npm ci&amp;#39; - task: Npm@1 inputs: command: &amp;#39;custom&amp;#39; customCommand: &amp;#39;run lint&amp;#39; displayName: &amp;#39;npm run lint&amp;#39; # ... azure-pipelines.yml の steps 以下で、上記のテンプレートファイルを読み込むには、template というキーワードを使用します。</description></item><item><title>Azure Pipelines トラブル: npm タスクを実行できないとき</title><link>https://maku.blog/p/7c2kdub/</link><pubDate>Wed, 22 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7c2kdub/</guid><description>Azure Pipelines の設定で、次のような感じで Npm タスクを追加したとき、
azure-pipelines.yml steps: - task: Npm@1 inputs: command: &amp;#39;ci&amp;#39; displayName: &amp;#39;npm ci&amp;#39; - task: Npm@1 inputs: command: &amp;#39;custom&amp;#39; customCommand: &amp;#39;run lint&amp;#39; displayName: &amp;#39;npm run lint&amp;#39; Node.js 系のコマンドが認識されていないと、エラーが出て Npm タスクを実行できません。
No agent found in pool Default which satisfies the specified demands: npm, Agent.Version -gtVersion 2.163.1 そのような場合は、steps の先頭で、次のように NodeTool (Node.js Tool Installer) タスクを実行しておくと、うまく動作するようになります 。
azure-pipelines.yml steps: # これで npm コマンドを認識するようになる - task: NodeTool@0 inputs: versionSpec: &amp;#39;10.x&amp;#39; displayName: &amp;#39;Install Node.</description></item><item><title>Bot Framework: Web チャットの表示をカスタマイズする</title><link>https://maku.blog/p/oitn3a3/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oitn3a3/</guid><description>Microsoft Bot Framework を使ってウェブサイト上にチャットボットを配置したときの表示のカスタマイズ方法です。 次のように、ボットやユーザーのアイコンを設定することができます。
このようなカスタマイズ表示を行うには、Azure portal 上の Web App Bot リソースの Channels タブから選択できる、Direct Line チャネルを使う必要があります。 Web Chat というチャネルを使うと、iframe タグで簡単にチャットウィンドウを埋め込むことができるのですが、そちらではあまりカスタマイズができないようです。
図: Direct Line チャネルのキーを確認 下記はチャットウィンドウをカスタマイズして表示するサンプルコードです。 Bot Framework が提供している WebChat.renderWebChat() 関数を呼び出すと、実際にチャットウィンドウが表示されるのですが、このときに styleOptions パラメータを指定することで表示方法をカスタマイズすることができます。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.botframework.com/botframework-webchat/latest/webchat.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; * { margin: 0; } #webchat { height: 100vh; width: 100vw; background: gray; border: solid 5px #f37; box-sizing: border-box; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;webchat&amp;#34; role=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const TOKEN = &amp;#39;HpJB2ofxzsA.</description></item><item><title>Azure: デプロイスロットでリリース時のダウンタイムをなくす（Blue-Green デプロイメント）</title><link>https://maku.blog/p/bog7iq8/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bog7iq8/</guid><description>なぜデプロイスロットが必要か？ App Service を作成すると、デフォルトでは運用スロット (production slot) がひとつだけ作成され、Azure Repos や GitHub からのアプリケーションのデプロイ先として使用されます。
アクセスの少ないアプリケーションであればこれでも問題ありませんが、デプロイ後にサーバー上でのビルド処理（ウォームアップ）が走るようなケースでは、少なからずダウンタイムが発生してしまいます。
このようなダウンタイムの発生を防ぐために、ステージング用のスロット (staging slot) を用意し、そこでのウォームアップが完了した後で運用スロット (production slot) と入れ替えるという方法を取ります。
GitHub or AzureRepos ─デプロイ→ staging スロット ↑ (スワップ) ↓ production スロット このようにサーバーインスタンス（ここではスロット）を 2 つ用意して、内容をスワップ（実際はアドレスをスワップ）することで運用環境を瞬間的に入れ替える手法を Blue-Green デプロイメント とか、A/B アップデートと呼びます。
Azure の App Service は、 デプロイスロット (Deployment slots) という機能名で、Blue-Green デプロイメントをサポートしています。
図: App Service の Deployments slots 設定 デプロイスロットを使ったスワップ運用には次のような利点があります。
ステージング環境 (staging slot) で事前に動作検証できる 運用環境 (production slot) のダウンタイムをほぼゼロにできる 運用環境 (production slot) で問題が発生したら、再度スワップして前のバージョンに戻すことができる App Service にステージング環境用のデプロイスロットを追加する デプロイスロットの作成 まず、App Service に新しくステージング環境用のデプロイスロット (Deployment slots) を作成します。 対象となる App Service のリソースを選択し、次のように選択するとデプロイスロットの追加ダイアログが開きます。</description></item><item><title>Azure: Node.js アプリを App Service へデプロイする（Kudu ビルド編）</title><link>https://maku.blog/p/wx3fvib/</link><pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wx3fvib/</guid><description>Azure App Service には、デプロイセンター という仕組みがあり、そこからソースコードのビルドからデプロイまでの自動化の設定を行うことができます。 簡単に言うと、Azure Repos や GitHub のリポジトリに最新の JavaScript コードをコミットするだけで、最新の Node.js アプリが自動で立ち上がるようになります。
ビルドの仕組みとしては、クラウド上の Azure Pipelines を使ったり、ローカルでビルドしてしまってからデプロイする方法があります。 App Service には Kudu エンジン が組み込まれており、デプロイ時に自動で実行されるスクリプトを使って簡易的なビルド処理を行うこともできます。
はじめに（用語定義） Azure ではデプロイ処理を構成するコンポーネントを下記のような名前で呼んでいます。
デプロイソース GitHub や Azure Repos など。 ソースコードが置いてある場所（リポジトリ）のこと。 Azure App Service は手軽なデプロイソースとして OneDrive や Dropbox などのフォルダ共有サービスを設定することもできますが、本格的な運用で使用することは推奨されていません。 ビルドパイプライン（ビルドプロバイダー） Azure Pipelines など。デプロイソースからソースコードを取得し、一連のビルド処理を行う仕組み。 App Service には組み込みで Kudu エンジンが搭載されており、デフォルトではデプロイ時にこの Kudu エンジンによって npm install などが実行されるようになっています。 また、デプロイ時に実行する カスタムスクリプトを .deployment ファイルで定義する こともできます。 これらの仕組みだけで十分であれば、Azure Pipelines を使う必要はありません。 デプロイメカニズム ビルドしたアプリを Azure App Service などに配置するためのアクション。Kudu エンジンや FTP (SFTP)、WebDeploy などのデプロイメカニズムが提供されています。 リポジトリの準備 (Azure Repos) ここでは、Azure Repos に Git リポジトリを作成し、そこに Node.</description></item><item><title>Azure: App Service の Node.js アプリのエントリポイントはどこで定義されているか？</title><link>https://maku.blog/p/3u4hj7h/</link><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3u4hj7h/</guid><description>Node.js アプリのエントリポイントの指定 Azure App Service で Node.js アプリをテンプレートから作成すると、うまいことルートに配置された index.js が起動してくれます。 この仕組みがブラックボックスな感じで気持ち悪いので調べてみたところ、このエントリポイントの指定は web.config ファイルにあるようです。
web.config（抜粋） &amp;lt;add name=&amp;#34;iisnode&amp;#34; path=&amp;#34;index.js&amp;#34; verb=&amp;#34;*&amp;#34; modules=&amp;#34;iisnode&amp;#34;/&amp;gt; Windows ベースの App Service で Node.js アプリを動作させる場合、Windows の Web サーバーである IIS 上で動作する iisnode という Node.js 実装が使用されます。 IIS が起動するときに設定ファイルである web.config が読み込まれ、上記の設定により iisnode がエントリポイント index.js を使って起動するという流れになります。 なので、作成している Node.js アプリのエントリポイント（メインの JS ファイル）が変わった場合は、この web.config ファイルを修正する必要があります。
あと、このような仕組みのため、web.config ファイルは必ずアプリを構成する JS ファイルと一緒にデプロイしないといけないということも分かります。 上記の設定のままであれば、デプロイ先のルートディレクトリに、少なくとも下記の 2 ファイルが配置されていなければいけません。
web.config （IIS の設定ファイル） index.js （上記ファイルで指定されたエントリポイント） なぜ紛らわしいのか？ Node.js アプリを開発するとき、通常は package.json の start スクリプトとしてエントリポイントを指定します。
package.json（抜粋） { &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;node index.</description></item><item><title>Azure Speech Service を使って音声をテキストに変換する (STT)</title><link>https://maku.blog/p/5zx3ozz/</link><pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5zx3ozz/</guid><description>Microsoft の Cognitive Services のひとつとして提供されている Speech Service を使用すると、音声をテキストに変換したり、逆にテキストを音声に変換したりすることができます。
ここでは、Python から Speech Service の機能を利用してみます（Windows 10 で動作確認済）。 実行するにはマイクのついた PC が必要です マイクのついていない PC で実行すると SPXERR_MIC_NOT_AVAILABLE エラーが発生します。
準備 Speech Service の準備 Azure Portal から Speech のリソースを作成し、Subscription Key を取得しておいてください。
Speech SDK のインストール Python の azure-cognitiveservices-speech パッケージをインストールします。
$ pip install azure-cognitiveservices-speech Visual Studio C++ Redistributable のインストール 必要があれば、Visual Studio C++ の再頒布可能パッケージをインストールします。
Visual C++ 再頒布可能パッケージ (vc_redist.x64.exe) Python コード 一回だけ変換して終わるバージョン stt.py import azure.cognitiveservices.speech as speechsdk # この設定は適宜変更してください subscription = &amp;#34;e1b5f0964ab743133b7de4f892741c7a&amp;#34; region = &amp;#34;japaneast&amp;#34; language = &amp;#34;ja-JP&amp;#34; # proxy = (&amp;#34;proxy.</description></item></channel></rss>