<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Firebase/CloudFunctions on まくろぐ</title><link>https://maku.blog/tags/firebase/cloudfunctions/</link><description>Recent content in Firebase/CloudFunctions on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><atom:link href="https://maku.blog/tags/firebase/cloudfunctions/index.xml" rel="self" type="application/rss+xml"/><item><title>Firestore のデータバンドルを作成してドキュメントの読み込み回数を削減する</title><link>https://maku.blog/p/dtdtbr8/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtdtbr8/</guid><description>何をするか？ Firestore はクライアントアプリから直接アクセスできることが利点ですが、多数のクライアントから複数のドキュメントを読み込んでいると、あっという間に無料枠を超えて高額な請求が発生してしまいます。
図: 同じデータなのに何度もドキュメントの Read が発生する Firebase 8.2.0 でリリースされた Cloud Firestore Data Bundles という仕組みを使用すると、Firestore から取得したデータ（クエリ結果）をバンドルというデータにまとめておいて、それを使いまわすことができます。 データバンドルを CDN でキャッシュ、あるいはクライアントサイドでキャッシュすることにより、Firestore へのアクセスを発生させずに、あたかも Firestore からデータフェッチしたかのように動作させることが可能です。 ユーザー数の多いアプリに導入すれば、大きなコスト削減につながります。
データバンドルは Cloud Functions を使って作成してしまうのが簡単です。 下記のような構成にすれば、クライアントアプリは Firestore にアクセスする代わりにデータバンドルを取得して動作するようになります。
図: Cloud Functions でバンドルを生成する しかし、これだけでは複数のクライアントから Cloud Functions へのアクセスが発生してしまうので、結局はその都度 Firestore へのアクセスが発生してしまいます。 各クライアントアプリではキャッシュが有効ですが、そのキャッシュでさえ、Ctrl(Cmd) + R によるスーパーリロードで無視されてしまいます。 そこで、次のようにさらに CDN (Firebase Hosting) を挟んでデータバンドルをキャッシュすることで、各クライアントからのアクセスで Cloud Functions が起動されてしまうのを防ぎます。
図: CDN でバンドルをキャッシュする この構成になっていれば、クライアントがいくら強制リロードしようが、CDN (Firebase Hosting) にキャッシュされたデータバンドルのみが参照されるようになります。 Firestore へのアクセスが発生するのは、CDN 上のキャッシュが無効になったときのみです。 クライアント側のキャッシュ時間や、CDN のキャッシュ時間は、Cloud Functions の関数が返すレスポンスヘッダ (Cache-Control) で制御できます。
Cloud Functions でデータバンドルを作成する 下記のコードでは、Cloud Functions に登録する createBundle 関数を定義しています。 処理の流れは次のようになっています。</description></item><item><title>Firestore のデータバンドルを作成してドキュメントの読み込み回数を削減する</title><link>https://maku.blog/p/dtdtbr8/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtdtbr8/</guid><description>何をするか？ Firestore はクライアントアプリから直接アクセスできることが利点ですが、多数のクライアントから複数のドキュメントを読み込んでいると、あっという間に無料枠を超えて高額な請求が発生してしまいます。
図: 同じデータなのに何度もドキュメントの Read が発生する Firebase 8.2.0 でリリースされた Cloud Firestore Data Bundles という仕組みを使用すると、Firestore から取得したデータ（クエリ結果）をバンドルというデータにまとめておいて、それを使いまわすことができます。 データバンドルを CDN でキャッシュ、あるいはクライアントサイドでキャッシュすることにより、Firestore へのアクセスを発生させずに、あたかも Firestore からデータフェッチしたかのように動作させることが可能です。 ユーザー数の多いアプリに導入すれば、大きなコスト削減につながります。
データバンドルは Cloud Functions を使って作成してしまうのが簡単です。 下記のような構成にすれば、クライアントアプリは Firestore にアクセスする代わりにデータバンドルを取得して動作するようになります。
図: Cloud Functions でバンドルを生成する しかし、これだけでは複数のクライアントから Cloud Functions へのアクセスが発生してしまうので、結局はその都度 Firestore へのアクセスが発生してしまいます。 各クライアントアプリではキャッシュが有効ですが、そのキャッシュでさえ、Ctrl(Cmd) + R によるスーパーリロードで無視されてしまいます。 そこで、次のようにさらに CDN (Firebase Hosting) を挟んでデータバンドルをキャッシュすることで、各クライアントからのアクセスで Cloud Functions が起動されてしまうのを防ぎます。
図: CDN でバンドルをキャッシュする この構成になっていれば、クライアントがいくら強制リロードしようが、CDN (Firebase Hosting) にキャッシュされたデータバンドルのみが参照されるようになります。 Firestore へのアクセスが発生するのは、CDN 上のキャッシュが無効になったときのみです。 クライアント側のキャッシュ時間や、CDN のキャッシュ時間は、Cloud Functions の関数が返すレスポンスヘッダ (Cache-Control) で制御できます。
Cloud Functions でデータバンドルを作成する 下記のコードでは、Cloud Functions に登録する createBundle 関数を定義しています。 処理の流れは次のようになっています。</description></item><item><title>Firebase の Cloud Functions で Hello World</title><link>https://maku.blog/p/fvevcs8/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fvevcs8/</guid><description>何をするか？ Cloud Functions に関数をデプロイすると、Google Cloud Platform 上でサーバーレス関数として実行できるようになります（Amazon の AWS Lambda や、Microsoft の Azure Functions に相当するものです）。 この関数は、次のように、様々なイベントをトリガーにして呼び出されます。
HTTP でのアクセス スケジュールされたタイミング Firestore データベースの更新時 ここでは、HTTP によるアクセス時に Hello from Firebase! というレスポンスを返すだけの関数を Cloud Functions に追加してみます。 また、Firebase にデプロイする前に、エミュレーターでのローカルテストを行います。
☝️ Firebase なのか GCP なのか Cloud Functions は Firebase プロジェクトからも使用できますが、実体は GCP で提供されているサービスです。 このようなサービスは他にもあり、Firebase のサービスのうち、頭に Cloud と付いてるものは実際には GCP が提供しています（例:「Cloud Firestore」「Cloud Functions」「Cloud Storage」）。 事前準備 最初に Firebase プロジェクトを作成し、Firebase CLI をインストールしておきます。 既存の Firebase プロジェクトに Cloud Functions を追加する場合は、プロジェクトの作成は必要ありません。
Firebase のアカウントを作成します Firebase コンソール から新規プロジェクトを作成します firebase コマンドでもプロジェクトを作成できますが、上記サイトから作成してしまった方が楽です（名前の重複チェックなどをしてくれます） Firebase CLI をインストール して、firebase コマンドを実行できるようにします Firebase CLI をインストールしたら、次のように Firebase アカウントでサインインしておきます。</description></item><item><title>Firebase の Cloud Functions で Hello World</title><link>https://maku.blog/p/fvevcs8/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fvevcs8/</guid><description>何をするか？ Cloud Functions に関数をデプロイすると、Google Cloud Platform 上でサーバーレス関数として実行できるようになります（Amazon の AWS Lambda や、Microsoft の Azure Functions に相当するものです）。 この関数は、次のように、様々なイベントをトリガーにして呼び出されます。
HTTP でのアクセス スケジュールされたタイミング Firestore データベースの更新時 ここでは、HTTP によるアクセス時に Hello from Firebase! というレスポンスを返すだけの関数を Cloud Functions に追加してみます。 また、Firebase にデプロイする前に、エミュレーターでのローカルテストを行います。
☝️ Firebase なのか GCP なのか Cloud Functions は Firebase プロジェクトからも使用できますが、実体は GCP で提供されているサービスです。 このようなサービスは他にもあり、Firebase のサービスのうち、頭に Cloud と付いてるものは実際には GCP が提供しています（例:「Cloud Firestore」「Cloud Functions」「Cloud Storage」）。 事前準備 最初に Firebase プロジェクトを作成し、Firebase CLI をインストールしておきます。 既存の Firebase プロジェクトに Cloud Functions を追加する場合は、プロジェクトの作成は必要ありません。
Firebase のアカウントを作成します Firebase コンソール から新規プロジェクトを作成します firebase コマンドでもプロジェクトを作成できますが、上記サイトから作成してしまった方が楽です（名前の重複チェックなどをしてくれます） Firebase CLI をインストール して、firebase コマンドを実行できるようにします Firebase CLI をインストールしたら、次のように Firebase アカウントでサインインしておきます。</description></item><item><title>Firebase の Cloud Functions で定期的に Firestore の集計処理を行う</title><link>https://maku.blog/p/vgs4dox/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dox/</guid><description>何をするか？ Firestore データベースは、コレクションデータを手軽に格納していくのにはとても便利ですが、全データを集計するような処理は苦手です。 例えば、各ドキュメントに付けられた「タグ」情報をすべて回収して、タグの一覧を生成したい場合、全てのドキュメントを read する必要があるため、ドキュメント数が Firebase の使用料金にダイレクトに効いてきます。 もし、Firestore にドキュメントが追加されるたびに Cloud Functions を起動してこのような集計処理を行うと、凄まじい勢いで課金されてしまいます。
ここでは、Cloud Functions による 集計処理を定期的なスケジュールで起動する ことで、Firestore ドキュメントの read 処理を削減してみます。 もちろん、リアルタイムな更新が必要なデータには使えませんが、カタログ的なデータであれば、定期的なデータ更新で間に合うケースは多いはずです。
事前準備 Firebase コンソール からテスト用のプロジェクトを作成してください。ここでは、自動生成されたアプリ ID を myapp-58138 とします。 Firestore データベースに books コレクションを追加し、次のようなサンプルドキュメントを追加してください。tag フィールドは本来は配列 (tags) であるべきですが、ここではシンプル化のために文字列型のスカラデータとしています。 id: 001 (title: Title1, author: Author1, tag: Tag1) id: 002 (title: Title2, author: Author2, tag: Tag2) id: 003 (title: Title3, author: Author3, tag: Tag3) Firebase CLI をインストール して、firebase コマンドを使用できるようにしてください。作成した関数を Cloud Functions にデプロイするために使います。 プロジェクトの雛形の生成 プロジェクト用のディレクトリを作成します。</description></item><item><title>Firebase の Cloud Functions で定期的に Firestore の集計処理を行う</title><link>https://maku.blog/p/vgs4dox/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dox/</guid><description>何をするか？ Firestore データベースは、コレクションデータを手軽に格納していくのにはとても便利ですが、全データを集計するような処理は苦手です。 例えば、各ドキュメントに付けられた「タグ」情報をすべて回収して、タグの一覧を生成したい場合、全てのドキュメントを read する必要があるため、ドキュメント数が Firebase の使用料金にダイレクトに効いてきます。 もし、Firestore にドキュメントが追加されるたびに Cloud Functions を起動してこのような集計処理を行うと、凄まじい勢いで課金されてしまいます。
ここでは、Cloud Functions による 集計処理を定期的なスケジュールで起動する ことで、Firestore ドキュメントの read 処理を削減してみます。 もちろん、リアルタイムな更新が必要なデータには使えませんが、カタログ的なデータであれば、定期的なデータ更新で間に合うケースは多いはずです。
事前準備 Firebase コンソール からテスト用のプロジェクトを作成してください。ここでは、自動生成されたアプリ ID を myapp-58138 とします。 Firestore データベースに books コレクションを追加し、次のようなサンプルドキュメントを追加してください。tag フィールドは本来は配列 (tags) であるべきですが、ここではシンプル化のために文字列型のスカラデータとしています。 id: 001 (title: Title1, author: Author1, tag: Tag1) id: 002 (title: Title2, author: Author2, tag: Tag2) id: 003 (title: Title3, author: Author3, tag: Tag3) Firebase CLI をインストール して、firebase コマンドを使用できるようにしてください。作成した関数を Cloud Functions にデプロイするために使います。 プロジェクトの雛形の生成 プロジェクト用のディレクトリを作成します。</description></item></channel></rss>