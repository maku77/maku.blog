<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Firebase/Firestore on まくろぐ</title><link>https://maku.blog/tags/firebase/firestore/</link><description>Recent content in Firebase/Firestore on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><atom:link href="https://maku.blog/tags/firebase/firestore/index.xml" rel="self" type="application/rss+xml"/><item><title>Firestore のデータバンドルを作成してドキュメントの読み込み回数を削減する</title><link>https://maku.blog/p/dtdtbr8/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtdtbr8/</guid><description>何をするか？ Firestore はクライアントアプリから直接アクセスできることが利点ですが、多数のクライアントから複数のドキュメントを読み込んでいると、あっという間に無料枠を超えて高額な請求が発生してしまいます。
図: 同じデータなのに何度もドキュメントの Read が発生する Firebase 8.2.0 でリリースされた Cloud Firestore Data Bundles という仕組みを使用すると、Firestore から取得したデータ（クエリ結果）をバンドルというデータにまとめておいて、それを使いまわすことができます。 データバンドルを CDN でキャッシュ、あるいはクライアントサイドでキャッシュすることにより、Firestore へのアクセスを発生させずに、あたかも Firestore からデータフェッチしたかのように動作させることが可能です。 ユーザー数の多いアプリに導入すれば、大きなコスト削減につながります。
データバンドルは Cloud Functions を使って作成してしまうのが簡単です。 下記のような構成にすれば、クライアントアプリは Firestore にアクセスする代わりにデータバンドルを取得して動作するようになります。
図: Cloud Functions でバンドルを生成する しかし、これだけでは複数のクライアントから Cloud Functions へのアクセスが発生してしまうので、結局はその都度 Firestore へのアクセスが発生してしまいます。 各クライアントアプリではキャッシュが有効ですが、そのキャッシュでさえ、Ctrl(Cmd) + R によるスーパーリロードで無視されてしまいます。 そこで、次のようにさらに CDN (Firebase Hosting) を挟んでデータバンドルをキャッシュすることで、各クライアントからのアクセスで Cloud Functions が起動されてしまうのを防ぎます。
図: CDN でバンドルをキャッシュする この構成になっていれば、クライアントがいくら強制リロードしようが、CDN (Firebase Hosting) にキャッシュされたデータバンドルのみが参照されるようになります。 Firestore へのアクセスが発生するのは、CDN 上のキャッシュが無効になったときのみです。 クライアント側のキャッシュ時間や、CDN のキャッシュ時間は、Cloud Functions の関数が返すレスポンスヘッダ (Cache-Control) で制御できます。
Cloud Functions でデータバンドルを作成する 下記のコードでは、Cloud Functions に登録する createBundle 関数を定義しています。 処理の流れは次のようになっています。</description></item><item><title>Firestore のデータバンドルを作成してドキュメントの読み込み回数を削減する</title><link>https://maku.blog/p/dtdtbr8/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtdtbr8/</guid><description>何をするか？ Firestore はクライアントアプリから直接アクセスできることが利点ですが、多数のクライアントから複数のドキュメントを読み込んでいると、あっという間に無料枠を超えて高額な請求が発生してしまいます。
図: 同じデータなのに何度もドキュメントの Read が発生する Firebase 8.2.0 でリリースされた Cloud Firestore Data Bundles という仕組みを使用すると、Firestore から取得したデータ（クエリ結果）をバンドルというデータにまとめておいて、それを使いまわすことができます。 データバンドルを CDN でキャッシュ、あるいはクライアントサイドでキャッシュすることにより、Firestore へのアクセスを発生させずに、あたかも Firestore からデータフェッチしたかのように動作させることが可能です。 ユーザー数の多いアプリに導入すれば、大きなコスト削減につながります。
データバンドルは Cloud Functions を使って作成してしまうのが簡単です。 下記のような構成にすれば、クライアントアプリは Firestore にアクセスする代わりにデータバンドルを取得して動作するようになります。
図: Cloud Functions でバンドルを生成する しかし、これだけでは複数のクライアントから Cloud Functions へのアクセスが発生してしまうので、結局はその都度 Firestore へのアクセスが発生してしまいます。 各クライアントアプリではキャッシュが有効ですが、そのキャッシュでさえ、Ctrl(Cmd) + R によるスーパーリロードで無視されてしまいます。 そこで、次のようにさらに CDN (Firebase Hosting) を挟んでデータバンドルをキャッシュすることで、各クライアントからのアクセスで Cloud Functions が起動されてしまうのを防ぎます。
図: CDN でバンドルをキャッシュする この構成になっていれば、クライアントがいくら強制リロードしようが、CDN (Firebase Hosting) にキャッシュされたデータバンドルのみが参照されるようになります。 Firestore へのアクセスが発生するのは、CDN 上のキャッシュが無効になったときのみです。 クライアント側のキャッシュ時間や、CDN のキャッシュ時間は、Cloud Functions の関数が返すレスポンスヘッダ (Cache-Control) で制御できます。
Cloud Functions でデータバンドルを作成する 下記のコードでは、Cloud Functions に登録する createBundle 関数を定義しています。 処理の流れは次のようになっています。</description></item><item><title>Firebase の Cloud Functions で定期的に Firestore の集計処理を行う</title><link>https://maku.blog/p/vgs4dox/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dox/</guid><description>何をするか？ Firestore データベースは、コレクションデータを手軽に格納していくのにはとても便利ですが、全データを集計するような処理は苦手です。 例えば、各ドキュメントに付けられた「タグ」情報をすべて回収して、タグの一覧を生成したい場合、全てのドキュメントを read する必要があるため、ドキュメント数が Firebase の使用料金にダイレクトに効いてきます。 もし、Firestore にドキュメントが追加されるたびに Cloud Functions を起動してこのような集計処理を行うと、凄まじい勢いで課金されてしまいます。
ここでは、Cloud Functions による 集計処理を定期的なスケジュールで起動する ことで、Firestore ドキュメントの read 処理を削減してみます。 もちろん、リアルタイムな更新が必要なデータには使えませんが、カタログ的なデータであれば、定期的なデータ更新で間に合うケースは多いはずです。
事前準備 Firebase コンソール からテスト用のプロジェクトを作成してください。ここでは、自動生成されたアプリ ID を myapp-58138 とします。 Firestore データベースに books コレクションを追加し、次のようなサンプルドキュメントを追加してください。tag フィールドは本来は配列 (tags) であるべきですが、ここではシンプル化のために文字列型のスカラデータとしています。 id: 001 (title: Title1, author: Author1, tag: Tag1) id: 002 (title: Title2, author: Author2, tag: Tag2) id: 003 (title: Title3, author: Author3, tag: Tag3) Firebase CLI をインストール して、firebase コマンドを使用できるようにしてください。作成した関数を Cloud Functions にデプロイするために使います。 プロジェクトの雛形の生成 プロジェクト用のディレクトリを作成します。</description></item><item><title>Firebase の Cloud Functions で定期的に Firestore の集計処理を行う</title><link>https://maku.blog/p/vgs4dox/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dox/</guid><description>何をするか？ Firestore データベースは、コレクションデータを手軽に格納していくのにはとても便利ですが、全データを集計するような処理は苦手です。 例えば、各ドキュメントに付けられた「タグ」情報をすべて回収して、タグの一覧を生成したい場合、全てのドキュメントを read する必要があるため、ドキュメント数が Firebase の使用料金にダイレクトに効いてきます。 もし、Firestore にドキュメントが追加されるたびに Cloud Functions を起動してこのような集計処理を行うと、凄まじい勢いで課金されてしまいます。
ここでは、Cloud Functions による 集計処理を定期的なスケジュールで起動する ことで、Firestore ドキュメントの read 処理を削減してみます。 もちろん、リアルタイムな更新が必要なデータには使えませんが、カタログ的なデータであれば、定期的なデータ更新で間に合うケースは多いはずです。
事前準備 Firebase コンソール からテスト用のプロジェクトを作成してください。ここでは、自動生成されたアプリ ID を myapp-58138 とします。 Firestore データベースに books コレクションを追加し、次のようなサンプルドキュメントを追加してください。tag フィールドは本来は配列 (tags) であるべきですが、ここではシンプル化のために文字列型のスカラデータとしています。 id: 001 (title: Title1, author: Author1, tag: Tag1) id: 002 (title: Title2, author: Author2, tag: Tag2) id: 003 (title: Title3, author: Author3, tag: Tag3) Firebase CLI をインストール して、firebase コマンドを使用できるようにしてください。作成した関数を Cloud Functions にデプロイするために使います。 プロジェクトの雛形の生成 プロジェクト用のディレクトリを作成します。</description></item><item><title>Firestore ドキュメントを TypeScript のユーザー定義型オブジェクトに変換する (withConverter)</title><link>https://maku.blog/p/bw9kv6g/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bw9kv6g/</guid><description>Firestore の JavaScript SDK でドキュメントを参照するときに、withConverter 関数を組み合わせて使用すると、ドキュメントの読み書きを行うときに、TypeScript のユーザーデータ型との変換処理を自動的に呼び出すことができます。
例えば、次のような Book 型のデータを、Firestore の books コレクションに保存するとします。
export type Book = { id: string title: string price?: number } Firestore ドキュメントとユーザーデータ型の変換処理は、次のように FirestoreDataConverter インタフェースを実装する形で定義します。 今回は Book 型に id プロパティを含めましたが、Firestore はドキュメントの ID をパス情報として表現するので、そのあたりの変換処理に注意する必要があります。
// import { // DocumentData, FirestoreDataConverter, QueryDocumentSnapshot, // SnapshotOptions, serverTimestamp } from &amp;#39;firebase/firestore&amp;#39; /** * Firestore のドキュメントと Book オブジェクトの型変換を行います。 */ const bookConverter: FirestoreDataConverter&amp;lt;Book&amp;gt; = { /** * Book オブジェクトを Firestore ドキュメントデータへ変換します。 */ toFirestore(book: Book): DocumentData { // id は Firestore のパスで表現されるのでドキュメントデータには含めない。 // 下記の updatedAt のように、自動で更新時刻のフィールドを追加することも可能。 return { title: book.</description></item><item><title>Firestore ドキュメントを TypeScript のユーザー定義型オブジェクトに変換する (withConverter)</title><link>https://maku.blog/p/bw9kv6g/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bw9kv6g/</guid><description>Firestore の JavaScript SDK でドキュメントを参照するときに、withConverter 関数を組み合わせて使用すると、ドキュメントの読み書きを行うときに、TypeScript のユーザーデータ型との変換処理を自動的に呼び出すことができます。
例えば、次のような Book 型のデータを、Firestore の books コレクションに保存するとします。
export type Book = { id: string title: string price?: number } Firestore ドキュメントとユーザーデータ型の変換処理は、次のように FirestoreDataConverter インタフェースを実装する形で定義します。 今回は Book 型に id プロパティを含めましたが、Firestore はドキュメントの ID をパス情報として表現するので、そのあたりの変換処理に注意する必要があります。
// import { // DocumentData, FirestoreDataConverter, QueryDocumentSnapshot, // SnapshotOptions, serverTimestamp } from &amp;#39;firebase/firestore&amp;#39; /** * Firestore のドキュメントと Book オブジェクトの型変換を行います。 */ const bookConverter: FirestoreDataConverter&amp;lt;Book&amp;gt; = { /** * Book オブジェクトを Firestore ドキュメントデータへ変換します。 */ toFirestore(book: Book): DocumentData { // id は Firestore のパスで表現されるのでドキュメントデータには含めない。 // 下記の updatedAt のように、自動で更新時刻のフィールドを追加することも可能。 return { title: book.</description></item><item><title>Next.js で Firebase: Cloud Firestore データベースを使う</title><link>https://maku.blog/p/m3bjrz7/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m3bjrz7/</guid><description>何をするか Cloud Firestore は、Firebase サービス（あるいは GCP）が提供するサーバーレスな NoSQL データベースです。 Firestore データベースには様々な環境からアクセスできますが、ここでは Web サイトからアクセスすることを想定して、Firebase が提供する JavaScript SDK（クライアントサイド SDK）を使って Firestore データベースを操作してみます。
☝️ Firebase と GCP の使い分け Firebase と GCP (Google Cloud Platform) の両方に Firestore の記載があるので混乱しますが、どちらのプロジェクトで作った Firestore データベースも内部的には共有されているようです。 Firebase プロジェクトも、GCP プロジェクトとして参照できるようになっています。 一方で、SDK は共通化されておらず、主に Firebase はクライアントサイド用の SDK を提供し、GCP はサーバーサイド用の SDK を提供しています。 前提条件として、Firebase プロジェクトの作成は完了し、FirebaseApp インスタンスの初期化コードは準備できているものとします。
参考: Next.js で Firebase: プロジェクトの作成と接続準備 Firestore データベースの作成 クライアントアプリの実装を始める前に、Firebase プロジェクトに Firestore データベースを作成します。
Firebase コンソール にサインインして、対象のプロジェクトを開く。 サイドバーから Firestore Database を選択し、データベースの作成 をクリックする。 保護ルールは 本番環境モード を選んでおけば OK ロケーションは asia-northeast1（東京）を選んでおけば OK 次のように空っぽのデータベースが作成されれば準備 OK です。</description></item><item><title>Next.js で Firebase: Cloud Firestore データベースを使う</title><link>https://maku.blog/p/m3bjrz7/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m3bjrz7/</guid><description>何をするか Cloud Firestore は、Firebase サービス（あるいは GCP）が提供するサーバーレスな NoSQL データベースです。 Firestore データベースには様々な環境からアクセスできますが、ここでは Web サイトからアクセスすることを想定して、Firebase が提供する JavaScript SDK（クライアントサイド SDK）を使って Firestore データベースを操作してみます。
☝️ Firebase と GCP の使い分け Firebase と GCP (Google Cloud Platform) の両方に Firestore の記載があるので混乱しますが、どちらのプロジェクトで作った Firestore データベースも内部的には共有されているようです。 Firebase プロジェクトも、GCP プロジェクトとして参照できるようになっています。 一方で、SDK は共通化されておらず、主に Firebase はクライアントサイド用の SDK を提供し、GCP はサーバーサイド用の SDK を提供しています。 前提条件として、Firebase プロジェクトの作成は完了し、FirebaseApp インスタンスの初期化コードは準備できているものとします。
参考: Next.js で Firebase: プロジェクトの作成と接続準備 Firestore データベースの作成 クライアントアプリの実装を始める前に、Firebase プロジェクトに Firestore データベースを作成します。
Firebase コンソール にサインインして、対象のプロジェクトを開く。 サイドバーから Firestore Database を選択し、データベースの作成 をクリックする。 保護ルールは 本番環境モード を選んでおけば OK ロケーションは asia-northeast1（東京）を選んでおけば OK 次のように空っぽのデータベースが作成されれば準備 OK です。</description></item></channel></rss>