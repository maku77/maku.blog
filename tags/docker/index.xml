<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on まくろぐ</title><link>https://maku.blog/tags/docker/</link><description>Recent content in Docker on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 18 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker で MongoDB サーバーを立ち上げる</title><link>https://maku.blog/p/y6zgrg2/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/y6zgrg2/</guid><description>Docker のオフィシャルイメージとして、mongo イメージが公開されています。
mongo - Official Image | Docker Hub このイメージには、MongoDB サーバー (mongod) や、MongoDB クライアント (mongosh) が含まれており、コマンドを省略してコンテナを起動すると、デフォルトで MongoDB サーバーが立ち上がります。
MongoDB サーバーのコンテナを起動する 次のように mongo コンテナを起動すると、ローカルホスト上で MongoDB サーバーを立ち上げたのと同様に振舞います。
$ docker container run --rm -d -p 27017:27017 --name mongo mongo オプションの意味:
--rm &amp;hellip; コンテナを停止したときにコンテナを削除します。コンテナを削除したくなければ、このオプションは外してください。 -d &amp;hellip; デーモンをバックグラウンドで動作させます。 -p 27107:27017 &amp;hellip; ローカルホストの 27107 ポートへのアクセスを、コンテナ内の MongoDB サーバーの 27107 ポートへ転送します。 --name mongo &amp;hellip; 起動するコンテナに mongo という名前を付けます。 mongo &amp;hellip; Docker イメージとして mongo:latest を使用します（デフォルトで :latest が使われます)。 次のようにして、mongo コンテナが起動していることを確認できます。</description></item><item><title>Go アプリを実行する軽量な Docker コンテナイメージを作成する</title><link>https://maku.blog/p/wbtbr8o/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wbtbr8o/</guid><description>何をするか？ Go 言語 (Golang) で簡単な Web サーバーを作成して、それを動かす軽量な Docker コンテナイメージを作成します。 Dockerfile には マルチステージのビルド構成 を適用し、Go 言語アプリのビルドと、実行イメージのビルドのステージを分けます。 実行用のコンテナイメージとしては、Alpine Linux ベースと、scratch ベースの 2 種類のイメージを作成してみます。
Golang は軽量なシングルバイナリを生成するのに適した言語で、Docker イメージの生成にも向いています。 Node.js などでイメージを作ろうとすると、Hello World でも 100MB 超えになってしまいますが、Golang を使えば、その 1/10 程度のサイズのイメージを生成できます。 軽量のイメージを作れるようになると、頻繁なビルドとデプロイを気兼ねなく行えるようになります。
Golang アプリを準備する Golang で作るアプリは何でもよいのですが、ここでは Golang 標準の net/http パッケージを使って、Hello World というレスポンスを返すだけの簡単な Web サーバーアプリを用意します。
まずは、お馴染みの go.mod の作成から。
$ mkdir hello &amp;amp;&amp;amp; cd hello $ go mod init hello あとは、次のような main.go ファイルを作成すれば完成です。
main.go package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.</description></item><item><title>Ansible タスク例: Docker と Docker Compose をインストールする</title><link>https://maku.blog/p/8k4j2gw/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8k4j2gw/</guid><description>何をするか？ 下記の Docker のインストールマニュアルに従い、Ansible で Ubuntu 22.04 に Docker の実行環境をセットアップします。
Install Docker Engine on Ubuntu | Docker Documentation Playbook の例 次の YAML ファイルは、Docker の公式サイトのインストール手順をほぼそのまま Playbook 化したものです。 この Playbook を ansible-playbook で実行することで、Docker (+ Docker Compose) のインストール、および Docker デーモンの起動まで完了します。
install-docker.yml - hosts: all gather_facts: false become: true tasks: - name: Install APT packages to use a repository over HTTPS ansible.builtin.apt: pkg: - ca-certificates - curl - gnupg - lsb-release update_cache: yes cache_valid_time: 86400 # cache for 1 day - name: Create APT&amp;#39;s keyrings directory ansible.</description></item><item><title>GitHub Actions でコンテナイメージをビルドして Docker Hub へ push する</title><link>https://maku.blog/p/v9r8o5k/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v9r8o5k/</guid><description>何をするか？ Docker イメージを作成するための Dockerfile を GitHub のリポジトリで管理しているとします。 ここでは、GitHub Actions のワークフローを作成して、GitHub リポジトリにコードを push したときに次のような処理が自動で実行されるようにします。
Dockerfile を使ってイメージをビルド Docker Hub にイメージを push 前提条件として、Docker Hub のアカウントは作成済みとします。
Dockerfile の準備 GitHub のリポジトリを作成して、ルートディレクトリに次のような Dockerfile をコミット＆プッシュしておきます。
Dockerfile FROM alpine:3 CMD [&amp;#34;echo&amp;#34;, &amp;#34;Hello World&amp;#34;] 上記のサンプルコードは、軽量の Alpine Linux で Hello World と出力するだけの Dockerfile ですが、もちろん好きなように記述していただいて構いません。
GitHub Actions の Secrets 情報を登録 GitHub Actions から Docker Hub にイメージをプッシュできるようにするため、GitHub リポジトリの Secrets 情報として、Docker Hub のユーザー名およびアクセストークンを登録しておきます。
Docker Hub のアクセストークンは次のように発行できます。
Docker Hub にサインイン 右上のユーザー名をクリックして、Account Settings を選択 Security → New Access Token と選択して、トークンの説明文を入力 Access Token description: Deploy hello world など適当に入力 Access permissions: 少なくとも Read, Write を付ける Generate ボタンを押して生成 これで、次のような感じのアクセストークンが発行されるので、どこかにコピーしておきます（後から確認することはできません）。</description></item><item><title>TypeScript を使った Node.js アプリを Docker コンテナ化する</title><link>https://maku.blog/p/ehxgwt4/</link><pubDate>Fri, 29 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ehxgwt4/</guid><description>何をするか？ TypeScript + Node.js で作成したサーバーアプリを、Docker コンテナ化する話です。 サーバーアプリは Express で簡単な Hello レスポンスを返すようなものを用意します。 Docker イメージビルド用の Dockerfile ファイルは、マルチステージビルドの構成にして、最終的な実行イメージができるだけ小さくなるようにします（それでも Node.js アプリだと、どうしても 100MB 超えになってしまいますが）。 NPM パッケージの管理には yarn を使わず、シンプルに npm だけでいきます。
Node.js アプリの用意 Node.js アプリは何でもよいのですが、ここでは Express で簡単な Web サーバーを作ることにします。
TypeScript プロジェクトのセットアップ $ npm init --yes # package.json を生成 $ npm install express $ npm install --save-dev typescript @types/express @types/node $ npx tsc --init # tsconfig.json を生成 package.json に、TypeScript のビルドと、サーバー起動のための NPM スクリプトを追加しておきます。
package.json（抜粋） &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;node out/index.</description></item><item><title>Docker コンテナで Ansible のテストベッド環境を用意する</title><link>https://maku.blog/p/csctaq7/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/csctaq7/</guid><description>何をするか ansible-playbook を使って何らかの Linux 環境のセットアップを自動化するとき、Playbook のテスト用に使い捨ての Docker コンテナ（テストベッド環境）があると便利です。
Ansible には、Playbook 実行後の冪等性を保つという性質がありますが、一度 Playbook を実行してしまうと元の状態に戻すことはできません。 一方通行の冪等性はあっても、可逆性はないということですね。 Playbook を試行錯誤して作っている段階では、何度も ansible-playbook を実行することになるので、本当にその Playbook がまっさらな状態の OS に対して適用できるのか不安になってきます（冪等性があるので理論的には動作するはずですが）。 異なるディストリビューションに対して実行できるのか試したくなることもあります。
ここでは、Ansible のテストベッド環境として Docker コンテナを作成し、各種 Ansible コマンド (ansible / ansible-playbook) で制御してみます。
テストベッド用のコンテナを起動する Ansible は一般的にはマネージドノードに SSH 接続して Playbook を実行しますが、実は Docker コンテナに直接接続することもできます。 つまり、テストベッド用の Docker コンテナには、sshd (OpenSSH) などのサービスをわざわざインストールする必要はありません。
ただし、Ansible マネージドノードの要件として、Python3 だけはインストールしておく必要があります。 次の Dockerfile では、Ubuntu を親イメージとして、Python3 だけ追加しています。
Dockerfile FROM ubuntu:22.04 # Python3 のインストール RUN apt update &amp;amp;&amp;amp; apt install --no-install-recommends -y python3 Dockerfile をビルドして、testbed イメージを作成します。</description></item><item><title>Docker コンテナで Nginx サーバーを立ち上げる</title><link>https://maku.blog/p/99qo8zf/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/99qo8zf/</guid><description>何をするか？ VPS などで Web アプリをホスティングする場合、各種サーバーを Docker コンテナとして立ち上げるようにすると OS 環境をクリーンに保てます。 特に、1 つのホスト（VPS サーバー）で複数の Web アプリを提供するような場合は、各アプリをコンテナで構成することで、関係ないアプリの設定が混ざってしまうのを防げます。 もちろん、Azure Container Instances や AWS Fargate といったコンテナ実行用のクラウドサービスを使えば、より独立した環境を構築できるのですが、これらのサービスは個人が趣味で使うにはまだまだ高価なので、VPS などの環境で Docker コンテナを立ち上げることには価値があります。
ここでは、Nginx サーバーを Docker コンテナとして立ち上げる方法を示します。 Docker Hub で公開されている Nginx イメージ は、デフォルトでコンテナ内の /usr/share/nginx/html ディレクトリに配置されたコンテンツを公開するようになっています。 大きく分けて、次の 2 つのいずれかの方法で簡単にコンテンツを公開できます。
bind マウントで Docker ホスト側のコンテンツを参照する方法 コンテンツを含んだコンテナイメージを作成する方法 以下、それぞれの方法を順番に見ていきます。
bind マウントで Docker ホスト側のコンテンツを参照する方法 Nginx のコンテナを起動するときに、Docker ホスト側のコンテンツディレクトリを bind マウントして、コンテナの /usr/share/nginx/html ディレクトリとして参照できるようにする方法です。
まず、簡単なコンテンツファイルとして次のような HTML ファイルを用意しておきます。
public/index.html &amp;lt;html&amp;gt;Hello&amp;lt;/html&amp;gt; あとは、docker container run コマンドで nginx コンテナを起動するだけです。
$ docker container run --rm -d -p 8000:80 -v &amp;#34;$(pwd)/public&amp;#34;:/usr/share/nginx/html --name web nginx 各引数は次のような意味を持っています。</description></item><item><title>Docker で Ansible の実行環境用のコンテナを作成する</title><link>https://maku.blog/p/euevcs8/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/euevcs8/</guid><description>何をするか？ Ansible の実行環境は Python がインストールされている環境であれば比較的簡単にインストールできますが、Docker の実行環境があれば、ホスト環境に何もインストールせずに Ansible の実行環境を手に入れることができます（もちろんコンテナは作る必要はありますが）。
Docker Hub を見ると、Alpine Linux ベースの Ansible 実行環境用イメージ alpine/ansible があるようですが、ここでは Dockerfile を使って自分でイメージを作成することにします。
Ansible 実行環境用イメージを作成する Dockerfile で Alpine Linux ベースの Ansible 実行環境を定義します。
Dockerfile FROM alpine:3 WORKDIR /app # --no-cache を付けることで /var/cache/apk 以下にキャッシュが残るのを防ぐ # --update-cache を付けることで先に apk update するのと同じ効果になる RUN apk --no-cache --update-cache add ansible openssh sshpass APK (Alpine Package Keeper) で次のようなパッケージをインストールしています。
ansible &amp;hellip; Ansible Community パッケージ（ansible コマンドや ansible-playbook コマンドなど） openssh &amp;hellip; ssh コマンドのため sshpass &amp;hellip; ターゲットホストにパスワード認証 (--ask-pass) で接続するときのため Ansible Community パッケージ (ansible) ではなく、Ansible Core (ansible-core) を使うようにすれば、イメージサイズは 500MB 弱から 80MB 程度に削減できますが、サイズを気にしなくてよいなら Ansible Community パッケージを使っておいた方が楽です。</description></item></channel></rss>