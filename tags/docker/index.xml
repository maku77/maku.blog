<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on まくろぐ</title><link>https://maku.blog/tags/docker/</link><description>Recent content in Docker on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 26 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>GitHub Actions でコンテナイメージをビルドして Docker Hub へ push する</title><link>https://maku.blog/p/v9r8o5k/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v9r8o5k/</guid><description>何をするか？ Docker イメージを作成するための Dockerfile を GitHub のリポジトリで管理しているとします。 ここでは、GitHub Actions のワークフローを作成して、GitHub リポジトリにコードを push したときに次のような処理が自動で実行されるようにします。
Dockerfile を使ってイメージをビルド Docker Hub にイメージを push 前提条件として、Docker Hub のアカウントは作成済みとします。
Dockerfile の準備 GitHub のリポジトリを作成して、ルートディレクトリに次のような Dockerfile をコミット＆プッシュしておきます。
Dockerfile FROMalpine:3CMD [&amp;#34;echo&amp;#34;, &amp;#34;Hello World&amp;#34;] 上記のサンプルコードは、軽量の Alpine Linux で Hello World と出力するだけの Dockerfile ですが、もちろん好きなように記述していただいて構いません。
GitHub Actions の Secrets 情報を登録 GitHub Actions から Docker Hub にイメージをプッシュできるようにするため、GitHub リポジトリの Secrets 情報として、Docker Hub のユーザー名およびアクセストークンを登録しておきます。
Docker Hub のアクセストークンは次のように発行できます。
Docker Hub にサインイン 右上のユーザー名をクリックして、Account Settings を選択 Security → New Access Token と選択して、トークンの説明文を入力 Access Token description: Deploy hello world など適当に入力 Access permissions: 少なくとも Read, Write を付ける Generate ボタンを押して生成 これで、次のような感じのアクセストークンが発行されるので、どこかにコピーしておきます（後から確認することはできません）。</description></item><item><title>TypeScript を使った Node.js アプリを Docker コンテナ化する</title><link>https://maku.blog/p/ehxgwt4/</link><pubDate>Fri, 29 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ehxgwt4/</guid><description>何をするか？ TypeScript + Node.js で作成したサーバーアプリを、Docker コンテナ化する話です。 サーバーアプリは Express で簡単な Hello レスポンスを返すようなものを用意します。 Docker イメージビルド用の Dockerfile ファイルは、マルチステージビルドの構成にして、最終的な実行イメージができるだけ小さくなるようにします（それでも Node.js アプリだと、どうしても 100MB 超えになってしまいますが）。 NPM パッケージの管理には yarn を使わず、シンプルに npm だけでいきます。
Node.js アプリの用意 Node.js アプリは何でもよいのですが、ここでは Express で簡単な Web サーバーを作ることにします。
TypeScript プロジェクトのセットアップ $ npm init --yes # package.json を生成 $ npm install express $ npm install --save-dev typescript @types/express @types/node $ npx tsc --init # tsconfig.json を生成 package.json に、TypeScript のビルドと、サーバー起動のための NPM スクリプトを追加しておきます。
package.json（抜粋） &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;node out/index.</description></item><item><title>Docker コンテナで Ansible のテストベッド環境を用意する</title><link>https://maku.blog/p/csctaq7/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/csctaq7/</guid><description>何をするか ansible-playbook を使って何らかの Linux 環境のセットアップを自動化するとき、Playbook のテスト用に使い捨ての Docker コンテナ（テストベッド環境）があると便利です。
Ansible には、Playbook 実行後の冪等性を保つという性質がありますが、一度 Playbook を実行してしまうと元の状態に戻すことはできません。 一方通行の冪等性はあっても、可逆性はないということですね。 Playbook を試行錯誤して作っている段階では、何度も ansible-playbook を実行することになるので、本当にその Playbook がまっさらな状態の OS に対して適用できるのか不安になってきます（冪等性があるので理論的には動作するはずですが）。 異なるディストリビューションに対して実行できるのか試したくなることもあります。
ここでは、Ansible のテストベッド環境として Docker コンテナを作成し、各種 Ansible コマンド (ansible / ansible-playbook) で制御してみます。
テストベッド用のコンテナを起動する Ansible は一般的にはマネージドノードに SSH 接続して Playbook を実行しますが、実は Docker コンテナに直接接続することもできます。 つまり、テストベッド用の Docker コンテナには、sshd (OpenSSH) などのサービスをわざわざインストールする必要はありません。
ただし、Ansible マネージドノードの要件として、Python3 だけはインストールしておく必要があります。 次の Dockerfile では、Ubuntu を親イメージとして、Python3 だけ追加しています。
Dockerfile FROMubuntu:22.04# Python3 のインストールRUN apt update &amp;amp;&amp;amp; apt install --no-install-recommends -y python3 Dockerfile をビルドして、testbed イメージを作成します。</description></item><item><title>Docker コンテナで Nginx サーバーを立ち上げる</title><link>https://maku.blog/p/99qo8zf/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/99qo8zf/</guid><description>何をするか？ VPS などで Web アプリをホスティングする場合、各種サーバーを Docker コンテナとして立ち上げるようにすると OS 環境をクリーンに保てます。 特に、1 つのホスト（VPS サーバー）で複数の Web アプリを提供するような場合は、各アプリをコンテナで構成することで、関係ないアプリの設定が混ざってしまうのを防げます。 もちろん、Azure Container Instances や AWS Fargate といったコンテナ実行用のクラウドサービスを使えば、より独立した環境を構築できるのですが、これらのサービスは個人が趣味で使うにはまだまだ高価なので、VPS などの環境で Docker コンテナを立ち上げることには価値があります。
ここでは、Nginx サーバーを Docker コンテナとして立ち上げる方法を示します。 Docker Hub で公開されている Nginx イメージ は、デフォルトでコンテナ内の /usr/share/nginx/html ディレクトリに配置されたコンテンツを公開するようになっています。 大きく分けて、次の 2 つのいずれかの方法で簡単にコンテンツを公開できます。
bind マウントで Docker ホスト側のコンテンツを参照する方法 コンテンツを含んだコンテナイメージを作成する方法 以下、それぞれの方法を順番に見ていきます。
bind マウントで Docker ホスト側のコンテンツを参照する方法 Nginx のコンテナを起動するときに、Docker ホスト側のコンテンツディレクトリを bind マウントして、コンテナの /usr/share/nginx/html ディレクトリとして参照できるようにする方法です。
まず、簡単なコンテンツファイルとして次のような HTML ファイルを用意しておきます。
public/index.html &amp;lt;html&amp;gt;Hello&amp;lt;/html&amp;gt; あとは、docker container run コマンドで nginx コンテナを起動するだけです。</description></item><item><title>Docker で Ansible の実行環境用のコンテナを作成する</title><link>https://maku.blog/p/euevcs8/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/euevcs8/</guid><description>何をするか？ Ansible の実行環境は Python がインストールされている環境であれば比較的簡単にインストールできますが、Docker の実行環境があれば、ホスト環境に何もインストールせずに Ansible の実行環境を手に入れることができます（もちろんコンテナは作る必要はありますが）。
Docker Hub を見ると、Alpine Linux ベースの Ansible 実行環境用イメージ alpine/ansible があるようですが、ここでは Dockerfile を使って自分でイメージを作成することにします。
Ansible 実行環境用イメージを作成する Dockerfile で Alpine Linux ベースの Ansible 実行環境を定義します。
Dockerfile FROMalpine:3WORKDIR/app# --no-cache を付けることで /var/cache/apk 以下にキャッシュが残るのを防ぐ# --update-cache を付けることで先に apk update するのと同じ効果になるRUN apk --no-cache --update-cache add ansible openssh sshpass APK (Alpine Package Keeper) で次のようなパッケージをインストールしています。
ansible &amp;hellip; Ansible Community パッケージ（ansible コマンドや ansible-playbook コマンドなど） openssh &amp;hellip; ssh コマンドのため sshpass &amp;hellip; ターゲットホストにパスワード認証 (--ask-pass) で接続するときのため Ansible Community パッケージ (ansible) ではなく、Ansible Core (ansible-core) を使うようにすれば、イメージサイズは 500MB 弱から 80MB 程度に削減できますが、サイズを気にしなくてよいなら Ansible Community パッケージを使っておいた方が楽です。</description></item></channel></rss>