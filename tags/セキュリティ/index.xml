<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>セキュリティ on まくろぐ</title><link>https://maku.blog/tags/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/</link><description>Recent content in セキュリティ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 09 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>各種 Linux のファイアウォール設定ツール</title><link>https://maku.blog/p/ceow5cj/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ceow5cj/</guid><description>従来 Linux のパケットフィルタリングの設定には、iptables が使われていましたが、現在ではより直感的な操作が可能な ufw、firewalld、nftables といったツールが使われています。
ディストリビューション ファイアウォール設定ツール Ubuntu 8.04 LTS 以降 ufw CentOS 7 以降 firewalld Fedora 18 以降 firewalld Rocky Linux firewalld および nftables 参考: ufw (Uncomplicated Firewall) によるファイアウォール設定 参考: firewalld によるファイアウォール設定 どのツールも下回りとしては Linux カーネルの Netfilter サブシステムの仕組みを利用しています。
ufw ---+ | firewalld ---+---&amp;gt; Netfilter (Linux kernel) | iptables ---+</description></item><item><title>Linuxメモ: firewalld による Linux のファイアウォール設定</title><link>https://maku.blog/p/ij6kxeq/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ij6kxeq/</guid><description>Red Hat 系 Linux のネットワークのアクセス制御には、従来 iptables が用いられていましたが、現在は firewalld に置き換えられています。 Fedora 18 や CentOS 7、および CentOS の後継的な位置付けの Rocky Linux 8、AlmaLinux 8 には firewalld が標準搭載されています（nftables というのもあります）。
CentOS 6 の頃は iptables が使われていました。 iptables のルールは /etc/sysconfig/iptables というファイルに保存され、システム再起動時にはこのファイルから設定を復帰させるという動作をしていました。 iptables はコマンド体系が煩雑すぎるという問題があり、より直感的な設定が可能な firewalld が作成されました。 firewalld では「一時的な」ルール設定などにも対応しています。
ファイアウォールの設定ツールは変化してきていますが、下回りとして Linux カーネルの Netfilter (netfilter firewall) が使用されていることに変わりはありません。
firewalld のインストール apt でのインストール $ sudo apt install firewalld firewalld の使い方 firewalld の起動・停止と自動起動設定 firewalld は、systemd のサービスとして自動起動できます。
$ systemctl status firewalld # 現在の状態を確認 $ systemctl start firewalld # 直ちに firewalld を起動 $ systemctl stop firewalld # 直ちに firewalld を停止 $ systemctl enable firewalld # 自動起動する $ systemctl disable firewalld # 自動起動しない firewalld の設定を確認する $ firewall-cmd --list-all firewalld の設定を変更する firewalld で HTTP 通信を許可するには次のようにします。</description></item><item><title>Linux コマンド: ufw による Ubuntu のファイアウォール設定</title><link>https://maku.blog/p/drar8o4/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/drar8o4/</guid><description>ufw とは ufw (Uncomplicated Firewall) は Debian/Ubuntu 系 Linux でパケットフィルタリングの設定（ファイアウォール設定）を行うためのツールです。 従来、パケットフィルタリングのツールとしては iptables が使われていましたが、iptables は設定が煩雑で扱いづらいという問題を抱えていたため、直感的な設定を行うためのツールとして ufw が開発されました。 ufw は Ubuntu 8.04 LTS 以降で使用することができます。
ufw のサブコマンド 通常コマンド コマンド 説明 ufw enable enables the firewall ufw disable disables the firewall ufw default ARG set default policy ufw logging LEVEL set logging to LEVEL ufw allow ARGS add allow rule ufw deny ARGS add deny rule ufw reject ARGS add reject rule ufw limit ARGS add limit rule ufw delete RULE|NUM delete RULE ufw insert NUM RULE insert RULE at NUM ufw prepend RULE prepend RULE ufw route RULE add route RULE `ufw route delete RULE NUM` ufw route insert NUM RULE insert route RULE at NUM ufw reload reload firewall ufw reset reset firewall ufw status show firewall status ufw status numbered show firewall status as numbered list of RULES ufw status verbose show verbose firewall status ufw show ARG show firewall report ufw version display version information アプリケーションプロファイル コマンド 説明 ufw app list list application profiles ufw app info PROFILE show information on PROFILE ufw app update PROFILE update PROFILE ufw app default ARG set default application policy ufw の基本的な使い方 ufw で現在の設定を確認する (ufw status) $ sudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) 1 行目の表示で、ufw によるファイアウォールが有効 (Status: active) になっているか、無効 (Status: inactive) になっているかを確認することができます。</description></item><item><title>電子署名と電子証明書の基礎</title><link>https://maku.blog/p/fzwyf7z/</link><pubDate>Fri, 28 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fzwyf7z/</guid><description>電子署名（デジタル署名）(digital signature) 「電子署名」とは、データに付加され、そのデータが本当に作成者が作ったのかを確認するためのものです。 別の言い方をすると、受け取ったデータが第三者によって作られた偽物でないことを確認するための印です。
以下のような手順で、データが偽物でないか確認します。
データ送信側の「電子署名の作成」手順 送信するデータのメッセージダイジェストを求める。 メッセージダイジェストを非公開鍵 (private key) で暗号化し、「電子署名」とする。 データ受信側の「電子署名の確認」手順 受信した「データ」のメッセージダイジェストを求める。 受信した「電子署名」を「送信者の公開鍵」で復号化し、メッセージダイジェストに戻す。 1 と 2 のメッセージダイジェストが等しければ、本人が作成したデータだと分かる。 上記の手順からも分かるように、一般的に「電子署名」の仕組みには、公開鍵暗号方式が用いられます。 問題は、公開鍵 (public key) が偽物である場合に、なりすましができてしまうことです。 そこで、公開鍵が本物であるかを証明するための、「電子証明書」が必要になってきます。
電子証明書（デジタル証明書) (digital certificate) 電子証明書とは？ 公開鍵が偽物であると、公開鍵暗号方式は意味をなさなくなるため、公開鍵の正当性を証明することが重要になってきます。 電子証明書は、ある公開鍵が本物であることを証明するためのものです。
電子証明書は、一般的には、ITU-T X.509 の標準フォーマット（拡張子 .cer）で作成されます。 X.509 で作成された電子証明書ファイル (.cer) には、公開鍵そのものに加え、公開鍵の作成者（証明書の申請者）の情報、有効期限などが含まれています。
電子証明書の発行 電子証明書は、公開鍵が本物であることを示すためのものですが、その電子証明書自体が本物であることを示すために、末尾に電子署名が付加されます。 その署名は、公開鍵を作成したユーザが行うこともあるし、信頼のおける第三者が行うこともあります。 通常は、信頼のおける第三者機関である認証局 (CA: Certificate Authority) が電子証明書への署名を行い、電子証明書の発行を行います。
電子証明書 (X.509) の構成 電子証明書は、下記のようなデータで構成されています。
+------------------------------------+---------------------------------+ | 公開鍵 + 作成者情報 + 有効期限など | ← これが本物だと示す CA の署名 | +------------------------------------+---------------------------------+ 認証局による電子証明書の発行の流れ 公開鍵の作成者が、身元情報と公開鍵を CA（認証局）へ提出する。 CA は 1 の情報を厳密に審査し、電子証明書（X.</description></item><item><title>暗号技術まとめ</title><link>https://maku.blog/p/6rn67mc/</link><pubDate>Tue, 20 Dec 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6rn67mc/</guid><description>昔の暗号 シーザー暗号 - 文字をずらすだけの最も古い暗号。ジュリアス・シーザー（ユリウス・カエサル）が作った。 共通鍵暗号 ブロック暗号 ブロック暗号というのは、共通鍵暗号の一種。 データを一定のブロックごとに暗号化する方式。 高速な暗号化処理を行える。
Triple DES - 1990年代。64 bit のブロック暗号 DES を 3 回繰り返す暗号化アルゴリズム。かつては米国政府標準暗号だった。 MISTY1 - 1990年代。三菱電機が開発した 128 bit 暗号鍵を持つ 64 bit ブロック暗号アルゴリズム。 CAST-128 - 64 bit ブロック暗号。 Camellia - 2000年代。128 bit ブロック暗号。NTT・三菱電機。 AES: Advanced Encryption Standard - 2000年代。128 bit ブロック暗号。 SEED - 128 bit ブロック暗号。 国際標準のブロック暗号 (ISO/IEC18033-3) は、Camellia、AES、SEED、CAST-128、MISTY1、Triple DES。
ストリーム暗号 MUGI MULTI-S01 SNOW 国際標準のストリーム暗号 (ISO/IEC18033-4) は、MUGI、MULTI-S01、SNOW。
公開鍵暗号 RSA RSA: Rivest - Shamir - Adleman - 大きな素数の素因数分解が難しいという根拠に基づいた暗号方式。 楕円曲線暗号 楕円曲線状での離散対数問題に基づいた公開鍵暗号方式。</description></item><item><title>HMAC-SHA256 コードを生成する</title><link>https://maku.blog/p/uqhbb5p/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uqhbb5p/</guid><description>Python で HMAC-SHA256 を生成する 下記の siggen.py スクリプトは、コマンドライン引数で渡された「秘密鍵テキスト」と「メッセージ」をもとに HMAC (Hash-based Message Authentication Code) 署名を生成します。
siggen.py import sys import hashlib import hmac def usage(): print(&amp;#39;python &amp;#39; + sys.argv[0] + &amp;#39; &amp;lt;key&amp;gt; &amp;lt;message&amp;gt;&amp;#39;) sys.exit(-1) if __name__ == &amp;#39;__main__&amp;#39;: if len(sys.argv) &amp;lt; 3: usage() key = sys.argv[1] msg = sys.argv[2] sig = hmac.new(key.encode(&amp;#39;ascii&amp;#39;), msg.encode(&amp;#39;ascii&amp;#39;), hashlib.sha256) print(sig.hexdigest()) 使用例 $ python siggen.py &amp;#39;SecretKey&amp;#39; &amp;#39;YourMessage&amp;#39; 8aff2951003c218bd26ee43c99e30527a0c30e06042008a60935ef1ab28891ec ここでは、SHA256 ハッシュ関数を使用していますが (HMAC-SHA256)、hashlib.sha256 の部分を変更すれば、他のハッシュ関数を適用することができます。
openssl コマンドで HMAC-SHA256 を生成する Linux や macOS などの、openssl コマンドを使用できる環境では、下記のようにして簡単に HMAC-SHA256 を求めることができます。</description></item></channel></rss>