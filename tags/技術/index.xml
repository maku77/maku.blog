<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技術 on まくろぐ</title><link>https://maku.blog/tags/%E6%8A%80%E8%A1%93/</link><description>Recent content in 技術 on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 08 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/%E6%8A%80%E8%A1%93/index.xml" rel="self" type="application/rss+xml"/><item><title>よいチャットボットとは？ボットを作成するときのベストプラクティス</title><link>https://maku.blog/p/o2nq2qa/</link><pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2nq2qa/</guid><description>とある事情によりチャットボットを作ろうという話になっています。 まずは、チャットボットってどんなことに気を付けて作ればよいかを調べたので、ポイントになりそうなことをまとめておきます。
下記の Microsoft が提供している Bot Framework のドキュメントがとても参考になりました。
参考: Principles of bot design - Bot Service | Microsoft Docs
チャットボットの知識は、今流行りのスマートスピーカー（Amazon Alexa や Google Home）などのスキルを作成する際にも応用がききそうです。 音声入力による会話は、チャットの特殊形態（キーボードやモニタがないときの手段）と考えることができるので、チャットボットの基本原則を押さえておくことはきっと参考になります。
チャットボットが目指すべきこと こだわるべき事 少ないステップで簡単に問題を解決できること 他の手段よりもチャットボットを使ったほうが速く、簡単で、よりよい結果を得られること ユーザが**使いたい環境（クライアント）**で動作すること ユーザがボットの存在に気付けること。それを使って何をすればよいのか気付けること 何より大切なのはユーザーエクスペリエンスです。 めっちゃ賢い AI を使っているかどうかではなく、ユーザがやりたいことを素早く、簡単に行えるかが重要です。
こだわらなくてよい事 機械学習は必須ではない。めっちゃ賢いボットは必須ではない。 完璧に自然言語を理解して会話できる必要はない。 ボイス対応により必ず UX が改善されるわけではない。ボイスを嫌うユーザはいるし、ノイズの多い環境では使えない。 大切なのは技術力とかクールさとかではなく、ユーザのやりたいことができることです。
最初の挨拶は「自然言語」か「メニュー選択」か？ どんな話しかけにも反応できるボットは存在しません（少なくとも現在は）。 ユーザは、ボットが何をできるのか知らないので、できることの選択肢を表示してあげるとよいです。
選択肢が少なければボタンを並べて、それを押すだけで会話を進められるようにすると、ユーザの入力の手間を大幅に削減することができます。 できることがたくさんあるのであれば、選択肢として「ヘルプ」ボタンを配置して、より詳しい使い方を提示してあげましょう。
図: 最初のメッセージの例 一般的に、自由回答形式の質問 (open-ended question) はユーザーの返答を予測できないので、選択回答形式の質問 (closed-ended question) を使用した方がボットの設計者にとっても望ましいといえます。 見栄を張ってどんな会話でもできる賢いボットを作ろうとするのではなく、できることを明確に示して上げたほうがユーザにとっても使いやすいボットができるでしょう。
プライバシーポリシーの表示 ユーザが「個人情報保護に関する方針と利用規約」(Privacy policy and terms of use) にアクセスできるようにしておくのが望ましいです。 特に、チャットボットサービスを介して個人情報を収集するのであれば、このような表示は必須になります。
会話 (Dialog) のスタック構造という罠 チャットボットのフレームワーク内部では、会話の流れは Dialog（会話）といった単位で管理されます。 一般的に、ユーザとの会話は、GUI アプリケーションのウィンドウと同様に、Dialog（会話）のスタック構造で管理されます。 つまり、ウィンドウを開いたり閉じたりするのと同様に、次の会話内容へ進んだり、前の会話内容へ戻ったりします。</description></item><item><title>ソフトウェアアーキテクトが考えること</title><link>https://maku.blog/p/x2b2gw3/</link><pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x2b2gw3/</guid><description>ソフトウェアアーキテクチャとは アーキテクチャとは「要求と設計の橋渡し」である ─『オブジェクト開発の神髄』より
外部から見える特性 構成要素 構成要素間の関係 アーキテクトが考えること 何をもとにシステムを設計するか 部品をどのように組み立てるか システムをどのように動作保証するか パフォーマンス アーキテクチャドライバとは アーキテクチャを決定する要件のことを「アーキテクチャドライバ」といいます。 つまり、アーキテクチャドライバはアーキテクチャ設計のためのインプットとなります。 アーキテクチャドライバには以下の３つの要素があります。
制約（最重要。変更できないものだから） ビジネス制約 技術制約 品質特性 Performance 性能 Modifiability 変更容易性 Usability ユーザビリティ Availability 可用性 Security セキュリティ Testability テスト容易性 主な機能要件（重要性としては一番低い。ほとんどの場合、制約にかかわらず実現できるので） アーキテクチャドライバはステークホルダーとのコミュニケーションの道具であり、このアーキテクチャドライバの作成（文章作成）を行うのがアーキテクトの最初の仕事です。
アーキテクチャ設計のステップ アーキテクチャ要件抽出 アーキテクチャドライバの作成（要求を要件として分類する。上の３つの要素） ステークホルダーと仕様優先度レビュー アーキテクチャドライバに基づくシステムの分割 ソフトウェアアーキテクチャレビュー アーキテクチャドキュメント ソフトウェアは様々な視点で捉えられ、これをビュー (View) と呼びます。 アーキテクチャドキュメントはビューの集合と相互作用の説明で構成されます。
アーキテクトが作成すべき図の例 パッケージ図 パッケージ間の依存関係 それぞれのパッケージに何が配置されるか ソースコードやライブラリの物理構造 コンポーネント図 配置図 物理的なハードウェアやソフトウェアの配置 実行環境を表すノードとの接続関係など アーキテクチャパターン アーキテクチャパターンとは、「アーキテクチャの要素と要素間の関係を使い方の制約と共に特定したもの」です。 ─出展『Principles of software architecture』。
様々なアーキテクチャパターンが提唱されており、GOF のデザインパターンとは違い統一された解釈は存在しません。
Shaw and Garlan &amp;ldquo;Software Architecture&amp;rdquo; ― Shaw と Garlan のリスト Buschmann et al.</description></item><item><title>ソフトウェアテストに関するリンク</title><link>https://maku.blog/p/6f8k3ns/</link><pubDate>Mon, 25 Mar 2013 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6f8k3ns/</guid><description> ソフトウェアテスト標準用語集 2012-04-01 時点で Version 2.1</description></item><item><title>HTTP ヘッダに関するメモ</title><link>https://maku.blog/p/3kkchub/</link><pubDate>Sat, 15 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3kkchub/</guid><description>HTTP1.1 Host 指定 HTTP1.1 では、メッセージヘッダーに Host: &amp;lt;ドメイン&amp;gt; の指定が必須です（これが唯一の必須ヘッダーです）。 これは、1 台の Web サーバーで複数のドメインを運用する、バーチャルホストの機能を実現するために必要とされています。 Web サーバーは、Host ヘッダーで示されたドメイン名と、相対 URI (/index.html など）を組み合わせて、実際のどのリソースを返すかを判断します。 HTTP1.0 を使う場合は、Host: の指定は必要ありません。
HTTP キープアライブ HTTP1.1 では、最初にスリーウェイハンドシェイクしたら、そのコネクションを一定時間使い続けることで、複数のリソースファイルの取得を効率化しています。 これを HTTP キープアライブ (KeepAlive) といい、HTTP1.1 では標準の振る舞いになっています（HTTP ヘッダーに Connection: keep-alive が付いていると考えるが規定の動作)。 例えば、ブラウザで Web ページを開くと、HTML ファイルだけではなく、CSS ファイルや画像ファイルなどのリソースを取得するために複数のリクエストが発行されますが、そこでは同じコネクションが使用されます。
コネクションの切断は、サーバーが設定しているタイムアウト時間を過ぎたときに行われますが、クライアントあるいはサーバーが Connection: close ヘッダーを含めることで、切断する意志を伝えることができます。
プロキシ経由時の「リクエスト行」の URI について プロキシサーバを介する場合は、リクエスト行に 絶対アドレス指定 で URI を指定する必要があります。 これは、リクエストを受け取ったプロキシサーバが、リクエストの転送先サーバを判断するためです。 逆に、プロキシを使わない場合は、リクエスト URI は相対パスで指定します。
Client ｜ ｜ GET http://target.example.com/index.html HTTP/1.1 ▽ Proxy server ｜ ｜ GET /index.html HTTP/1.1 ▽ target.</description></item><item><title>電子署名と電子証明書の基礎</title><link>https://maku.blog/p/fzwyf7z/</link><pubDate>Fri, 28 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fzwyf7z/</guid><description>電子署名（デジタル署名）(digital signature) 「電子署名」とは、データに付加され、そのデータが本当に作成者が作ったのかを確認するためのものです。 別の言い方をすると、受け取ったデータが第三者によって作られた偽物でないことを確認するための印です。
以下のような手順で、データが偽物でないか確認します。
データ送信側の「電子署名の作成」手順 送信するデータのメッセージダイジェストを求める。 メッセージダイジェストを非公開鍵 (private key) で暗号化し、「電子署名」とする。 データ受信側の「電子署名の確認」手順 受信した「データ」のメッセージダイジェストを求める。 受信した「電子署名」を「送信者の公開鍵」で復号化し、メッセージダイジェストに戻す。 1 と 2 のメッセージダイジェストが等しければ、本人が作成したデータだと分かる。 上記の手順からも分かるように、一般的に「電子署名」の仕組みには、公開鍵暗号方式が用いられます。 問題は、公開鍵 (public key) が偽物である場合に、なりすましができてしまうことです。 そこで、公開鍵が本物であるかを証明するための、「電子証明書」が必要になってきます。
電子証明書（デジタル証明書) (digital certificate) 電子証明書とは？ 公開鍵が偽物であると、公開鍵暗号方式は意味をなさなくなるため、公開鍵の正当性を証明することが重要になってきます。 電子証明書は、ある公開鍵が本物であることを証明するためのものです。
電子証明書は、一般的には、ITU-T X.509 の標準フォーマット（拡張子 .cer）で作成されます。 X.509 で作成された電子証明書ファイル (.cer) には、公開鍵そのものに加え、公開鍵の作成者（証明書の申請者）の情報、有効期限などが含まれています。
電子証明書の発行 電子証明書は、公開鍵が本物であることを示すためのものですが、その電子証明書自体が本物であることを示すために、末尾に電子署名が付加されます。 その署名は、公開鍵を作成したユーザが行うこともあるし、信頼のおける第三者が行うこともあります。 通常は、信頼のおける第三者機関である認証局 (CA: Certificate Authority) が電子証明書への署名を行い、電子証明書の発行を行います。
電子証明書 (X.509) の構成 電子証明書は、下記のようなデータで構成されています。
+------------------------------------+---------------------------------+ | 公開鍵 + 作成者情報 + 有効期限など | ← これが本物だと示す CA の署名 | +------------------------------------+---------------------------------+ 認証局による電子証明書の発行の流れ 公開鍵の作成者が、身元情報と公開鍵を CA（認証局）へ提出する。 CA は 1 の情報を厳密に審査し、電子証明書（X.</description></item><item><title>CPU のアーキテクチャ名と CPU 名の対応表</title><link>https://maku.blog/p/v7bxgmn/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/v7bxgmn/</guid><description>Intel 系 CPU アーキテクチャ名 CPU名 i386 80386 i486 80486 i586 Pentium, MMX Pentium i686 Pentium Pro, Pentium II, Pentium III, Pentium 4 athlon Athlon, Athlon MP, Athlon XP x86_64 Opteron, Athlon64, Xeon (EM64T), Core, Core2Duo メモ x86 (IA-32) Intel 社の 8086 系のプロセッサの略称。（binary hacks より） x86_64 (AMD64) AMD が設計した x86 上位互換の 64 ビットプロセッサのアーキテクチャ。（binary hacks より）</description></item><item><title>暗号技術まとめ</title><link>https://maku.blog/p/6rn67mc/</link><pubDate>Tue, 20 Dec 2005 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6rn67mc/</guid><description>暗号技術についてのメモです。
共通鍵暗号 ブロック暗号 ブロック暗号というのは、共通鍵暗号の一種。 データを一定のブロックごとに暗号化する方式。 高速な暗号化処理を行える。
Triple DES - 1990年代。64 bit のブロック暗号 DES を 3 回繰り返す暗号化アルゴリズム。かつては米国政府標準暗号だった。 MISTY1 - 1990年代。三菱電機が開発した 128 bit 暗号鍵を持つ 64 bit ブロック暗号アルゴリズム。 CAST-128 - 64 bit ブロック暗号。 Camellia - 2000年代。128 bit ブロック暗号。NTT・三菱電機。 AES: Advanced Encryption Standard - 2000年代。128 bit ブロック暗号。 SEED - 128 bit ブロック暗号。 国際標準のブロック暗号 (ISO/IEC18033-3) は、Camellia、AES、SEED、CAST-128、MISTY1、Triple DES。
ストリーム暗号 MUGI MULTI-S01 SNOW 国際標準のストリーム暗号 (ISO/IEC18033-4) は、MUGI、MULTI-S01、SNOW。
公開鍵暗号 RSA RSA: Rivest - Shamir - Adleman - 大きな素数の素因数分解が難しいという根拠に基づいた暗号方式。 楕円曲線暗号 楕円曲線状での離散対数問題に基づいた公開鍵暗号方式。</description></item><item><title>IETF によるプロトコル標準化の流れ</title><link>https://maku.blog/p/44o4a9p/</link><pubDate>Wed, 01 Oct 2003 00:00:00 +0000</pubDate><guid>https://maku.blog/p/44o4a9p/</guid><description>プロトタイプが普及する 独自バージョンが作られるようになる IETF (Internet Engineering Task Force) の援助で Working group が作られる Working group は「インターネットドラフト」としてプロトコルを文書化する IETF の IESG (Internet Engineering Steering Group) に提出する 実験期間を経て、IESG によって RFC 番号が割り当てられ、修正などをして「実験 RFC」として公表される 実際の運用によるテストを経て、IESG が「提案標準」として認定する IESG が「ドラフト標準」に推薦する プロトコルに STD 番号が割り当てられ、RFC に加えて STD となる 上記の流れで最低でも 10 ヵ月以上はかかる。</description></item></channel></rss>