<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技術 on まくろぐ</title><link>https://maku.blog/tags/%E6%8A%80%E8%A1%93/</link><description>Recent content in 技術 on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Fri, 08 Feb 2019 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/%E6%8A%80%E8%A1%93/index.xml" rel="self" type="application/rss+xml"/><item><title>よいチャットボットとは？ボットを作成するときのベストプラクティス</title><link>https://maku.blog/p/o2nq2qa/</link><pubDate>Fri, 08 Feb 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/o2nq2qa/</guid><description>&lt;p>とある事情によりチャットボットを作ろうという話になっています。
まずは、&lt;strong>チャットボットってどんなことに気を付けて作ればよいか&lt;/strong>を調べたので、ポイントになりそうなことをまとめておきます。&lt;/p>
&lt;p>下記の Microsoft が提供している Bot Framework のドキュメントがとても参考になりました。&lt;/p>
&lt;p>参考: &lt;a href="https://docs.microsoft.com/en-us/azure/bot-service/bot-service-design-principles?view=azure-bot-service-4.0">Principles of bot design - Bot Service | Microsoft Docs&lt;/a>&lt;/p>
&lt;p>チャットボットの知識は、今流行りのスマートスピーカー（Amazon Alexa や Google Home）などのスキルを作成する際にも応用がききそうです。
音声入力による会話は、チャットの特殊形態（キーボードやモニタがないときの手段）と考えることができるので、チャットボットの基本原則を押さえておくことはきっと参考になります。&lt;/p>
&lt;h2 id="チャットボットが目指すべきこと">チャットボットが目指すべきこと&lt;/h2>
&lt;h3 id="こだわるべき事">こだわるべき事&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>少ないステップ&lt;/strong>で簡単に問題を解決できること&lt;/li>
&lt;li>&lt;strong>他の手段よりも&lt;/strong>チャットボットを使ったほうが&lt;strong>速く、簡単で、よりよい結果&lt;/strong>を得られること&lt;/li>
&lt;li>ユーザが**使いたい環境（クライアント）**で動作すること&lt;/li>
&lt;li>ユーザがボットの&lt;strong>存在に気付ける&lt;/strong>こと。それを使って&lt;strong>何をすればよいのか気付ける&lt;/strong>こと&lt;/li>
&lt;/ol>
&lt;p>何より大切なのはユーザーエクスペリエンスです。
めっちゃ賢い AI を使っているかどうかではなく、ユーザがやりたいことを素早く、簡単に行えるかが重要です。&lt;/p>
&lt;h3 id="こだわらなくてよい事">こだわらなくてよい事&lt;/h3>
&lt;ol>
&lt;li>機械学習は必須ではない。めっちゃ賢いボットは必須ではない。&lt;/li>
&lt;li>完璧に自然言語を理解して会話できる必要はない。&lt;/li>
&lt;li>ボイス対応により必ず UX が改善されるわけではない。ボイスを嫌うユーザはいるし、ノイズの多い環境では使えない。&lt;/li>
&lt;/ol>
&lt;p>大切なのは技術力とかクールさとかではなく、ユーザのやりたいことができることです。&lt;/p>
&lt;h2 id="最初の挨拶は自然言語かメニュー選択か">最初の挨拶は「自然言語」か「メニュー選択」か？&lt;/h2>
&lt;p>どんな話しかけにも反応できるボットは存在しません（少なくとも現在は）。
ユーザは、ボットが何をできるのか知らないので、&lt;strong>できることの選択肢を表示してあげる&lt;/strong>とよいです。&lt;/p>
&lt;p>選択肢が少なければボタンを並べて、それを押すだけで会話を進められるようにすると、ユーザの入力の手間を大幅に削減することができます。
できることがたくさんあるのであれば、選択肢として「ヘルプ」ボタンを配置して、より詳しい使い方を提示してあげましょう。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="400" height="196" src="../../p/o2nq2qa/chatbot-menu_hu16396877291593138427.png" alt="/p/o2nq2qa/chatbot-menu.png" />
 &lt;figcaption>図: 最初のメッセージの例&lt;/figcaption>
&lt;/figure>

&lt;p>一般的に、自由回答形式の質問 (open-ended question) はユーザーの返答を予測できないので、&lt;strong>選択回答形式の質問 (closed-ended question)&lt;/strong> を使用した方がボットの設計者にとっても望ましいといえます。
見栄を張ってどんな会話でもできる賢いボットを作ろうとするのではなく、できることを明確に示して上げたほうがユーザにとっても使いやすいボットができるでしょう。&lt;/p>
&lt;h2 id="プライバシーポリシーの表示">プライバシーポリシーの表示&lt;/h2>
&lt;p>ユーザが「個人情報保護に関する方針と利用規約」(Privacy policy and terms of use) にアクセスできるようにしておくのが望ましいです。
特に、チャットボットサービスを介して個人情報を収集するのであれば、このような表示は必須になります。&lt;/p>
&lt;h2 id="会話-dialog-のスタック構造という罠">会話 (Dialog) のスタック構造という罠&lt;/h2>
&lt;p>チャットボットのフレームワーク内部では、会話の流れは Dialog（会話）といった単位で管理されます。
一般的に、ユーザとの会話は、GUI アプリケーションのウィンドウと同様に、Dialog（会話）のスタック構造で管理されます。
つまり、ウィンドウを開いたり閉じたりするのと同様に、次の会話内容へ進んだり、前の会話内容へ戻ったりします。&lt;/p></description></item><item><title>ソフトウェアアーキテクトが考えること</title><link>https://maku.blog/p/x2b2gw3/</link><pubDate>Tue, 21 Jul 2015 00:00:00 +0900</pubDate><guid>https://maku.blog/p/x2b2gw3/</guid><description>&lt;h2 id="ソフトウェアアーキテクチャとは">ソフトウェアアーキテクチャとは&lt;/h2>
&lt;p>アーキテクチャとは「&lt;strong>要求と設計の橋渡し&lt;/strong>」である ─『オブジェクト開発の神髄』より&lt;/p>
&lt;ul>
&lt;li>外部から見える特性&lt;/li>
&lt;li>構成要素&lt;/li>
&lt;li>構成要素間の関係&lt;/li>
&lt;/ul>
&lt;h3 id="アーキテクトが考えること">アーキテクトが考えること&lt;/h3>
&lt;ul>
&lt;li>何をもとにシステムを設計するか&lt;/li>
&lt;li>部品をどのように組み立てるか&lt;/li>
&lt;li>システムをどのように動作保証するか&lt;/li>
&lt;li>パフォーマンス&lt;/li>
&lt;/ul>
&lt;h2 id="アーキテクチャドライバとは">アーキテクチャドライバとは&lt;/h2>
&lt;p>アーキテクチャを決定する要件のことを「&lt;strong>アーキテクチャドライバ&lt;/strong>」といいます。
つまり、アーキテクチャドライバはアーキテクチャ設計のためのインプットとなります。
アーキテクチャドライバには以下の３つの要素があります。&lt;/p>
&lt;ul>
&lt;li>制約（最重要。変更できないものだから）
&lt;ul>
&lt;li>ビジネス制約&lt;/li>
&lt;li>技術制約&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>品質特性
&lt;ul>
&lt;li>Performance 性能&lt;/li>
&lt;li>Modifiability 変更容易性&lt;/li>
&lt;li>Usability ユーザビリティ&lt;/li>
&lt;li>Availability 可用性&lt;/li>
&lt;li>Security セキュリティ&lt;/li>
&lt;li>Testability テスト容易性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主な機能要件（重要性としては一番低い。ほとんどの場合、制約にかかわらず実現できるので）&lt;/li>
&lt;/ul>
&lt;p>アーキテクチャドライバはステークホルダーとのコミュニケーションの道具であり、このアーキテクチャドライバの作成（文章作成）を行うのがアーキテクトの最初の仕事です。&lt;/p>
&lt;h2 id="アーキテクチャ設計のステップ">アーキテクチャ設計のステップ&lt;/h2>
&lt;ol>
&lt;li>アーキテクチャ要件抽出
&lt;ol>
&lt;li>アーキテクチャドライバの作成（要求を要件として分類する。上の３つの要素）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ステークホルダーと仕様優先度レビュー&lt;/li>
&lt;li>アーキテクチャドライバに基づくシステムの分割&lt;/li>
&lt;li>ソフトウェアアーキテクチャレビュー&lt;/li>
&lt;/ol>
&lt;h2 id="アーキテクチャドキュメント">アーキテクチャドキュメント&lt;/h2>
&lt;p>ソフトウェアは様々な視点で捉えられ、これをビュー (View) と呼びます。
アーキテクチャドキュメントはビューの集合と相互作用の説明で構成されます。&lt;/p>
&lt;h3 id="アーキテクトが作成すべき図の例">アーキテクトが作成すべき図の例&lt;/h3>
&lt;ul>
&lt;li>パッケージ図
&lt;ul>
&lt;li>パッケージ間の依存関係&lt;/li>
&lt;li>それぞれのパッケージに何が配置されるか&lt;/li>
&lt;li>ソースコードやライブラリの物理構造&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コンポーネント図&lt;/li>
&lt;li>配置図
&lt;ul>
&lt;li>物理的なハードウェアやソフトウェアの配置&lt;/li>
&lt;li>実行環境を表すノードとの接続関係など&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="アーキテクチャパターン">アーキテクチャパターン&lt;/h2>
&lt;p>アーキテクチャパターンとは、「&lt;strong>アーキテクチャの要素と要素間の関係を使い方の制約と共に特定したもの&lt;/strong>」です。 ─出展『Principles of software architecture』。&lt;/p>
&lt;p>様々なアーキテクチャパターンが提唱されており、GOF のデザインパターンとは違い統一された解釈は存在しません。&lt;/p>
&lt;ul>
&lt;li>Shaw and Garlan "Software Architecture" ― &lt;b>Shaw と Garlan のリスト&lt;/b>&lt;/li>
&lt;li>Buschmann et al. "Pattern-oriented Software" ― &lt;b>Buschmann らのパターンシステム&lt;/b>&lt;/li>
&lt;li>Clements et al. "Documenting Software Architecture" ― &lt;b>CMU SEI のパターンカタログ&lt;/b>&lt;/li>
&lt;/ul>
&lt;p>パターンの説明を覚えるより、「ルール」や「どの品質特性に影響するのか」を理解することが重要です。
例えば、Layered Pattern に関しては、&lt;/p></description></item><item><title>ソフトウェアテストに関するリンク</title><link>https://maku.blog/p/6f8k3ns/</link><pubDate>Mon, 25 Mar 2013 00:00:00 +0900</pubDate><guid>https://maku.blog/p/6f8k3ns/</guid><description>&lt;ul>
&lt;li>&lt;a href="http://jstqb.jp/syllabus.html">ソフトウェアテスト標準用語集&lt;/a>
&lt;ul>
&lt;li>2012-04-01 時点で Version 2.1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>HTTP ヘッダに関するメモ</title><link>https://maku.blog/p/3kkchub/</link><pubDate>Sat, 15 Dec 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/3kkchub/</guid><description>&lt;h2 id="http11">HTTP1.1&lt;/h2>
&lt;h3 id="host-指定">Host 指定&lt;/h3>
&lt;p>HTTP1.1 では、メッセージヘッダーに &lt;strong>&lt;code>Host: &amp;lt;ドメイン&amp;gt;&lt;/code>&lt;/strong> の指定が必須です（これが唯一の必須ヘッダーです）。
これは、1 台の Web サーバーで複数のドメインを運用する、バーチャルホストの機能を実現するために必要とされています。
Web サーバーは、&lt;code>Host&lt;/code> ヘッダーで示されたドメイン名と、相対 URI (&lt;code>/index.html&lt;/code> など）を組み合わせて、実際のどのリソースを返すかを判断します。
HTTP1.0 を使う場合は、&lt;code>Host:&lt;/code> の指定は必要ありません。&lt;/p>
&lt;h3 id="http-キープアライブ">HTTP キープアライブ&lt;/h3>
&lt;p>HTTP1.1 では、最初にスリーウェイハンドシェイクしたら、そのコネクションを一定時間使い続けることで、複数のリソースファイルの取得を効率化しています。
これを HTTP キープアライブ (KeepAlive) といい、HTTP1.1 では標準の振る舞いになっています（HTTP ヘッダーに &lt;strong>&lt;code>Connection: keep-alive&lt;/code>&lt;/strong> が付いていると考えるが規定の動作)。
例えば、ブラウザで Web ページを開くと、HTML ファイルだけではなく、CSS ファイルや画像ファイルなどのリソースを取得するために複数のリクエストが発行されますが、そこでは同じコネクションが使用されます。&lt;/p>
&lt;p>コネクションの切断は、サーバーが設定しているタイムアウト時間を過ぎたときに行われますが、クライアントあるいはサーバーが &lt;strong>&lt;code>Connection: close&lt;/code>&lt;/strong> ヘッダーを含めることで、切断する意志を伝えることができます。&lt;/p>
&lt;h2 id="プロキシ経由時のリクエスト行の-uri-について">プロキシ経由時の「リクエスト行」の URI について&lt;/h2>
&lt;p>プロキシサーバを介する場合は、リクエスト行に &lt;strong>絶対アドレス指定&lt;/strong> で URI を指定する必要があります。
これは、リクエストを受け取ったプロキシサーバが、リクエストの転送先サーバを判断するためです。
逆に、プロキシを使わない場合は、リクエスト URI は相対パスで指定します。&lt;/p>
&lt;pre tabindex="0">&lt;code>Client
 ｜
 ｜ GET http://target.example.com/index.html HTTP/1.1
 ▽
Proxy server
 ｜
 ｜ GET /index.html HTTP/1.1
 ▽
target.example.com
&lt;/code>&lt;/pre>&lt;h2 id="http-のメッセージヘッダの種類">HTTP のメッセージヘッダの種類&lt;/h2>
&lt;p>HTTP のメッセージヘッダには、大きく分けて、&lt;/p></description></item><item><title>CPU のアーキテクチャ名と CPU 名の対応表</title><link>https://maku.blog/p/v7bxgmn/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0900</pubDate><guid>https://maku.blog/p/v7bxgmn/</guid><description>&lt;h2 id="intel-系-cpu">Intel 系 CPU&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>アーキテクチャ名&lt;/th>
 &lt;th>CPU名&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>i386&lt;/td>
 &lt;td>80386&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>i486&lt;/td>
 &lt;td>80486&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>i586&lt;/td>
 &lt;td>Pentium, MMX Pentium&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>i686&lt;/td>
 &lt;td>Pentium Pro, Pentium II, Pentium III, Pentium 4&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>athlon&lt;/td>
 &lt;td>Athlon, Athlon MP, Athlon XP&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>x86_64&lt;/td>
 &lt;td>Opteron, Athlon64, Xeon (EM64T), Core, Core2Duo&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="メモ">メモ&lt;/h2>
&lt;dl>
&lt;dt>x86 (IA-32)&lt;/dt>
&lt;dd>Intel 社の 8086 系のプロセッサの略称。（binary hacks より）&lt;/dd>
&lt;dt>x86_64 (AMD64)&lt;/dt>
&lt;dd>AMD が設計した x86 上位互換の 64 ビットプロセッサのアーキテクチャ。（binary hacks より）&lt;/dd>
&lt;/dl></description></item><item><title>暗号技術まとめ</title><link>https://maku.blog/p/6rn67mc/</link><pubDate>Tue, 20 Dec 2005 00:00:00 +0900</pubDate><guid>https://maku.blog/p/6rn67mc/</guid><description>&lt;p>暗号技術についてのメモです。&lt;/p>
&lt;h2 id="共通鍵暗号">共通鍵暗号&lt;/h2>
&lt;h3 id="ブロック暗号">ブロック暗号&lt;/h3>
&lt;p>ブロック暗号というのは、共通鍵暗号の一種。
データを一定のブロックごとに暗号化する方式。
高速な暗号化処理を行える。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Triple DES&lt;/strong> - 1990年代。64 bit のブロック暗号 DES を 3 回繰り返す暗号化アルゴリズム。かつては米国政府標準暗号だった。&lt;/li>
&lt;li>&lt;strong>MISTY1&lt;/strong> - 1990年代。三菱電機が開発した 128 bit 暗号鍵を持つ 64 bit ブロック暗号アルゴリズム。&lt;/li>
&lt;li>&lt;strong>CAST-128&lt;/strong> - 64 bit ブロック暗号。&lt;/li>
&lt;li>&lt;strong>Camellia&lt;/strong> - 2000年代。128 bit ブロック暗号。NTT・三菱電機。&lt;/li>
&lt;li>&lt;strong>AES: Advanced Encryption Standard&lt;/strong> - 2000年代。128 bit ブロック暗号。&lt;/li>
&lt;li>&lt;strong>SEED&lt;/strong> - 128 bit ブロック暗号。&lt;/li>
&lt;/ul>
&lt;p>国際標準のブロック暗号 (&lt;strong>ISO/IEC18033-3&lt;/strong>) は、Camellia、AES、SEED、CAST-128、MISTY1、Triple DES。&lt;/p>
&lt;h3 id="ストリーム暗号">ストリーム暗号&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>MUGI&lt;/strong>&lt;/li>
&lt;li>&lt;strong>MULTI-S01&lt;/strong>&lt;/li>
&lt;li>&lt;strong>SNOW&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>国際標準のストリーム暗号 (&lt;strong>ISO/IEC18033-4&lt;/strong>) は、MUGI、MULTI-S01、SNOW。&lt;/p>
&lt;h2 id="公開鍵暗号">公開鍵暗号&lt;/h2>
&lt;h3 id="rsa">RSA&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>RSA: Rivest - Shamir - Adleman&lt;/strong> - 大きな素数の素因数分解が難しいという根拠に基づいた暗号方式。&lt;/li>
&lt;/ul>
&lt;h3 id="楕円曲線暗号">楕円曲線暗号&lt;/h3>
&lt;p>楕円曲線状での離散対数問題に基づいた公開鍵暗号方式。&lt;/p></description></item><item><title>IETF によるプロトコル標準化の流れ</title><link>https://maku.blog/p/44o4a9p/</link><pubDate>Wed, 01 Oct 2003 00:00:00 +0900</pubDate><guid>https://maku.blog/p/44o4a9p/</guid><description>&lt;ol>
&lt;li>プロトタイプが普及する&lt;/li>
&lt;li>独自バージョンが作られるようになる&lt;/li>
&lt;li>IETF (Internet Engineering Task Force) の援助で Working group が作られる&lt;/li>
&lt;li>Working group は「インターネットドラフト」としてプロトコルを文書化する&lt;/li>
&lt;li>IETF の IESG (Internet Engineering Steering Group) に提出する&lt;/li>
&lt;li>実験期間を経て、IESG によって RFC 番号が割り当てられ、修正などをして「実験 RFC」として公表される&lt;/li>
&lt;li>実際の運用によるテストを経て、IESG が「提案標準」として認定する&lt;/li>
&lt;li>IESG が「ドラフト標準」に推薦する&lt;/li>
&lt;li>プロトコルに STD 番号が割り当てられ、RFC に加えて STD となる&lt;/li>
&lt;/ol>
&lt;p>上記の流れで最低でも 10 ヵ月以上はかかる。&lt;/p></description></item></channel></rss>