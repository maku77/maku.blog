<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on まくろぐ</title><link>https://maku.blog/tags/java/</link><description>Recent content in Java on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 13 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>ISO 639-2 (alpha-3) 言語コードから Java の Locale オブジェクトを生成する</title><link>https://maku.blog/p/jbs8o3h/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jbs8o3h/</guid><description>Locale クラスは ISO 639-2（3桁）の言語コードを受け付けるのか？ ISO 639-2 (alpha-3) では、言語を 3 桁のアルファベットで識別できるよう定義しています（例: 日本語は jpn）。 この言語識別子を使って、Java の Locale オブジェクトを生成できるのでしょうか？
Java の Locale クラス の説明には、次のように記載されています。
言語に alpha-2 コードと alpha-3 コードの両方がある場合は、alpha-2 コードを使用する必要があります。
また、Locale クラスのコンストラクタ の第 1 引数の説明には、次のように書かれています。
language - ISO 639 alpha-2 または alpha-3 言語コード、または最高 8 文字の言語のサブタグ。
実際に試してみると、alpha-2 コード（2桁）はほぼすべて対応しているのに対し、alpha-3 コード（3桁）は対応がいまいちのようです。
sample.kt fun main() { // alpha-2 で指定 println(Locale(&amp;#34;ja&amp;#34;).displayLanguage) // 日本語 (OK) println(Locale(&amp;#34;en&amp;#34;).displayLanguage) // 英語 (OK) println(Locale(&amp;#34;fr&amp;#34;).displayLanguage) // フランス語 (OK) println(Locale(&amp;#34;zh&amp;#34;).</description></item><item><title>Java/Kotlin で ISO 3166 国コードの一覧を取得する</title><link>https://maku.blog/p/5weufam/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5weufam/</guid><description>Locale クラスで国コードのリストを取得する Locale クラスの getISOCountries() メソッド を使用すると、ISO 3166 で定義されている国コードの一覧を取得することができます。
String[] Locale.getISOCountries() ISO3166-1 alpha-2（2桁のアルファベット） Set&amp;lt;String&amp;gt; Locale.getISOCountries(Locale.IsoCountryCode.PART1_ALPHA2) ISO3166-1 alpha-2（2桁のアルファベット） Set&amp;lt;String&amp;gt; Locale.getISOCountries(Locale.IsoCountryCode.PART1_ALPHA3) ISO3166-1 alpha-3（3桁のアルファベット） Set&amp;lt;String&amp;gt; Locale.getISOCountries(Locale.IsoCountryCode.PART3) ISO3166-3（4桁のアルファベット） サンプルコード 次の Kotlin コードでは、Locale.getISOCountries() で ISO3166-1 alpha-2 の国コードをすべて取得し、それぞれについて、2桁の国コード、3桁の国コード、国名を表示しています。 Try Kotlin のサイトにコピペして実行できます。
import java.util.Locale fun main() { for (alpha2 in Locale.getISOCountries()) { val loc = Locale(&amp;#34;dummylang&amp;#34;, alpha2) val alpha3 = loc.getISO3Country() val name = loc.</description></item><item><title>Java/Kotlin で ISO 639 言語コードの一覧を取得する</title><link>https://maku.blog/p/wjxanza/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wjxanza/</guid><description>Locale クラスで言語識別子のリストを取得する Locale クラスの getISOLanguages() メソッド を使用すると、ISO 639-1 alpha2 で定義されている 2 桁の言語識別子の一覧を取得することができます。
String[] Locale.getISOLanguages() サンプルコード 次の Kotlin コードでは、Locale.getISOLanguages() で ISO 639-1 alpha-2 の言語識別子をすべて取得し、それぞれについて、2桁の言語識別子、3桁の言語識別子 (ISO 639-2/T)、言語名を表示しています。 Try Kotlin のサイトにコピペして実行できます。
langcodes.kt import java.util.Locale fun main() { for (alpha2 in Locale.getISOLanguages()) { val loc = Locale(alpha2) val alpha3 = loc.getISO3Language() val name = loc.getDisplayLanguage() println(&amp;#34;$alpha2$alpha3$name&amp;#34;) } } 実行結果 aa aar Afar ab abk Abkhazian ae ave Avestan af afr Afrikaans ak aka Akan am amh Amharic .</description></item><item><title>国コードや言語コードのまとめ (ISO 3166, ISO 639)</title><link>https://maku.blog/p/tfs5gr3/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tfs5gr3/</guid><description>国コード ISO 3166-1 (country codes) ISO 3166-1 は、国を示すコードとして、短いアルファベットや数値を割り当てています。 日本では JIS X 0304 として標準化されています。
ISO 3166-1 alpha-2 : ラテン大文字 2 桁で国を表す（例: JP、US） ISO 3166-1 alpha-3 : ラテン大文字 3 桁で国を表す（例: JPN、USA） ISO 3166-1 numeric : 数字 3 桁で国を表す（例: 392、840） 下記は、これらの国コードの例です（ISO - Country Codes Collection より）。
Short name Alpha-2 code Alpha-3 code Numeric code JAPAN JP JPN 392 UNITED STATES OF AMERICA US USA 840 UNITED KINGDOM OF GREAT BRITAIN AND NORTHERN IRELAND GB GBR 826 CHINA CN CHN 156 ISO 3166-2 (country subdivision code) ISO 3166-2 では、国より細かい行政区画名（県や州）のコードを定義しています。</description></item><item><title>読書メモ『J2EE パターン』 Deepak Alur、John Crupi、Dan Malks</title><link>https://maku.blog/p/saanpfh/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>https://maku.blog/p/saanpfh/</guid><description>J2EE のパターンコレクションを示した本です。 有名な GoF のデザインパターンとは異なる、21 のパターンが紹介されています。 既存のプロジェクトにパターンを適用するにはリファクタリングが必要になりますが、その方法も示されています。
Grady Booch（Rational Software Corporation 主任研究員）のまえがき パターンに名前を付けることによって、新たな語彙を手に入れ、それまでは気付かなかったであろう方法でパターンを適用できるようになる。
慢性的に時間に余裕がないところでは、美しいソフトウェアはなかなか書けない。 しかし、適切なパターンを選んで適用すれば、システムにある程度の優雅さをもたらすことができる。
マイクロアーキテクチャとは マイクロアーキテクチャは、アプリケーションおよびシステムの構築に利用できるビルディングブロック。個々のパターンよりも抽象度が高く、複数のパターンをリンクさせ組み合わせて表現することができる。
第1章: パターンとJ2EE パターンの定義 パターンとは、特定の文脈、問題、および解決策の相関関係を表した、3要素から成る規則である。
─Christopher Alexander 『A Pattern Language』 パターンとは、「特定の文脈」、「その文脈において繰り返し発生する問題」、および「これらの問題を解決する特定のソフトウェア構造」の3要素の相関関係を表した規則である。
─Richard Gabriel『A Timeless Way of Hacking』 パターンとは、ある現実の文脈の中で有用であって、他の文脈の中でもおそらく有用であろうと思われるアイデアである。
─Martin Fowler『Analysis Patterns』 繰り返し発生する問題と、その解決策に関する知識を表現して伝えるには、パターンが理想的なツールである。 考慮事項、アイデア、メモなどの知識を公式に文書化して伝えることができるようになる。
第2章: プレゼンテーション層における設計上の考慮事項とバッドプラクティス この章では、ユーザセッションやクライアントアクセスの制限に関しての概要が述べられている。 プレゼンテーション層におけるバッドプラクティスがざっと羅列してあるが、特に目新しさは感じられない（コントローラーが肥大化したら他のオブジェクトに処理を委譲する、といった程度のことしか書いてない）。 第6章以降のパターンカタログの方を見ていくのがよい。
第3章: ビジネス層における設計上の考慮事項とバッドプラクティス ステートレスなセッションBeanであれば、Beanをプールしておいて、複数のクライアントで使いまわせる。 スケーラビリティの問題のほとんどは、ステートフルセッションBeanや、ステートレスセッションBeanの誤用によるものである。 スケーラビリティが必要なシステムでは、ステートレスセッションBeanを使用することがより実用的な設計戦略となり得る。 1回のメソッド呼び出しでサービスが完了するビジネスプロセス（非対話型ビジネスプロセス）を実装するには、ステートレスセッションBeanを使うとよい。
スケーラビリティの向上を狙って、どのようなケースでもステートレスセッションBeanを選択する設計者もいる。 しかし、こうした設計を行ったために、ネットワークトラフィックのオーバーヘッド、再構築時間、アクセス時間などが絡んできて、かえってスケーラビリティが低下してしまっては本末転倒である。</description></item><item><title>macOS で JAVA_HOME に設定すべきパスを調べる（java_home コマンド）</title><link>https://maku.blog/p/7jkgzd4/</link><pubDate>Sat, 19 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7jkgzd4/</guid><description>複数の JDK がインストールされている場合にバージョンを切り替えて java (javac) コマンドを使用するには、JAVA_HOME 環境変数を設定します。 JAVA_HOME に設定すべきパスは、java_home コマンドで調べることができます。 下記は、Apple の JDK1.6、Oracle の JDK1.8 がインストールされている場合の出力例です。
$ /usr/libexec/java_home -v 1.6 /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home $ /usr/libexec/java_home -v 1.8 /Library/Java/JavaVirtualMachines/jdk1.8.0_11.jdk/Contents/Home 普段使用する JDK バージョンは、下記のように .bash_profile で設定しておけばよいでしょう。
~/.bash_profile # JDK 1.6 を使用する場合 export JAVA_HOME=$(/usr/libexec/java_home -v 1.6) # JDK 1.8 を使用する場合（デフォルト） export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</description></item><item><title>JavaFX2 で CheckBox を ScrollPane に並べる</title><link>https://maku.blog/p/j6jv8iu/</link><pubDate>Mon, 10 Oct 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6jv8iu/</guid><description>Main.java import javafx.application.Application; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.control.CheckBox; import javafx.scene.layout.VBox; import javafx.scene.paint.Color; import javafx.stage.Stage; public class Main extends Application { public static void main(String[] args) { launch(args); } private Group createRootGroup() { CheckBox cb1 = new CheckBox(&amp;#34;First&amp;#34;); CheckBox cb2 = new CheckBox(&amp;#34;Second&amp;#34;); CheckBox cb3 = new CheckBox(&amp;#34;Third&amp;#34;); // Align vertically VBox vbox = new VBox(); vbox.setSpacing(10); vbox.getChildren().add(cb1); vbox.getChildren().add(cb2); vbox.getChildren().add(cb3); // Add to the root Group root = new Group(); root.</description></item><item><title>JavaFX2 で HelloWorld（ウィンドウの表示）</title><link>https://maku.blog/p/haq7myf/</link><pubDate>Mon, 10 Oct 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/haq7myf/</guid><description> Main.java import javafx.application.Application; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.paint.Color; import javafx.stage.Stage; public class Main extends Application { public static void main(String[] args) { launch(args); } @Override public void start(Stage primaryStage) { Group root = new Group(); Scene scene = new Scene(root, 400, 300, Color.GRAY); primaryStage.setScene(scene); primaryStage.show(); } }</description></item><item><title>読書メモ『Javaの鉄則』ピーター・ハガー</title><link>https://maku.blog/p/kojyx2x/</link><pubDate>Mon, 22 Nov 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kojyx2x/</guid><description>Javaの鉄則 ピーター・ハガー ピアソンエデュケーション 鉄則1 パラメータは参照渡しではなく値で渡される パラメータを参照渡しするという誤解がある。Java ではパラメータはすべて値渡しされる。オブジェクトをパラメータで渡す場合は、オブジェクトへの参照が値渡しされる。つまり、以下のようにしても呼び出し元のオブジェクトは変更されない。
public void doSomething(MyClass obj) { obj = new MyClass(); } 鉄則2 定数データおよび定数オブジェクトへの参照に final を使う final で定数を定義すると、別の場所での 代入 がエラーになる。
public class MyClass { private static final int mInt = 100; private static final Circle mCircle = new Circle(3.0); ... 例えば上記のように宣言されている場合、以下のような代入処理がエラーになる。
mInt = 200; // Error! mCircle = new Circle(5.0); // Error! オブジェクトの参照先の値は変更できることに注意。
mCircle.setRadius(6.0); // OK 鉄則3 非 static メソッドはデフォルトでオーバーライドできることを理解する メソッドを final で宣言すると、そのメソッドはサブクラスでオーバーライドできなくなる。 クラスを final で宣言すると、そのクラスはサブクラス化できなくなる。すべてのメソッドを暗黙のうちに final で宣言するのと同じ。 ▽メモ &amp;ndash; ユニットテストの書きやすさを考慮すると、final 宣言は実はあまり使うべきではない。参考：『レガシーコード改善ガイド』。</description></item></channel></rss>