<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Material-UI on まくろぐ</title><link>https://maku.blog/tags/material-ui/</link><description>Recent content in Material-UI on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 15 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/material-ui/index.xml" rel="self" type="application/rss+xml"/><item><title>Next.js で Material-UI を使う</title><link>https://maku.blog/p/s6djqw3/</link><pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s6djqw3/</guid><description>Material-UI は、マテリアルデザインを提供する React コンポーネントライブラリです。
Material-UI のインストール Material-UI のコアパッケージ (@material-ui/core) は、npm コマンドで簡単にインストールできます。 マテリアルデザイン系のアイコン を使いたい場合は、@material-ui/icons パッケージもインストールしておきます。
### yarn の場合 $ yarn add @material-ui/core $ yarn add @material-ui/icons ### npm の場合 $ npm install @material-ui/core $ npm install @material-ui/icons Next.js の create-next-app コマンドでプロジェクトを作成済みであれば、これだけで Material-UI コンポーネントを使う準備は完了です。 Material-UI のデフォルトテーマは Roboto フォントを使用する ので、次のようなコードを head 要素内に記述する必要がありますが、これは後述の _document.tsx で設定します。
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;amp;display=swap&amp;#34; /&amp;gt; Material-UI は font weight に 300/400/500/700 のいずれかを使用するので、上記のように読み込むデータを制限することで、ロード時間を削減できます。
Material-UI のコンポーネントを使ってみる Material-UI のインストールができたら、あとは、各コンポーネントの実装ファイルから import するだけで使用できます。 次の例では、Button コンポーネントと、ButtonGroup コンポーネントを使っています。</description></item><item><title>Material-UI のコンポーネントに独自の CSS スタイルを設定する (makeStyle)</title><link>https://maku.blog/p/cw9ju6f/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cw9ju6f/</guid><description>Material-UI コンポーネントのスタイル設定 Material-UI が提供する各種コンポーネントには、表示スタイルを切り替えるためのプロパティが用意されています。 例えば、Button コンポーネント は variant や color プロパティで見た目を切り替えることができます。
&amp;lt;Button&amp;gt;Default&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;contained&amp;#34; color=&amp;#34;primary&amp;#34;&amp;gt;Primary&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;contained&amp;#34; color=&amp;#34;secondary&amp;#34;&amp;gt;Secondary&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;outlined&amp;#34; disabled&amp;gt;Disabled&amp;lt;/Button&amp;gt; 多くのケースでは、この仕組みで十分にスタイル設定できるのですが、デフォルトのスタイルから外れた表示をしたり、div 要素など Material-UI 以外のコンポーネントに対して独自の CSS を適用したいことがあります。 このような場合、コンポーネントの実装ファイル内に直接 CSS コードを記述してスタイルをカスタマイズできます（JavaScript 内に記述するので CSS-in-JS と呼びます）。 React の世界では色々な CSS 参照方法がありますが、Material-UI は次のような理由で CSS-in-JS な記述方法を採用しています。
現在のテーマ設定に基づいたスタイル設定を行える（例: 基準スペースの2倍のマージンを設定する） コンポーネントの props の値を使って動的にスタイル設定できる（例: &amp;lt;MyButton color=&amp;quot;vivid&amp;quot;&amp;gt; で派手な色のスタイルを設定する） フックによるスタイル設定 (makeStyle) Material-UI で、コンポーネントに独自スタイルを設定する方法としては、主に次の 3 種類の方法が用意されています。
Hook API makeStyle 関数で生成したフック関数をコンポーネント内で呼び出す方法。一番よく使われてる。 Styled components API 既存のコンポーネント (Button など）をラップする形で、スタイルを適用したコンポーネント（MyButton など）を作成する方法。 Higher-order component API Styled components に似てるけど、HoC の仕組みでスタイル設定したコンポーネントを作成する方法。ちょっとわかりにくい。 ここでは、一番メジャーで分かりやすい、フックを利用したスタイル設定方法を紹介します。 次の例では、Material-UI の Button コンポーネントに、独自の CSS スタイル（customButton クラス）を適用しています。</description></item><item><title>MUI (Material-UI) でカスタムコンポーネントに sx プロパティを渡せるようにする</title><link>https://maku.blog/p/5e4cikn/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5e4cikn/</guid><description>何をするか？ MUI (Material-UI) ver.5 以降では、各コンポーネントのスタイル設定に便利な sx props を使うことができます。
The sx prop - MUI MUI コンポーネントをラップするようなカスタムコンポーネントを作成するときは、カスタムコンポーネント経由で sx props を渡せるようにしておくと、利用するときにマージン設定などを簡単に行えて便利です。
実装例 下記は、sx props を渡せるようにした CustomButton コンポーネントの実装例です。 sx props の値は、MUI の Button コンポーネントにそのまま渡しています。 型情報として SxProps&amp;lt;Theme&amp;gt; を使うところがポイントです。
src/components/CustomButton.tsx import { FC, ReactNode } from &amp;#39;react&amp;#39; import Button from &amp;#39;@mui/material/Button&amp;#39; import { SxProps, Theme } from &amp;#39;@mui/material/styles&amp;#39; type Props = { children: ReactNode sx?: SxProps&amp;lt;Theme&amp;gt; } export const CustomButton: FC&amp;lt;Props&amp;gt; = ({ children, sx }) =&amp;gt; { return ( &amp;lt;Button variant=&amp;#34;contained&amp;#34; sx={sx}&amp;gt; {children} &amp;lt;/Button&amp;gt; ) } これで、次のように sx prop 流のマージン設定などを行えるようになります。</description></item><item><title>Next.js のページコンポーネントが Client と Server どちらで実行されているか調べる (isServer, isClient, NoSsr)</title><link>https://maku.blog/p/m7is4dn/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7is4dn/</guid><description>Next.js のページコンポネント (src/pages/*.tsx) の関数は、静的な HTML ファイルを生成するためにビルド時にも実行されます（参考: Next.js のプリレンダリング機能を使用する）。 従来の React による SPA アプリはクライアントサイド JavaScript でしか実行されないので、同じような感覚で実装していると振る舞いの違いでハマることがあります。 例えば、ページコンポーネントから次のように window オブジェクトを参照しようとすると、Next.js によるプリレンダリング時にエラーになります。 これは、window オブジェクトは、Web ブラウザ上で JavaScript を実行しているときにしか存在しないからです。
src/pages/hello.tsx import { FC } from &amp;#39;react&amp;#39; const HelloPage: FC = () =&amp;gt; { console.log(window.location) // ReferenceError: window is not defined return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; } 逆に言うと、実行時に window オブジェクトが存在しているかどうかを調べることによって、ページコンポーネント内のコードが、どのタイミングで実行されているかを判別できます。
const isClient = () =&amp;gt; typeof window !== &amp;#39;undefined&amp;#39; // const isServer = () =&amp;gt; typeof window === &amp;#39;undefined&amp;#39; const HelloPage: FC = () =&amp;gt; { if (isClient()) { console.</description></item><item><title>Next.js アプリでのリンク方法まとめ（Material-UI との連携なども） (next/link, next/router)</title><link>https://maku.blog/p/vgs4dnw/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dnw/</guid><description>アプリ内ページへのリンク（基本） // import Link from &amp;#39;next/link&amp;#39; &amp;lt;Link href=&amp;#34;/about&amp;#34;&amp;gt; &amp;lt;a&amp;gt;About us&amp;lt;/a&amp;gt; &amp;lt;/Link&amp;gt; pages/about.tsx ページコンポーネントが生成するページへのリンクになります。 リンクを &amp;lt;a&amp;gt; コンポーネントとして出力するために、上記のように子要素として明示的に &amp;lt;a&amp;gt; タグの記載が必要です。 &amp;lt;a&amp;gt; を省略しても、リンククリック時は JavaScript でハンドルされるので動作しますが、HTML 的には正しく &amp;lt;a&amp;gt; 要素を出力しておくべきです（SEO 的にも）。
replace オプション &amp;lt;Link href=&amp;#34;/about&amp;#34; replace&amp;gt; 上記のように replace オプションを指定すると、ページ遷移前の URL がブラウザの履歴に残りません（戻るキーで戻らなくなります）。
外部リンク https:// で始まる外部リンクを出力したい場合は、&amp;lt;a&amp;gt; コンポーネントをそのまま使用します。 next/link（や react-router) が提供する Link コンポーネントは、アプリ内のルーティング用なので使えません。 外部リンクを開く場合は、安全性のために一律で rel=&amp;quot;noopener noreferrer&amp;quot; を付けましょう。 リンククリック時に必ず別タブで開きたいときは、target=&amp;quot;_blank&amp;quot; を指定してください。
&amp;lt;a href=&amp;#34;https://example.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt; サイト名 &amp;lt;/a&amp;gt; Material-UI を採用したサイトの場合は、a の代わりに @material-ui/core/Link コンポーネントを使用することで、サイト内のデザインを統一することができます。 Link という名前のコンポーネントはいろいろなライブラリが提供しているので、下記のように別名 (MuiLink) を付けて使用すると混乱を防ぐことができます。</description></item></channel></rss>