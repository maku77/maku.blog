<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chatbot on まくろぐ</title><link>https://maku.blog/tags/chatbot/</link><description>Recent content in Chatbot on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 19 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/chatbot/index.xml" rel="self" type="application/rss+xml"/><item><title>チャットボット (1-1) Bot Builder SDK とは</title><link>https://maku.blog/p/tzaeb9x/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tzaeb9x/</guid><description>Microsoft の Azure は Chatbot サービスを作成する機能を提供しています。 Microsoft が提供している Bot Framework は、この Chatbot サービスを作成するとき、あるいは Chatbot を使用するクライアントを作成するときに使用するツール群（あるいは仕組み）やそれらを取り巻く環境の総称です。
Microsoft Bot Framework ボットのサーバを実装するためのライブラリは、Bot Builder SDK という名前で提供されています。 現状では、ボットは Node.js と .NET による開発が想定されているため、Bot Builder SDK も Node.js と .NET 用のものが提供されています（2019年3月現在、Python と Java 版が preview リリースされているようです）。
Bot Builder SDK (for Node.js) Bot Builder SDK (for .Net) Bot Builder サンプルコード集 Node.js と .NET のどちらを使って開発するかに迷ったら、非同期処理を前提にして設計されている Node.js 版を選択するのがよいでしょう。
Node.js の Bot Builder SDK は、NPM パッケージとして公開されているため、npm コマンドを使って簡単にインストールすることができます。</description></item><item><title>チャットボット (1-2) Bot Builder SDK で Echo ボットを作成する</title><link>https://maku.blog/p/you6q5r/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/you6q5r/</guid><description>ここでは、Microsoft の Bot Builder SDK を使ったボット作成のファーストステップとして、チャットクライアントから入力されたテキストをそのままオウム返しするだけの Echo ボットを作成します。 言語としては JavaScript (Node.js) を使用することにします。
ここで作成するのはボットの本体（サービス側）で、クライアントとしては Microsoft が提供している Bot Framework Emulator を使用します。
Bot Builder SDK をインストールする Node.js 版の Bot Builder SDK（botbuilder パッケージ）は、npm コマンドを使ってインストールすることができます。 パッケージの依存関係を管理するための package.json ファイルも、npm init コマンドで作成しておきます。
$ mkdir mybot $ cd mybot $ npm init -y $ npm install --save botbuilder@4.x Bot Service のインタフェースは REST API として提供することが定められているのですが、Bot Builder SDK には REST API サーバを作成する機能は含まれていません。 そこで、REST API サーバを作成するための restify パッケージも一緒にインストールしておきます（express などでも実装できると思いますが、リファレンス実装では restify が使用されています）。</description></item><item><title>チャットボット (2-1) Azure でボットをホストするための Web App Bot リソースを作成する</title><link>https://maku.blog/p/tttou4o/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tttou4o/</guid><description>Web App Bot リソースを作成する 作成したボットプログラムは、Azure 上の Web App Bot リソース上で動作させることができます。 このリソースのことを特にボットサービスと呼んだりします。
Azure ポータル にログインし、下記のように辿ることで Web App Bot リソースの作成画面を表示できます。
＋リソースの作成 AI + Machine Learning Web App Bot 下記のような Web App Bot リソースの設定画面が表示されるので、1 つずつ入力していきます。
ボット名 任意のボット名称。後から自由に変更することができるので、自分のわかりやすい名前を付けておけば OK です。例: maku-bot サブスクリプション 月額の請求先となるサブスクリプションを選択します。最初の Azure トライアル期間であれば、Free Trial などを選択できるはずです。 リソースグループ この Web App Bot リソースを所属させるリソースグループを選択します。存在しない場合は 新規作成 のリンクをクリックして新しく作成します。 場所 リソースグループの場所を選択。ここでは、地理的に近い Japan East を選択してます。 価格レベル チャンネルに応じたメッセージ制限解除のためのプラン設定です。 スタンダードチャンネル（Skype、Cortana、Teams、Facebook、Slack などの一般的なクライアント）とのやりとりは無制限なので、通常は F0 の無料プランを選択しておけば OK です。 一方で、プレミアムチャンネル（ユーザ独自のチャンネルや、Web ページ埋め込みチャットボットなど）と多くのメッセージをやりとりする予定がある場合は、有料の S1 プランを選択する必要があります。 無料の F0 だと 1 か月に 10,000 メッセージまでの制限があります。 （参考: Standard channels と Premium channels について） アプリ名 ボットサービスのエンドポイント URL となる XXX.</description></item><item><title>チャットボット (2-2) Web App Bot で生成されたボットのコードを編集する</title><link>https://maku.blog/p/bpqkm2o/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bpqkm2o/</guid><description>チャットボットのソースコードをダウンロードする 下記のページの手順に従い、Azure ポータル上で Web App Bot のリソースを作成すると、自動的に Echo Bot のテンプレートコードが生成されているはずです（選択したテンプレートの種類によって変わりますが、ここでは Node.js 版の Echo Bot テンプレートを指定しているとします）。
Azure でボットをホストするための Web App Bot リソースを作成する ボットプログラムを作成する場合は、基本的にはこのテンプレートコードをベースにして修正を行っていくのがよいでしょう。 自動生成されたコードは、Azure ポータルから下記のように辿ると ZIP アーカイブでダウロードすることができます。
すべてのリソース を選択 対象の Web アプリボット リソースを選択（下記の例では maku-bot） ボット管理 の ビルド を選択 ボットのソースコードをダウンロードする のボタンをクリック 図: ボットコードをダウンロード bot ファイルの復号化・暗号化 botFileSecret とは ダウンロードした ZIP アーカイブの中には、ボットサーバの設定ファイルである .bot ファイルが含まれています。
このファイルは、ローカルでボットサーバを立ち上げたり、エミュレータからそのサーバに接続するときの設定ファイルとして使用するのですが、自動生成された .bot ファイルは、接続情報などの値が暗号化されています。 .bot ファイルの復号化、および暗号化に使用されているキーのことを botFileSecret と呼びます。
ボットサーバやエミュレータを正しく起動するためには、この botFileSecret を使って .bot ファイルをあらかじめ復号化しておくか、環境変数などでキーを設定しておく必要があります。
.bot ファイルを復号化した場合は、Azure 上の Web App Bot サービスにデプロイする前に、忘れずに暗号化しておく必要があります。</description></item><item><title>チャットボット (2-3) Azure の Web App Bot リソースにボットをデプロイする</title><link>https://maku.blog/p/gxm9shf/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gxm9shf/</guid><description>まず前提として、下記の手順により、Azure 上に Web App Bot リソースが作成済みであることとします。 ここに、ローカルで作成したボットをデプロイすることになります。
Azure でボットをホストするための Web App Bot リソースを作成する Web ブラウザでデプロイする方法（KUDU の Zip Deploy UI） プロジェクトのファイルを ZIP ファイルとしてアーカイブし、Zip Deploy UI という Web ページにドラッグ＆ドロップでデプロイする方法です。 この Web サイトには、下記のような URL でアクセスできます。 &amp;lt;app_name&amp;gt; の部分は、自分のボットアプリ名に置き換えてください。
https://&amp;lt;app_name&amp;gt;.scm.azurewebsites.net/ZipDeployUI 図: Web App Bot の Zip Deploy UI 左上に表示されるロゴからも分かるように、Azure の Web App サービスでは、Kudu というデプロイエンジンが使われているようですね。
この /wwwroot ディレクトリの内容が表示されている画面で、エクスプローラ領域に ZIP ファイルをドラッグ＆ドロップすると、ZIP ファイル内のファイルがまとめて /wwwroot にアップロードされます。
図: ZIP ファイルのドラッグ＆ドロップでデプロイ ボットプログラムのエントリポイントとなる bot.js ファイルを編集してから ZIP 化し、デプロイすることで、ボットの動作が変わることを確認できると思います。</description></item><item><title>チャットボット: Azure ポータルで生成されるボットのテンプレートコードを解読＆リファクタしてみる</title><link>https://maku.blog/p/iob68qa/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iob68qa/</guid><description>Azure が生成するテンプレートコードを理解する 下記の手順に従って Azure ポータル上で Web App Bot リソースを作成すると、ボットプログラムのテンプレートとして index.js や bot.js などのコードが自動生成されます。
Azure でボットをホストするための Web App Bot リソースを作成する ボットサーバのエントリポイントとなる index.js には、設定情報の読み取りと Web サーバの立ち上げ処理が記述されており、bot.js の方にはボットの応答処理を記述するようになっています。
つまり、基本的にボットの作成者は bot.js の方にボットのコア部分を実装していけばよいのですが、LUIS や QnA Maker などのサービスと連携する場合は、それぞれの初期化処理が必要であり、結局のところ index.js 側の実装に関してもある程度理解しておく必要があります。
Azure ポータルで自動生成される index.js は決して理解しやすいものではないので（少なくとも記述時点では）、ここでは index.js の内容を理解する目的と、わかりやすくリファクタする目的を兼ねて、ボットのベースとなるコードを作成していきます。
最終的には Azure が生成するテンプレートコードと同様の振る舞いになることを想定しています（少なくとも、環境変数の名前などは合わせておいた方がよいです）。
全体の流れ ボットプログラムのエントリポイントとなる index.js では、大まかに下記のような処理を行います。
.env ファイルを読み込み、環境変数の情報とマージする 1 の情報を基に、.bot ファイルを読み込む 2 の情報を基に、ボットサーバーを立ち上げる Azure ポータルで生成されるテンプレートコードでは、上記の処理をすべて index.js の中で行っているのですが、ここでは設定の読み込み部分と、ボットサーバの立ち上げ部分を明確に分離してみます。
config.js: 環境変数や .env ファイルの情報を基に、.bot ファイルの設定を読み込む。 index.js: 上記の設定情報を基にボットサーバを立ち上げる。 という感じにします。</description></item><item><title>チャットボット: MS Bot Framework の .bot ファイルで接続情報を管理する</title><link>https://maku.blog/p/8choj4w/</link><pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8choj4w/</guid><description>エミュレータのための .bot ファイル Bot Framework Emulator は、自分自身（チャットクライアント）が接続するボットサーバのアドレスを .bot ファイルから取得します。
.bot ファイルの中には、&amp;quot;type&amp;quot;: &amp;quot;endpoint&amp;quot; というエンドポイント定義が 1 つ以上記述されており、ここにはボットプログラムのアドレスが記述されています。 エミュレータの設定で、どのエンドポイント設定を使用するかを切り替えることで、実際に接続するボットを使い分けることができます。 典型的には、開発時にローカルホスト上で動作させたボットサーバに接続するための development と、実稼働用に Azure 上で動作させたボットサーバに接続するための production というエンドポイントを定義します。
図: エミュレータ上でのエンドポイント切り替え ボットプログラムのための .bot ファイル .bot ファイルは、ボットプログラムからも利用されます（こちらの方がメイン）。
.bot ファイルには、LUIS や QnA Maker のサービスを利用するためのエンドポイント情報（アドレスやエンドポイントキー）が定義されており、ボットプログラムはこれらの情報を使って各サービスの API を利用します。 こららの情報は、ボット自体がローカルホスト上で動作していても、Azure 上で動作していても同様に利用されます。
また、ここでもボット自体の endpoint エントリが参照され、各種チャンネル（チャットクライアント）がボットにアクセスするときの認証処理のために使用されます。 このあたりの処理は、Bot Builder SDK を使ってボット実装を行っていれば、Adapter クラスとして抽象化されるため、特に意識せずに実装することができます。
.bot ファイルに LUIS や QnA Maker の接続設定を記述する .bot ファイルは XML ファイルなので、フォーマットさえ理解すればテキストエディタなどで編集してしまうことはできますが、エンドポイントキー部分の復号化・暗号化が必要だったりして面倒です。 Bot Framework Emulator には、.bot ファイルの内容を GUI で編集する機能が付いているのでこの機能を使うのがよいでしょう。</description></item><item><title>チャットボット: LUIS や QnA Maker サービスへの接続情報を .bot ファイルから取得する</title><link>https://maku.blog/p/o2bqajv/</link><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/o2bqajv/</guid><description>参考: MS Bot Framework の .bot ファイルで接続情報を管理する ここで作るもの こちらの実装 では、最初のステップとしてボットサーバ自体 (Azure Web Apps) のエンドポイント情報を .bot ファイルから取得する実装を行いました (config.js)。 ここでは、さらに、LUIS サービスや QnA Maker サービスを利用することを想定し、これらの情報も .bot ファイルから取得できるように拡張します。
使用イメージとしては、下記のようにしてそれぞれの接続情報を簡単に読み込めるようにします。
const config = require(&amp;#39;./config.js&amp;#39;); const LUIS_APP_NAME = &amp;#39;maku-luis-sample&amp;#39;; const QNA_APP_NAME = &amp;#39;maku-qna-sample&amp;#39;; const botEndpoint = config.loadBotEndpoint(); // ボット自体への接続情報 const luisEndpoint = config.loadLuisEndpoint(LUIS_APP_NAME); // LUIS への接続情報 const qnaEndpoint = config.loadQnaEndpoint(QNA_APP_NAME); // QnA Maker への接続情報 単一のオブジェクトとしてまとめて取得するように実装することもできるのですが、分かりやすさのために、3 つの情報に分けて取得するようにしています。 LUIS や QnA Maker は、複数のアプリ（ナレッジベース）を同時に使用する可能性があるので、アプリ名を指定して接続情報を取得できるようにしています。
取得した情報は、次のように BotBuilder SDK が提供するクラスへの入力として使用することを想定しています。</description></item><item><title>チャットボット: 作成したチャットボットを LINE に接続する</title><link>https://maku.blog/p/asuzg7k/</link><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/asuzg7k/</guid><description>LINE に Messaging API チャネルを作成する 自作したチャットボットアプリを LINE から「友だち」として見えるようにするには、まず LINE 側に「プロバイダー」を作成し、そこに「Messaging API チャネル」を追加する必要があります。 この Messaging API チャネルは、LINE アプリから「友だち」として見える単位だと考えればよいでしょう。
LINE に開発者として登録する LINE のプロバイダー登録作業などは、下記の LINE Developer Console から行うことができます。 初めてアクセスする場合は、開発者としての登録を求められるので、LINE アカウントでログインして開発者情報を入力してください。
LINE Developer Console プロバイダーを新規作成する LINE に開発者登録できたら、新規プロバイダー作成 のボタンを押して、プロバイダーを作成します。
Messaging API チャネルを追加する プロバイダーの作成が終わったら、そこに Messaging API チャネル を追加します。
チャネルの作成時には、アプリアイコンやアプリ名を自由に登録することができます。 アプリ名は一度設定すると 7 日間は変更できないようなので慎重に決めましょう（アイコンは 1 時間経てば変更できます）。
下のように、プロバイダー上に Messaging API チャネルが追加されていれば OK です。
スマホの LINE に友達登録する Messaging API のチャネルを選択し、チャネル基本設定 タブを見ると、LINE アプリ用の QR コードが見つかります。</description></item><item><title>チャットボット: 作成したチャットボットを Slack に接続する</title><link>https://maku.blog/p/rtxqceq/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rtxqceq/</guid><description>Slack に Bot Framework で作成したボットを接続する 図: ボットとのダイレクトメッセージによる会話 Microsoft Azure 上に作成したボットアプリを Slack に接続するには、下記の Bot Service 公式ドキュメントで説明されている手順に従ってください。
（日本語）ボットを Slack に接続する - Bot Service ｜ Microsoft Docs （英語）Connect a bot to Slack - Bot Service ｜ Microsoft Docs 接続のおおまかな手順は下記のような感じです。
Slack アプリを作成する（何らかのワークスペースに所属させる形で作成する） Slack アプリにボット用のユーザーを登録する Azure ポータルから、Web アプリボットのチャンネルとして Slack を追加（Slack アプリ側の Client ID、Client Secret、Verification Token をコピペすれば OK） この作業が終わると、ボット（アプリ）が Slack のワークスペースに参加している状態になります。 その時点ではどのチャンネルにも参加していませんが、ダイレクトメッセージを使って一対一でボットと会話することができます。
特定のチャンネルで会話している最中に @ボット名 と話かけると、そのチャンネルにボットを招待することができます。 チャンネルにボットが参加すると、後はそのチャンネルに対してつぶやくだけでボットが反応するようになります。
わかりにくいところの補足 図入りで説明されているので、特に迷うことはないと思いますが、Microsoft の Bot チームのドキュメント通りにはうまくいかない部分があるので若干補足しておきます。</description></item><item><title>チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する</title><link>https://maku.blog/p/mgujykj/</link><pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mgujykj/</guid><description>Bot Builder SDK (Node.js) の botbuilder-core パッケージには、ActivityHandler という、ボットのイベントハンドラ部分の実装を簡略化するためのライブラリが含まれています。 ボットの世界では、「Activity」はひとつのメッセージの処理単位のことを示しています。 この Activity をうまくハンドルするためのクラスだから ActivityHandler という名前が付けられているんですね。
ここでは、独自のボットクラス (MyBot) を、ActivityHandler を利用せずに実装した場合と、利用して実装した場合で比較してみたいと思います。
ActivityHandler を使わない場合 例えば、下記のように BotFrameworkAdapter で受信したイベントの処理を MyBot.onTurn() に委譲するとします。
mybot.js const myBot = new MyBot(); const adapter = new BotFrameworkAdapter({}); const server = require(&amp;#39;restify&amp;#39;).createServer(); server.post(&amp;#39;/api/messages&amp;#39;, (req, res) =&amp;gt; { adapter.processActivity(req, res, async (context) =&amp;gt; { await myBot.onTurn(context); // あとは MyBot に丸投げ }); }); このイベントは、ユーザからメッセージを送られたときだけでなく、ユーザがチャットに参加したとき (ConversationUpdate) などにも発生するため、MyBot.onTurn() の実装の中でアクティビティタイプを見て分岐処理を行わなければなりません。
class MyBot { constructor() { // .</description></item><item><title>チャットボット: ユーザーの参加／離脱のイベントをハンドルする</title><link>https://maku.blog/p/onctywi/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/onctywi/</guid><description>Bot Builder SDK の ActivityHandler を使って、ユーザーが会話に参加したこと、離脱したことをハンドルする方法を説明します。 ActivityHandler を使ったボット実装の基本に関しては下記を参照してください。
チャットボット: ActivityHandler でボットのイベントハンドラ実装を簡略化する 下記は、ユーザーが新しく会話に参加したときに、ボットから挨拶するように実装した例です。 ユーザー参加のイベントをハンドルするには、ActivityHandler#onMembersAdded() で、イベントハンドラを登録します。
mybot.js const { ActivityHandler, BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); // ボット実装 class MyBot extends ActivityHandler { constructor() { super(); this.onMessage(this.handleMessage); this.onMembersAdded(this.handleMembersAdded); } async handleMessage(context, next) { const name = context.activity.from.name; const utterance = context.activity.text; await context.sendActivity(`${name}さんは、${utterance}と言いました。`); await next(); } async handleMembersAdded(context, next) { const members = context.activity.membersAdded; for (let i = 0; i &amp;lt; members.length; ++i) { const m = members[i]; if (m.</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (Storage)</title><link>https://maku.blog/p/3fnyk44/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3fnyk44/</guid><description>ボットは基本的にステートレスで動作するので、ユーザとの会話のコンテキストを把握するには、ステートの管理を明示的に行う必要があります。 Bot Builder SDK にはそのためのユーティリティクラスが用意されています。 ここでは、Node.js の botbuilder パッケージを使って説明します。
Storage インタフェース botbuilder パッケージに含まれている Storage インタフェースは、抽象化されたストレージに JSON オブジェクトを保存するための API を定義しています。 write、read、delete の 3 つの API のみなのでとてもシンプルです。
write メソッド JSON オブジェクトをストレージに保存するための API です。 オブジェクトを保存するときには、名前（キー）を付けて、キー＆バリューの形のオブジェクトとして保存します。 下記の例では、保存したい state オブジェクトに、botState という名前を付けて保存しています。
state.topic = &amp;#39;someTopic&amp;#39;; await storage.write({ &amp;#39;botState&amp;#39;: state }); read メソッド ストレージに保存されたオブジェクトを読み出すための API です。 読み出したいオブジェクトの名前を配列で渡すと、オブジェクトの連想配列が返ってきます。 下記の例では、botState という名前で保存されたオブジェクトを、state 変数に取り出しています。
const items = await storage.read([&amp;#39;botState&amp;#39;]); const state = items[&amp;#39;botState&amp;#39;] || {}; delete メソッド ストレージに保存されたオブジェクトを削除するための API です。 削除したいオブジェクトの名前を配列で渡します。</description></item><item><title>チャットボット: Bot Builder SDK で会話の状態を保存する (BotState)</title><link>https://maku.blog/p/6wtzzq4/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6wtzzq4/</guid><description>BotState クラス Bot Builder SDK の BotState クラス は、ボットとの会話内の特定のコンテキストにおける状態を保持するためのクラスです。
というと難しいですが、簡単に言うと、会話ごとの状態保存や、ユーザーごとの状態保存を行うための便利クラスです。
BotState クラスには次のようなサブクラスが定義されています。
ConversationState クラス &amp;hellip; 会話ごとの状態を保存する UserState クラス &amp;hellip; ユーザーごとの状態を保存する PrivateConversationState クラス &amp;hellip; 会話ごとのユーザごとの状態を保存する これらのクラスは、内部で Storage オブジェクトを利用します。
≪生成コード&amp;#x1F4D6;≫ Storage がグローバルに状態保存を行っていたのに対し、BotState はネームスペースを考慮して状態保存を行うものだと考えることができます。 実際に、ConversationState クラスや UserState クラスの実装を覗いてみると、getStorageKey() というメソッドでストレージ用の保存キーを作成しており、それぞれ次のように構成しています。
ConversationState が使用する保存キー ${ channelId }/conversations/${ conversationId }/${ this.namespace } UserState が使用する保存キー ${ channelId }/users/${ userId }/${ this.namespace } PrivateConversationState が使用するキー ${ channelId }/conversations/${ conversationId }/users/${ userId }/${ this.</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (1) ダイアログの基本</title><link>https://maku.blog/p/w36evii/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w36evii/</guid><description>Dialog を使わない会話管理 Bot Builder SDK の UserState や ConversationState を使う と、ユーザーや会話ごとの状態管理を行うことできるため、複数回のやりとりが必要な会話を実現することができます。
例えば、下記のような会話ができるボットを実装してみます。
User: こんにちは Bot: あなたの名前は？ User: まく Bot: こんにちは まく さん User: おやすみなさい Bot: また来てね まく さん 次のボット実装は、UserState クラスを使って、pos という名前のプロパティを作成し、会話がどこまで進んでいるかを管理しています。
mybot.js const { ActivityHandler, UserState } = require(&amp;#39;botbuilder&amp;#39;); class MyBot extends ActivityHandler { constructor(storage) { super(); this._createStateObjects(storage); this.onMessage(async (context, next) =&amp;gt; { const prop = await this.nameProp.get(context, { pos: &amp;#39;init&amp;#39; }); // プロパティの &amp;#39;pos&amp;#39; により処理を分岐させる if (prop.pos === &amp;#39;init&amp;#39;) { prop.</description></item><item><title>チャットボット: Bot Builder SDK の Dialog で会話の流れをデザインする (2) スタック管理</title><link>https://maku.blog/p/6arjar6/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6arjar6/</guid><description>ダイアログの基本 で説明したように、Dialog クラスを使用した会話フローでは、ユーザーからメッセージを受け取るたびに DialogContext#continueDialog() を呼び出すことで、1 ステップずつ処理を進めていきます。 ダイアログには、スタック構造で会話を管理する仕組みがあり、次のようなメソッドを使って、ダイアログの起動（スタックに積む）、ダイアログの終了（スタックから降ろす）という操作を行うことが可能です。
DialogContext#beginDialog(&amp;quot;ID&amp;quot;) &amp;hellip; ダイアログを開始する（スタックに積む） DialogContext#endDialog() &amp;hellip; アクティブなダイアログを終了する（スタックから降ろす） DialogContext#replaceDialog(&amp;quot;ID&amp;quot;) &amp;hellip; アクティブなダイアログを別のダイアログに置き換える（スタックの一番上を入れ替え） DialogContext#cancelAllDialog() &amp;hellip; すべてのダイアログを終了する（スタックをクリア） ここでは、RootDialog と GreetDialog という名前の 2 つのダイアログクラス作成し、RootDialog から GreetDialog を起動してダイアログのスタックを積むような実装を行ってみます。
図: ダイアログ遷移のイメージ 下記は、実際のチャットクライアントの表示例です。 右側のバーで示すように、 最初に RootDialog による選択肢が表示され、次に GreetDialog の処理に遷移し、最後に RootDialog に戻ってくるという流れです。
図: チャットのイメージ 下記は、最初に起動される RootDialog クラスの実装です。 前回の説明 で使用した DialogBot クラスを使って RootDialog を起動することを想定しています。 ウォーターフォールダイアログの最初のステップ (_step1) として、ユーザーに選択肢を提示し、「挨拶する」を選んだ場合に、GreetDialog を新たに起動するようにしています。
dialogs/rootDialog.js const { ChoiceFactory, ChoicePrompt, ComponentDialog, ListStyle, WaterfallDialog, } = require(&amp;#39;botbuilder-dialogs&amp;#39;); const { GreetDialog } = require(&amp;#39;.</description></item><item><title>チャットボット: Bot Builder SDK で画像やリストなどのリッチなメッセージを送る (MessageFactory)</title><link>https://maku.blog/p/q7vw95i/</link><pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7vw95i/</guid><description>Activity オブジェクトと MessageFactory Bot Builder SDK によるボット実装において、ユーザーにメッセージを送るには TurnContext クラス の sendActivity() メソッドを使用します。 下記は、単純なテキストメッセージを送る例です。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); sendActivity() の第一引数には、このように文字列を渡すことができますが、その名の通り Activity オブジェクトを渡すこともできるようになっています。 Activity オブジェクトを使うと、単純なテキストよりもリッチな形式で表示を行うことができます（どう表示されるかは各チャンネルの実装によりますが）。
Activity インタフェースは botframework-schema モジュール で定義されていますが、このインタフェースを意識してオブジェクトを作成することはあまりありません。 というのも、いろいろな用途の Activity オブジェクトを生成するためのファクトリーである MessageFactory クラス が用意されているからです。
例えば、MessageFactory#text() は単純なテキストメッセージを送るための Activity オブジェクトを生成します。
// const { MessageFactory } = require(&amp;#39;botbuilder&amp;#39;); const msg = MessageFactory.text(&amp;#39;Hello!&amp;#39;); await context.sendActivity(msg); これは実は下記のようにするのと同じです。
await context.sendActivity(&amp;#39;Hello!&amp;#39;); TurnContext#sendActivity() に直接文字列を渡した場合は、内部で前者のような MessageFactory.text() による Activity 生成が行われています。 単純なテキストを送るだけであれば、sendActivity('Hello') としてしまうのが早いでしょう。
MessageFactory でリッチなメッセージを作成する MessageFactory が提供するファクトリメソッドを使って、リッチなメッセージを送る例をいくつか紹介します。 ここでは、Bot Framework Emulator の表示例を載せておきます。</description></item><item><title>チャットボット: 独自のミドルウェアを作成してログを記録する</title><link>https://maku.blog/p/fn3amda/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fn3amda/</guid><description>ミドルウェアとは Bot Framework において、クライアントから受信したメッセージはアダプターを介してボットに届けられますが、アダプターにミドルウェアを設定しておくことで、メッセージがボットに届く前に割り込んで処理を行うことができます。
Adapter → Middleware1 → Middleware2 → Middleware3 → ... → YourBot ミドルウェアは上記のように複数登録することができ、登録された順に呼び出されていきます。 アダプターにミドルウェアを追加するには、BotFrameworkAdapter#use() メソッドを使用します。
ミドルウェアの追加 const { BotFrameworkAdapter } = require(&amp;#39;botbuilder&amp;#39;); const adpater = new BotFrameworkAdapter(endpoint); adapter.use(new Middleware1()); adapter.use(new Middleware2()); adapter.use(new Middleware3()); ミドルウェアを実装する 独自のミドルウェアを作成するには、Middleware インタフェース が提供する onTurn メソッドを実装します。
ここでは、ユーザーの入力をコンソールに出力するだけの ConsoleLogger というミドルウェアクラスを実装してみます。
middlewares/consoleLogger.js exports.ConsoleLogger = class ConsoleLogger { async onTurn(context, next) { if (context.activity.type === &amp;#34;message&amp;#34;) { console.log(context.activity.text); } await next(); // Invoke a next middleware } }; とても簡単ですね。 あと、onTurn() を抜ける前に忘れずに next() を呼び出して、後続のミドルウェアが正しく呼び出されるようにしておく必要があります。</description></item><item><title>チャットボット: 独自のミドルウェアを作成して禁止ワードを拒否するようにする</title><link>https://maku.blog/p/gt9g2na/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gt9g2na/</guid><description>前回の記事 では、チャットボットに独自のミドルウェアを追加して、ユーザー入力をログ出力できるようにしました。 今回は、ユーザーが NG ワードを入力したときに、警告を表示して処理を中断するようなミドルウェアを作成してみます。
その名も NgWordMiddleware です！
middlewares/NgWordMiddleware.js const NG_WORDS = /アホ|まぬけ|バカ/; exports.NgWordMiddleware = class NgWordMiddleware { async onTurn(context, next) { if (context.activity.type === &amp;#39;message&amp;#39;) { const line = context.activity.text; if (NG_WORDS.test(line)) { await context.sendActivity(&amp;#39;そんなこと言っちゃダメ&amp;#39;); return; } } await next(); // Invoke a next middleware } }; 上記の例では、NG_WORDS 定数に、禁止語句を正規表現の形で登録しています。 ユーザーが入力したテキストに、禁止語句が含まれていたら、「そんなこと言っちゃダメ」と返事して処理を進めないようにします（next() を呼び出さないことで後続の処理を打ち切る）。
このミドルウェアは、下記のようにアダプターに追加することで有効化できます。
// const { NgWordMiddleware } = require(&amp;#39;./middlewares/ngWordMiddleware.js&amp;#39;); const adapter = new BotFrameworkAdapter(botEndpoint); adapter.use(new NgWordMiddleware()); この例では、単純に禁止語句が含まれているかだけをチェックしているので、「バカルディ」と入力した場合にも弾かれてしまいます。 このあたりは工夫して処理しなきゃですね。</description></item><item><title>LUIS (2) LUIS のオーサリングキー、エンドポイントキーとは</title><link>https://maku.blog/p/mdyedwq/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mdyedwq/</guid><description>LUIS アプリで使用するキーの種類には、オーサリングキー (Authoring Key) とエンドポイントキー (Endpoint Key) の 2 種類があります。
オーサリングキー (Authoring Key) オーサリングキーは LUIS アカウントの作成時に自動的に作成される、無料のキーです。 オーサリングキーはリージョン内で共通であり、1 つだけ作成されます。 最初に作成されるので、スターターキー (Starter Key)、作成者キーとも呼ばれます。
オーサリングキーは、LUIS アカウントに結び付けられているので、LUIS 右上のアカウント名をクリックし、Settings を選択することで確認できるようになっています。
オーサリングキーは、LUIS アプリ自体の作成や、公開、コラボレーターの管理、バージョン管理などを行うときに必要になります。 つまり、あなたが作成する LUIS アプリの管理用のキーであり、LUIS の Web サイトで行えることほぼすべてをこのキーを使ったオーサリング API 経由で行えます。
LUIS ポータル上にログインして作業している間は、オーサリングキーの存在を意識しなくても LUIS アプリの管理を行うことができますが、Web API を使って LUIS アプリの管理作業を自動化したいときなどにオーサリングキーが必要になります。
作成した個々の LUIS アプリに対するクエリ実行のためにもオーサリングキーを使用できますが、これは実装中のテスト用途に限られます（権限の強いオーサリングキーを、公開アプリからのクエリ用途に使うのは避けるべきです）。 実運用でのクエリ実行は、後述のエンドポイントキーを使用します。
ちなみに、オーサリングキーは Microsoft のユーザアカウントごとに割り当てられるものです。 LUIS アプリのコラボレータとして登録されたユーザは、自分のオーサリングキーを使って LUIS アプリの管理を行います。
エンドポイントキー (Endpoint Key) 運用環境で LUIS アプリに対するクエリ実行を行うには、Azure の LUIS リソースとして作成されたエンドポイント URL とエンドポイントキーを使用します。 Azure ポータル にログインして、LUIS リソースを作成することでエンドポイントキーを取得できます。</description></item><item><title>LUIS (3) Node.js から LUIS の API を利用する</title><link>https://maku.blog/p/tewj3gs/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tewj3gs/</guid><description>LUIS API を呼び出すためのエンドポイント情報を調べる LUIS アプリの Publish REST API 経由で LUIS アプリによる発話解析を行うには、LUIS ポータル上で対象の LUIS アプリを Train し、Publish しておく必要があります（LUIS アプリというのは、いわゆる訓練されたモデルのことだと考えるとよいです）。
API 実行用のエンドポイント URL とキーを確認する Publish 処理が完了すると、エンドポイント URL と エンドポイントキー (Endpoint key) を使って、LUIS アプリに対してクエリ要求を投げることができるようになります。 テスト用途であれば、LUIS ポータル上で最初に作成される オーサリングキー (Authoring key) でもクエリを実行できますが、最終的なユーザ環境でのクエリ実行には Azure 上で作成したリソースに付けられたエンドポイント URL とエンドポイントキーのペアを使用する必要があります。
参考: オーサリングキー、エンドポイントキーとは LUIS の REST API を呼び出すための URL は、下記のような情報から構成されています（下記例の ID はデタラメです）。
Application ID: 5c548551-f6ba-4fc8-c695-529ac194317d Application version: 0.1 エンドポイントキー: ff824a1409f929c8e2a15301ccff431d Application ID と Application version は、MANAGE タブの Application Information のページで確認することができます。</description></item><item><title>LUIS (4) botbuilder-ai ライブラリを使って LUIS の API を利用する</title><link>https://maku.blog/p/dtwckb9/</link><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtwckb9/</guid><description>こちらの記事（Node.js から LUIS の API を利用する） では、自力で LUIS の REST API を呼び出すための URL を構築していました。 ここでは、botbuilder-ai パッケージを使用して、もっと手軽に LUIS の機能を呼び出してみます。
☝️ ワンポイント 残念ながら botbuilder-ai が提供している LuisRecognizer などのクラスは、チャットボットの実装に使用する TurnContext オブジェクトに依存した設計になっています。 そのため、単純なコンソールアプリケーションから botbuilder-ai パッケージを使用することは難しく、チャットボットの実装でしか利用できません。 LUIS のエンドポイント情報（接続情報）を確認しておく LUIS API を使用するには、下記のような LUIS アプリの APP ID やエンドポイント情報が必要です。
APP ID: c39eb4df-fbcf-224f-b8b7-a0ee445d11b3 エンドポイント: https://japaneast.api.cognitive.microsoft.com エンドポイントキー（サブスクリプションキー）: c9162c5c0b5edff5270feb6145618acb APP ID とエンドポイントキーは、LUIS ポータル から対象のアプリケーションを開き、下記のように確認できます。
APP ID: MANAGEタブ → Application Information エンドポイント: MANAGEタブ → Keys and Endpoints → Endpoint カラムの URL の前半部分。 エンドポイントキー: MANAGEタブ → Keys and Endpoints → Key 1 カラム LUIS のエンドポイントキーは、Azure ポータル に作成した LUIS リソース の キー の項目に表示されるものと同じです。 念のため、同一のものが表示されているか確認しておくとよいでしょう。</description></item><item><title>QnA Maker (1) QnA Maker とは？</title><link>https://maku.blog/p/2t6xrbm/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2t6xrbm/</guid><description>QnA Maker でできること Microsoft が提供している QnA Maker というサービスを使用すると、「質問(Q)と回答(A)」のペアデータを登録するだけで、自然言語での FAQ 検索を行うための API を使用できるようになります。 Microsoft が提供している一連の Cognitive Service のひとつとして位置づけられていて、主に FAQ 系のチャットボット (Bot) を手軽に作成するために使用されています。
QnA Maker QnA Maker Documentation QnA Maker REST API V4.0 QnAMaker class | Microsoft Docs 例えば、下記のような Q&amp;amp;A のペアを登録していくだけで、機械学習によって回答のモデルが自動生成されます。 QnA Maker では、このモデルのことをナレッジベース (Knowledge base) と呼んでいます。
Q. お店の営業時間を教えてください。 A. 営業時間は午前10時から午後6時までです。 実際にユーザが入力する質問文章は、登録した Q&amp;amp;A データの質問文と完全に一致する必要はありません。 QnA Maker がどの質問に近いかを判別して、対応する回答文（と一致度）を返してくれます。
ユーザ入力: 営業時間は？ QnA Makerの回答: 営業時間は午前10時から午後6時までです。 簡単に言ってしまえば、QnA Maker の API が提供する機能はこれだけです（データ管理用の API などもありますが）。 回答文を自動生成してくれるようなこともなく、返される文章は、Q&amp;amp;A データとして登録した回答文そのままです。 とはいえ、サクッと FAQ 系のサービスを作成するときには便利に使用できるサービスです。</description></item><item><title>QnA Maker (2) QnA Maker のサブスクリプションキー、エンドポイントキーとは</title><link>https://maku.blog/p/t6n6jc8/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t6n6jc8/</guid><description>サブスクリプションキー (Subscription Key) サブスクリプションキーは、QnA Maker アプリ自体の作成や編集を行うためのキーです。 後述のエンドポイントキーよりも厳重に管理しなければならないキーです。
このキーは、Azure ポータル上で QnA Maker のリソースを作成した際に生成されます。 QnA Maker アプリは、Azure 上にリソースを作ってからでないと作成できないため、QnA Maker アプリがすでに存在するのであれば、サブスクリプションキーも必ず存在することになります。
Azule の QnA Maker リソースに割り当てられたサブスクリプションキーは、Azure ポータルの QnA Maker リソースの Keys のページで確認することができます。
図: Azure ポータル上での QnA Maker のサブスクリプションキーの確認 LUIS の場合は、アプリ管理用のキーはオーサリングキーと呼んでいたりしますが、それの QnA Maker 版だと考えればよいです。 QnA Maker アプリの場合、このキーの管理は Azure ポータル上で管理されることになっており、Azure 上ではこのようなキーのことをサブスクリプションキーと呼んでいるんですね。 このあたりのチグハグ感に関しては こちらを参照。
エンドポイントキー (Endpoint Key) エンドポイントキーは、チャットアプリなどのユーザクライアント（Bot Framework では「チャンネル」と呼びます）が、QnA Maker に対してクエリを行うときに使用するキーです。 エンドポイントキーは、QnA Maker ポータルで対象となるナレッジベースを選択後、PUBLISH タブから Publish 処理を実行したとき、あるいは SETTING タブを選択することで確認することができます。
図: QnA Maker ポータル上での QnA Maker のエンドポイントキーの確認 チャットボットなどから QnA Maker を利用する場合、実運用時に設定する API アクセス用のキーは、こっちのエンドポイントキーです。</description></item><item><title>QnA Maker (3) Node.js から QnA Maker の API を利用する</title><link>https://maku.blog/p/rgnvp2r/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rgnvp2r/</guid><description>QnA Maker API を呼び出すためのエンドポイント情報を調べる QnA Maker ナレッジベースの Publish REST API を使用して QnA Maker のナレッジベースを使用するためには、QnA Maker ポータル上で対象のナレッジベースを Publish しておく必要があります。
Publish 処理が完了すると、ナレッジベースにアクセスするための Endpoint key が発行されます。
curl での QnA Maker API の呼び出しテスト 任意の質問文に対する回答文を得るには、REST API として下記のような HTTP POST リクエストを送ります。
curl -X POST https://xxx.azurewebsites.net/qnamaker/knowledgebases/＜ナレッジベースID＞/generateAnswer -H &amp;quot;Authorization: EndpointKey ＜上記で発行したキー＞&amp;quot; -H &amp;quot;Content-type: application/json&amp;quot; -d &amp;quot;{'question':'&amp;lt;質問文&amp;gt;'}&amp;quot; Linux の curl コマンドを使用できる環境であれば、上記のように実行するだけで JSON 形式のレスポンスを確認することができます。
Node.js から QnA Maker の REST API を呼び出す Node.js から HTTP POST リクエストを送って JSON レスポンスを取得してみます。 HTTP リクエストを行うためのモジュールとして、ここでは request モジュールを使用します。 JavaScript ファイルを作成するディレクトリと同じディレクトリ内で、下記のようにインストールしておいてください。</description></item><item><title>QnA Maker (4) Python から QnA Maker の API を利用する</title><link>https://maku.blog/p/fwyi2fh/</link><pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fwyi2fh/</guid><description>QnA Maker は REST API を提供しているので、HTTP リクエストを発行できるプログラミング言語から簡単に制御することができます。 ここでは、Python に標準で付属している urllib.request モジュールを使って HTTP リクエストを発行し、QnA Maker にアクセスしてみます。
事前準備（アクセスキーの準備） REST API を使用するには、HTTP リクエストのヘッダ情報としてアクセスキーを付加する必要があります。 こちらの記事 を参考に、下記のどちらかのアクセスキーを確認しておいてください。
サブスクリプションキー (Subscription Key) &amp;hellip; 管理用 エンドポイントキー (Endpoint Key) &amp;hellip; クエリ用 アクセスキーは 9d16b3e6345489ad4a57a0755eb4f96a のような 16 進数文字列です。 QnA のクエリ実行だけであればエンドポイントキーの方を使えば大丈夫ですが、ナレッジベースの作成や更新などを行う場合は、サブスクリプションキーの方を使う必要があります。
QnA Maker の REST API を呼び出す Python ライブラリ REST API は HTTP リクエストを送るだけで使用できるので、ここでは自力で QnA Maker の API を使用するライブラリを作ってみます。
下記の QnaRequest クラスは、ナレッジベースの一覧を取得する getAllKnowledgeBases メソッドと、指定したナレッジベースの情報を取得する getKnowledgeBase メソッドを提供しています。 戻り値は JSON 形式のテキストです。
mylib/qna.py import urllib.</description></item><item><title>LUIS と QnA Maker でキーの管理方法が異なるのはなぜか？</title><link>https://maku.blog/p/8myms6s/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8myms6s/</guid><description>LUIS や QnA Maker サービスを利用するためのエンドポイントキーは、下記の 2 種類が提供されます。
実運用のためのキー: チャットクライアントなどからの、一般的な問い合わせを処理するためのキー。 管理用のキー: 各サービスの情報を取得したり、データを編集したりするためのキー。 LUIS も QnA Maker も便利なサービスなのですが、Azure リソースとの結びつけ方法や、キーの管理方法が異なっているため、最初はわけがわからなくなるかもしれません。 例えば、Azure ポータル上の RESOURCE MANAGEMENT / Keys のページで表示されるキー（サブスクリプションキー）が、LUIS の場合は実運用のためのキーであるのに対し、QnA Maker の場合は管理用のキー であったりします。
LUIS/QnA を使用する場合は、それぞれ、エンドポイントキーとしてどちらのキーを使用するかを間違えないようしなければいけません。
LUIS のサブスクリプションキー（実運用のためのキー）: Azure ポータルの LUIS リソースの Keys で表示されるもの LUIS のオーサリングキー（管理用のキー）: LUIS ポータルの Authoring Key で表示されるもの QnA Maker のエンドポイントキー（実運用のためのキー）: QnA Maker ポータルのプロファイル設定で表示されるもの QnA Maker のサブスクリプションキー（管理用のキー）: Azure ポータルの QnA Maker リソースの Keys で表示されるもの この時点で、キーの管理方法が QnA Maker と LUIS では完全に逆になっています。 Azure 上でのインタフェースは LUIS リソースと QnA Maker リソースで見た目が同じなので、混乱に拍車をかけています。</description></item><item><title>Bot Framework: Web チャットの表示をカスタマイズする</title><link>https://maku.blog/p/oitn3a3/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oitn3a3/</guid><description>Microsoft Bot Framework を使ってウェブサイト上にチャットボットを配置したときの表示のカスタマイズ方法です。 次のように、ボットやユーザーのアイコンを設定することができます。
このようなカスタマイズ表示を行うには、Azure portal 上の Web App Bot リソースの Channels タブから選択できる、Direct Line チャネルを使う必要があります。 Web Chat というチャネルを使うと、iframe タグで簡単にチャットウィンドウを埋め込むことができるのですが、そちらではあまりカスタマイズができないようです。
図: Direct Line チャネルのキーを確認 下記はチャットウィンドウをカスタマイズして表示するサンプルコードです。 Bot Framework が提供している WebChat.renderWebChat() 関数を呼び出すと、実際にチャットウィンドウが表示されるのですが、このときに styleOptions パラメータを指定することで表示方法をカスタマイズすることができます。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.botframework.com/botframework-webchat/latest/webchat.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; * { margin: 0; } #webchat { height: 100vh; width: 100vw; background: gray; border: solid 5px #f37; box-sizing: border-box; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;webchat&amp;#34; role=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const TOKEN = &amp;#39;HpJB2ofxzsA.</description></item></channel></rss>