<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Svelte on まくろぐ</title><link>https://maku.blog/tags/svelte/</link><description>Recent content in Svelte on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 11 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/svelte/index.xml" rel="self" type="application/rss+xml"/><item><title>Svelte を始める (SvelteKit で Hello World）</title><link>https://maku.blog/p/qmy6cdh/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qmy6cdh/</guid><description>Svelte とは Svelte は、コンパイラベースの Web アプリケーションフレームワークです。 特殊なテンプレート言語を使ってコンポーネントを実装することで、高度に最適化された HTML/JavaScript/CSS を出力することができます。 React.js アプリなどは、クライアントサイド JavaScript から共通のライブラリを呼び出す形で動作しますが、Svelte はコンパイル後の最適化された JavaScript のみで動作するようになっており、最終的な成果物が非常にコンパクトになります。 独自のテンプレート構文を学ぶ必要はありますが、ユーザー操作に反応するコンポーネントを、少ないコードで記述できるよう工夫されています。
☝️ ライバル？の Astro との違い Svelte よりも後発のコンパイラベースの Web アプリフレームワークに Astro があります。 Astro は、ビルド時にほとんどの JavaScript コードを実行して、その時点で静的な HTML ファイルを生成するというアプローチをとっています。 最終的にデプロイするのは、HTML (+CSS) だけになるので、初期表示が爆速になるという考え方です。 一方、Svelte はあくまで最適化された JavaScript コードはクライアントサイドで動かすという考え方です。
完全に静的なサイトであれば Astro を使い、インタラクティブなサイトであれば Svelte を使う、という使い分けがよさそうです。
参考: Astro 関連メモ Svelte + SvelteKit プロジェクトの作成 Svelte のプロジェクトは次のように npm create svelte コマンドで簡単に作成できます。 ウィザード形式の質問に答えていくだけで、TypeScript や ESLint、Prettier の導入まで一気にやってくれます。
Svelte プロジェクト (myapp) の作成 $ npm create svelte@latest myapp .</description></item><item><title>Astro と Svelte を使ってみた所感（Web サイト作るときに何を使うか）</title><link>https://maku.blog/p/zays9nw/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zays9nw/</guid><description>Next.js 以外の選択肢 2023 年現在、ある程度の規模の Web アプリを作れと言われたら、間違いなく Next.js (React.js) を使うのですが、小規模でほとんど静的な Web サイトを作れと言われたらちょっと迷ってしまうので、Astro と Svelte を少しだけ触ってみました。 もちろん、HTML や CSS を生でガリガリ書いて Web サイトを作ることもできますが、これらのフレームワークを使うことで、コンポーネント単位で Web ページを組み上げていくことができるのでコードの見通しがよくなります。
参考: Svelte 関連記事 Astro vs. Svelte 感覚としては、完全に静的な Web サイトを作るのであれば Astro がとてもシンプル でよさそうです。 ただし、フォームなどの入力要素が必要な場合は、データバインドを独自構文でサポートしている Svelte の方が便利かもしれません。 Svelte は簡単に使えるというけれど、独自のテンプレート構文などは若干 Vue.js の匂いがするので、そこを嫌う人は多そうです。 一方、Astro であれば、ほとんどドキュメントすら読まなくても理解できるくらい簡単です（React.js 触ったことがあれば即理解できるはず）。
Astro も Svelte も npm でビルドツールをインストールしますが、Astro であれば package.json の dependencies セクションが astro モジュールだけになるくらいシンプルです。
package.json { // ... &amp;#34;dependencies&amp;#34;: { &amp;#34;astro&amp;#34;: &amp;#34;^2.10.7&amp;#34; } } Astro モジュール自体が TypeScript や Vite を内包してくれているので、別途 TypeScript や Vite をインストールする必要はないし、VS Code の Astro 拡張 をポチッとインストールするだけで、Prettier による自動整形や TypeScript の型チェックがかかるようになります。 Svelte の場合は、Svelte 本体の他にも、SvelteKit や Vite や TypeScript などが dependencies にごちゃっと入ってきてしまうので、シンプルさに欠けます（こちらを好む人もいるのかもですが）。 まぁどちらも npm create で雛形生成すれば、ほぼゼロコンフィグで使えるんですが、Hello World レベルのコードで依存ファイルが多くなるのは避けたいところです。</description></item><item><title>Svelte 入門: サーバー Hooks で Basic 認証を実装する</title><link>https://maku.blog/p/mem8u54/</link><pubDate>Tue, 11 Feb 2025 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mem8u54/</guid><description>Hooks とは SvelteKit には Hooks の仕組みが提供されており、特にサーバー Hooks を定義することで、任意のリクエストに割り込んで処理を行うことができます。 例えば、各ルートのハンドラーが呼び出される前に、次のような処理を行うことができます。
リクエストのログを取る リクエストの内容を変更する（リダイレクトなど） リクエストを拒否する（アクセス制御） 後続の処理のためにデータを付加する（Cookie に基づくユーザー情報など） この記事では、サーバー Hooks の利用例として、簡単な Basic 認証 を実装する方法を解説します。
図: Chrome の Basic 認証ダイアログ 管理者にしかアクセスできないページを手っ取り早く作りたい場合などに便利ですが、Basic 認証はセキュアな認証方式ではないので、あくまで Hooks の使い方の例と考えてください。 本番環境に認証・認可の仕組みを導入する場合は、OAuth などのよりセキュアな方式を検討してください。
サーバー Hooks の基本 サーバー Hooks を定義するのはとても簡単で、SvelteKit のプロジェクト内に src/hooks.server.ts（あるいは .js）を作成し、handle 関数をエクスポートするだけです。 ファイル名を間違えると、Hooks が正しく動作しないので注意してください（特に hook でなく hooks であることに注意）。
次の サーバー Hooks 実装では、リクエストイベントの内容をコンソールに出力しています。
src/hooks.server.ts import type { Handle } from &amp;#39;@sveltejs/kit&amp;#39;; export const handle: Handle = async ({ event, resolve }) =&amp;gt; { console.</description></item><item><title>Svelte 入門: 外部 API 用のキーを Private な環境変数で定義する ($env)</title><link>https://maku.blog/p/nmdte68/</link><pubDate>Sun, 09 Feb 2025 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nmdte68/</guid><description>何をするか？ Svelte (+SvelteKit) を使ったアプリケーションから、API キーが必要な外部サービスを呼び出す方法を紹介します。 例えば、サードパーティ API や、データベースサーバーにアクセスするときには、API キーが必要になることがあります。 API キーはクライアントサイドからは見えてはいけないので、プライベートな環境変数として定義し、サーバー側で実行されるコードからのみ参照するようにします。
Private 環境変数 Svelte アプリでは、PUBLIC_ というプレフィックスが付いている環境変数は Public な環境変数、それ以外は Private な環境変数として扱われます。 つまり、環境変数名に PUBLIC_ を付けなければ、サーバーサイドで実行されるコード（+page.server.ts や +server.ts）からのみ参照できるようになります。
本番環境用の環境変数は、デプロイ先のサービス上（Cloudflare Pages や Vercel）で設定する必要がありますが、開発サーバーで使用する環境変数は、.env ファイルで定義しておくことができます。
.env MY_API_KEY=&amp;#34;c3ytex9bsyed9zjgnbxhk2hninmd&amp;#34; .env ファイルには、API キーなどの機密情報を記述することになるため、Git などのバージョン管理ツールにコミットしてはいけません（おそらく .gitignore に .env ファイルが登録されているはずです）。 Git にコミットするのは、次のような参考ファイルだけにしておきます。
.env.example MY_API_KEY=&amp;#34;XXXXX&amp;#34; アプリ実行時に Private な環境変数を参照するには、SvelteKit が提供する $env/dynamic/private モジュールを使います。
src/routes/lib/server/sample.ts import { env } from &amp;#39;$env/dynamic/private&amp;#39;; // ... console.log(env.MY_API_KEY); これに似たモジュールに $env/static/private がありますが、こちらは名前の通り、ビルド時に（static に）環境変数の値を参照することになります。 多くのケースでは dynamic の方を使うことになると思いますが、環境に応じて使い分けてください。
モジュール 環境変数の参照タイミング $env/static/private ビルド時に 環境変数を参照する。 $env/dynamic/private 実行時に 環境変数を参照する。 例えば、GitHub Actions でビルドして Cloudflare Pages にデプロイするようなケースでは、static の方を使った場合は GitHub Actions の環境変数が参照され、dynamic の方を使った場合は Cloudflare Pages の環境変数が参照されることになります。</description></item><item><title>Svelte 実装例: Web ブラウザで音声認識する (SpeechRecognition)</title><link>https://maku.blog/p/bf4cpjx/</link><pubDate>Wed, 31 Jul 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bf4cpjx/</guid><description>何をするか？ Web ブラウザーの SpeechRecognition API を使って、音声認識をしてみます。 ここでは Svelte アプリケーションとして作成しますが、単純な HTML + JavaScript の組み合わせでもほぼ同様のコードになると思います（参考: Svelte 関連メモ）。
デモ: https://p-bf4cpjx-svelte-speech-recognition.vercel.app/ ソースコード: https://github.com/maku77/p-bf4cpjx-svelte-speech-recognition/ プロジェクトの準備 Svelte (SvelteKit) のプロジェクトがない場合は最初に作成しておきます。
プロジェクトの作成 $ npm create svelte@latest myapp (選択肢が表示されたら TypeScript を選択しておく） $ cd myapp $ npm install SpeechRecognition はブラウザ標準の API として策定されているものですが、TypeScript の型情報が認識されなかったので DefinitelyTyped で提供されている型情報 @types/dom-speech-recognition をインストールしておきます。
型情報のインストール $ npm install --save-dev @types/dom-speech-recognition これで、window.SpeechRecognition コンストラクタや、SpeechRecognitionResult などの各型情報を参照できるようになります。
SpeechRecognition の使い方 SpeechRecognition による音声認識の基本的な流れは次のようになります。
SpeechRecognition インスタンスを生成して、各種パラメーターを設定する。 SpeechRecognition.onresult プロパティに、認識結果を受け取るためのコールバック関数を設定する。 SpeechRecognition.start() でマイクからの音声キャプチャと音声認識を開始する。 SpeechRecognition インスタンスの生成 まず、SpeechRecognition インスタンスを生成して、各種パラメータを設定していきます。 次のような感じで関数化しておくと分かりやすいです。</description></item><item><title>Svelte 実装例: MediaPipe で Web カメラ映像をジェスチャー認識する</title><link>https://maku.blog/p/pqmxxqz/</link><pubDate>Sun, 30 Jun 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pqmxxqz/</guid><description>何をするか？ 図: Svelte &amp;#43; MediaPipe によるジェスチャー認識 MediaPipe を使った Svelte アプリを作ってみます。 MediaPipe は様々なメディアの認識処理に対応していますが、ここでは Web カメラからの入力映像を使ったジェスチャー認識を行います。 MediaPipe を使った Web アプリは、Web ブラウザだけで動作するので、静的な Web サイトとしてホスティングすることができます（参考: Svelte アプリを静的サイトとしてビルドする）。
プロジェクトの作成 まずは空っぽの Svelte プロジェクトを新規作成します。
$ npm create svelte@latest myapp （種類として Skeleton、TypeScript を選択） 続いて、必要なライブラリをインストールしておきます。 MediaType ではタスク別に使用するモジュールが分かれており、視覚系のタスクには @mediapipe/tasks-vision モジュールを使用します。
@mediapipe/tasks-vision &amp;hellip; 視覚（画像／動画）系タスク ← 今回はコレを使う @mediapipe/tasks-genai &amp;hellip; 生成 AI (LLM) 系タスク @mediapipe/tasks-text &amp;hellip; テキスト系タスク @mediapipe/tasks-audio &amp;hellip; 音声系タスク Svelte アプリで依存ライブラリを追加するときは devDependencies として追加すれば OK です。
$ cd myapp $ npm install -D @mediapipe/tasks-vision Web カメラからの入力映像を表示する MediaPipe を使った認識処理の前に、Web カメラからの入力映像を画面上に表示できるようにしておきましょう。 そのためには、HTML の video 要素に、Web カメラからの入力 (MediaStream) を関連付ける必要があります。</description></item><item><title>Svelte 実装例: テキストフィールドと URL のクエリ文字列を同期させる</title><link>https://maku.blog/p/uy89x6s/</link><pubDate>Tue, 12 Mar 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uy89x6s/</guid><description>Web サイトに検索用のテキストフィールドなどを配置する場合、入力内容と URL のクエリパラメーターを同期させると、ブラウザのブックマークなどで入力内容を保存することができます。
図: input 要素とクエリパラメーターの同期 Svelte での実装例 下記は input 要素を 1 つだけ持つシンプルな Svelte ページコンポーネントの例です。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import { onMount } from &amp;#39;svelte&amp;#39;; import { page } from &amp;#39;$app/stores&amp;#39;; import { replaceState } from &amp;#39;$app/navigation&amp;#39;; /** 入力フィールドのテキスト */ let query = &amp;#39;&amp;#39;; // マウント時に URL のクエリパラメーターを取得し、入力フィールドの内容 (query) として反映する。 onMount(() =&amp;gt; { const params = $page.url.searchParams; query = params.get(&amp;#39;q&amp;#39;) ?? &amp;#39;&amp;#39;; }); /** 入力フィールドの内容 (query) に合わせて URL のクエリパラメーターを変更する。 */ function updateUrl() { const url = $page.</description></item><item><title>Svelte 実装例: チャットボット用の UI を作る</title><link>https://maku.blog/p/t6f8b4s/</link><pubDate>Mon, 11 Mar 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t6f8b4s/</guid><description>図: Svelte によるチャットボット用 UI の実装例 Svelte で ChatGPT のようなチャットボット UI を作るときの実装例です。 UI ライブラリなどを使わずに、プレーンな Svelte (+SvelteKit) だけで実装しています。 シンプルなチャットボットを作りたいときに参考になるかもしれません。
ソースコード（GitHub リポジトリ） デモサイト (Cloudflare Pages) 実際にはボットサーバーは存在しないので、ユーザーの入力したテキストを 1 秒後にオウム返しする関数を作っています。 下記のトップページ (+page.svelte) で呼び出している sendMessageToBot() 関数がそれです。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import &amp;#39;./global.css&amp;#39;; import { sendMessageToBot } from &amp;#39;$lib/utils&amp;#39;; import Chat, { type ChatBubbleData } from &amp;#39;$lib/Chat/Chat.svelte&amp;#39;; /** 表示する会話の内容（ユーザーと Bot のメッセージのリスト） */ let bubbles: ChatBubbleData[] = []; /** * ユーザーがメッセージを入力し終わったときに呼ばれるコールバック関数です。 * * ユーザーの入力内容は直ちにチャットバブルとして表示し、ボットに入力内容を送ります。 * ボットからの応答が返ってきたときに、その内容をチャットバブルとして表示します。 */ async function handleSend(userMessage: string): Promise&amp;lt;void&amp;gt; { bubbles = [.</description></item><item><title>Svelte 入門: Svelte コンポーネントからイベントを発生させる</title><link>https://maku.blog/p/6d8gjyg/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6d8gjyg/</guid><description>Svelte コンポーネント内で発生するイベント（ボタンクリックなど）を親コンポーネントでハンドルできるようにすると、親子コンポーネント間で連携が可能になります（コンポーネント内の値そのものを bind プロパティで連携させる方法もあります）。
イベントをそのまま伝搬させる方法 Svelte が提供する HTML 要素は、on:イベント名 というプロパティでそのイベントを補足するためのハンドラー関数を設定できるようになっています（例: &amp;lt;button on:click={handleClick}&amp;gt;）。 イベントハンドラーを指定せずに on:イベント名 というプロパティだけを指定した場合は、そのイベントがそのまま親コンポーネントに伝搬されます。 次の MyButton コンポーネントは、button 要素で発生する click イベントを伝搬させています。
src/lib/MyButton.svelte &amp;lt;button on:click&amp;gt;MyButton&amp;lt;/button&amp;gt; この click イベントは、親コンポーネントから次のようにハンドルすることができます。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import MyButton from &amp;#39;$lib/MyButton.svelte&amp;#39;; function handleClick() { alert(&amp;#39;Clicked!&amp;#39;); } &amp;lt;/script&amp;gt; &amp;lt;MyButton on:click={handleClick} /&amp;gt; シンプルですね！ でもこれだとあまり汎用性がありません。
独自のインベントをディスパッチする方法 Svelte コンポーネントから独自のイベントをディスパッチするには、createEventDispatcher() 関数で作成したディスパッチ関数を呼び出します。 ディスパッチ関数の第 1 引数はイベント名で、必要があれば第 2 引数で送信するデータを指定します。
次の MyPrompt コンポーネントは、ユーザーメッセージの入力エリアと、送信ボタンを備えたコンポーネントです（チャットの入力エリアのようなイメージです）。 送信ボタンを押すと、ユーザーが入力したメッセージと一意の ID を、独自の send イベントとしてディスパッチします。
src/lib/MyPrompt.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import { createEventDispatcher } from &amp;#39;svelte&amp;#39;; let message = &amp;#39;&amp;#39;; // ユーザーが入力したテキスト let messageId = 0; // 一意の ID // イベントディスパッチャーを作成（イベント名とデータ型のペアを並べる） const dispatch = createEventDispatcher&amp;lt;{ send: { message: string; messageId: number }; // &amp;#34;send&amp;#34; イベントの定義 }&amp;gt;(); function handleSubmit() { if (message) { dispatch(&amp;#39;send&amp;#39;, { message, messageId }); // イベントを送信 message = &amp;#39;&amp;#39;; // ユーザーが入力したテキストをクリア messageId += 1; // ID を更新 } } &amp;lt;/script&amp;gt; &amp;lt;form on:submit|preventDefault={handleSubmit}&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; bind:value={message} placeholder=&amp;#34;Write a message.</description></item><item><title>Svelte 入門: 開発サーバーで動作中かどうかを調べる (dev)</title><link>https://maku.blog/p/wu4bn29/</link><pubDate>Sat, 04 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wu4bn29/</guid><description>SvelteKit の $app/environment モジュールが提供する dev 変数 (boolean) の値を見ると、開発サーバー (npm run dev) で動作しているかどうかを調べることができます。 このフラグを利用することで、次のように開発環境と本番環境における振る舞いを切り替えることができます。
開発環境と本番環境で、異なる API エンドポイントに接続する 開発環境で動作しているときは、作成途中のコンポーネントを表示する 次の Svelte コンポーネントでは、dev 変数の値に応じて処理を分岐しています。
&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import { dev } from &amp;#39;$app/environment&amp;#39;; let envName = dev ? &amp;#39;開発環境&amp;#39; : &amp;#39;本番環境&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;p&amp;gt;現在&amp;lt;b&amp;gt;{envName}&amp;lt;/b&amp;gt;で動作しています。&amp;lt;/p&amp;gt; {#if dev} &amp;lt;p&amp;gt;このメッセージは&amp;lt;b&amp;gt;開発環境&amp;lt;/b&amp;gt;でのみ表示されます。&amp;lt;/p&amp;gt; {:else} &amp;lt;p&amp;gt;このメッセージは&amp;lt;b&amp;gt;本番環境&amp;lt;/b&amp;gt;でのみ表示されます。&amp;lt;/p&amp;gt; {/if} npm run dev による開発サーバー上で実行しているときは次のように出力されます。
&amp;lt;p&amp;gt;現在&amp;lt;b&amp;gt;開発環境&amp;lt;/b&amp;gt;で動作しています。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;このメッセージは&amp;lt;b&amp;gt;開発環境&amp;lt;/b&amp;gt;でのみ表示されます。&amp;lt;/p&amp;gt; npm run build でビルドし、npm run preview でプレビュー用サーバーを起動した場合は次のように出力されます。
&amp;lt;p&amp;gt;現在&amp;lt;b&amp;gt;本番環境&amp;lt;/b&amp;gt;で動作しています。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;このメッセージは&amp;lt;b&amp;gt;本番環境&amp;lt;/b&amp;gt;でのみ表示されます。&amp;lt;/p&amp;gt;</description></item><item><title>Svelte 入門: SvelteKit を使ったプロジェクトのディレクトリ構成／コーディングルールなど</title><link>https://maku.blog/p/69urn22/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/69urn22/</guid><description>Svelte/SvelteKit を使用したプロジェクトのディレクトリ構成やファイル名などのルールのまとめです。 これはひとつの案なので、具体的なルールはプロジェクトごとに決めてください。
SvelteKit のようなファイルベースのルーティングを採用したフレームワークでは、プロジェクトの構成は大体決まったものになるのですが、それでも細かい部分では独自のルールを採用することが多いと思います。 プロジェクトごとに定義したルールは、GitHub リポジトリの README.md あたりに記述しておくとよいです。
ディレクトリ構成 下記のプロジェクト構造は、SvelteKit 本家の Project structure • Docs • SvelteKit からの抜粋です。
my-project/ ├ src/ │ ├ lib/ │ │ ├ server/ │ │ │ └ [your server-only lib files] │ │ └ [your lib files] │ ├ params/ │ │ └ [your param matchers] │ ├ routes/ │ │ └ [your routes] │ ├ app.html │ ├ error.html │ ├ hooks.client.js │ ├ hooks.</description></item><item><title>Svelte 入門: SvelteKit の load 関数でデータのロード処理を定義する</title><link>https://maku.blog/p/wqt76qw/</link><pubDate>Tue, 31 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wqt76qw/</guid><description>load 関数の基本 SvelteKit には、+pages.ts や +pages.server.ts といった、特殊なルートファイルにデータのロード処理を定義する仕組みが用意されています。 ページコンポーネント (+page.svelte) の UI 実装からデータのロード処理を分離することで、データの取得タイミングを細かく制御できるようになり、以下のような恩恵を得られます。
サーバーサイドレンダリング (SSR) ビルド時に外部データを使ってページを生成することができます。 静的な HTML を配信することは、SEO の観点で有利に働く可能性があります。 外部 API の呼び出しにアクセストークンが必要な場合は、サーバーサイドでのみ呼び出すようにすることで、アクセストークンを公開せずに済みます。 プリロード SvelteKit は、リンクホバーなどをトリガーにして、ページ遷移前にデータをプリロードすることができます。 ロード処理の使い回し layout.js(.ts) や layout.server.js(.ts) にデータのロード処理を記述することで、そのレイアウトが適用される複数のページから同じデータを参照できます。 データのロード処理は、決められた名前のルートファイルで、load という名前の関数を export することで定義します（Promise を返す async 関数として定義することも可能です）。 load 関数から return した値は、ページコンポーネント内から data という変数で参照することができます。 この対応付けは SvelteKit のルールであり、慣れるしかありません（逆にこの作法を知らないとコードを読めません）。
図: data 変数と load 関数の関係 load 関数は、ユーザー操作によってインタラクティブに情報を取得するためのものというよりは、あくまでページの初期表示内容を取得するためのものだと考えるとよいです。
load 関数は、src/routes ディレクトリ以下に配置する次のようなファイルに定義することができ、それぞれ呼び出されるタイミング（サーバーサイド (SSR) or クライアントサイド (CSR)）や、適用範囲が異なっています。
ファイル名 CSR SSR 注釈 適用範囲 +page.js(.ts) ✅ ✅※ ※ export const ssr = false と記述した場合はクライアントサイドでのみ呼び出されます。 同一ディレクトリの +page.</description></item><item><title>Svelte 実装例: インクリメンタルサーチによる頻繁な API 呼び出しを防ぐ debounce 処理</title><link>https://maku.blog/p/c3ckhdf/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c3ckhdf/</guid><description>debounce 処理とは Web アプリケーションにインクリメンタルサーチの機能を組み込む際、検索 API の頻繁な呼び出しが課題となることがあります。 たとえば、&amp;ldquo;abcde&amp;rdquo; というキーワードで検索したいときに、&amp;ldquo;a&amp;rdquo; → &amp;ldquo;ab&amp;rdquo; → &amp;ldquo;abc&amp;rdquo; のように 1 文字入力するたびに API 呼び出しが走ると検索サーバーに負荷がかかってしまいます。
このような場合に、最後のユーザー入力から一定時間待つ debounce 処理を入れます。 次の Svelte コンポーネントでは、入力エリアでキーボード入力するたびに handleKeyUp 関数を呼び出していますが、入力内容を query 変数に反映するのを 1 秒間待つようにしています。
debounce 処理 &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; let query = &amp;#39;&amp;#39;; // クエリ文字列（この値が変化したらサーチ API を呼び出す想定） let timeoutId: number; // debounce 処理用のタイマー ID const handleKeyUp = (event: KeyboardEvent) =&amp;gt; { // リアルタイムなユーザー入力テキスト const text: string = (event.target as HTMLInputElement).value; // query 変数への代入はユーザー入力が終わってから 1 秒後に行う（debounce 処理） clearTimeout(timeoutId); timeoutId = setTimeout(() =&amp;gt; { query = text; }, 1000); }; &amp;lt;/script&amp;gt; &amp;lt;input on:keyup={handleKeyUp} /&amp;gt; &amp;lt;p&amp;gt;query: {query}&amp;lt;/p&amp;gt; こうすることで、ユーザーが一連のテキストを入力し終わったタイミングで、一度だけ検索 API を呼び出すことができるようになります（もちろん、1 秒以上の間隔を上げずにキーボード入力がされた場合ですが）。</description></item><item><title>Svelte 入門: YAML ファイルをインポートして使う</title><link>https://maku.blog/p/umhwooq/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/umhwooq/</guid><description>Svelte で YAML ファイルをインポートして使う方法 Svelte (SvelteKit) には YAML ファイルを直接インポートして JavaScript オブジェクトして扱う仕組みはありませんが、raw インポートの仕組みを使えば、YAML ファイルを文字列データとしてそのまま読み込むことができます（これは SvelteKit がビルドに使っている Vite の仕組みです）。
YAML ファイルを文字列としてインポートする import gamesYaml from &amp;#39;$lib/assets/games.yaml?raw&amp;#39; このようにして読み込んだ YAML テキストを、Node.js の YAML ライブラリなどでパースすれば、YAML ファイルの内容を JavaScript オブジェクトとして扱うことができます。 ビルド時に処理を完結させることができるので、例えば、static-adapter を使った静的ビルド (SSG) が必要な環境でも利用できます。
実装例 YAML ファイルを扱うために js-yaml ライブラリを使うので、次のようにしてインストールしておきます。
js-yaml（およびその型ファイル）のインストール $ npm install --save-dev js-yaml @types/js-yaml サンプルの YAML ファイルとして、下記のようなゲームソフト情報を含んだ games.yaml を使います。 この YAML ファイルはビルド時にインポートするので、static ディレクトリではなく src ディレクトリのどこかに配置します（ここでは、lib/assets というディレクトリに配置しています）。
src/lib/assets/games.yaml - title: シャドウラン date: 1996-02-23 price: 7800 - title: トムキャットアレイ date: 1994-12-22 price: 7800 - title: 真・女神転生 date: 1994-02-25 次の Svelte コンポーネントでは、ビルド時に YAML ファイルを読み込んで、JavaScript オブジェクトと扱えるようにしていします。 実装には TypeScript を使っていますが、raw インポートした YAML ファイルからは型情報を推測してくれないようなので、自分で Game 型を定義しています。</description></item><item><title>Svelte 入門: JSON ファイルをインポートして使う</title><link>https://maku.blog/p/pzrza7m/</link><pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pzrza7m/</guid><description>Svelte (SvelteKit) アプリ内の Svelte コンポーネントや JavaScript/TypeScript ライブラリでは、JSON ファイルを import 文で簡単に読み込めるようになっています（正確には Vite の Static Asset Handling の仕組みを利用しています）。
ここでは、サンプルデータとして下記のようなゲームソフト情報を含んだ JSON ファイルを用意します。 この JSON ファイルはビルド時にインポートするので、static ディレクトリではなく src ディレクトリのどこかに配置します（ここでは、lib/assets というディレクトリに配置しています）。
src/lib/assets/games.json [ { &amp;#34;title&amp;#34;: &amp;#34;シャドウラン&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1996-02-23&amp;#34;, &amp;#34;price&amp;#34;: 7800 }, { &amp;#34;title&amp;#34;: &amp;#34;トムキャットアレイ&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1994-12-22&amp;#34;, &amp;#34;price&amp;#34;: 7800 }, { &amp;#34;title&amp;#34;: &amp;#34;真・女神転生&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1994-02-25&amp;#34; } ] このファイルを Svelte コンポーネントから直接インポートしてもよいのですが、次のように明示的に TypeScript の型情報を付加するライブラリでラップしておくと便利かもしれません。
src/lib/games.ts import rawJson from &amp;#39;$lib/assets/games.json&amp;#39;; /** ゲームソフトの情報 */ export type Game = { /** ゲームタイトル */ title: string; /** 発売日 */ date: string; /** 価格 */ price?</description></item><item><title>Svelte 入門: Svelte アプリを完全な静的サイトとしてビルドする (SSG: Static Site Generation)</title><link>https://maku.blog/p/4oudmxy/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4oudmxy/</guid><description>何をするか？ Svelte/SvelteKit を使ったプロジェクト全体を、完全な静的リソースの形にビルドする SSG (Static Site Genration) 機能の使い方について説明します。 AWS の S3 ストレージのようなファイルの配信機能しか持たないサービスで Web サイトをホスティングする場合、SSG によるビルドが必要になります。
ちなみに、Cloudflare Pages や Vercel のようなモダンなホスティングサービス上で Svelte アプリをビルドする場合は、このような設定は一切行わずにデプロイすることができます（ゼロコンフィグ）。 できればそういったサービスを使うことを推奨しますが、ここでは何らかの事情でそういった便利なサービスを使用できないケースを想定しています（会社のポリシーで S3 しか使えないなど）。
SvelteKit の SSG 設定 adapter-static のインストール SvelteKit の @sveltejs/adapter-static というモジュールが SSG 機能を提供しているので、まずはこのモジュールをインストールします。
adapter-static のインストール $ npm install --save-dev @sveltejs/adapter-static adapter-static の有効化 ビルド設定ファイル (svelte.config.js) で、adapter-static を使用するように設定します。 プロジェクトの初期状態では、次のような感じで adapter-auto というモジュールが使われるように設定されていると思います。
svelte.config.js（変更前） import adapter from &amp;#39;@sveltejs/adapter-auto&amp;#39;; import { vitePreprocess } from &amp;#39;@sveltejs/kit/vite&amp;#39;; /** @type {import(&amp;#39;@sveltejs/kit&amp;#39;).Config} */ const config = { preprocess: vitePreprocess(), kit: { adapter: adapter() } }; export default config; adapter-auto は、Vercel や Cloudflare Pages などのサービス上でビルドするときに使えるモジュールですが、SSG するときには使えないので、ここを adapter-static に置き換えてやります。</description></item><item><title>Svelte 実装例: Svelte アプリから D3.js を使う</title><link>https://maku.blog/p/7acxmwo/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7acxmwo/</guid><description>何をするか？ Svelte を使用した Web アプリケーションの中から、SVG 描画ライブラリである D3.js を使用する方法を説明します。 Svelte のプロジェクトは、npm create svelte@latest コマンドなどで既に作成されていることを前提とします。
参考: Svelte を始める (SvelteKit で Hello World） D3.js のインストール Svelte はビルド時に実装コードをバニラ JS の形にコンパイルするので、D3.js (d3) などの外部ライブラリは devDependencies としてインストールすれば OK です。 TypeScript を使う場合は、型情報の @types/d3 も一緒にインストールしておきます。
d3 モジュールと型情報をインストール $ npm install --save-dev d3 @types/d3 D3.js による描画 ここでは、次のような簡単な棒グラフを Svelte アプリ内の D3.js で描画してみます。
D3.js による棒グラフの例 D3.js の d3.select() 関数は DOM 要素を参照するため、クライアントサイド JavaScript として実行しなければいけないことに注意してください。 具体的には、Svelte の onMount() コールバック内で呼び出すようにします。 直接 d3.select() 関数を呼び出してしまうと、ReferenceError: document is not defined のようなエラーが発生します。</description></item><item><title>Svelte 実装例: Hamburger ボタンを作る</title><link>https://maku.blog/p/z5cwfjm/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z5cwfjm/</guid><description>Svelte コンポーネントによる Hamburger アイコンの実装例です。 ボタンをクリックすると open 変数の値が true になり、CSS アニメーションで×印に変化します。
図: Svelte コンポーネントによるハンバーガーアイコン src/lib/components/Hamburger.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let open = false; &amp;lt;/script&amp;gt; &amp;lt;button class:open on:click={() =&amp;gt; (open = !open)}&amp;gt; &amp;lt;svg width=&amp;#34;40&amp;#34; height=&amp;#34;40&amp;#34;&amp;gt; &amp;lt;line id=&amp;#34;top&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;10&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;line id=&amp;#34;middle&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;20&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;20&amp;#34; /&amp;gt; &amp;lt;line id=&amp;#34;bottom&amp;#34; x1=&amp;#34;9&amp;#34; y1=&amp;#34;30&amp;#34; x2=&amp;#34;31&amp;#34; y2=&amp;#34;30&amp;#34; /&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;style&amp;gt; button { display: inline-block; width: 40px; height: 40px; padding: 0; cursor: pointer; border: none; background: #333; box-shadow: inset 0 0 0 2px #cccccc; /* 内側に枠を付ける */ z-index: 20; /* （これは必要に応じて）他の要素より上に表示する */ } button:hover { background: #555; } svg line { stroke: currentColor; stroke-linecap: round; stroke-width: 3; stroke: #cccccc; transition: transform 0.</description></item><item><title>Svelte 実装例: ページ遷移用のナビゲーションメニューを作成する</title><link>https://maku.blog/p/2nrgf2m/</link><pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2nrgf2m/</guid><description>Svelte サイト内でページ遷移を行うためのナビゲーションコンポーネントの作成例です。
現在の URL（パス）の取得方法 SvelteKit の $app/stores モジュールが提供する page ストアを利用すると、現在表示中のページの URL や、その一部であるパス情報を取得することができます。 この情報を利用することで、ナビゲーションコンポーネント内のカレントページに相当する項目をハイライト表示します（この URL 情報は、パンくずリストなどでも利用できます）。
現在のページのパス情報は、次のように $page.url.pathname 参照できます。
&amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;b&amp;gt;pathname = {$page.url.pathname}&amp;lt;/b&amp;gt; ページ遷移すると、pathname の値が、/ → /about → /blog のような感じで変化します。
Nav コンポーネントの実装例 次の Svelte コンポーネント (Nav) は、サイト内でページ遷移を行うためのボタンを表示します。 現在のページに相当するボタンには、赤色の下線を表示しています。
図: Nav コンポーネントの表示 src/lib/components/Nav.svelte &amp;lt;script&amp;gt; import { page } from &amp;#39;$app/stores&amp;#39;; const pages = [ { name: &amp;#39;Home&amp;#39;, path: &amp;#39;/&amp;#39; }, { name: &amp;#39;About&amp;#39;, path: &amp;#39;/about&amp;#39; }, { name: &amp;#39;Blog&amp;#39;, path: &amp;#39;/blog&amp;#39; } ]; &amp;lt;/script&amp;gt; &amp;lt;nav&amp;gt; {#each pages as p} {#if p.</description></item><item><title>Svelte 入門: 動的に class 属性を off/on する</title><link>https://maku.blog/p/x3vpkn4/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/x3vpkn4/</guid><description>HTML 要素の class 属性の値を動的に変化させることで、スタイルの切り替えをしたいことはよくあります。 ナビゲーションメニューで、現在表示しているページをハイライトするのは典型的な例です。
ここでは、ボタンを押すことで Off/On できる簡単なランプ (Lamp) コンポーネントを作ってみます。
図: class 属性の変更による表示切り替え Lamp.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; let active = false; // ランプの On/Off 状態 function toggle() { active = !active; } &amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;lamp {active ? &amp;#39;active&amp;#39; : &amp;#39;&amp;#39;}&amp;#34; /&amp;gt; &amp;lt;button on:click={toggle}&amp;gt; {#if active}OFF{:else}ON{/if} &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; align-items: center; gap: 0.5rem; } .lamp { display: inline-block; width: 30px; height: 30px; box-sizing: border-box; border: 4px ridge rgba(0, 0, 0, 0.</description></item><item><title>Svelte 入門: 複数のページで共通のレイアウトを定義する (+layout.svelte)</title><link>https://maku.blog/p/vwyvd5x/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vwyvd5x/</guid><description>レイアウトファイル (+layout.svelte) の基本 Svelte のフレームワークである SvelteKit は、複数のページで使用する共通レイアウトを定義するための仕組みを提供しています。 共通レイアウトを定義するのは簡単で、src/routes/+layout.svelte というファイルを作成するだけで、そのレイアウトが全ページ (src/routes/**/+page.svelte) に適用されます。
src/routes/&amp;#43;layout.svelte（共通レイアウト） &amp;lt;header&amp;gt; &amp;lt;h1&amp;gt;サイト名&amp;lt;/h1&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&amp;#34;main&amp;#34;&amp;gt; &amp;lt;slot /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; header { position: fixed; top: 0; left: 0; width: 100%; padding: 1rem 1.5rem; background-color: #333; color: #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); z-index: 1000; } h1 { margin: 0; } .main { margin: 7rem 2rem 4rem 2rem; } &amp;lt;/style&amp;gt; 各ページのコンテンツは、レイアウトファイル内の &amp;lt;slot /&amp;gt; 部分に展開されます（参考: スロットの仕組み）。
実際には SvelteKit で作成したアプリケーションは、最上位のページテンプレートとして src/app.</description></item><item><title>Svelte 入門: Svelte コンポーネントに子要素を渡せるようにする (&lt;slot />)</title><link>https://maku.blog/p/gcdawrj/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gcdawrj/</guid><description>スロットの基本 &amp;lt;slot /&amp;gt; Svelte コンポーネントを使用するときに子要素として渡した内容は、Svelte コンポーネントの中から &amp;lt;slot /&amp;gt; で参照することができます。 &amp;lt;slot /&amp;gt; の仕組みは、Vue.js や Astro でも採用されています（React.js では children prop で参照します）。
次の ExtLink コンポーネントは、外部サイトへのリンクを表示するコンポーネントの実装例です。
src/lib/ExtLink.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let href: string; &amp;lt;/script&amp;gt; &amp;lt;a {href} target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;&amp;lt;slot /&amp;gt;&amp;lt;/a&amp;gt; この ExtLink コンポーネントは次のように使用します。
src/routes/&amp;#43;page.svelte &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import ExtLink from &amp;#39;$lib/ExtLink.svelte&amp;#39;; &amp;lt;/script&amp;gt; &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; &amp;lt;ExtLink href=&amp;#34;https://www.bing.com/&amp;#34;&amp;gt;Bing&amp;lt;/ExtLink&amp;gt; この例では、コンポーネント内の &amp;lt;slot /&amp;gt; という部分に Bing というテキストが展開されることになります。 よって、リンク部分は次のような HTML にコンパイルされます。
&amp;lt;a href=&amp;#34;https://www.bing.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;Bing&amp;lt;/a&amp;gt; 名前付きスロット &amp;lt;slot name=&amp;ldquo;name&amp;rdquo; /&amp;gt; 子要素を複数のパートに分けてコンポーネントに渡したいことがあります。 このような場合は、名前付きスロット という仕組みを使います。 次の Box コンポーネントは、3 つのスロットを受け取れるようにしています。</description></item></channel></rss>