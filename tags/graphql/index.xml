<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GraphQL on まくろぐ</title><link>https://maku.blog/tags/graphql/</link><description>Recent content in GraphQL on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 16 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/graphql/index.xml" rel="self" type="application/rss+xml"/><item><title>GitHub の GraphQL API Explorer の使い方</title><link>https://maku.blog/p/sk3rykz/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sk3rykz/</guid><description>GraphQL API Expolorer とは GitHub の GraphQL API (API ver.4) を使用すると、GitHub で管理されているリポジトリの情報やユーザーの情報などを、柔軟な GraphQL クエリを使って取得することができます。 しかし、いろいろなクエリ方法が用意されていて、実際にどのような情報が取得できるのかが分かりにくかったりします。 そんなとき便利なのが、GitHub が Web サイトとして用意してくれている、GraphQL API Explorer です。
GraphQL API Explorer | GitHub Developer Guide GraphQL API Explorer を使用すると、GraphQL API を使ってどのような情報を取得できるのか、実際にクエリを実行して確かめることができます。 GitHub アカウントでサインインした状態であれば、プライベートリポジトリの情報も取得することができます。 GitHub GraphQL API を利用するアプリケーションを作成するときは、このサイトでどのようなクエリを発行すればよいのかを調べながら作っていくことになると思います。
クエリエディタでは、下記のようなショートカットキーを使用することができます。
Ctrl + Space &amp;hellip; 入力補完 Ctrl + Enter &amp;hellip; 実行 History 機能と Explorer 機能 History ボタンを押すと、過去に実行したクエリをロードすることができます。 クエリに次のように名前を付けておくと、History にその名前が表示されるので、後ほど再利用する予定があれば、わかりやすい名前を付けておくとよいでしょう。
queryGetApolloRepo{repository(owner:&amp;#34;apollographql&amp;#34;,name:&amp;#34;apollo-client&amp;#34;){owner{loginurl}nameurl}} Explorer ボタンを押すと、スキーマ定義に基づいて、入力可能なフィールドをツリー形式で参照することができます（これを使うより、Ctrl + Space による補完の方が便利ですが）。</description></item><item><title>Apollo Client で GitHub GraphQL API を使う (Node &amp; React)</title><link>https://maku.blog/p/qcp2cnx/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2cnx/</guid><description>Apollo Client とは Apollo パッケージは、GraphQL を使ったクライアントアプリやサーバーを作成するためのライブラリ群です。 クライアントアプリを作るためのライブラリは、Apollo Client として @apollo/client という NPM パッケージにまとめられています。
Web アプリのコンポーネントを作成するときは React がよく使われますが、Apollo は GraphQL を扱いやすくする React コンポーネント（ApolloProvider、Query、Mutation、Subscription）や React Hook 拡張（useQuery) などを提供しています。
ここでは、Apollo Client パッケージを使用して、
Node.js アプリ（コマンドラインアプリの JS）から GraphQL API の実行 React アプリ（Web サイトの JS）から GraphQL API の実行 を行ってみます。 呼び出す GraphQL API は何でもよいのですが、今回は GitHub GraphQL API を利用することにします。
Node パッケージのインストール Apollo Client Apollo Client 関連のパッケージとしては、@apollo/client と、それが使用する graphql をインストールします。
Apollo Client のインストール ### yarn の場合 $ yarn add @apollo/client graphql ### npm の場合 $ npm install @apollo/client graphql fetch ポリフィル Apollo クライアント内部の実装では、Web ブラウザの fetch API を利用しています。 React アプリから Apollo クライアントを利用する場合は問題ないのですが、コンソールで動作する Node.</description></item><item><title>Apollo Client の fetchMore を自動で呼び出して GitHub GraphQL の100件制限を乗り越える (useAutoFetchMore)</title><link>https://maku.blog/p/w7igunc/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7igunc/</guid><description>何をするか？ GitHub の GraphQL API で Issue 情報などを取得しようとすると、リソース制限 のため一度に 100 件までの情報しか取得できません。 Apollo Client が提供する useQuery や useLazyQuery などの React フック関数を使用すると、戻り値で返される fetchMore 関数を使って追加読み込み（ページネーション処理）を行うことができますが、この関数の使用例として提示されているものは、ユーザーによるボタンクリックなどを必要とするものばかりです。 ここでは、useQuery 実行後に自動で fetchMore を繰り返し呼び出して、100 件を超える情報を取得する方法の例を示します。
fetchMore のための設定 前提として、Apollo Client の fetchMore 関数の基本的な使い方は理解しているものとします（下記記事などを参考にしてください）。
Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す 今回サンプルコードで使う GraphQL クエリには、次のような search コネクションが含まれていることを想定しています。 ページネーションの対象となるのは、この search コネクション部分です。
queryQueryIssues($cursor:String){search(type:ISSUE,first:100,after:$cursor,query:&amp;#34;...&amp;#34;){...}} そのため、ApolloClient に設定するキャッシュのフィールドポリシーとして、search フィールドの値が fetchMore 時にマージされるように設定しておきます。 cache オブジェクトの生成時に呼び出している relayStylePagination 関数あたりがポイントです。
GitHubApolloProvider.tsx import * as React from &amp;#39;react&amp;#39; import { ApolloClient, ApolloLink, ApolloProvider, createHttpLink, InMemoryCache, } from &amp;#39;@apollo/client&amp;#39; import { relayStylePagination } from &amp;#39;@apollo/client/utilities&amp;#39; import { setContext } from &amp;#39;@apollo/client/link/context&amp;#39; import { Auth } from &amp;#39;@/utils/auth&amp;#39; const httpLink = createHttpLink({ uri: &amp;#39;https://api.</description></item><item><title>Apollo CLI の codegen で GraphQL クエリレスポンスの TypeScript 型を自動生成する</title><link>https://maku.blog/p/bnrrqpn/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bnrrqpn/</guid><description>何をするか TypeScript プロジェクトにおいて、Apollo Client の useQuery フックで GraphQL クエリ呼び出しを行っていると、レスポンスの型情報が any になってしまうことに悩むことになります。 例えば、GitHub の GraphQL クエリで、次のようにログイン中のユーザー情報を取得するとします。
import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; export const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` const Viewer: FC = () =&amp;gt; { const { error, loading, data } = useQuery(QUERY_VIEWER) // ... } useQuery 関数の戻り値の data はデフォルトで any 型なので、そのままだと ESLint などに怒られることになります。
Unsafe array destructuring of a tuple element with an any value @typescript-eslint/no-unsafe-assignment</description></item><item><title>GraphQL の仕様メモ</title><link>https://maku.blog/p/jz78nmk/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jz78nmk/</guid><description>GraphQL 関連用語 クエリ文字列 (query string) query {...} という文字列全体のこと。 操作タイプ (operation type, root type) query {...} などの query というキーワード部分のこと。操作の種類を表しており、query の他には mutation と subscription があります。 操作名 (operation name) query HogeHoge {...} などの HogeHoge の部分のこと。特に query 操作の場合は query name、mutation 操作の場合は mutation name と呼ぶことがあります。操作名の指定は multi-operation documents じゃない限りオプショナルですが、ログ解析やデバッグをしやすくするために、名前を付けることが推奨されています。 クエリ変数 (query variables) query User($name: String!) {...} などの $name の部分のこと。 クエリ引数 (query arguments) book(id: &amp;quot;xyz&amp;quot;) {...} など、フィールド参照時に指定する id: &amp;quot;xyz&amp;quot; の部分のこと。クエリに変数が渡されている場合は、ここで book(id: $bookId) のような感じで参照できます。 選択セット、セレクションセット (selection sets) query HogeHoge {.</description></item><item><title>GraphQL のクエリの一部をフラグメント化して再利用する (Fragments)</title><link>https://maku.blog/p/wiv7it5/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wiv7it5/</guid><description>GraphQL のフラグメントを定義する GraphQL クエリの中で、同じようなフィールドの指定（選択セット）を複数回使用する場合、それを フラグメント (Fragment) という再利用可能な選択セットとして切り出して定義しておくことができます。
例えば次の GraphQL クエリは、GitHub から自分のユーザー情報 (viewer) と、特定のユーザーの情報 (user) を一度に取得しています。
GraphQL クエリ queryQueryTwoUsers{viewer{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}user(login:&amp;#34;ログインID&amp;#34;){loginnameurlwebsiteUrlavatarUrl}} viewer フィールドと user フィールドは、両方とも User 型 のフィールドで、しかも、上記の例では User オブジェクトの中の同じフィールドを参照しています。 明らかに冗長な書き方です。
このようなケースでは、あるオブジェクトの特定のフィールドを参照するための選択セット (selection set) を、フラグメントの形で定義することができます。 次の例では、User オブジェクトの特定のフィールドを選択するための userFragment というフラグメントを定義しています。 フラグメントを使用する場所では、...userFragment のようにドットを 3 つ付けて参照します（JavaScript のスプレッド構文と同じです）。
GraphQL クエリ queryQueryTwoUsers{viewer{...userFragment}user(login:&amp;#34;ログインID&amp;#34;){...userFragment}}fragmentuserFragmentonUser{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像} fragment の定義は、query の定義と同じ階層に記述することに注意してください。 また、on User というのは、User オブジェクトのフィールドを選択するフラグメントであることを示しており、このフラグメントは User オブジェクトのフィールド部分でしか使えません。 上記の例では、viewer も user も User 型のフィールドなので、その中で問題なく .</description></item><item><title>Apollo Client の useQuery 呼び出し部分をカスタムフックで分離する</title><link>https://maku.blog/p/kmj7sdv/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kmj7sdv/</guid><description>Apollo Client で GraphQL クエリを実行するときは、カスタムフックとして useQuery 関数の呼び出し部分を抽出すると、コンポーネント側のコードをシンプルにすることができます。
分離前のコード 次のサンプルコードでは、GraphQL クエリで GitHub のログインユーザー情報を取得して表示する Viewer コンポーネントを実装しています。 GraphQL のクエリ呼び出し部分や、取得したデータを ViewerData オブジェクトに詰める部分などが混在しており、あまり整理されているとは言えません。
components/Viewer.tsx import { FC } from &amp;#39;react&amp;#39; import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; import { LoadingComponent } from &amp;#39;./LoadingComponent&amp;#39; import styles from &amp;#39;./Viewer.scss&amp;#39; const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` type ViewerData = { /** ログインID */ login: string /** ホームページのURL */ url: string /** アバター画像のURL */ avatarUrl: string } /** 「ユーザー情報」を表示するコンポーネント */ export const Viewer: FC = () =&amp;gt; { const {loading, error, data} = useQuery(QUERY_VIEWER) if (loading) return &amp;lt;LoadingComponent /&amp;gt; const viewer: ViewerData = data.</description></item><item><title>Apollo Client でクリック時に GraphQL クエリを実行する</title><link>https://maku.blog/p/m7ju6gr/</link><pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7ju6gr/</guid><description>図: useLazyQuery による GraphQL クエリ実行 はじめに Apollo Client の useQuery フックを使用すると、GraphQL を使って取得した情報を表示する React コンポーネントをシンプルに実装することができます。 useQuery フックによる GraphQL クエリは、React コンポーネントの表示時に実行されますが、代わりに useLazyQuery フックを使用すると、任意のタイミング、例えばボタンを押した時に GraphQL クエリを実行できるようになります。
前提として、Apollo Client の useQuery の基本的な使い方は下記の記事などで理解しているものとし、ここでは、useLazyQuery フックの使い方を説明します。
参考: Apollo Client で GitHub GraphQL API を使う (Node &amp;amp; React)&amp;quot; useQuery と useLazyQuery の違い 下記の抜粋コードは、useQuery 関数と useLazyQuery 関数の使い方の違いを表しています。
// const GET_ISSUES = gql`...`; const {loading, error, data} = useQuery(GET_ISSUES); const [getIssues, {loading, error, data}] = useLazyQuery(GET_ISSUES); useQuery 関数は呼び出し直後に GraphQL クエリが実行され、その状態や結果が直ちに loading、error、data といった戻り値に格納されます。 一方 useLazyQuery 関数の場合は、戻り値の最初の要素として、クエリ実行関数が返されます（上記の例では getIssues にしてるけど、変数名は executeQuery とか何でも OK）。 GraphQL クエリを実行するには、このクエリ実行関数を呼び出す必要があるので、例えば次のようにボタン要素の onClick で呼び出すようにしておきます。 あとは、useQuery 関数の使い方と同様です。</description></item><item><title>Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す</title><link>https://maku.blog/p/cu6eox7/</link><pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cu6eox7/</guid><description>Apollo Client の Pagination 機能 GraphQL API では柔軟なクエリ発行が可能ですが、多数の要素を取得する場合は、Pagenation 処理 により何度かに分けて API 呼び出しを行う必要があります。 例えば、GitHub の GraphQL API では一度のクエリで取得可能な要素数は 100 件までであり、それを超える情報を取得する場合に Pagination 処理が必要です。
Apollo Client には、GraphQL の Pagination 処理を簡単に扱うための仕組み（fetchMore 関数）が用意されています。
参考: Pagination - Client (React) - Apollo GraphQL Docs と言っても、そこまで簡単ではないので、ここでは GitHub の GraphQL API における Pagination 処理の具体的な実装例を紹介します。
Pagination の実装例（フィールドポリシーを使う方法） 次のサンプルコードは、GitHub の myorg/myrepo リポジトリの Issue リストを表示する IssueList コンポーネントの実装例です。 Issue の数が 100 件を超える場合は、「さらに読み込む」ボタンを表示し、このボタンが押されたときに Pagination 処理（fetchMore 関数）で次のデータを取得するようにしています。
Apollo クライアントの useQuery 関数が返す fetchMore 関数を呼び出すと、再度 GraphQL クエリを実行することができます。 このとき、オプションで variables パラメータの値（クエリ変数）を変更できるので、Issue の読み出し開始位置を示す after の値を進めていくことで、100 件を超えるデータを順番に読み出すことができます。</description></item><item><title>GitHub GraphQL クエリ例: マイルストーン情報を取得する (milestone)</title><link>https://maku.blog/p/fdnpuro/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fdnpuro/</guid><description>マイルストーン番号で Milestone オブジェクトを取得する リポジトリ名（組織名/リポジトリ名）が分かっている場合は、repository クエリ で取得した Repository オブジェクト の milestone フィールドに マイルストーン番号 を指定することで、そのマイルストーンの Milestone オブジェクト を取得することができます。 例えば、Web アプリなどでは、/milestone/123 のようなパスで指定したマイルストーンの情報を表示したいことがありますが、このようなケースで 123 という番号を使って情報を取得することができます。
記述中
GraphQL クエリ query{repository(owner:&amp;#34;myorg&amp;#34;,name:&amp;#34;myrepo&amp;#34;){milestone(number:123){numbertitledueOndescriptionurlissues(first:100){nodes{numbertitleclosedurl}}}}} マイルストーンが設定されていないイシューを取得する search クエリ で、Issue や PullRequest を検索するときに、query パラメータで渡す文字列に no:milestone を含めると、マイルストーンの設定されていないものだけを検索することができます。
次の例では、myorg/myrepo リポジトリにおいて、マイルストーンの設定されていない Issue の一覧を取得しています（query 引数に is:issue を含めることで、PullRequest まで取得されてしまうのを防いでいます）。
GraphQL クエリ query{rateLimit{costremaining}search(type:ISSUE,last:100,query:&amp;#34;repo:myorg/myrepo is:issue no:milestone&amp;#34;){nodes{...onIssue{numbertitleclosedurlassignees(first:100){nodes{loginavatarUrlurl}}labels(first:100){nodes{namecolor}}}}}} no:milestone の他にも、no:label（ラベルのないもの）、no:assignee（アサインされていないもの）、といった条件で検索することができます。
参考: 欠損しているメタデータで検索 - GitHub Docs あるリポジトリのマイルストーンの一覧を取得する → こちらを参照</description></item><item><title>GitHub GraphQL クエリ例: PullRequest の情報を取得する (search)</title><link>https://maku.blog/p/z69a3tk/</link><pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z69a3tk/</guid><description>自分のレビュー待ちになっている PR を取得する search クエリの query パラメータで、is:pr review-requested:@me と指定すると、自分がレビューワー (reviewer) として設定されているプルリクエストを検索することができます。
GraphQL クエリ query{search(type:ISSUE,last:100,query:&amp;#34;is:open is:pr review-requested:@me&amp;#34;){issueCountnodes{...onPullRequest{numbertitleurlcreatedAtauthor{loginavatarUrlurl}reviewRequests(first:100){nodes{requestedReviewer{...onUser{loginavatarUrlurl}}}}}}}} PullRequest オブジェクトの詳細はこちら。</description></item><item><title>GitHub GraphQL クエリ例: イシュー情報を取得する (search)</title><link>https://maku.blog/p/i5ht5ep/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i5ht5ep/</guid><description>イシュー情報の取得方法 イシュー情報を取得する方法は次のような方法があります。
ユーザーからたどる方法 &amp;ndash; viewer/user クエリ で User オブジェクト を取得し、そのユーザーに関連するイシュー（issues フィールド）を参照する方法 リポジトリからたどる方法 &amp;ndash; repository クエリ で Repository オブジェクト を取得し、そのリポジトリ内のイシュー（issues フィールド）を参照する方法 ダイレクトに検索する方法 &amp;ndash; search クエリ でもろもろの検索条件（リポジトリ名、タイプなど）を使ってダイレクトに検索する方法 search クエリによる検索はとても柔軟で、様々な条件（query パラメータ）を指定してイシューを検索することができます。 query パラメータには、GitHub の Issues ページの検索窓に入力できる is:issue is:open といった文字列で、下記のサイトに詳細仕様が記述されています。
Issue およびプルリクエストを検索する - GitHub Docs あるリポジトリのイシューの一覧を取得する 次の GraphQL クエリでは、myorg/myrepo リポジトリの最新 5 件のイシュー情報を取得しています。
GraphQL クエリ query{search(type:ISSUE,query:&amp;#34;repo:myorg/myrepo is:issue&amp;#34;,last:100){issueCountnodes{...onIssue{idnumbertitleclosedurlauthor{login}assignees(first:100){nodes{loginnameemail}}labels(first:100){nodes{namecolor}}}}}} search クエリはそのパラメータの意味を理解するのが重要です。
type: ISSUE 検索対象を示す必須パラメータで、ISSUE / REPOSITORY / USER のいずれかを指定する必要があります。ここでは、イシューやプルリクエストの情報を検索することを示しています（ISSUE はプルリクエストの情報まで含むことに注意）。 query: &amp;quot;repo:myorg/myrepo is:issue&amp;quot; 検索対象を指定したリポジトリに絞り込み、さらに、is:issue を指定することでプルリクエストを除外します。他にもいろいろな指定方法があります。 last: 100 最新の 100 件までのイシュー情報を取得します。100 件を超えるデータを取得するときはページネーション処理により、複数回のクエリ実行が必要です。 その他のクエリ方法いろいろ あるマイルストーンが設定されたイシューを取得する search(type:ISSUE,last:100,query:&amp;#34;repo:myorg/myrepo milestone: \&amp;#34;Milestone #123\&amp;#34; is:issue&amp;#34;) この例では、myorg/myrepo リポジトリから、マイルストーン名 Milestone #123 が設定されたイシューの一覧を取得しています。 マイルストーン名にスペースを含んでいる場合は、上記のようにエスケープされたダブルクォートでマイルストーン名を囲む必要があります。</description></item><item><title>GitHub GraphQL クエリ例: リポジトリの情報を取得する (repository)</title><link>https://maku.blog/p/du6env5/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/du6env5/</guid><description>GitHub の GraphQL API を使ってリポジトリの情報を取得するには、次のような方法があります。
repository クエリ &amp;hellip; 組織名（あるいはユーザ名）とリポジトリ名が分かっている場合 organization クエリ &amp;hellip; ある組織内のリポジトリの一覧を取得する場合（こちらの記事 を参考にしてください） search クエリ &amp;hellip; 汎用的な検索用クエリ でリポジトリを検索する search クエリでリポジトリを検索する 特定の組織 (organization) 内のリポジトリを取得するには、organization クエリを使って 得られた Organization オブジェクトの repositories を参照する方法もありますが、最初から search クエリを使っていろいろな条件を指定して検索する方が早いです。
参考: リポジトリを検索する - GitHub Docs 次の例では、myorg という組織内の、product というトピックの付けられたリポジトリの一覧を取得しています。
クエリ例 query{search(type:REPOSITORY,query:&amp;#34;org:myorg topic:product&amp;#34;,last:100){repositoryCountnodes{...onRepository{idurlnamedescriptioncreatedAt}}}} 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;search&amp;#34;: { &amp;#34;repositoryCount&amp;#34;: 3, &amp;#34;nodes&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;DEMwOlJlcG9zaXRvcnkzODA5MTQ0OQ==&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/myorg/Repo1&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Repo1&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Repo1 の概要説明&amp;#34;, &amp;#34;createdAt&amp;#34;: &amp;#34;2015-06-26T04:54:51Z&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;DEMwOlJlcG9zaXRvcnkxNjI2NjczMjY=&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.</description></item><item><title>GitHub GraphQL クエリ例: 組織の情報を取得する (organization)</title><link>https://maku.blog/p/3o2doyb/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3o2doyb/</guid><description>GitHub GraphQL API で指定した組織の情報を（ここでは github organization）の情報を取得には、organization クエリ を使用します。 organization クエリには、login パラメーターで組織名を渡します。
organization クエリが返す Organization オブジェクト を参照すると、そこに所属する メンバーの一覧、チームの一覧、リポジトリの一覧 などを取得することができます。
ある組織に所属するユーザー情報を取得する (Organization.membersWithRole) Organization オブジェクトの membersWithRole フィールドは OrganizationMemberConnection オブジェクトを保持しており、この nodes を参照することで、組織に所属するメンバーの一覧を取得できます。
GraphQL クエリ query{organization(login:&amp;#34;github&amp;#34;){namedescriptionurlmembersWithRole(first:3){nodes{nameemailupdatedAt}}}} 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;organization&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;GitHub&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;How people build software.&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/github&amp;#34;, &amp;#34;membersWithRole&amp;#34;: { &amp;#34;nodes&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Josh Nichols&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;technicalpickles@github.com&amp;#34;, &amp;#34;updatedAt&amp;#34;: &amp;#34;2020-09-09T11:22:35Z&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;Matt Todd&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;matt@github.com&amp;#34;, &amp;#34;updatedAt&amp;#34;: &amp;#34;2020-09-02T21:54:56Z&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;Pat Nakajima&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;patnakajima@gmail.</description></item><item><title>Node.js で GitHub GraphQL API を使用する (@octokit/graphql)</title><link>https://maku.blog/p/h5s6ht5/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h5s6ht5/</guid><description>概要 GitHub 上の情報を扱う API として、GitHub は GraphQL API を提供しています。
GitHub GraphQL API v4 | GitHub Developer Guide Node.js で GraphQL を扱う方法としては、Apollo ライブラリを使った方法 などがありますが、GitHub の GraphQL API を呼び出したいのであれば、GitHub が提供している GraphQL パッケージ @octokit/graphql を使うのが手っ取り早いかもしれません（エンドポイントの URL などを省略できます）。
octokit/graphql.js: GitHub GraphQL API client for browsers and Node @octokit/graphql - npm ここでは、TypeScript からこの @octokit/graphql パッケージを使用する方法を紹介します。
☝️ REST API と GraphQL API GitHub API バージョン 3 は REST API でしたが、柔軟性などの観点 から、GitHub API バージョン 4 の GraphQL 版の API を使用することが推奨されています。 GraphQL API を使用することで、REST API で複数のリクエストが必要だったものを 1 度のリクエストで取得できたりします。 また、GraphQL API でしか取得できない情報もあったりします。 セットアップ まず、TypeScript のプロジェクトを作成します。</description></item><item><title>GitHub GraphQL のスキーマ情報を取得する</title><link>https://maku.blog/p/whv8it5/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whv8it5/</guid><description>GitHub API のサイトからダウンロードする方法 次のサイトから GitHub GraphQL API のスキーマ定義ファイル (schema.docs.graphql) をダウンロードすることができます。
パブリックスキーマ - GitHub Docs 例えば、このファイル内の Query オブジェクト (type Query) の定義を見ると、クエリのトップレベルにどのようなオブジェクト（フィールド）を指定できるかが分かります。
schema.docs.graphql typeQuery{...organization(login:String!):Organization...user(login:String!):User} 上記の場合、Query オブジェクト内に organization や user フィールドが定義されているので、クライアントアプリからクエリ要求を出すときに、次のような感じで指定できるということが分かります。
query{organization(login:&amp;#34;netflix&amp;#34;){namedescriptionavatarUrl}user(login:&amp;#34;octocat&amp;#34;){namecompanyurlavatarUrl}} スキーマ定義ファイル (.graphql) とクライアントアプリ側のクエリ定義 (query {...}) を組み合わせることで、TypeScript 用の型定義ファイルを自動生成することができます（クエリ要求の戻り値の型を定義できます）。 詳しくは、Apollo CLI などのコマンドラインツールを確認してください。
GraphQL サーバーから直接取得する方法 GitHub の GraphQL API サーバーに HTTP GET リクエストを送ることで、スキーマ定義を直接取得することができます。 パーソナルアクセストークンはこちら から生成してください。
$ token=&amp;lt;YOUR_PERSONAL_ACCESS_TOKEN&amp;gt; $ curl -H &amp;#34;Authorization: bearer $token&amp;#34; https://api.github.com/graphql 結果は圧縮された JSON テキストで返されます。 python -m json.</description></item><item><title>GitHub GraphQL API の呼び出し回数制限 (rate limit) の情報を取得する</title><link>https://maku.blog/p/bqz7emt/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bqz7emt/</guid><description>GitHub API を使ったアプリケーションを作成するときは、API の呼び出し回数制限を意識した設計を行う必要があります。 GitHub API バージョン3 の REST API には、1 時間に 5000 リクエストまでという明確な呼び出し回数制限がありましたが、API バージョン4 の GraphQL API はそのクエリの性質上、ちょっと異なるコスト計算方法が採用されています。
GraphQL resource limitations | GitHub Developer Guide 正確な計算方法は上記のサイトに記述されていますが、簡単にいうと、GraphQL クエリの入れ子階層が深くなり、複雑になるほどコストがかかるという計算になっています。
ある GraphQL クエリが実際にどれだけのコストがかかるかは、下記のように rateLimit 情報を取得することで調べることができます。
query{rateLimit{limitcostremainingresetAt}search(query:&amp;#34;repo:electron/electron is:issue&amp;#34;,type:ISSUE,first:5){issueCountnodes{...onIssue{titlelabels(first:10){nodes{name}}}}}} 上記のクエリを実行すると、次のような感じの JSON レスポンスが返ってきます。
{ &amp;#34;data&amp;#34;: { &amp;#34;rateLimit&amp;#34;: { &amp;#34;limit&amp;#34;: 5000, &amp;#34;cost&amp;#34;: 1, &amp;#34;remaining&amp;#34;: 4999, &amp;#34;resetAt&amp;#34;: &amp;#34;2020-08-02T09:15:20Z&amp;#34; }, &amp;#34;search&amp;#34;: { &amp;#34;issueCount&amp;#34;: 13278, &amp;#34;nodes&amp;#34;: [ // ... ] } } } rateLimit の各プロパティの値は次のような意味を持っています。</description></item><item><title>GitHub GraphQL API のクエリ例: ユーザー情報を取得する (viewer, user)</title><link>https://maku.blog/p/9bku4cj/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9bku4cj/</guid><description>サインイン済みのユーザー情報を取得する (viewer) viewer クエリを使用すると、現在アクセスしているユーザー（サインイン中のユーザー）のユーザー情報（User オブジェクト）を取得することができます。
Queries - viewer GraphQL クエリ query{viewer{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}} 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;viewer&amp;#34;: { &amp;#34;login&amp;#34;: &amp;#34;maku77&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Maku Maku&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/maku77&amp;#34;, &amp;#34;websiteUrl&amp;#34;: &amp;#34;https://maku77.github.io/&amp;#34;, &amp;#34;avatarUrl&amp;#34;: &amp;#34;https://avatars2.githubusercontent.com/u/5519503?v=4&amp;#34; } } } 指定したログイン ID のユーザー情報を取得する (user) user クエリを使用すると、指定したユーザー名のユーザー情報を取得することができます。
Queries - user GraphQL クエリ query{user(login:&amp;#34;maku77&amp;#34;){login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}} 取得できるオブジェクトは、viewer クエリの場合と同様に User オブジェクト です。</description></item></channel></rss>