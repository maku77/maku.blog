<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GraphQL on まくろぐ</title><link>https://maku.blog/tags/graphql/</link><description>Recent content in GraphQL on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 26 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/graphql/index.xml" rel="self" type="application/rss+xml"/><item><title>GraphQL ベストプラクティス</title><link>https://maku.blog/p/4reqy9i/</link><pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4reqy9i/</guid><description>GraphQL のスキーマ定義やクエリドキュメントを記述するときのノウハウ集です（主にスキーマ設計に関するもの）。 主要なライブラリ (Apollo や gqlgen）の設計や、『GraphQL in Action』 、『Production Ready GraphQL』などの書籍を参考にしています。
クライアントファースト、スキーマファースト クライアントファースト (Client First) で考える 何よりも、クライアントのユースケースを念頭において考えます。 これは、GraphQL を採用するそもそもの目的でもあります。 バックエンドで使うデータベースや言語などの、実装詳細に引っ張られた API 設計にならないように気を付けます。
できるだけ早い段階でクライアントとのインテグレーションを始めるようにします。組織内での開発であれば、スキーマ定義が終わった段階で すぐにモックサーバーを用意する ことで、クライアント開発チームが実装を開始できます。 クライアントのユースケース以上の API は作らない ようにします。YAGNI (You Aren&amp;rsquo;t Going to Need It) の原則に従いましょう。クライアント要求のない API を提供しようとすると、混沌とした設計になりがちで、パフォーマンスの悪化やセキュリティリスクを招きます。そして、deprecated な API の管理に苦しむことになります。 既存のデータベースから GraphQL API を生成するツールはいろいろありますが、クライアントファーストの考えからするとナンセンスであり、多くの場合は採用すべきではありません。クライアントのニーズを満たす API にはなりませんし、バックエンドの実装詳細に依存した API になってしまいます。必要のない情報まで公開してしまうことによるセキュリティリスクなど、総合的にデメリットが多いです。こういったツールは、本当にデータベースに依存した API がマッチするケースでのみ導入すべきです。REST API 定義から GraphQL スキーマを生成するツールもありますが、そもそも両者はデザインコンセプトから異なるものであり、それでよい API ができると考えてはいけません。 スキーマファーストで実装を進める 多くのケースでは、スキーマ定義を先に考える スキーマファースト で設計を進めると、サーバーとクライアントを並行して開発することができます。 どのような API を実装すればよいか、どのような情報を取得できるのかが、早い段階で全員に明らかになるからです。
型やフィールドの定義には description を含める ようにすることで、実装メンバーの認識を合わせます。 サーバー開発チームに、GraphiQL などの内部サーバーを立ててもらえば、全員が常に最新のスキーマ定義（ドキュメント）を参照できます。</description></item><item><title>GraphQL スキーマ仕様: スキーマ定義の基本</title><link>https://maku.blog/p/5s5jvfz/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5s5jvfz/</guid><description>GraphQL スキーマとは GraphQL スキーマは、GraphQL API サーバーがどんなクエリを受け付けてくれるかを示すもので、GraphQL Schema Language という独自言語 (DSL) で記述します。 スキーマは型情報だけを定義したものであり、サーバーの実装ロジックは考慮しません（各型のデータを返すための具体的な実装は「リゾルバー」と呼ばれており、こちらはプログラミング言語に依存した実装を行います）。
GraphQL スキーマは、クライアントのニーズを把握して、クライアントファーストで考えるのがポイントです。 サーバーのバックエンドで使用する技術（RDB など）に影響されたスキーマ定義をしてはいけません。
☝️ .graphql vs .graphqls GraphQL スキーマドキュメントを独立したファイルとして作成する場合は、ファイルの拡張子を .graphqls あるいは .graphql とするのが一般的です。 .graphqls の方は「GraphQL のスキーマ」を表し、.graphql の方は「GraphQL のクエリドキュメント」を表すので明確に分けるべきだという主張もあります。 迷ったら、スキーマファイルには .graphqls を使っておけば間違いないと思います。 スキーマ定義のベストプラクティスに関しては、こちら にまとめています。
オブジェクト型 スキーマの中で基本的な要素となるのはオブジェクト型で、type キーワードを使って次のように定義します。
typeオブジェクト型の名前{フィールド名:型フィールド名:型フィールド名:型}これは、GraphQL クエリによって取得可能なデータの構造を表しています。 例えば、下記は書籍情報を表すオブジェクト型の例です。
typeBook{id:ID!year:Inttitle:String!authors:[String!]tags:[String!]!}Book オブジェクトが持つフィールドは、フィールド名: 型 という形式で定義します。 型には、スカラー型、列挙型、リスト、オブジェクト型などを指定できます。 オブジェクト型のフィールドとして、別のオブジェクト型を指定することができますが、末端のオブジェクト型はスカラー型のフィールドのみで構成されている必要があります。
すべての型は デフォルトで Nullable であり、Non-null なフィールドであることを示すためには、型名の末尾に ! を付ける必要があります。 上記の例の場合、各フィールドの定義は次のような意味を持ちます。
id: ID! id フィールドは ID 型（組み込みのスカラー型のひとつ）であり、null になることはない。 year: Int year フィールドは整数型であり、null になる可能性がある。 title: String!</description></item><item><title>GraphQL 関連用語</title><link>https://maku.blog/p/jz78nmk/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/jz78nmk/</guid><description>ドキュメント (document) GraphQL リクエストで送る全体の文字列のこと。 HTTP Get リクエストで指定する場合は、query というクエリパラメーターで指定します（これは紛らわしいので、本当は document という名前になっているべきでした）。 HTTP Post リクエストで指定する場合は、ペイロードの JSON 内の query プロパティで指定します。 複数の GraphQL Operation（操作）や Fragment（フラグメント）を含むことができます。 クエリ (query) ドキュメント全体のことを示す場合と、query {...} という個々のクエリ操作を示す場合があります。後者の場合は、データの取得要求を表しています。 操作タイプ (operation type, root type) query {...} などの query というキーワード部分のこと。操作の種類を表しており、query の他には mutation と subscription があります。 操作名 (operation name) query GetHoge {...} などの GetHoge の部分のこと。特に query 操作の場合は query name、mutation 操作の場合は mutation name と呼ぶことがあります。操作名の指定は multi-operation documents じゃない限りオプショナルですが、ログ解析やデバッグをしやすくするために、名前を付けることが推奨されています。 HTTP Get リクエストで指定する場合は、operationName というクエリパラメーターで指定します。 HTTP Post リクエストで指定する場合は、ペイロードの JSON 内の operationName プロパティで指定します。 マルチ操作ドキュメント (multi-operation documents) 複数の query や mutation リクエストを含むドキュメント。どの操作を実行するかは、操作名 (operation name) で指定します。 変数 (variables) query や mutation などの各操作に与えることのできる、キー＆バリューの形で定義する値。query GetUser($id: ID!</description></item><item><title>GitHub の GraphQL API Explorer の使い方</title><link>https://maku.blog/p/sk3rykz/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sk3rykz/</guid><description>GraphQL API Expolorer とは GitHub の GraphQL API (API ver.4) を使用すると、GitHub で管理されているリポジトリの情報やユーザーの情報などを、柔軟な GraphQL クエリを使って取得することができます。 しかし、いろいろなクエリ方法が用意されていて、実際にどのような情報が取得できるのかが分かりにくかったりします。 そんなとき便利なのが、GitHub が Web サイトとして用意してくれている、GraphQL API Explorer です。
GraphQL API Explorer | GitHub Developer Guide GraphQL API Explorer を使用すると、GraphQL API を使ってどのような情報を取得できるのか、実際にクエリを実行して確かめることができます。 GitHub アカウントでサインインした状態であれば、プライベートリポジトリの情報も取得することができます。 GitHub GraphQL API を利用するアプリケーションを作成するときは、このサイトでどのようなクエリを発行すればよいのかを調べながら作っていくことになると思います。
クエリエディタでは、下記のようなショートカットキーを使用することができます。
Ctrl + Space &amp;hellip; 入力補完 Ctrl + Enter &amp;hellip; 実行 History 機能と Explorer 機能 History ボタンを押すと、過去に実行したクエリをロードすることができます。 クエリに次のように名前を付けておくと、History にその名前が表示されるので、後ほど再利用する予定があれば、わかりやすい名前を付けておくとよいでしょう。
queryGetApolloRepo{repository(owner:&amp;#34;apollographql&amp;#34;,name:&amp;#34;apollo-client&amp;#34;){owner{loginurl}nameurl}} Explorer ボタンを押すと、スキーマ定義に基づいて、入力可能なフィールドをツリー形式で参照することができます（これを使うより、Ctrl + Space による補完の方が便利ですが）。</description></item><item><title>Apollo Client で GitHub GraphQL API を使う (Node &amp; React)</title><link>https://maku.blog/p/qcp2cnx/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2cnx/</guid><description>Apollo Client とは Apollo パッケージは、GraphQL を使ったクライアントアプリやサーバーを作成するためのライブラリ群です。 クライアントアプリを作るためのライブラリは、Apollo Client として @apollo/client という NPM パッケージにまとめられています。
Web アプリのコンポーネントを作成するときは React がよく使われますが、Apollo は GraphQL を扱いやすくする React コンポーネント（ApolloProvider、Query、Mutation、Subscription）や React Hook 拡張（useQuery) などを提供しています。
ここでは、Apollo Client パッケージを使用して、
Node.js アプリ（コマンドラインアプリの JS）から GraphQL API の実行 React アプリ（Web サイトの JS）から GraphQL API の実行 を行ってみます。 呼び出す GraphQL API は何でもよいのですが、今回は GitHub GraphQL API を利用することにします。
Node パッケージのインストール Apollo Client Apollo Client 関連のパッケージとしては、@apollo/client と、それが使用する graphql をインストールします。
Apollo Client のインストール ### yarn の場合 $ yarn add @apollo/client graphql ### npm の場合 $ npm install @apollo/client graphql fetch ポリフィル Apollo クライアント内部の実装では、Web ブラウザの fetch API を利用しています。 React アプリから Apollo クライアントを利用する場合は問題ないのですが、コンソールで動作する Node.</description></item><item><title>Apollo Client の ApolloLink チェーンで HTTP リクエストをカスタマイズする</title><link>https://maku.blog/p/xa62yo4/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xa62yo4/</guid><description>ApolloLink とは？ 図: Apollo Client の Link チェ―ン Apollo Client を使って GraphQL API を呼び出すとき、GraphQL サーバーに対して HTTP リクエストが送られるわけですが、Apollo Client は内部で Link チェーンというものを作って具体的な HTTP リクエストを構築します。 この構築処理を実装するものが Link オブジェクトであり、具体的には ApolloLink クラスのインスタンスです。 Link オブジェクトは図のように Link チェーンの形で連結して使用できるようになっており、通信内容を加工する一連のミドルウェア として機能します。 Link オブジェクトの用途としては、次のようなものがあります。
HTTP リクエストヘッダの付加 認証情報の付加（authorization ヘッダー） GraphQL サーバーで独自定義したヘッダー アクセス先 URL（GraphQL エンドポイント）の切り替え デバッグログの出力 自動リトライ（参考: RetryLink） リクエスト回数をカウント サーバー応答速度（ラウンドトリップ時間）の計測 複数のクエリのバッチ送信（参考: BatchHttpLink） Persisted クエリ（参考: PersistedQueryLink） Link オブジェクトは任意の順序でチェーンできますが、末端の GraphQL サーバーに接続する部分は Teminating link として振る舞う必要があり、通常は HttpLink クラスのインスタンスを設定します。 HttpLink クラスは ApolloLink を継承して実装されています。</description></item><item><title>GraphQL スキーマ仕様: ユニオン型 (Union types) を定義する</title><link>https://maku.blog/p/vqsyz9j/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vqsyz9j/</guid><description>GraphQL スキーマの ユニオン型 (Union types) は、複数の型のうち、いずれかの型であることを表現する型です。 典型的には、検索系のフィールドにおいて、様々な種類のデータを返す場合に使われます。 ユニオン型は、union キーワードを使って次のように定義します。
ユニオン型の定義 unionTaskOrTodo=Task|TodotypeQuery{search(term:String!):[TaskOrTodo!]} 下記は GitHub の GraphQL スキーマで定義されているユニオン型の例です。
GitHub API の union 型の例 &amp;#34;&amp;#34;&amp;#34; Used for return value of Repository.issueOrPullRequest. &amp;#34;&amp;#34;&amp;#34;unionIssueOrPullRequest=Issue|PullRequest&amp;#34;&amp;#34;&amp;#34; Types that can be inside a Milestone. &amp;#34;&amp;#34;&amp;#34;unionMilestoneItem=Issue|PullRequest GraphQL クエリにおいてユニオン型のフィールドを参照するときは、インラインフラグメント を使って、具体的な型ごとにフィールドを参照する必要があります。
ユニオン型のフィールドを参照するクエリ queryQueryRecentActivities{search(type:ISSUE,query:&amp;#34;repo:graphql/graphql-spec&amp;#34;,last:10){nodes{...onIssue{numbertitle}...onPullRequest{titlebaseRefName}}}} ユニオン型は、エラーを表現するためにも使用できます。 次の createBook は新しい書籍データを登録するための mutation ですが、登録に成功したときは Book オブジェクトを返し、失敗したときは各種エラーを表すオブジェクトを返します。</description></item><item><title>GraphQL Code Generator でスキーマから TypeScript の型情報を生成する (graphql-codegen)</title><link>https://maku.blog/p/n2k2hxd/</link><pubDate>Mon, 03 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n2k2hxd/</guid><description>GraphQL Code Generator とは GraphQL Code Generator は、GraphQL スキーマ (schema.graphqls) とクエリ用のドキュメント (query {...}) を入力として与えることで、さまざまな言語とライブラリに対応した型情報を生成するツールです。
公式 Web サイト - GraphQL Code Generator GitHub リポジトリ - dotansimha/graphql-code-generator C# や Dart 用のコードも生成できるようですが、ツール自体が NPM パッケージとして提供されているので、やはり TypeScript がメインターゲットですね。 クライアント側で、React + Apollo Client のフレームワークを使用している場合は、Apollo Client のフック API (useQuery) に渡すためのオブジェクトを生成してくれます。 GraphQL サーバー側のリゾルバー実装に使用する型情報を生成するのにも使用できますが、GraphQL サーバーを Golang の gqlgen で作る 場合などは、スキーマから Golang コードを生成する仕組みがそれ自体に備わっていたりするので、そこではこのツールは使いません。 一方、フロントエンドは React + TypeScript で作ることが比較的多いので、このツールの出番も多くなります。
入力するスキーマ情報としては、スキーマファイル（schema.graphqls など）を指定することも、GraphQL サーバーのアドレスを指定して Introspection 機能で取得することもできます。 GraphQL クライアントの開発中は、接続先の GraphQL サーバーも動いているでしょうから、そこから直接スキーマ情報を取得するのは理にかなっています。 例えば、GraphQL サーバー側の Git リポジトリでスキーマファイルを管理している場合、クライアント開発時にこのスキーマファイル自体を共有しなくて済みます。</description></item><item><title>GraphQL クエリ仕様: クエリで変数を使用する</title><link>https://maku.blog/p/dtwtpzj/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dtwtpzj/</guid><description>変数定義と変数値の指定 特定のパラメーターのみ値を変えて複数の GraphQL のクエリを発行したい場合は、ドキュメント内で query や mutation を定義するときに、変数定義 (variable definitions) を追加します。
次の GetBook クエリでは、$id: String! という変数定義を行っています。 これは、クエリ実行時に id という名前の文字列変数を参照することを示しています。 そして、型名に ! が付いているので、変数値の指定は必須です。
変数を参照するクエリの例 queryGetBook($id:String!){book(id:$id){idtitleprice}} 指定された id 変数の値は、book フィールドの id 引数として渡され、対応する書籍を取得するリクエストとして処理されます。
肝心の変数の値は、query や mutation などのドキュメントとは異なる variables という HTTP ペイロード・フィールドで GraphQL サーバーへ送ります（HTTP POST 経由での GraphQL API 呼び出しの場合）。 ただ、このあたりの variables フィールドの送信に関しては、通常は各種言語用の GraphQL ライブラリに隠蔽されているため、明示的に HTTP POST リクエストのペイロードを設定することはありません。 例えば、React 用の Apollo Client ライブラリは、次のような感じで変数を設定するインタフェースを提供しています。
const { loading, error, data } = useQuery&amp;lt;QueryType, VarType&amp;gt;(query, { variables: { id: &amp;#34;book-123&amp;#34; } }) Web ブラウザ上で GraphQL API のテストを行える GraphiQL（グラフィカル） の UI では、次のようにドキュメントと変数を別々に記述できるようになっています。</description></item><item><title>GraphQL スキーマ仕様: ミューテーションを定義する（データ更新 API）</title><link>https://maku.blog/p/pk9c9qs/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pk9c9qs/</guid><description>GraphQL API でサーバーサイドのデータを更新するには、ミューテーション操作 (mutation) を含むクエリを送信します。 このときどのようなミューテーションを行えるかは、GraphQL スキーマの中で、Mutation 型のフィールドとして定義します。
ミューテーションのスキーマを定義する 次の例では、書籍データを新規作成するための createBook ミューテーションと、削除するための deleteBook ミューテーションを定義しています。 フィールド名は変更内容を表す動詞で始めるのが一般的です。
GraphQL スキーマ定義 typeMutation{createBook(title:String!,author:String!):Book!deleteBook(id:ID!):Boolean!} 各フィールドにはパラメーター（上記の title など）を定義することができ、そのパラメーターの指定が必須である場合には、型名の末尾に ! を付けます (String!)。
ミューテーションが呼び出されたときの実際の処理内容は、GraphQL サーバー側のミューテーション・リゾルバーで実装します。 リゾルバーの実装方法は、各言語の GraphQL サーバーライブラリによって異なります。 例えば、下記は Golang の gqlgen パッケージを使った場合のリゾルバー実装の例です。
ミューテーション・リゾルバーの実装 // CreateBook is the resolver for the createBook field. func (r *mutationResolver) CreateBook( ctx context.Context, title string, author *string, ) (*model.Book, error) { id := uuid.NewString() book := &amp;amp;model.Book{ ID: id, Title: title, Author: author, } // 本当はこのあたりで DB などに book を追加 // if err := db.</description></item><item><title>GraphQL スキーマ仕様: 入力型 (input type) を定義する</title><link>https://maku.blog/p/nhhwqtu/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nhhwqtu/</guid><description>GraphQL スキーマで定義する 入力型 (input type) は、クエリ／ミューテーション要求時のフィールド引数にのみに使用できるオブジェクト型です。 入力型を使うと、複数のフィールド引数をひとつのオブジェクトにまとめることができます。
次の Mutation 型の createBook フィールドは、フィールド引数として CreateBookInput という入力型を使っています。
スキーマ定義 typeMutation{createBook(input:CreateBookInput!):Book} 入力型を定義するときは input キーワードを使用します（フィールド自体を表す型の定義には type キーワードを使用します。こちらは出力型と呼ばれたりします）。 フィールドの定義方法は type も input も同じです。
次のスキーマは、上記の createBook フィールドの型 (Book) と、その引数の型 (CreateBookInput) を定義しています。 type キーワードと input キーワードを使い分けていることに注意してください。
スキーマ定義 typeBook{id:ID!title:String!author:Stringyear:Int}inputCreateBookInput{title:String!author:Stringyear:Int} Book 型と CreateBookInput 型のフィールドはほとんど共通ですが、Book 型には GraphQL サーバー側で自動生成される id 情報が含まれています。
クライアントがミューテーション要求を送るときは、ミューテーション操作の変数経由で入力型のデータを渡します。
ミューテーションの実行 mutationCreateBook($input:CreateBookInput!){createBook(input:$input){idtitleauthoryear}} 実際に使用する変数値は、次のような JSON 形式のデータとして、上記ドキュメントと一緒に GraphQL サーバーに送ります。
variables {&amp;#34;input&amp;#34;:{&amp;#34;title&amp;#34;:&amp;#34;書籍タイトル&amp;#34;,&amp;#34;author&amp;#34;:&amp;#34;まく&amp;#34;}} ミューテーション操作の戻り値は、一般的には新規作成した（あるいは更新後の）オブジェクトの内容です。
上記ミューテーションのレスポンス { &amp;#34;data&amp;#34;: { &amp;#34;createBook&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;d3cn2sx&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;書籍タイトル&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;まく&amp;#34;, &amp;#34;year&amp;#34;: null } } } 上記の createBook フィールドの型（ミューテーション操作の戻り値）は Book 型でしたが、CreateBookPayload のような別の出力型を定義すれば、ミューテーション操作に関するメタ情報を含めることができます。 例えば、ミューテーション操作によって実際に追加されたデータの数などを戻り値として返すことができます。</description></item><item><title>GraphQL スキーマ仕様: 列挙型 (enum type) を定義する</title><link>https://maku.blog/p/isotm77/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/isotm77/</guid><description>列挙型の基本 GraphQL スキーマでは、enum キーワードを使って列挙型を定義することができます。 列挙型は、スカラー型と同様に単一の値を表しますが、とり得る値があらかじめ限定されています。 String や Int などの代わりに適切な列挙型を使えば、API の使い方が明確になり、クライアントによる誤用を防ぐことができます。
次の例では、Episode という名前の列挙型を定義しています。
GraphQL スキーマでの列挙型の定義 enumEpisode{NEWHOPEEMPIREJEDI} 列挙型は、フィールドのパラメーターの型として使用することができます。
typeQuery{hero(episode:Episode):Character}列挙型は、フィールドの型としても使用できます。
typeCharacter{name:String!appearsIn:[Episode]!}列挙型の使用例 列挙型の典型的な使用例として、ソート用のフィールド・パラメーターがあります。 下記は、GitHub の GraphQL スキーマで定義されている列挙型の例です。 GistOrder 入力型 のフィールドに、GistOrderField 列挙型が使われています。
GitHub の GraphQL スキーマ（抜粋） &amp;#34;&amp;#34;&amp;#34; Ordering options for gist connections &amp;#34;&amp;#34;&amp;#34;inputGistOrder{&amp;#34;&amp;#34;&amp;#34; The ordering direction. &amp;#34;&amp;#34;&amp;#34;direction:OrderDirection!&amp;#34;&amp;#34;&amp;#34; The field to order repositories by. &amp;#34;&amp;#34;&amp;#34;field:GistOrderField!}&amp;#34;&amp;#34;&amp;#34; Properties by which gist connections can be ordered. &amp;#34;&amp;#34;&amp;#34;enumGistOrderField{&amp;#34;&amp;#34;&amp;#34; Order gists by creation time &amp;#34;&amp;#34;&amp;#34;CREATED_AT&amp;#34;&amp;#34;&amp;#34; Order gists by push time &amp;#34;&amp;#34;&amp;#34;PUSHED_AT&amp;#34;&amp;#34;&amp;#34; Order gists by update time &amp;#34;&amp;#34;&amp;#34;UPDATED_AT} 意味はほとんど自明かと思いますが、Gist（コード断片）のリストを取得するときに、どのフィールドでソートして返して欲しいかを指定するのに使用します。 下記の GraphQL クエリを発行すると、自分（サインイン済みユーザー）が登録している Gist を、作成日時 (CREATED_AT) で降順ソート (DESC) された状態で取得できます。</description></item><item><title>GraphQL スキーマ仕様: 組み込みのスカラー型とカスタムスカラー型</title><link>https://maku.blog/p/tw75a7p/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tw75a7p/</guid><description>5 つの組み込みスカラー型 (Scalar types) GraphQL 仕様で定義されているスカラー型は次の 5 つで、これらを各オブジェクト型のフィールドの型や、フィールド引数の型として使用します。
型名 意味 Int 符号付き 32 ビット整数 Float 符号付き倍精度浮動小数点数 String 文字列（UTF-8 エンコーディング） Boolean true または false ID 一意の識別子。データ形式としては String と同様ですが、ID はリーダブル（意味のある単語）にはなっていないことを示唆します。ID は GraphQL サーバーとクライアントの間でオブジェクトの同一性を示すために使用します。 これ以外のより具体的な型を使用したいときは、独自のオブジェクト型、スカラー型、列挙型を定義して使用します。
カスタムスカラー型 (Custom scalar types) スカラー型にフォーマット制約を設けたいときや、任意のクラスのインスタンスとして扱いたいときは、独自の カスタムスカラー型 を定義します。 例えば、日時や E メールアドレス、UUID、URI などは、カスタムスカラーを使うべき典型的なフィールドの例です。 カスタムスカラーは、スキーマドキュメント内で scalar キーワードを使って定義できます。
カスタムスカラー型の定義 &amp;#34;&amp;#34;&amp;#34;日時を表すスカラー型(ISO8601形式の文字列)&amp;#34;&amp;#34;&amp;#34;scalarDateTimetypeEvent{title:String!startAt:DateTime} ライブラリの実装によりますが、カスタムスカラー型をそのまま使おうとすると、単なる String 型として扱われます。 カスタムスカラー型のデータを GraphQL サーバー型でどのようにハンドルするかは、サーバーライブラリごとに実装方法が提供されています。 例えば、下記は Golang の gqlgen ライブラリにおけるカスタムスカラー型のドキュメントです。 実装例として、yes や no として送られてきた文字列データを、Golang の bool 型として参照できるようにする方法が紹介されています。</description></item><item><title>GraphQL クエリ仕様: ディレクティブによる条件分岐 (@include, @skip)</title><link>https://maku.blog/p/dcdv7rv/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dcdv7rv/</guid><description>GraphQL クエリで、各フィールド名（あるいはフラグメント）の後ろに @include ディレクティブや @skip ディレクティブを配置すると、if 引数で指定した条件によってそのフィールドを取得するかどうかを制御できます。
fieldName@include(if:$someTest)fieldName@skip(if:$someTest)@include ディレクティブと @skip ディレクティブの違いは、if 引数の判定が逆転しているだけです。
@include(if: Boolean) ディレクティブ if 引数の値が true のときにのみフィールドを取得します @skip(if: Boolean) ディレクティブ if 引数の値が false のときにのみフィールドを取得します クエリ内での @include ディレクティブによる条件分岐 queryQueryOrganization($org:String!,$details:Boolean=false){organization(login:$org){namedescriptionwebsiteUrl@include(if:$details){}} variables { &amp;#34;org&amp;#34;: &amp;#34;graphql&amp;#34;, &amp;#34;details&amp;#34;: true }</description></item><item><title>GraphQL クエリ仕様: フィールド名にエイリアスを付ける</title><link>https://maku.blog/p/vnkd4ur/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vnkd4ur/</guid><description>GraphQL クエリ言語の フィールド・エイリアス 機能を使うと、取得したフィールド値を参照するときに、任意の別名を付けて参照することができます。 例えば、GraphQL スキーマとしては company というフィールド名で定義されているものを、companyName という JSON プロパティ名で返して欲しいときは、次のようにフィールド・エイリアスを使用します。
GraphQL クエリ queryProfileInfoWithAlias{user(login:&amp;#34;maku77&amp;#34;){namecompanyName:companybio}} レスポンス { &amp;#34;data&amp;#34;: { &amp;#34;user&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Makkuma&amp;#34;, &amp;#34;companyName&amp;#34;: &amp;#34;maku maku company&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;すーぱーぷにぐらまー&amp;#34; } } } フィールド・エイリアスは、同名のフィールドを異なる引数で取得するときに役立ちます。
GraphQL クエリ query{maku77:user(login:&amp;#34;maku77&amp;#34;){...basicUserInfo}puni:user(login:&amp;#34;puni&amp;#34;){...basicUserInfo}}fragmentbasicUserInfoonUser{namebio} 上記のように 1 つのクエリの中で同名のフィールド（ここでは user）を要求する場合に、フィールド・エイリアス（ここでは maku と puni）を付けることで、レスポンスのプロパティ名がコンフリクトしないようにします。 というより、このケースではエイリアスを設定しないと、リクエスト時にエラーになります。
レスポンス { &amp;#34;data&amp;#34;: { &amp;#34;maku77&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Makkuma&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;すーぱーぷにぐらまー&amp;#34; }, &amp;#34;puni&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;Puni Puni&amp;#34;, &amp;#34;bio&amp;#34;: &amp;#34;ぷにぷにぷにょーん&amp;#34; }, } } なお、上記クエリ内の .</description></item><item><title>GraphQL スキーマ仕様: @deprecated ディレクティブで非推奨のフィールドを示す</title><link>https://maku.blog/p/bg9g8rc/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bg9g8rc/</guid><description>GraphQL スキーマ内のある型のフィールドや Enum 値が非推奨になったことを表すには、@deprecated ディレクティブを使用します。 reason 引数で非推奨とされた理由を記述することができるので、その文章中に代替となるフィールド名を記述しておくと親切です。
次の例では、email フィールドが非推奨 (deprecated) になり、代わりに emailAddress フィールドを参照して欲しいことを示しています。
typeUser{emailAddress:Stringemail:String@deprecated(reason:&amp;#34;Use &amp;#39;emailAddress&amp;#39;.&amp;#34;)}</description></item><item><title>GraphQL スキーマ仕様: インタフェース型 (interface type) を定義する</title><link>https://maku.blog/p/yp9mv5d/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yp9mv5d/</guid><description>GraphQL のインタフェース型は、複数の型が共通して持つフィールドを定義するための抽象型で、interface キーワードを使って定義します。 次の ScheduleItem インタフェースは、2 つのフィールド（id と title）を持つことを示しています。 インタフェースを実装する (imlements) 側の型は、必ず id と title フィールドを持つ必要があります。
スキーマ定義 # 共通のインタフェースを定義interfaceScheduleItem{id:ID!title:String!}# Task 型は必ず id と title フィールドを持つtypeTaskimplementsScheduleItem{id:ID!title:String!content:String}# Milestone 型は必ず id と title フィールドを持つtypeMilestoneimplementsScheduleItem{id:ID!title:String!date:DateTime}scalarDateTimetypeQuery{allItems():[ScheduleItem!]} 上記の Task 型と Milestone 型は、ScheduleItem というインタフェースを実装しています。 allItems クエリは、Task と Milestone を要素に持つリストを返すことを想定していますが、戻り値のリスト要素の型が ScheduleItem になっているため、必ず id と title フィールドが含まれることが保証されています。 クエリ内でリスト要素を参照するときは、次のように直接これらのフィールドを参照できます。
クエリ queryQueryAllItems{allItems{idtitle}} 一方、Task 型や Milestone 型にしか含まれないフィールドを取得したいときは、次のように インラインフラグメント (... on Xxx) の形で分岐させて参照する必要があります。
クエリ queryQueryAllItems{allItems{idtitle...onTask{content}...onMilestone{date}}} 複数のインタフェースを実装したいときは、次のように implements の後ろにインタフェース名を &amp;amp; で並べます。</description></item><item><title>GraphQL スキーマ仕様: 型やフィールドに説明文 (description) を記述する</title><link>https://maku.blog/p/c5pbs6p/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/c5pbs6p/</guid><description>GraphQL スキーマで定義する型には、Python の docstring と同様のフォーマットで description というドキュメントを付加できます。 description は型の直前、あるいはフィールドの直前に、3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲む形で記述します。
description の記述例 &amp;#34;&amp;#34;&amp;#34; Represents an auto-merge request for a pull request &amp;#34;&amp;#34;&amp;#34;typeAutoMergeRequest{&amp;#34;&amp;#34;&amp;#34; The email address of the author of this auto-merge request. &amp;#34;&amp;#34;&amp;#34;authorEmail:String&amp;#34;&amp;#34;&amp;#34; The commit message of the auto-merge request. If a merge queue is required by the base branch, this value will be set by the merge queue when merging. &amp;#34;&amp;#34;&amp;#34;commitBody:String...} description の記述例 &amp;#34;&amp;#34;&amp;#34;The root query entry point for the API&amp;#34;&amp;#34;&amp;#34;typeQuery{&amp;#34;&amp;#34;&amp;#34;The current time in ISO UTC&amp;#34;&amp;#34;&amp;#34;currentTime:String} GraphQL スキーマ内の description はただのコメントではなく、その型のプロパティとして扱われ、GraphiQL などの各種ツールがその情報を参照して利用します。 GraphQL スキーマの型名やフィールド名だけで表現できる情報は限られているので、ほぼすべての型、フィールドに対して description を設定するのはよいプラクティスです。 下記は GitHub の GraphQL API のスキーマです。 description の記述方法の参考になります。</description></item><item><title>Apollo Client の fetchMore を自動で呼び出して GitHub GraphQL の100件制限を乗り越える (useAutoFetchMore)</title><link>https://maku.blog/p/w7igunc/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7igunc/</guid><description>何をするか？ GitHub の GraphQL API で Issue 情報などを取得しようとすると、リソース制限 のため一度に 100 件までの情報しか取得できません。 Apollo Client が提供する useQuery や useLazyQuery などの React フック関数を使用すると、戻り値で返される fetchMore 関数を使って追加読み込み（ページネーション処理）を行うことができますが、この関数の使用例として提示されているものは、ユーザーによるボタンクリックなどを必要とするものばかりです。 ここでは、useQuery 実行後に自動で fetchMore を繰り返し呼び出して、100 件を超える情報を取得する方法の例を示します。
fetchMore のための設定 前提として、Apollo Client の fetchMore 関数の基本的な使い方は理解しているものとします（下記記事などを参考にしてください）。
Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す 今回サンプルコードで使う GraphQL クエリには、次のような search コネクションが含まれていることを想定しています。 ページネーションの対象となるのは、この search コネクション部分です。
queryQueryIssues($cursor:String){search(type:ISSUE,first:100,after:$cursor,query:&amp;#34;...&amp;#34;){...}} そのため、ApolloClient に設定するキャッシュのフィールドポリシーとして、search フィールドの値が fetchMore 時にマージされるように設定しておきます。 cache オブジェクトの生成時に呼び出している relayStylePagination 関数あたりがポイントです。
GitHubApolloProvider.tsx import * as React from &amp;#39;react&amp;#39; import { ApolloClient, ApolloLink, ApolloProvider, createHttpLink, InMemoryCache, } from &amp;#39;@apollo/client&amp;#39; import { relayStylePagination } from &amp;#39;@apollo/client/utilities&amp;#39; import { setContext } from &amp;#39;@apollo/client/link/context&amp;#39; import { Auth } from &amp;#39;@/utils/auth&amp;#39; const httpLink = createHttpLink({ uri: &amp;#39;https://api.</description></item><item><title>Apollo CLI の codegen で GraphQL クエリレスポンスの TypeScript 型を自動生成する</title><link>https://maku.blog/p/bnrrqpn/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bnrrqpn/</guid><description>何をするか TypeScript プロジェクトにおいて、Apollo Client の useQuery フックで GraphQL クエリ呼び出しを行っていると、レスポンスの型情報が any になってしまうことに悩むことになります。 例えば、GitHub の GraphQL クエリで、次のようにログイン中のユーザー情報を取得するとします。
import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; export const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` const Viewer: FC = () =&amp;gt; { const { error, loading, data } = useQuery(QUERY_VIEWER) // ... } useQuery 関数の戻り値の data はデフォルトで any 型なので、そのままだと ESLint などに怒られることになります。
Unsafe array destructuring of a tuple element with an any value @typescript-eslint/no-unsafe-assignment</description></item><item><title>GraphQL クエリ仕様: フラグメント (Fragments) とインラインフラグメント (Inline Fragments)</title><link>https://maku.blog/p/wiv7it5/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wiv7it5/</guid><description>GraphQL フラグメントでクエリをパーツ化する フラグメントの基本 GraphQL クエリの中で、同じようなフィールドの指定（選択セット）を複数回使用する場合、それを フラグメント (Fragments) という再利用可能な選択セットとして切り出して定義しておくことができます。
例えば次の GraphQL クエリは、GitHub から自分のユーザー情報 (viewer) と、特定のユーザーの情報 (user) を一度に取得しています。
GraphQL クエリ queryQueryTwoUsers{viewer{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}user(login:&amp;#34;ログインID&amp;#34;){loginnameurlwebsiteUrlavatarUrl}} viewer フィールドと user フィールドは、両方とも User 型 のフィールドで、しかも、上記の例では User オブジェクトの中の同じフィールドを参照しています。 明らかに冗長な書き方です。
このようなケースでは、あるオブジェクトの特定のフィールドを参照するための選択セット (selection set) を、フラグメントの形で定義することができます。 次の例では、User オブジェクトの特定のフィールドを選択するための userFragment というフラグメントを定義し、クエリ内で参照しています。
GraphQL クエリ queryQueryTwoUsers{viewer{...userFragment}user(login:&amp;#34;ログインID&amp;#34;){...userFragment}}# User オブジェクトの中のフィールドを選択するためのフラグメントfragmentuserFragmentonUser{login# ログインIDname# ユーザー名url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像} フラグメントを使用する場所では、...userFragment のようにドットを 3 つ付けて参照します。 これを GraphQL 用語で フラグメント・スプレッド（fragment spread) といいます。 その場所にフラグメントの内容を「展開する」という意味です。 JavaScript でオブジェクトを展開するときのスプレッド構文 (.</description></item><item><title>Apollo Client の useQuery 呼び出し部分をカスタムフックで分離する</title><link>https://maku.blog/p/kmj7sdv/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kmj7sdv/</guid><description>Apollo Client で GraphQL クエリを実行するときは、カスタムフックとして useQuery 関数の呼び出し部分を抽出すると、コンポーネント側のコードをシンプルにすることができます。
分離前のコード 次のサンプルコードでは、GraphQL クエリで GitHub のログインユーザー情報を取得して表示する Viewer コンポーネントを実装しています。 GraphQL のクエリ呼び出し部分や、取得したデータを ViewerData オブジェクトに詰める部分などが混在しており、あまり整理されているとは言えません。
components/Viewer.tsx import { FC } from &amp;#39;react&amp;#39; import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; import { LoadingComponent } from &amp;#39;./LoadingComponent&amp;#39; import styles from &amp;#39;./Viewer.scss&amp;#39; const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` type ViewerData = { /** ログインID */ login: string /** ホームページのURL */ url: string /** アバター画像のURL */ avatarUrl: string } /** 「ユーザー情報」を表示するコンポーネント */ export const Viewer: FC = () =&amp;gt; { const {loading, error, data} = useQuery(QUERY_VIEWER) if (loading) return &amp;lt;LoadingComponent /&amp;gt; const viewer: ViewerData = data.</description></item><item><title>Apollo Client でクリック時に GraphQL クエリを実行する</title><link>https://maku.blog/p/m7ju6gr/</link><pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7ju6gr/</guid><description>図: useLazyQuery による GraphQL クエリ実行 はじめに Apollo Client の useQuery フックを使用すると、GraphQL を使って取得した情報を表示する React コンポーネントをシンプルに実装することができます。 useQuery フックによる GraphQL クエリは、React コンポーネントの表示時に実行されますが、代わりに useLazyQuery フックを使用すると、任意のタイミング、例えばボタンを押した時に GraphQL クエリを実行できるようになります。
前提として、Apollo Client の useQuery の基本的な使い方は下記の記事などで理解しているものとし、ここでは、useLazyQuery フックの使い方を説明します。
参考: Apollo Client で GitHub GraphQL API を使う (Node &amp;amp; React)&amp;quot; useQuery と useLazyQuery の違い 下記の抜粋コードは、useQuery 関数と useLazyQuery 関数の使い方の違いを表しています。
// const GET_ISSUES = gql`...`; const {loading, error, data} = useQuery(GET_ISSUES); const [getIssues, {loading, error, data}] = useLazyQuery(GET_ISSUES); useQuery 関数は呼び出し直後に GraphQL クエリが実行され、その状態や結果が直ちに loading、error、data といった戻り値に格納されます。 一方 useLazyQuery 関数の場合は、戻り値の最初の要素として、クエリ実行関数が返されます（上記の例では getIssues にしてるけど、変数名は executeQuery とか何でも OK）。 GraphQL クエリを実行するには、このクエリ実行関数を呼び出す必要があるので、例えば次のようにボタン要素の onClick で呼び出すようにしておきます。 あとは、useQuery 関数の使い方と同様です。</description></item><item><title>Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す</title><link>https://maku.blog/p/cu6eox7/</link><pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cu6eox7/</guid><description>Apollo Client の Pagination 機能 GraphQL API では柔軟なクエリ発行が可能ですが、多数の要素を取得する場合は、Pagenation 処理 により何度かに分けて API 呼び出しを行う必要があります。 例えば、GitHub の GraphQL API では一度のクエリで取得可能な要素数は 100 件までであり、それを超える情報を取得する場合に Pagination 処理が必要です。
Apollo Client には、GraphQL の Pagination 処理を簡単に扱うための仕組み（fetchMore 関数）が用意されています。
参考: Pagination - Client (React) - Apollo GraphQL Docs と言っても、そこまで簡単ではないので、ここでは GitHub の GraphQL API における Pagination 処理の具体的な実装例を紹介します。
Pagination の実装例（フィールドポリシーを使う方法） 次のサンプルコードは、GitHub の myorg/myrepo リポジトリの Issue リストを表示する IssueList コンポーネントの実装例です。 Issue の数が 100 件を超える場合は、「さらに読み込む」ボタンを表示し、このボタンが押されたときに Pagination 処理（fetchMore 関数）で次のデータを取得するようにしています。
Apollo クライアントの useQuery 関数が返す fetchMore 関数を呼び出すと、再度 GraphQL クエリを実行することができます。 このとき、オプションで variables パラメータの値（クエリ変数）を変更できるので、Issue の読み出し開始位置を示す after の値を進めていくことで、100 件を超えるデータを順番に読み出すことができます。</description></item><item><title>GitHub GraphQL クエリ例: マイルストーン情報を取得する (milestone)</title><link>https://maku.blog/p/fdnpuro/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fdnpuro/</guid><description>マイルストーン番号で Milestone オブジェクトを取得する リポジトリ名（組織名/リポジトリ名）が分かっている場合は、repository クエリ で取得した Repository オブジェクト の milestone フィールドに マイルストーン番号 を指定することで、そのマイルストーンの Milestone オブジェクト を取得することができます。 例えば、Web アプリなどでは、/milestone/123 のようなパスで指定したマイルストーンの情報を表示したいことがありますが、このようなケースで 123 という番号を使って情報を取得することができます。
記述中
GraphQL クエリ query{repository(owner:&amp;#34;myorg&amp;#34;,name:&amp;#34;myrepo&amp;#34;){milestone(number:123){numbertitledueOndescriptionurlissues(first:100){nodes{numbertitleclosedurl}}}}} マイルストーンが設定されていないイシューを取得する search クエリ で、Issue や PullRequest を検索するときに、query パラメータで渡す文字列に no:milestone を含めると、マイルストーンの設定されていないものだけを検索することができます。
次の例では、myorg/myrepo リポジトリにおいて、マイルストーンの設定されていない Issue の一覧を取得しています（query 引数に is:issue を含めることで、PullRequest まで取得されてしまうのを防いでいます）。
GraphQL クエリ query{rateLimit{costremaining}search(type:ISSUE,last:100,query:&amp;#34;repo:myorg/myrepo is:issue no:milestone&amp;#34;){nodes{...onIssue{numbertitleclosedurlassignees(first:100){nodes{loginavatarUrlurl}}labels(first:100){nodes{namecolor}}}}}} no:milestone の他にも、no:label（ラベルのないもの）、no:assignee（アサインされていないもの）、といった条件で検索することができます。
参考: 欠損しているメタデータで検索 - GitHub Docs あるリポジトリのマイルストーンの一覧を取得する → こちらを参照</description></item><item><title>GitHub GraphQL クエリ例: PullRequest の情報を取得する (search)</title><link>https://maku.blog/p/z69a3tk/</link><pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/z69a3tk/</guid><description>自分のレビュー待ちになっている PR を取得する search クエリの query パラメータで、is:pr review-requested:@me と指定すると、自分がレビューワー (reviewer) として設定されているプルリクエストを検索することができます。
GraphQL クエリ query{search(type:ISSUE,last:100,query:&amp;#34;is:open is:pr review-requested:@me&amp;#34;){issueCountnodes{...onPullRequest{numbertitleurlcreatedAtauthor{loginavatarUrlurl}reviewRequests(first:100){nodes{requestedReviewer{...onUser{loginavatarUrlurl}}}}}}}} PullRequest オブジェクトの詳細はこちら。</description></item><item><title>GitHub GraphQL クエリ例: イシュー情報を取得する (search)</title><link>https://maku.blog/p/i5ht5ep/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i5ht5ep/</guid><description>イシュー情報の取得方法 イシュー情報を取得する方法は次のような方法があります。
ユーザーからたどる方法 &amp;ndash; viewer/user クエリ で User オブジェクト を取得し、そのユーザーに関連するイシュー（issues フィールド）を参照する方法 リポジトリからたどる方法 &amp;ndash; repository クエリ で Repository オブジェクト を取得し、そのリポジトリ内のイシュー（issues フィールド）を参照する方法 ダイレクトに検索する方法 &amp;ndash; search クエリ でもろもろの検索条件（リポジトリ名、タイプなど）を使ってダイレクトに検索する方法 search クエリによる検索はとても柔軟で、様々な条件（query パラメータ）を指定してイシューを検索することができます。 query パラメータには、GitHub の Issues ページの検索窓に入力できる is:issue is:open といった文字列で、下記のサイトに詳細仕様が記述されています。
Issue およびプルリクエストを検索する - GitHub Docs あるリポジトリのイシューの一覧を取得する 次の GraphQL クエリでは、myorg/myrepo リポジトリの最新 5 件のイシュー情報を取得しています。
GraphQL クエリ query{search(type:ISSUE,query:&amp;#34;repo:myorg/myrepo is:issue&amp;#34;,last:100){issueCountnodes{...onIssue{idnumbertitleclosedurlauthor{login}assignees(first:100){nodes{loginnameemail}}labels(first:100){nodes{namecolor}}}}}} search クエリはそのパラメータの意味を理解するのが重要です。
type: ISSUE 検索対象を示す必須パラメータで、ISSUE / REPOSITORY / USER のいずれかを指定する必要があります。ここでは、イシューやプルリクエストの情報を検索することを示しています（ISSUE はプルリクエストの情報まで含むことに注意）。 query: &amp;quot;repo:myorg/myrepo is:issue&amp;quot; 検索対象を指定したリポジトリに絞り込み、さらに、is:issue を指定することでプルリクエストを除外します。他にもいろいろな指定方法があります。 last: 100 最新の 100 件までのイシュー情報を取得します。100 件を超えるデータを取得するときはページネーション処理により、複数回のクエリ実行が必要です。 その他のクエリ方法いろいろ あるマイルストーンが設定されたイシューを取得する search(type:ISSUE,last:100,query:&amp;#34;repo:myorg/myrepo milestone: \&amp;#34;Milestone #123\&amp;#34; is:issue&amp;#34;) この例では、myorg/myrepo リポジトリから、マイルストーン名 Milestone #123 が設定されたイシューの一覧を取得しています。 マイルストーン名にスペースを含んでいる場合は、上記のようにエスケープされたダブルクォートでマイルストーン名を囲む必要があります。</description></item><item><title>GitHub GraphQL クエリ例: リポジトリの情報を取得する (repository)</title><link>https://maku.blog/p/du6env5/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/du6env5/</guid><description>GitHub の GraphQL API を使ってリポジトリの情報を取得するには、次のような方法があります。
repository クエリ &amp;hellip; 組織名（あるいはユーザ名）とリポジトリ名が分かっている場合 organization クエリ &amp;hellip; ある組織内のリポジトリの一覧を取得する場合（こちらの記事 を参考にしてください） search クエリ &amp;hellip; 汎用的な検索用クエリ でリポジトリを検索する search クエリでリポジトリを検索する 特定の組織 (organization) 内のリポジトリを取得するには、organization クエリを使って 得られた Organization オブジェクトの repositories を参照する方法もありますが、最初から search クエリを使っていろいろな条件を指定して検索する方が早いです。
参考: リポジトリを検索する - GitHub Docs 次の例では、myorg という組織内の、product というトピックの付けられたリポジトリの一覧を取得しています。
クエリ例 query{search(type:REPOSITORY,query:&amp;#34;org:myorg topic:product&amp;#34;,last:100){repositoryCountnodes{...onRepository{idurlnamedescriptioncreatedAt}}}} 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;search&amp;#34;: { &amp;#34;repositoryCount&amp;#34;: 3, &amp;#34;nodes&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;DEMwOlJlcG9zaXRvcnkzODA5MTQ0OQ==&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/myorg/Repo1&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Repo1&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Repo1 の概要説明&amp;#34;, &amp;#34;createdAt&amp;#34;: &amp;#34;2015-06-26T04:54:51Z&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;DEMwOlJlcG9zaXRvcnkxNjI2NjczMjY=&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.</description></item><item><title>GitHub GraphQL クエリ例: 組織の情報を取得する (organization)</title><link>https://maku.blog/p/3o2doyb/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3o2doyb/</guid><description>GitHub GraphQL API で指定した組織の情報を（ここでは github organization）の情報を取得には、organization クエリ を使用します。 organization クエリには、login パラメーターで組織名を渡します。
organization クエリが返す Organization オブジェクト を参照すると、そこに所属する メンバーの一覧、チームの一覧、リポジトリの一覧 などを取得することができます。
ある組織に所属するユーザー情報を取得する (Organization.membersWithRole) Organization オブジェクトの membersWithRole フィールドは OrganizationMemberConnection オブジェクトを保持しており、この nodes を参照することで、組織に所属するメンバーの一覧を取得できます。
GraphQL クエリ query{organization(login:&amp;#34;github&amp;#34;){namedescriptionurlmembersWithRole(first:3){nodes{loginnameemailupdatedAt}}}} 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;organization&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;GitHub&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;How people build software.&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/github&amp;#34;, &amp;#34;membersWithRole&amp;#34;: { &amp;#34;nodes&amp;#34;: [ { &amp;#34;login&amp;#34;: &amp;#34;mtodd&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Matt Todd&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;xxx@example.com&amp;#34;, &amp;#34;updatedAt&amp;#34;: &amp;#34;2022-05-28T16:13:01Z&amp;#34; }, { &amp;#34;login&amp;#34;: &amp;#34;jonmagic&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Jonathan Hoyt&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;xxx@example.com&amp;#34;, &amp;#34;updatedAt&amp;#34;: &amp;#34;2022-06-07T18:27:30Z&amp;#34; }, { &amp;#34;login&amp;#34;: &amp;#34;mislav&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Mislav Marohnić&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;xxx@example.</description></item><item><title>Node.js で GitHub GraphQL API を使用する (@octokit/graphql)</title><link>https://maku.blog/p/h5s6ht5/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h5s6ht5/</guid><description>概要 GitHub 上の情報を扱う API として、GitHub は GraphQL API を提供しています。
GitHub GraphQL API v4 | GitHub Developer Guide Node.js で GraphQL を扱う方法としては、Apollo ライブラリを使った方法 などがありますが、GitHub の GraphQL API を呼び出したいのであれば、GitHub が提供している GraphQL パッケージ @octokit/graphql を使うのが手っ取り早いかもしれません（エンドポイントの URL などを省略できます）。
octokit/graphql.js: GitHub GraphQL API client for browsers and Node @octokit/graphql - npm ここでは、TypeScript からこの @octokit/graphql パッケージを使用する方法を紹介します。
☝️ REST API と GraphQL API GitHub API バージョン 3 は REST API でしたが、柔軟性などの観点 から、GitHub API バージョン 4 の GraphQL 版の API を使用することが推奨されています。 GraphQL API を使用することで、REST API で複数のリクエストが必要だったものを 1 度のリクエストで取得できたりします。 また、GraphQL API でしか取得できない情報もあったりします。 セットアップ まず、TypeScript のプロジェクトを作成します。</description></item><item><title>GitHub GraphQL のスキーマ情報を取得する</title><link>https://maku.blog/p/whv8it5/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whv8it5/</guid><description>GitHub API のサイトからダウンロードする方法 次のサイトから GitHub GraphQL API のスキーマ定義ファイル (schema.docs.graphql) をダウンロードすることができます。
パブリックスキーマ - GitHub Docs 例えば、このファイル内の Query オブジェクト (type Query) の定義を見ると、クエリのトップレベルにどのようなオブジェクト（フィールド）を指定できるかが分かります。
schema.docs.graphql typeQuery{...organization(login:String!):Organization...user(login:String!):User} 上記の場合、Query オブジェクト内に organization や user フィールドが定義されているので、クライアントアプリからクエリ要求を出すときに、次のような感じで指定できるということが分かります。
query{organization(login:&amp;#34;netflix&amp;#34;){namedescriptionavatarUrl}user(login:&amp;#34;octocat&amp;#34;){namecompanyurlavatarUrl}} スキーマ定義ファイル (.graphql) とクライアントアプリ側のクエリ定義 (query {...}) を組み合わせることで、TypeScript 用の型定義ファイルを自動生成することができます（クエリ要求の戻り値の型を定義できます）。 詳しくは、Apollo CLI などのコマンドラインツールを確認してください。
GraphQL サーバーから直接取得する方法 GitHub の GraphQL API サーバーに HTTP GET リクエストを送ることで、スキーマ定義を直接取得することができます。 パーソナルアクセストークンはこちら から生成してください。
$ token=&amp;lt;YOUR_PERSONAL_ACCESS_TOKEN&amp;gt; $ curl -H &amp;#34;Authorization: bearer $token&amp;#34; https://api.github.com/graphql 結果は圧縮された JSON テキストで返されます。 python -m json.</description></item><item><title>GitHub GraphQL API の呼び出し回数制限 (rate limit) の情報を取得する</title><link>https://maku.blog/p/bqz7emt/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bqz7emt/</guid><description>GitHub API を使ったアプリケーションを作成するときは、API の呼び出し回数制限を意識した設計を行う必要があります。 GitHub API バージョン3 の REST API には、1 時間に 5000 リクエストまでという明確な呼び出し回数制限がありましたが、API バージョン4 の GraphQL API はそのクエリの性質上、ちょっと異なるコスト計算方法が採用されています。
GraphQL resource limitations | GitHub Developer Guide 正確な計算方法は上記のサイトに記述されていますが、簡単にいうと、GraphQL クエリの入れ子階層が深くなり、複雑になるほどコストがかかるという計算になっています。
ある GraphQL クエリが実際にどれだけのコストがかかるかは、下記のように rateLimit 情報を取得することで調べることができます。
query{rateLimit{limitcostremainingresetAt}search(query:&amp;#34;repo:electron/electron is:issue&amp;#34;,type:ISSUE,first:5){issueCountnodes{...onIssue{titlelabels(first:10){nodes{name}}}}}} 上記のクエリを実行すると、次のような感じの JSON レスポンスが返ってきます。
{ &amp;#34;data&amp;#34;: { &amp;#34;rateLimit&amp;#34;: { &amp;#34;limit&amp;#34;: 5000, &amp;#34;cost&amp;#34;: 1, &amp;#34;remaining&amp;#34;: 4999, &amp;#34;resetAt&amp;#34;: &amp;#34;2020-08-02T09:15:20Z&amp;#34; }, &amp;#34;search&amp;#34;: { &amp;#34;issueCount&amp;#34;: 13278, &amp;#34;nodes&amp;#34;: [ // ... ] } } } rateLimit の各プロパティの値は次のような意味を持っています。</description></item><item><title>GitHub GraphQL API のクエリ例: ユーザー情報を取得する (viewer, user)</title><link>https://maku.blog/p/9bku4cj/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9bku4cj/</guid><description>サインイン済みのユーザー情報を取得する (viewer) viewer クエリを使用すると、現在アクセスしているユーザー（サインイン中のユーザー）のユーザー情報（User オブジェクト）を取得することができます。
Queries - viewer GraphQL クエリ query{viewer{login# ログインIDname# ユーザー名email# メールアドレス（ユーザーが公開していれば）url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}} 実行結果 { &amp;#34;data&amp;#34;: { &amp;#34;viewer&amp;#34;: { &amp;#34;login&amp;#34;: &amp;#34;maku77&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Maku Maku&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;maku@example.com&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/maku77&amp;#34;, &amp;#34;websiteUrl&amp;#34;: &amp;#34;https://maku77.github.io/&amp;#34;, &amp;#34;avatarUrl&amp;#34;: &amp;#34;https://avatars2.githubusercontent.com/u/5519503?v=4&amp;#34; } } } 指定したログイン ID のユーザー情報を取得する (user) user クエリを使用すると、指定したユーザー名のユーザー情報を取得することができます。
Queries - user GraphQL クエリ query{user(login:&amp;#34;maku77&amp;#34;){login# ログインIDname# ユーザー名email# メールアドレス（ユーザーが公開していれば）url# ユーザーの GitHub ホームページwebsiteUrl# ユーザーの Web サイトavatarUrl# ユーザーのアバター画像}} 取得できるオブジェクトは、viewer クエリの場合と同様に User オブジェクト です。</description></item></channel></rss>