<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Electron on まくろぐ</title><link>https://maku.blog/tags/electron/</link><description>Recent content in Electron on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 03 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/electron/index.xml" rel="self" type="application/rss+xml"/><item><title>Electron で Hello World (1) 最小構成で作る</title><link>https://maku.blog/p/ter4eq2/</link><pubDate>Mon, 08 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ter4eq2/</guid><description>Electron とは Electron | Build cross-platform desktop apps with JavaScript, HTML, and CSS.
Electron は GitHub が開発した、デスクトップアプリを開発するためのプラットフォームで、2020 年現在も活発な開発が続けられています。 Node.js や HTML5 技術を利用しており、 様々な OS (Windows, macOS, Linux) で動作するデスクトップアプリ を作成することができます。
フロントエンド（UI 表示部分）に Chromium (HTML/CSS) を使用し、バックエンド（OSとの連携部分）に Node.js を使用するという構成になっています。 Electron で作成されている有名なアプリケーションに Visual Studio Code や Slack などがあります。 これらのアプリケーションの完成度を見れば、大規模なアプリケーション開発にも使用できるプラットフォームだということが分かります。
Node.js さえ入っていれば、簡単にデスクトップアプリの開発を始められる ので、下記の Hello World だけでも試してみてください。
Electron で Hello World アプリを作成する package.json の作成 Electron アプリは Node.js アプリとして作成するので、プロジェクトのルートディレクトリに package.json を作成します。 npm init コマンドなどでベースとなる package.json ファイルをサクッと生成し、</description></item><item><title>Electron で Hello World (2) TypeScript で開発できるようにする</title><link>https://maku.blog/p/78whxix/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/78whxix/</guid><description>概要 前回の記事（Electron で Hello World (1) 最小構成で作る）では、プレーンな JavaScript を使用して簡単な Electron アプリを作成しましたが、本格的な開発を始めるときは TypeScript の環境を導入しておいた方がよいでしょう。
ここでは、上記のプレーンな JavaScript による Hello World ができているとして、TypeScript の環境を追加でセットアップします。 次のように、src ディレクトリ内に .ts ファイルを作成し、トランスパイルされた .js ファイルを build ディレクトリに出力するように設定することにします。
myapp/ +-- build/ # トランスパイル後の .js ファイルを格納 +-- src/ # .ts ファイルを格納 +-- public/ # そのままパッケージングするもの | +-- index.html +-- package.json # Node.js 用設定ファイル +-- tsconfig.json # TypeScript 用設定ファイル ビルド設定 TypeScript をインストールします。
$ npm install typescript --save-dev Node.js ライブラリ用の型宣言ファイル (node.d.ts) をインストールします。</description></item><item><title>Electron で Hello World (3) React を使えるようにする</title><link>https://maku.blog/p/6pybmv6/</link><pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6pybmv6/</guid><description>概要 ここでは、Electron アプリの開発に React を導入する手順を示します。 React を導入すると、HTML をフラットな形でゴリゴリ記述していくのではなく、独自コンポーネント（例: &amp;lt;MyButton&amp;gt; コンポーネント）を定義して、まとまりのある単位でコンテンツを構築していくことができます。
下記の手順により、Electron + TypeScript による開発環境が構築できていることを前提とします。
Electron で Hello World (1) 最小構成で作る Electron で Hello World (2) TypeScript で開発できるようにする この記事の手順が完了すると、Electron + TypeScript + React による開発環境が整います。 一応 webpack などのバンドルツールを使わなくても開発を始められるので、Electron と React の開発環境としての相性はよさそうです。
React のセットアップ React モジュールのインストール React モジュールおよび、TypeScript 用の型定義ファイルをインストールします。
$ npm install --save react react-dom $ npm install --save-dev @types/react @types/react-dom package.json の内容は次のような感じになります。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.</description></item><item><title>プロキシ環境から Electron をインストールできない場合の対処方法</title><link>https://maku.blog/p/t7gqxyf/</link><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t7gqxyf/</guid><description>問題 プロキシ環境下で、Electron (9.0.5) をインストールしようとしたら、まぁいろいろとエラーになってハマりました。 どうも、node install.js の実行がうまくいっていないようです。
D:\sandbox&amp;gt; npm install electron --save-dev &amp;gt; core-js@3.6.5 postinstall D:\sandbox\node_modules\core-js &amp;gt; node -e &amp;#34;try{require(&amp;#39;./postinstall&amp;#39;)}catch(e){}&amp;#34; &amp;gt; electron@9.0.5 postinstall D:\sandbox\node_modules\electron &amp;gt; node install.js RequestError: read ECONNRESET at ClientRequest.&amp;lt;anonymous&amp;gt; (D:\sandbox\node_modules\got\source\request-as-event-emitter.js:178:14) at Object.onceWrapper (events.js:422:26) at ClientRequest.emit (events.js:327:22) at ClientRequest.origin.emit (D:\sandbox\node_modules\@szmarczak\http-timer\source\index.js:37:11) at TLSSocket.socketErrorListener (_http_client.js:467:9) ... ECONNRESET ってことはプロキシの設定かなぁと思ったけど、プロキシは npm config set proxy ... でちゃんとセットしているし、なんだろう。。。
解決方法 と調べていたら、下記の Electron のチュートリアルに書いてありました。
Installation - Proxies | Electron If you need to use an HTTP proxy, you need to set the ELECTRON_GET_USE_PROXY variable to any value, plus additional environment variables depending on your host system&amp;rsquo;s Node version.</description></item><item><title>Electron で設定情報を扱う (electron-store)</title><link>https://maku.blog/p/ev6env5/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ev6env5/</guid><description>electron-store パッケージ を使用すると、Electron アプリ用の設定を簡単にローカルファイルとして保存できます。
electron-store のインストール $ npm install --save electron-store electron-store パッケージには TypeScript 用の型定義も含まれているため、別途型定義ファイルをインストールする必要はありません。
electron-store の使い方 簡単な使い方 electron-store モジュールは、キー＆バリューの形で設定値を保存する簡単な API (get/set) を提供しています。 下記の例では、color というキーで色情報を取得・保存しています。
main.ts import ElectronStore from &amp;#39;electron-store&amp;#39;; const store = new ElectronStore(); // 設定情報を取得する（第2パラメーターはデフォルト値） const color = store.get(&amp;#39;color&amp;#39;, &amp;#39;unknown&amp;#39;); console.log(color); // 設定情報の保存する store.set(&amp;#39;color&amp;#39;, &amp;#39;blue&amp;#39;); 1度目の実行では、設定情報が保存されていないので、get メソッドは第2引数で指定した unknown を返します。 2度目の実行では、前回保存した blue という値を取得できます。
設定値の型を定義する TypeScript を使っている場合は、get() で取得した値を特定の型の変数で受け取ることになると思います。 ElectronStore はジェネリクスクラスとして定義されており、各設定キーの型をあらかじめ指定しておくことができます。 次の例では、color 設定を文字列型として宣言しています。
import ElectronStore from &amp;#39;electron-store&amp;#39;; type StoreType = { color: string; } const store = new ElectronStore&amp;lt;StoreType&amp;gt;(); const color: string = store.</description></item><item><title>Electron アプリで OS のプロキシ設定をメインプロセスに反映する</title><link>https://maku.blog/p/t7ekrx4/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t7ekrx4/</guid><description>Electron アプリは「メインプロセス」と「レンダラープロセス」の 2 種類を扱わないといけないので、プロキシの設定でハマりがちです。 ここでは、システム (OS) のプロキシ設定を、自動的に両プロセスに反映する方法を説明します。 この仕組みを入れておけば、ユーザーにわざわざプロキシの設定をしてもらわなくて済むようになります。
レンダラープロセスの HTTP 通信 レンダラープロセス側は、Chromium の仕組みで システムのプロキシ設定が自動的に反映される ようになっています。 例えば、Web ブラウザ上の JavaScript で使用する XMLHttpRequest 関数や fetch 関数による HTTP 通信は、自動的にプロキシ経由で実行されます。 この振る舞いで問題なければ、特に設定を行う必要はありません。
BrowserWindow で扱うプロキシを明示的に指定するには、session オブジェクトの setProxy メソッド を使用します。
メインプロセスの HTTP 通信 Electron のメインプロセスはいわゆる Node.js アプリケーションと同様の仕組みで動作するので、Web ブラウザ側のプロキシ設定が自動的に反映されるようなことはありません。 しかし、electron モジュールが提供する session オブジェクトには、Chromium 側のプロキシ設定を参照する機能が備わっています。 この情報を利用すれば、メインプロセス側のプロキシ設定も自動的に行うことができます。
下記の autoProxy() 関数をメインプロセス起動直後に呼び出しておけば、メインプロセス側で実行する HTTP 通信に対してシステムのプロキシ設定が反映されます。
import {app, session} from &amp;#39;electron&amp;#39;; import {bootstrap} from &amp;#39;global-agent&amp;#39;; /** * システムのプロキシ設定情報をメインプロセスの HTTP 通信に反映します。 */ export function autoProxy() { app.</description></item><item><title>Electron アプリがパッケージングされた環境 (production) で動作しているか調べる</title><link>https://maku.blog/p/5ku5dmt/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5ku5dmt/</guid><description>Electron の app モジュールの isPackaged プロパティ を参照すると、アプリが electron-builder などでパッケージングされた状態で動作しているかどうかを調べることができます。 一般的に、app.isPackaged が true となる場合、production モードで動作していると考えられます。
次の例では、アプリが開発中の場合のみ Chromium の DevTools を開くようにしています。
// const win = new BrowserWindow(this.options); // 開発中のみ起動時に DevTools を開く if (!app.isPackaged) { win.webContents.openDevTools() }</description></item><item><title>Electron アプリ内のリンクをOSのデフォルトブラウザで開く</title><link>https://maku.blog/p/7yhwcr7/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7yhwcr7/</guid><description>BrowserWindow 内で表示した HTML のリンクをクリックすると、デフォルトではそのウィンドウ内でリンク先のページへ遷移します。 リンククリック時に発生する will-navigate イベント と new-window イベント をハンドルすることで、OS のデフォルトブラウザでリンクを開くことができます。 リンククリック時には通常 will-navigate イベントが発生するのですが、&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt; のように別ウィンドウで開くようなリンクをクリックした場合は new-window イベントが発生するので、両方のイベントをハンドルする必要があります。
// リンククリック時に OS のデフォルトブラウザで開く const handleUrlOpen = (event: Event, url: string) =&amp;gt; { event.preventDefault(); shell.openExternal(url); }; // リンククリック時のイベントハンドラを登録 win.webContents.on(&amp;#39;will-navigate&amp;#39;, handleUrlOpen); win.webContents.on(&amp;#39;new-window&amp;#39;, handleUrlOpen); 下記はメインプロセス全体のコードです。
main.ts import { app, BrowserWindow, shell } from &amp;#39;electron&amp;#39;; class MainWindow { private options: Electron.BrowserWindowConstructorOptions = { width: 800, height: 400, webPreferences: { nodeIntegration: true } } // リンククリック時に OS のデフォルトブラウザで開く private handleUrlOpen = (event: Event, url: string) =&amp;gt; { event.</description></item><item><title>Electron アプリのレイアウトにはフレックスボックスなど新しいスタイルを使用する</title><link>https://maku.blog/p/awamxak/</link><pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/awamxak/</guid><description>Electron アプリのレンダリングには、最新の Chromium を使用できるため、比較的新しい CSS 機能を安心して使用することができます。 Web ブラウザで動作するわけではないので、ベンダープレフィックスなどのケアをする必要もありません。
例えば、次の例では、サイドバーと領域の広がる本文部分に別れるレイアウトを、CSS のフレックスボックス (Flexbox) で実現しています（ここでは React を使用しています）。
app.tsx import * as React from &amp;#39;react&amp;#39;; const styles: {[key: string]: React.CSSProperties} = { container: { display: &amp;#39;flex&amp;#39;, minHeight: &amp;#39;100vh&amp;#39;, }, sidebar: { background: &amp;#39;lightgray&amp;#39;, width: &amp;#39;150px&amp;#39;, }, body: { background: &amp;#39;#ddd&amp;#39;, flex: 1, } }; export class App extends React.Component { public render(): React.ReactNode { return ( &amp;lt;div style={styles.container}&amp;gt; &amp;lt;div style={styles.sidebar}&amp;gt;Sidebar&amp;lt;/div&amp;gt; &amp;lt;div style={styles.body}&amp;gt;Body&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ); } } フレックスボックスはとても柔軟で、画面上端で左右に広がるメニュー など、いろいろな用途に使用することができます。</description></item><item><title>Electron のメインプロセスとレンダラープロセスの関係</title><link>https://maku.blog/p/mkisgqb/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/mkisgqb/</guid><description>メインプロセスとレンダラープロセス Electron アプリを作成するときは、メインプロセスとレンダラープロセスを意識して使い分ける必要があります。
レンダラープロセス側で呼び出し可能な Electron モジュール（他の Node モジュールも含む）は制限されていて、実行できる JavaScript ライブラリは、Web ブラウザ上で実行可能な JavaScript に毛が生えたものくらいものと考えておくのがよいです。
ipcRenderer モジュールは例外的にレンダラープロセスから使ってもよいとされているモジュールのひとつで、これ経由でメインプロセスに対して要求（メッセージ）を送ることができます。 逆にメインプロセスからのメッセージをハンドルすることもできます。
通知先のレンダラープロセスの指定 メインプロセスに対して、レンダラープロセスは複数存在することがあるので、メインプロセスからメッセージを送るときは、どのレンダラープロセスへのメッセージなのかを意識する必要があります。
レンダラープロセスからのメッセージに応答する レンダラープロセスからのイベントを ipcMain.on() でハンドルする場合、コールバック関数の第1パラメータとして渡される event: Electron.IpcMainEvent オブジェクトから送信元のレンダラープロセス (sender: Electron.WebContents) を参照することができます。
下記のメインプロセスは、my-add イベントとしてレンダラープロセスから 2 つの数値を受け取り、IpcMainEvent.reply() を使って送信元のレンダラープロセスに応答メッセージ（数値を足した結果）を返しています。
main.ts（メインプロセス） // レンダラープロセスからメッセージを受信して、応答メッセージを返す ipcMain.on(&amp;#39;my-add&amp;#39;, (evt: Electron.IpcMainEvent, num1: number, num2: number) =&amp;gt; { evt.reply(&amp;#39;my-add-reply&amp;#39;, num1 + num2); //evt.sender.send(&amp;#39;my-add-reply&amp;#39;, num1 + num2); }); レンダラープロセス側では、ipcRenderer.send() でメインプロセスにメッセージを送り、その応答を ipcRenderer.on() でハンドルするように実装します。
renderer.ts（レンダラープロセス） import { ipcRenderer } from &amp;#39;electron&amp;#39;; // メインプロセスへメッセージを送信 ipcRenderer.</description></item><item><title>Electron の app.getData() で取得できる特殊ディレクトリパスの一覧</title><link>https://maku.blog/p/77sas8m/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/77sas8m/</guid><description>app.getPath について electron モジュールの app.getPath(name) 関数を使用すると、OS 固有の特殊フォルダパスを取得することができます。 例えば、getPath('userData') とすると、ユーザーの設定ファイルなどを格納するディレクトリを取得することができます。
下記は、いろんな特殊フォルダのパスを取得するテストコードです。
import { app } from &amp;#39;electron&amp;#39;; export function showSpecialDirs() { console.log(`app.getAppPath() = ${app.getAppPath()}`); console.log(&amp;#39;\n==== Application data&amp;#39;); console.log(`app.getPath(&amp;#39;home&amp;#39;) = ${app.getPath(&amp;#39;home&amp;#39;)}`); console.log(`app.getPath(&amp;#39;temp&amp;#39;) = ${app.getPath(&amp;#39;temp&amp;#39;)}`); console.log(`app.getPath(&amp;#39;appData&amp;#39;) = ${app.getPath(&amp;#39;appData&amp;#39;)}`); console.log(`app.getPath(&amp;#39;cache&amp;#39;) = ${app.getPath(&amp;#39;cache&amp;#39;)}`); console.log(`app.getPath(&amp;#39;userData&amp;#39;) = ${app.getPath(&amp;#39;userData&amp;#39;)}`); console.log(`app.getPath(&amp;#39;logs&amp;#39;) = ${app.getPath(&amp;#39;logs&amp;#39;)}`); console.log(`app.getPath(&amp;#39;crashDumps&amp;#39;) = ${app.getPath(&amp;#39;crashDumps&amp;#39;)}`); console.log(&amp;#39;\n==== OS multimedia&amp;#39;) console.log(`app.getPath(&amp;#39;desktop&amp;#39;) = ${app.getPath(&amp;#39;desktop&amp;#39;)}`); console.log(`app.getPath(&amp;#39;documents&amp;#39;) = ${app.getPath(&amp;#39;documents&amp;#39;)}`); console.log(`app.getPath(&amp;#39;downloads&amp;#39;) = ${app.getPath(&amp;#39;downloads&amp;#39;)}`); console.log(`app.getPath(&amp;#39;music&amp;#39;) = ${app.getPath(&amp;#39;music&amp;#39;)}`); console.log(`app.getPath(&amp;#39;pictures&amp;#39;) = ${app.getPath(&amp;#39;pictures&amp;#39;)}`); console.log(`app.getPath(&amp;#39;videos&amp;#39;) = ${app.getPath(&amp;#39;videos&amp;#39;)}`); console.log(&amp;#39;\n==== Executables&amp;#39;) console.</description></item><item><title>Electron アプリの配布パッケージを作る (electron-builder)</title><link>https://maku.blog/p/2tcs8n2/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2tcs8n2/</guid><description>概要 electron-builder を使用すると、Electron アプリを Windows、macOS、Linux 用の配布用バイナリとしてパッケージングすることができます。 各 OS 用のインストーラはもちろん、ポータブルな zip パッケージを作成することもできます。
electron-builder 公式サイトのドメイン名が electron.build っていうのがかっこいいですね。
electron-builder のインストール Node.js のパッケージ管理ツールとして、npm よりも yarn を使うことが strongly recommended されているので、まず yarn をインストールしてから yarn で electron-builder をインストールすることにします。
$ npm install -g yarn $ yarn add electron-builder --dev 下記のように実行して、ヘルプを表示できればインストール完了です。
$ npx electron-builder --help ビルド設定 electron-builder 用の設定は、package.json の build プロパティで行うことができます。 ポイントは、files の指定で、パッケージングする html ファイルや js ファイル、画像ファイルなどをすべてカバーするように指定しておく必要があります。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;build/main.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;tsc &amp;amp;&amp;amp; electron .</description></item><item><title>Electron: レンダラーからの要求でメインプロセスでファイルを読み込んで返す</title><link>https://maku.blog/p/aq2airz/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aq2airz/</guid><description>Electron アプリのメインプロセスで使用できる ipcMain.handle を使うと、レンダラーから呼び出せる関数のようなものを定義できます。 正確には、特定の名前のチャネル (channel) へのメッセージをハンドルするコールバック関数を設定します。 次の例では、メインプロセスで read-textfile メッセージを受診したときに、指定されたファイルを読み込んでその内容を返すように実装しています。
main.js（メインプロセス） import { app, ipcMain, BrowserWindow } from &amp;#39;electron&amp;#39;; import * as fs from &amp;#39;fs&amp;#39;; // ... // 指定されたテキストファイルを読みこんで、その内容を返します。 ipcMain.handle(&amp;#39;read-textfile&amp;#39;, async (event, filename) =&amp;gt; { const buf = await fs.promises.readFile(filename); return buf.toString(); }); 一方、レンダラー側では ipcRenderer.invoke を使って、あたかも関数呼び出しのようにメインプロセス側の処理を呼び出すことができます。 次の例では、画面上のボタンを押した時にメインプロセスに read-textfile メッセージを送り、その戻り値を表示しています。
renderer.js import { ipcRenderer } from &amp;#39;electron&amp;#39;; const btn = document.querySelector(&amp;#39;#btn&amp;#39;)!; const output = document.querySelector(&amp;#39;#output&amp;#39;)!; btn.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; { ipcRenderer.</description></item><item><title>Electron: 処理が終わるまでボタンを無効状態 (disabled) にする</title><link>https://maku.blog/p/xkxbnza/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xkxbnza/</guid><description>button 要素の disabled プロパティ JavaScript で button 要素の disabled プロパティを true に設定すると、ボタンを無効状態 (disabled) にすることができます。 TypeScript を使っている場合は、document.querySelector() の戻り値を HTMLButtonElement にキャストすることで disabled プロパティを参照できるようになります。
button 要素を disabled にする const btn = document.querySelector(&amp;#39;#btn&amp;#39;) as HTMLButtonElement; btn.disabled = true; ボタンを押したときに重い処理（データ取得など）を実行する場合、処理中にボタンを無効化することで、ユーザーによるボタンの連打を防ぐことができます。
より実践的なサンプル 下記は Electron アプリの実装サンプル（レンダラープロセスの抜粋）です。 ボタンを押したときにボタンを無効化すると同時に Web からデータ取得します。 そして、データ取得が完了するか、エラーが発生したときにボタンを有効化します。
ここでは、HTTP GET リクエストを送るために superagent モジュールを使用しています。
superagent のインストール $ npm install --save superagent $ npm install --save @types/superagent renderer.ts import * as superagent from &amp;#39;superagent&amp;#39;; const btn = document.</description></item><item><title>Electron で各種ダイアログを表示する (dialog)</title><link>https://maku.blog/p/ihwanyc/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ihwanyc/</guid><description>electron モジュールが提供する dialog を使用すると、いろいろなダイアログを表示することができます。 ダイアログの表示は、メインプロセスからしか行えません。
参考: Electron Documentation - dialog エラーボックス (showErrorBox) 一番簡単に使えそうなエラーボックスから。 ダイアログのタイトルと、メッセージの内容を指定するだけで表示できます。
dialog.showErrorBox(title, content) import { dialog } from &amp;#39;electron&amp;#39;; dialog.showErrorBox(&amp;#39;File Not Found&amp;#39;,&amp;#39;指定されたファイルが見つかりませんでした。&amp;#39;); このエラーボックスが表示されている間は、他の全てのウィンドウが操作できなくなるようです（つまり、モーダルダイアログとして振る舞います）。
ドキュメントによると、この dialog.showErrorBox は、「app モジュールが ready イベントを emit する前に呼び出すことができる」とされています。 つまり、アプリケーションの起動時に行うエラーチェックなどで使用できるということです（メインウィンドウ表示前に設定ファイルの内容が正しいか調べたり）。
レンダラープロセス側では alert() を使っちゃうことが多いかもしれません。
メッセージボックス (showMessageBox, showMessageBoxSync) メッセージボックスを表示するには、次のような関数を使用します。
dialog.showMessageBox(options) dialog.showMessageBox(browserWindow, options) dialog.showMessageBoxSync(options) dialog.showMessageBoxSync(browserWindow, options) 表示内容を options パラメータでいろいろ制御できます（下記に例を示します）。
メッセージボックスが表示されている間は、基本的には他のウィンドウを操作できなくなります。 browserWindow パラメーターで、親ウィンドウとなる BrowserWindow インスタンスを指定すると、その親ウィンドウのモーダレスダイアログとなり、その親ウィンドウだけ操作できなくなります。
☝️ ワンポイント showMessageBoxSync() にも親ウィンドウを指定するバージョンがありますが、この関数を呼び出すと結局他のウィンドウも操作できなくなります。 いまいち使いどころが分かりませんが、親ウィンドウを指定することで、親ウィンドウの表示位置に近いところにダイアログが表示されるという効果は得られます。 例: OK ボタンだけあるダイアログ const options: Electron.</description></item></channel></rss>