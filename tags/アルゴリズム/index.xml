<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>アルゴリズム on まくろぐ</title><link>https://maku.blog/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/</link><description>Recent content in アルゴリズム on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Wed, 03 Jun 2020 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>文字列の類似度を計算する（LCS: 最長共通部分列）</title><link>https://maku.blog/p/a3jyhwd/</link><pubDate>Thu, 20 Nov 2014 00:00:00 +0900</pubDate><guid>https://maku.blog/p/a3jyhwd/</guid><description>&lt;h2 id="lcs-とは">LCS とは&lt;/h2>
&lt;p>&lt;strong>LCS: Longest Common Subsequence（最長共通部分列）&lt;/strong> 問題とは、2 つのシーケンスから最長の共通部分列を探す問題です。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem">Wikipedia - Longest common subsequence problem&lt;/a>&lt;/li>
&lt;li>参考: &lt;a href="http://ja.wikipedia.org/wiki/%E6%9C%80%E9%95%B7%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86%E5%88%97%E5%95%8F%E9%A1%8C">Wikipedia - 最長共通部分列問題&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>部分列は飛び飛びの要素で構成されていても構いませんが、順番はキープして作成する必要があります。下記の例は、2 つの文字列とその最長共通部分列 (LCS) を示したものです。&lt;/p>
&lt;ul>
&lt;li>文字列1: "ABCDCE"&lt;/li>
&lt;li>文字列2: "ACCDEX"&lt;/li>
&lt;li>LCS: "ACCE" or "ACDE"&lt;/li>
&lt;/ul>
&lt;h2 id="lcs-の計算方法">LCS の計算方法&lt;/h2>
&lt;p>LCS は、動的計画法（DP: Dynamic Programming）の例題としてよく示される問題で、DP を使うことで効率的に答えを求めることができます。
考え方としては、下記のような文字列の入ったスタックから、任意の順番で文字を取り出していく問題だとみなすと分かりやすいです。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="253" height="268" src="../../p/a3jyhwd/img-001.png" alt="/p/a3jyhwd/img-001.png" />
&lt;/figure>

&lt;p>どちらか一方から要素を取り出すときは、文字をマッチさせないと考えます。
両方の要素を同時に取り出すときは、そのタイミングで文字をマッチさせる（LCS を構成する要素）と考えます。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="252" height="251" src="../../p/a3jyhwd/img-002.png" alt="/p/a3jyhwd/img-002.png" />
&lt;/figure>

&lt;p>このように、任意の順番で取り出してマッチングしていったときに、最大の一致数になったものが LCS ということになります。&lt;/p>
&lt;p>ここでは、DP（動的計画法）を使って、文字列 1 と文字列 2 の LCS の長さを求めるコードを考えてみます。&lt;/p>
&lt;ul>
&lt;li>文字列 1 の長さを &lt;code>Len1&lt;/code>、文字列 2 の長さを &lt;code>Len2&lt;/code> とします。&lt;/li>
&lt;li>&lt;code>dp[i][j]&lt;/code> には、文字列 1 の &lt;code>j&lt;/code> 文字目までの部分文字列と、文字列 2 の &lt;code>i&lt;/code> 文字目までの部分文字列を一致させた場合 LCS の長さを格納します。&lt;/li>
&lt;/ul>
&lt;p>まず、0 文字の部分文字列同士の LCS は当然 0 文字なので、&lt;/p></description></item><item><title>文字列の類似度を計算する（レーベンシュタイン距離）</title><link>https://maku.blog/p/xjw9ju7/</link><pubDate>Tue, 18 Nov 2014 00:00:00 +0900</pubDate><guid>https://maku.blog/p/xjw9ju7/</guid><description>&lt;h2 id="レーベンシュタイン距離とは">レーベンシュタイン距離とは&lt;/h2>
&lt;p>&lt;strong>レーベンシュタイン距離 (Levenshtein Distance)&lt;/strong> は、ある文字列に対して、何回の変更処理（削除、挿入、置換）を行えば対象の文字列に変換できるかを示します。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Wikipedia - Levenshtein distance&lt;/a>&lt;/li>
&lt;li>参考: &lt;a href="http://ja.wikipedia.org/wiki/%E3%83%AC%E3%83%BC%E3%83%99%E3%83%B3%E3%82%B7%E3%83%A5%E3%82%BF%E3%82%A4%E3%83%B3%E8%B7%9D%E9%9B%A2">Wikipedia - レーベンシュタイン距離&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>レーベンシュタイン距離を効率的に計算するために、一般的に DP マッチング（動的計画法による距離計算）が使用されます（ここでは文字列間の距離を求めていますが、DP マッチングは単純に二つの波形を伸縮させながらマッチングするためにも使用されます）。
下記に詳細なマッチングの過程を示します。&lt;/p>
&lt;h2 id="2-つの文字列のレーベンシュタイン距離を求める">2 つの文字列のレーベンシュタイン距離を求める&lt;/h2>
&lt;p>次のような文字列 A と文字列 B のレーベンシュタイン距離を求めるとします。&lt;/p>
&lt;ul>
&lt;li>文字列 A = "CARROT"&lt;/li>
&lt;li>文字列 B = "CAT"&lt;/li>
&lt;/ul>
&lt;p>文字列 A の文字数が &lt;code>i&lt;/code> 文字、文字列 B の文字数が &lt;code>j&lt;/code> 文字だとした場合の距離（最短変換数）を格納するための &lt;code>dp&lt;/code> 配列を用意します。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">dp[LenA + 1, LenB + 1]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>下記の図は、この配列を表にしたものです。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="455" height="312" src="../../p/xjw9ju7/img-001.png" alt="/p/xjw9ju7/img-001.png" />
&lt;/figure>

&lt;p>セル内の数値は文字列を一致させるのに費やした変換手順数を表しており、&lt;code>dp[0, 0]&lt;/code> は文字列 A も文字列 B も空文字だった場合の距離なので 0 です（空文字から空文字に変換するまでの手順数です）。
この表に左下から順番に手順数を埋めていき、最終的に右上の G が示している &lt;code>dp[7, 4]&lt;/code> に文字列 A と文字列 B の距離が格納されます（"CAT" を "CARROT" に変換する手順数）。&lt;/p></description></item><item><title>Insertion Sort（挿入ソート）の実装練習</title><link>https://maku.blog/p/axg4xms/</link><pubDate>Tue, 10 Apr 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/axg4xms/</guid><description>&lt;h2 id="insertion-sort-実装の練習">Insertion Sort 実装の練習！&lt;/h2>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">insertion_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">vals&lt;/span>&lt;span class="p">[],&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Insert vals[i] into the sorted sequence vals[0..i-1].
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">vals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">vals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">vals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">--&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>降順ソート (descending order) にするには、&lt;code>vals[j] &amp;gt; key&lt;/code> というところを、&lt;code>vals[j] &amp;lt; key&lt;/code> にするだけで OK。&lt;/p>
&lt;h3 id="テスト">テスト&lt;/h3>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">vals&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vals&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">insertion_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vals&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">vals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>参考: Introduction to Algorithms&lt;/p></description></item></channel></rss>