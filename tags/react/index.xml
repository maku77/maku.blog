<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on まくろぐ</title><link>https://maku.blog/tags/react/</link><description>Recent content in React on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 13 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/react/index.xml" rel="self" type="application/rss+xml"/><item><title>React + TypeScript の環境を整える (1) 自力で webpack 設定する方法</title><link>https://maku.blog/p/m4dmt3a/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4dmt3a/</guid><description>React とは Web サイトを作成するときに React を採用すると、HTML をフラットな形でゴリゴリ記述していくのではなく、独自コンポーネント（例: &amp;lt;MyButton&amp;gt; コンポーネント）を定義してまとまりのある単位でサイトを構築していくことができます。 Web Components という同様な技術の標準化が進んでいますが、しばらくは React のようなコンポーネントライブラリが使われるでしょう。
React – ユーザインターフェース構築のための JavaScript ライブラリ ここでは React を使った Web サイト開発用に、下記のようなツールを組み合わた環境を構築します。
React &amp;hellip; コンポーネントベースで Web サイト構築するためのライブラリ TypeScript &amp;hellip; JavaScript を型付けできるようにした言語 webpack &amp;hellip; Web サイトのリソースをバンドルするためのツール この環境構築方法を理解すれば、React を利用した Web サイトをどんどん作ることができます。 ちなみに、上記のすべてのツールは Node.js 上で動作するため、Node.js がインストールされていない場合は先にインストールしてください。
TypeScript、React、webpack のインストール チュートリアルなどでは、create-react-app を使って React アプリの雛形を生成する方法がよく載っていますが、よくわからないモジュールが勝手にインストールされるのは気持ち悪いので、ここでは自力で各モジュールをインストールしてきます。
☝️ create-react-app は使わない方がいい TypeScript ベースの React アプリの雛形を生成するには、create-react-app myapp --template typescript のように実行します。 このコマンドによって作成された雛形をリファレンスにするのがよいかなと思ったのですが、少なくともバージョン 3.4.1 時点で生成される雛形はかなり怪しいです。 例えば、TypeScript の処理系や型定義ファイルが devDependencies ではなく、dependencies でインストールされるようになっていたりします。 最終的に Web サーバーにデプロイするファイル群は webpack で生成（バンドル）することを想定しているので、npm (or yarn) でインストールするモジュールは、 すべて devDependencies（開発用モジュール）としてインストール していきます（Web サーバー側で npm install を実行することはないということです）。</description></item><item><title>Next.js で HelloWorld（プロジェクト作成からサーバー起動まで）</title><link>https://maku.blog/p/ubmu3bj/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ubmu3bj/</guid><description>Next.js とは Next.js は、React.js アプリ開発に必要なアレコレを詰め込んだパッケージです。 React.js を素の状態で導入すると、他にもいろいろなツールやライブラリを組み合わせていくことになるのですが、Next.js を使うとモダンな Web アプリ開発に必要なものが一気に揃えられます。
React.js は基本的に SPA（シングルページアプリ）を想定していますが、Next.js では複数ページによる構成や、サーバーサイドレンダリングなどをサポートしています。 これは、Next.js が単なる React.js 用のコンポーネントライブラリでないことを示しています。
Next.js には次のような特徴があります。
ゼロコンフィグ: 何も設定しなくても、最初から開発サーバーの立ち上げ、プロダクト用ビルドを行えるようになっています。これらは、最適なパフォーマンスが出るようメンテナンスが続けられています。カスタマイズしたいときも、複雑怪奇な webpack.config.js を作成する必要はなく、next.config.js による最小限の設定で済みます。できれば何も設定しないのが理想です。 SSR/SSG によるプリレンダリング: React.js はクライアントサイドで JavaScript を実行する CSR (Client Side Rendering) で動作しますが、Next.js は SSR (Server Side Rendering) や SSG (Static Site Generation) をサポートしています。これは、一般的な Node.js の API を利用してページを構築できることを意味します。開発元の Vercel は、パフォーマンスの面から SSG を推奨しています。 TypeScript をサポート: いまどきの Web アプリ開発では TypeScript はほぼ必須なので、標準サポートはうれしいです。空の tsconfig.js を置くだけで、TypeScript 対応は完了です（設定は自動で行われます）。 ファイルベースのルーティング: pages ディレクトリ以下の構成をそのままルーティング用のリンク名として使うことができます。例えば、pages/xxx/yyy.js は、/xxx/yyy というリンク名にマッピングされます。React Router によるルーティング設定が面倒だと感じている人にとってはうれしいかもしれません。 部分的な高速リロード (Fast Refresh): Next.</description></item><item><title>React + TypeScript の環境を整える (2) Parcel を使う方法</title><link>https://maku.blog/p/r7fov4b/</link><pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r7fov4b/</guid><description>Parcel とは Parcel は、ゼロ設定 をウリとした Web アプリバンドラーです。 React + TypeScript + SCSS + CSS Modules といった環境を自力でセットアップしようとすると なかなか大変な設定が必要 なのですが、Parcel を使うと、開発環境がサクサクッと完成します。
React プロジェクトを作成するときは、create-react-app を使って雛形を生成する方法もありますが、余計なファイルがたくさん作られたりして、あまり分かりやすいとは言えません。 そんなときは Parcel を使ってみると、そのシンプルさに驚くと思います。
Parcel を使うと、次のような機能がほとんど設定なしでいきなり使えます。 コマンドラインオプションの一覧 を見ると、どのような機能があるかをざっと把握することができます。
開発用の Web サーバー機能（HMR: Hot Module Replacement 対応） TypeScript の自動変換（HTML ファイルから直接ロードする記述が可能） PostCSS による CSS 生成（SCSS、ベンダープレフィックス） CSS ファイルのインポート (CSS Modules) JSON ファイルのインポート PNG ファイルのインポート Pug (Jade) による HTML 生成 リリース用の minify また、Parcel は Node モジュールの自動インストール機能を備えており、parcel コマンドで開発用 Web サーバーを起動すると、自動的に依存モジュールをインストールしてくれます。 例えば、HTML ファイルから TypeScript ファイルを読み込んでいると、typescript モジュールが自動的にインストールされます。</description></item><item><title>Next.js のプロジェクトを TypeScript 化する</title><link>https://maku.blog/p/ny9fmty/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ny9fmty/</guid><description>何をするか？ create-next-app コマンドで Next.js プロジェクトを生成するときに --typescript (--ts) オプションをつけて実行すると、TypeScript 対応したプロジェクトを生成することができます。
$ npx create-next-app myapp --typescript # ただ、こっちのテンプレートを使う方法の方が若干洗練されてる気はする $ npx create-next-app myapp --example with-typescript また、Next.js は既存の JavaScript プロジェクトを TypeScript 化する機能も備えています。 ここから先は、その方法を説明します。
参考 Next.js で HelloWorld TypeScript 環境の導入 Next.js は、プロジェクトのルートに tsconfig.json ファイルがあると、自動的に TypeScript モードで動作するようになります。 次のようにして、空の tsconfig.json ファイルを作成し、TypeScript 用のパッケージをインストールします。
$ touch tsconfig.json $ npm install typescript @types/node @types/react --save-dev なんと、これだけで Next.js プロジェクトへの TypeScript 導入は完了です。 お手軽〜
自動生成される設定ファイルを見ておく 上記のステップで、TypeScript の設定ファイル (tsconfig.json) に何も記述していないことに気づいたかもしれません。 実は、Next.js のビルド（next dev や next build）を実行すると、自動的に設定ファイルの内容を更新してくれるようになっています。</description></item><item><title>GitHub OAuth トークンを取得する (2) Azure Functions 経由で取得する</title><link>https://maku.blog/p/ar2bjs2/</link><pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ar2bjs2/</guid><description>何をするか？ ここでは、静的な Web サイト（の JavaScript) から、GitHub の OAuth トークンを取得できるようにしてみます。 この処理を実装すると、GitHub と連携した Web アプリを、GitHub Pages や Azure Static Web Apps などの、静的サイト用のホスティングサービス上で公開できるようになります。 汎用的な Web サーバー（VPSなど）でホスティングする場合と比べ、非常に安価に運用することができます。
前提知識として、下記の GitHub の OAuth トークン取得の流れを理解しているものとします。
参考: GitHub OAuth トークンを取得する (1) 処理の流れを理解する 静的な Web サイトから GitHub のアクセストークンを取得するときにネックになるのが、クロスオリジン通信 (CORS) の制約です。 また、GitHub のアクセストークンリクエストには、クライアントシークレット情報が必須であり（2020年、2021年現在）、これをクライアントサイドの JavaScript にハードコードするわけにはいきません。 よって、ブラウザ上で実行される JavaScript からは、実質アクセストークンの取得ができないので、何らかのバックエンドサーバーを介す形でアクセストークンを取得する必要があります。
バックエンドサーバーはどのようなものでも構わないのですが、ここではサーバーレス環境である Azure Functions を使ってアクセストークンの取得機能を実装します。
Azure Functions に関数を追加する Azure Functions に HTTP トリガーで起動する関数を追加し、GitHub の OAuth トークンを取得する処理を実装します。 まずは下記の記事を参考にして、Functions アプリ（プロジェクト）を作成してください。
参考: Azure Functions で簡単な関数を作ってみる 作成する関数の仕様は次のとおりとします。</description></item><item><title>Next.js アプリのソースコードを GitHub で管理する</title><link>https://maku.blog/p/xjw8it5/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjw8it5/</guid><description>Next.js のプロジェクトは、create-next-app コマンドで作成済みであるとします。
参考: Next.js で HelloWorld create-next-app コマンドで Next.js アプリを新規作成すると、アプリのトップディレクトリに、Git リポジトリ (.git/) が自動的に生成されます。 git log コマンドを実行すると、初回のコミットがすでに生成されていることがわかります。
$ git log commit 4607ecdd2f3f9f3d0d4c86442463c3b86856e88a (HEAD -&amp;gt; main) Author: maku &amp;lt;maku@example.com&amp;gt; Date: Sun Apr 18 23:28:22 2021 +0900 Initial commit from Create Next App この Next.js アプリを GitHub で管理したいときは、以下の手順で GitHub リポジトリと結びつけます。
GitHub 上に 新規リポジトリを追加 します リポジトリ名は create-next-app で指定したアプリ名と合わせましょう。 Initialize this repository with: の項目では、README.txt の作成にはチェックを入れないでください。リポジトリファイル (.git) はすでに create-next-app によって生成されているので、GitHub 側のリポジトリは空の状態で作成する必要があります。 既存の Next.js アプリを上記の GitHub リポジトリに結びつけます $ cd myapp $ git remote add origin https://github.</description></item><item><title>Electron で Hello World (3) React を使えるようにする</title><link>https://maku.blog/p/6pybmv6/</link><pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6pybmv6/</guid><description>概要 ここでは、Electron アプリの開発に React を導入する手順を示します。 React を導入すると、HTML をフラットな形でゴリゴリ記述していくのではなく、独自コンポーネント（例: &amp;lt;MyButton&amp;gt; コンポーネント）を定義して、まとまりのある単位でコンテンツを構築していくことができます。
下記の手順により、Electron + TypeScript による開発環境が構築できていることを前提とします。
Electron で Hello World (1) 最小構成で作る Electron で Hello World (2) TypeScript で開発できるようにする この記事の手順が完了すると、Electron + TypeScript + React による開発環境が整います。 一応 webpack などのバンドルツールを使わなくても開発を始められるので、Electron と React の開発環境としての相性はよさそうです。
React のセットアップ React モジュールのインストール React モジュールおよび、TypeScript 用の型定義ファイルをインストールします。
$ npm install --save react react-dom $ npm install --save-dev @types/react @types/react-dom package.json の内容は次のような感じになります。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;build/main.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;tsc &amp;amp;&amp;amp; electron .</description></item><item><title>Next.js アプリを GitHub Actions でビルドして GitHub Pages で公開する</title><link>https://maku.blog/p/au8ju6g/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/au8ju6g/</guid><description>何をするか？ ここでは、Next.js アプリを次のような構成でホスティング（Web サイトとして公開）できるようにします。
create-next-app で作成した Next.js アプリのコードを GitHub で管理する main ブランチにプッシュ（マージ）したら GitHub Actions で下記を実行 Next.js アプリをビルド (npm run build, npm run export) GitHub Pages にデプロイ つまり、この設定が終わると、GitHub に Next.js アプリのコードをプッシュするだけで、自動的にビルドされて、Web サイトに反映されるようになります。
GitHub リポジトリの準備 空の GitHub リポジトリを作成し、そこに create-next-app で作成した Next.js アプリをプッシュします。 リポジトリ名は、最終的な Web サイトのアドレスをどうしたいかで、次のように作り分けます。
ユーザーサイト（あるいは Organization サイト） 公開 URL: https://&amp;lt;username&amp;gt;.github.io/ 作成するリポジトリ名: &amp;lt;username&amp;gt;.github.io プロジェクトサイト 公開 URL: https://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository&amp;gt;/ 作成するリポジトリ名: &amp;lt;repository&amp;gt; ここでは、プロジェクトサイトとして myapp というリポジトリを作成した場合の例で説明していきます。
$ npx create-next-app myapp $ cd myapp $ git remote add origin https://github.</description></item><item><title>React コンポーネント実装の基本（関数コンポーネントとクラスコンポーネント）</title><link>https://maku.blog/p/vfr3cnw/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vfr3cnw/</guid><description>React で独自コンポーネントを作成する方法として、大きく次の 2 種類の方法があります。
関数コンポーネント (Function Components) クラスコンポーネント (Class Components) 昔は、ステートを持つコンポーネントは「クラスコンポーネント」で作成し、ステートを持たないものは「関数コンポーネント」として作成するという使い分けがありました。 現在は、関数コンポーネントでも Hook の仕組みでステートを管理することができるようになったため、関数コンポーネントの使用が推奨されています。
関数コンポーネント 関数コンポーネントの基本 下記は、固定のテキストを表示するシンプルな関数コンポーネントの定義例です。 TypeScript (@types/react) では、関数コンポーネントの型は React.FunctionComponent インタフェースとして定義されています。 エイリアスとして React.FC が定義されているので、こちらを使えばより短く記述できます。
components/Hello.tsx import * as React from &amp;#39;react&amp;#39;; // Hello コンポーネントの定義 export const Hello: React.FC = () =&amp;gt; { return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; }; HTML ファイルから読み込む JS ファイルでは、ReactDOM.render() で上記の Hello コンポーネントを描画します。 次のコードを実行すると、&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt; 要素の内容が、Hello コンポーネントの内容に置き換えられます。
index.tsx（使用例） import * as React from &amp;#39;react&amp;#39;; import * as ReactDOM from &amp;#39;react-dom&amp;#39;; import { Hello } from &amp;#39;.</description></item><item><title>Apollo Client で GitHub GraphQL API を使う (Node &amp; React)</title><link>https://maku.blog/p/qcp2cnx/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2cnx/</guid><description>Apollo Client とは Apollo パッケージは、GraphQL を使ったクライアントアプリやサーバーを作成するためのライブラリ群です。 クライアントアプリを作るためのライブラリは、Apollo Client として @apollo/client という NPM パッケージにまとめられています。
Web アプリのコンポーネントを作成するときは React がよく使われますが、Apollo は GraphQL を扱いやすくする React コンポーネント（ApolloProvider、Query、Mutation、Subscription）や React Hook 拡張（useQuery) などを提供しています。
ここでは、Apollo Client パッケージを使用して、
Node.js アプリ（コマンドラインアプリの JS）から GraphQL API の実行 React アプリ（Web サイトの JS）から GraphQL API の実行 を行ってみます。 呼び出す GraphQL API は何でもよいのですが、今回は GitHub GraphQL API を利用することにします。
Node パッケージのインストール Apollo Client Apollo Client 関連のパッケージとしては、@apollo/client と、それが使用する graphql をインストールします。
Apollo Client のインストール ### yarn の場合 $ yarn add @apollo/client graphql ### npm の場合 $ npm install @apollo/client graphql fetch ポリフィル Apollo クライアント内部の実装では、Web ブラウザの fetch API を利用しています。 React アプリから Apollo クライアントを利用する場合は問題ないのですが、コンソールで動作する Node.</description></item><item><title>React フック: useSWR でデータフェッチ</title><link>https://maku.blog/p/vm2ft83/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vm2ft83/</guid><description>SWR とは useSWR フック SWR (useSWR) は、Next.js を開発している人たち (Vercel) が開発したデータフェッチ用の React フックライブラリです。 React アプリでデータフェッチを真面目に実装しようとすると、大体最後にこのライブラリに行き着きますので、最初からこれを使いましょう（GraphQL の場合は Apollo Client がありますが）。
SWR - React Hooks library for data fetching React コンポーネント内から Web API などを呼び出してデータフェッチを行う場合、標準の仕組みだけで実現しようとすると、useEffect フックなどで fetch 関数を呼び出したりすることになります。
useEffect による不完全なデータフェッチ実装 function Page () { const [user, setUser] = useState(null) useEffect(() =&amp;gt; { fetch(&amp;#39;/api/user&amp;#39;) .then(res =&amp;gt; res.json()) .then(data =&amp;gt; setUser(data)) }, []) // ... } もちろん、それで実現は可能なのですが、「データ取得前の表示」「エラー処理/リトライ処理」「非同期処理のキャンセル処理」などをちゃんとやろうとすると非常に煩雑なコードになってきます（上記コードはそれらが全く考慮できていません）。 useSWR フックを使うと、クライアントサイド JavaScript からのデータフェッチ処理をとても綺麗に記述することができます。
useSWR の使用例 import { FC } from &amp;#39;react&amp;#39; import useSWR from &amp;#39;swr&amp;#39; const fetcher = (url: string) =&amp;gt; fetch(url).</description></item><item><title>React コンポーネントのプロパティでハンドラメソッドを渡す</title><link>https://maku.blog/p/e2dpycn/</link><pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e2dpycn/</guid><description>ここでは、次のようにプロパティ（属性）でハンドラメソッドを設定可能な React コンポーネントの実装例を示します。
&amp;lt;MyButton onClick={handleClick} /&amp;gt; ハンドラメソッドを設定可能なコンポーネントを実装する 次の MyButton コンポーネントは、ボタンクリック時に呼び出されるイベントハンドラを、onClick プロパティで設定できるようにしています。 この MyButton コンポーネントは、クリックするたびに内部のカウンタ (state.count) を +1 し、その値を指定されたイベントハンドラへ通知します。
components/myButton.tsx import * as React from &amp;#39;react&amp;#39;; // MyButton のプロパティ（属性）の型 export interface MyButtonProps { onClick?: (count: number) =&amp;gt; void; } // MyButton の状態（ステート）の型 interface MyButtonState { count: number; } // MyButton コンポーネント export class MyButton extends React.Component&amp;lt;MyButtonProps, MyButtonState&amp;gt; { constructor(props: MyButtonProps) { super(props); this.state = {count: 0}; } public render(): React.ReactNode { const {count} = this.</description></item><item><title>React コンポーネントのプロパティで配列データを渡す</title><link>https://maku.blog/p/av9mxak/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/av9mxak/</guid><description>React コンポーネントのプロパティには、文字列や数値などの単純なスカラ値だけではなく、配列などの複雑なオブジェクトを渡すことができます。 使用イメージは次のような感じです。
&amp;lt;MyComponent values={配列変数} /&amp;gt; 配列型のプロパティを扱うコンポーネントを作成する 次の Books コンポーネントは、プロパティ titles で文字列配列を受け取り、それぞれの値を li 要素で描画します。 配列の map メソッドを使用すると、複数の li 要素を簡単に生成することができます。
components/books.tsx（Books コンポーネント） import * as React from &amp;#39;react&amp;#39;; // Books コンポーネントのプロパティの型 export interface BooksProps { titles: string[] } // Books コンポーネントの定義 export const Books: React.FC&amp;lt;BooksProps&amp;gt; = (props) =&amp;gt; { // titles プロパティの要素数が 0 であれば何も描画しない if (props.titles.length == 0) return null; // titles プロパティの値を使って、複数の li 要素を作る const listItems = props.titles.map((title: string) =&amp;gt; &amp;lt;li&amp;gt;{title}&amp;lt;/li&amp;gt; ); // ul 要素の描画 return &amp;lt;ul&amp;gt;{listItems}&amp;lt;/ul&amp;gt;; }; この Books コンポーネントは次のような感じで使用します。</description></item><item><title>React コンポーネントで入力フォームを作成する (1) 自力編</title><link>https://maku.blog/p/tdpybmw/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tdpybmw/</guid><description>制御コンポーネント (controlled components) React コンポーネントでフォームを構成する場合、コンポーネントの状態 (state) に基づいて表示を行うように実装すると、フォームの表示内容を制御しやすくなります。
このように、コンポーネントの表示内容が、完全にその状態 (state) によって決まるように実装されたものを、制御されたコンポーネント (controlled components) と呼びます。
このように設計することで、若干コード量は増えますが、表示内容を変更したいときはコンポーネントの state を変更するだけで済むようになります。 例えば、ネットワークから取得したデータをフォームに表示するような場合、そのフォームの構造を知る必要はなく、単純に state を更新するだけでよくなります。 これは、データとビューが分離された設計になっており、アプリ設計におけるベストプラクティスのひとつです。
input 要素の実装例 下記は、&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt; 要素と &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt; 要素を持つ MessageForm コンポーネントの実装例です。 ユーザーがテキストを入力するたびに handleChange() が呼び出され、コンポーネントの状態 (state) が更新されます。 setState() の呼び出しにより state が変更が変更されると、再度 render() が実行され、表示内容が state の値に基づいて更新されます。
まずは、クラスコンポーネント形式での実装例。
components/MessageForm.tsx import * as React from &amp;#39;react&amp;#39;; interface IState { msg: string; } // テキスト入力エリアと、submit ボタンを持つフォームを表示するコンポーネント export class MessageForm extends React.Component&amp;lt;{}, IState&amp;gt; { constructor(props: {}) { super(props); // ステートの初期化（最初は入力エリアは空っぽ） this.</description></item><item><title>React コンポーネントで入力フォームを作成する (2) react-hook-form 編</title><link>https://maku.blog/p/k7it5fp/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k7it5fp/</guid><description>React Hook Form とは React アプリで入力フォームを自力で作ろうとすると、各入力エリアのステート管理などが 意外と大変だったりします。 React Hook Form ライブラリ (react-hook-form) を使用すると、そのあたりの定型処理をシンプルに記述することができます。
React Hook Form / npm / GitHub React Hook Form は次のような特徴を備えています。
軽量（別のライブラリに依存しない） TypeScript をサポート パフォーマンスがよい（不要なレンダリングを軽減） HTML 標準のフォームバリデーション との互換性 required / min / max / minLength / maxLength / pattern / validate React Native でも使える 2022 年 2 月時点で活発に開発が進められており、npm のダウンロード数は右肩上がりに増えています。 GitHub のスター数も 25,000 を超えているため、しばらくは安心して使えそうなライブラリです。
React Hook Form を導入する react-hook-form パッケージは、npm あるいは yarn で簡単にインストールできます。 既存の React プロジェクト内で次のように実行してください。
$ npm install react-hook-form あるいは $ yarn add react-hook-form React Hook Form の基本的な使い方 次の MyForm コンポーネントは、1 つのテキスト入力フィールドと、1 つの数値入力フィールドを持つフォームの実装例です。 ここでは TypeScript を使い、フォームの入力要素の型を FormData と定義しています。</description></item><item><title>React Context で複数のコンポーネント間でデータを共有する</title><link>https://maku.blog/p/qoz8fow/</link><pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qoz8fow/</guid><description>Context とは React の Context（コンテクスト） は、いわゆるグローバル変数の格納領域のようなもので、複数のコンポーネント間でのデータ共有に使用できます。 各コンポーネントから Context 情報にダイレクトにアクセスできるため、prop のように上位のコンポーネントから情報を伝搬させていく必要がありません。
Context をむやみに使うと、コンポーネントの再利用性が下がってしまいますが、アプリケーション全体で使用する次のような情報を Context で管理するとコードがすっきりします。
ログイン中のユーザー情報（認証情報） 言語設定 テーマ設定 Context の使い方 Context を作成する (createContext) Context オブジェクトは、React.createContext() で作成することができます。 複数のコンポーネントから参照することになるので、Context オブジェクトは単独のファイルとしてモジュール化しておきます。
React.createContext() の引数に任意のオブジェクトを渡すと、その値を初期値とする Context オブジェクトが生成されます。 次の例では、string 型のデータを保持する Context オブジェクトを生成しています。
MyContext.ts import * as React from &amp;#39;react&amp;#39;; export const MyContext: React.Context&amp;lt;string&amp;gt; = React.createContext&amp;lt;string&amp;gt;(&amp;#39;Default message&amp;#39;); Context を参照する (useContext) 関数コンポーネント内で、Context が保持するデータを参照するには、React.useContext() を使用します。 デフォルトでは、React.createContext() の引数に設定したデフォルト値が返されます。 上記の例では、Default message というデフォルトテキストを設定しているので、その値が返されることになります。
App.tsx import * as React from &amp;#39;react&amp;#39;; import { MyContext } from &amp;#39;.</description></item><item><title>React Context の情報をローカルストレージに保存する</title><link>https://maku.blog/p/bv9kv7h/</link><pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bv9kv7h/</guid><description>何をするか？ ここでは、React の Context オブジェクトにセットした値をローカルストレージに保存し、次回のアプリ起動時にそこから値を復帰させる方法を説明します。 Context の使い方の基本は、次の記事を参照してください。
React Context で複数のコンポーネント間でデータを共有する Context の実装 下記の UserContext.tsx モジュールでは、React.createContext() で UserContext というオブジェクトを作成しています。 このオブジェクトは、gitHubToken という文字列データと、その値を更新するための setGitHubToken 関数を保持しています。 次のように実装することで、UserContext のデータをローカルストレージと同期させることができます。
gitHubToken の初期値に localStorage.getItem() から取得した値を設定する setGitHubToken の呼び出し時に localStorage.setItem() で値を保存する UserContext.tsx import * as React from &amp;#39;react&amp;#39;; // UserContext が保持する値の型 export interface UserContextType { gitHubToken: string; setGitHubToken: (token: string) =&amp;gt; void; } // ローカルストレージ用のキー const KEY_GITHUB_TOKEN = &amp;#39;gitHubToken&amp;#39;; // UserContext の生成 export const UserContext = React.createContext&amp;lt;UserContextType&amp;gt;({ gitHubToken: localStorage.getItem(KEY_GITHUB_TOKEN), // デフォルト値 setGitHubToken: (token: string) =&amp;gt; {} // ダミーセッター }); // UserContext にセッター関数を登録するためのコンポーネント export const UserContextProvider: React.</description></item><item><title>React実装例: クリックで開閉可能なツリービューを作る</title><link>https://maku.blog/p/weow5dm/</link><pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/weow5dm/</guid><description>ここでは、React コンポーネントとして、開閉可能なツリービューを作ってみます。 コンポーネント名はツリーのノードを示す TreeNode です。
図: TreeNode コンポーネントの表示例 初期の表示内容としては、ルートの TreeNode を 1 つだけ配置し、そのラベルをクリックしたときに、子要素となる TreeNode を 3 つ生成して表示します。 実際のアプリケーションでは、このタイミングで GraphQL サーバーなどからデータを取得してツリー展開していく、といったことができると思います。
下記は TreeNode コンポーネントの実装です。
components/TreeNode.tsx import * as React from &amp;#39;react&amp;#39;; import styles from &amp;#39;./TreeNode.scss&amp;#39;; export const TreeNode: React.FC&amp;lt;{label: string}&amp;gt; = ({label}) =&amp;gt; { const [isOpen, setIsOpen] = React.useState(false); const [childNodes, setChildNodes] = React.useState(null); // チェックボックスのクリックで isOpen ステートを更新 const handleChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { setIsOpen(e.target.checked); } // isOpen ステートの変更を監視し、childNodes に子ノードとなる TreeNode をセットする React.</description></item><item><title>React アプリの中で D3.js を使ってチャートを描画する</title><link>https://maku.blog/p/j52iy4k/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j52iy4k/</guid><description>何をするか？ D3.js は、Web ブラウザ上で様々なデータをビジュアライズするためのデファクトスタンダードな描画ライブラリです。 ここでは、React (Next.js) アプリ内で、D3.js を使って簡単なチャートを描画してみます。
☝️ ほかの描画ライブラリ JavaScript による描画ライブラリには、他にも Chart.js や Mermaid.js などいろいろなものがあります。 Chart.js を使うと、折れ線グラフや散布図などを簡単に描画することができます。 Mermaid.js を使うと、独自フォーマットのテキストをもとにフローチャートなどを描画することができます。 これらの描画ライブラリは、D3.js と比べて簡単に使うことができますが、描画可能な図の種類は限られています。 一方、D3.js は高度なカスタマイズや自由度の高いデータの可視化が可能ですが、初学者にとってはやや学習コストが高くなっています。 D3.js のインストール NPM あるいは Yarn で、プロジェクトに D3.js の依存を追加します。 TypeScript を使用している場合は、D3.js 本体 (d3) に加え、型情報 (@types/d3) もインストールします。
D3.js のインストール（NPM の場合） $ npm install d3 $ npm install --save-dev @types/d3 D3.js のインストール（Yarn の場合） $ yarn add d3 $ yarn add --dev @types/d3 React コンポーネント内で D3.js を使う React アプリは作成済みであるとし、D3.js を使って描画を行うコンポーネントを新しく作成します。 次の HelloChart コンポーネントは、D3.</description></item><item><title>React で入力フォームの onChange イベントを IME ON のときに無視する</title><link>https://maku.blog/p/cv6fpx7/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cv6fpx7/</guid><description>何をするか？ React のテキスト入力フォーム（input コンポーネントや mui の TextField など）で onChange イベントハンドラーを設定すると、入力テキストが変化したときに任意の処理を行うことができます。 ただ、onChange イベントは IME での日本語変換中にも呼び出されてしまう ので、おそらく、想定しているよりも多く呼び出されてしまいます。 インクリメンタルサーチなどで、入力のたびに API 呼び出しをしているようなケースでは、この振る舞いは抑制しなければいけません。
ここでは、IME が ON になっているとき（つまり日本語変換中）に、onChange イベントを無視する実装例を紹介します。 このあたりの実装は、ブラウザごとの微妙な振る舞いの差（特に Esc キーで IME 入力をキャンセルした場合など）を考えると、結構複雑だったりします。
実装してみる React の input コンポーネントの onCompositionStart と onCompositionEnd イベントハンドラーを設定すると、IME を ON/OFF したタイミングを知ることができます。 そのタイミングで、isImeOn のようなフラグを制御すれば、必要に応じて onChange イベントを無視できるようになります。
// import { FC, useRef, useState } from &amp;#39;react&amp;#39; const SearchBox: FC = () =&amp;gt; { // 現在 IME ON（変換中）かどうかのフラグ const isImeOn = useRef(false) // 以前の入力テキスト（ブラウザごとの onChange の振る舞いの差異への対策） const [prevText, setPrevText] = useState(&amp;#39;&amp;#39;) // 入力テキストを処理する const handleChange = (text: string) =&amp;gt; { if (prevText === text) return if (text === &amp;#39;&amp;#39;) { // Chrome ではテキストクリア時に onCompositionEnd が呼ばれないことがある isImeOn.</description></item><item><title>Apollo Client の fetchMore を自動で呼び出して GitHub GraphQL の100件制限を乗り越える (useAutoFetchMore)</title><link>https://maku.blog/p/w7igunc/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7igunc/</guid><description>何をするか？ GitHub の GraphQL API で Issue 情報などを取得しようとすると、リソース制限 のため一度に 100 件までの情報しか取得できません。 Apollo Client が提供する useQuery や useLazyQuery などの React フック関数を使用すると、戻り値で返される fetchMore 関数を使って追加読み込み（ページネーション処理）を行うことができますが、この関数の使用例として提示されているものは、ユーザーによるボタンクリックなどを必要とするものばかりです。 ここでは、useQuery 実行後に自動で fetchMore を繰り返し呼び出して、100 件を超える情報を取得する方法の例を示します。
fetchMore のための設定 前提として、Apollo Client の fetchMore 関数の基本的な使い方は理解しているものとします（下記記事などを参考にしてください）。
Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す 今回サンプルコードで使う GraphQL クエリには、次のような search コネクションが含まれていることを想定しています。 ページネーションの対象となるのは、この search コネクション部分です。
query QueryIssues($cursor: String) { search(type: ISSUE, first: 100, after: $cursor, query: &amp;#34;...&amp;#34;) { ... } } そのため、ApolloClient に設定するキャッシュのフィールドポリシーとして、search フィールドの値が fetchMore 時にマージされるように設定しておきます。 cache オブジェクトの生成時に呼び出している relayStylePagination 関数あたりがポイントです。</description></item><item><title>React の props.children の型定義には ReactNode を使う</title><link>https://maku.blog/p/xenv4bh/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xenv4bh/</guid><description>children の型定義 TypeScript で React の関数コンポーネントを定義するときには、下記のような React.FC (React.FunctionComponent) を使用します。
type FC&amp;lt;P = {}&amp;gt; = FunctionComponent&amp;lt;P&amp;gt;; interface FunctionComponent&amp;lt;P = {}&amp;gt; { (props: PropsWithChildren&amp;lt;P&amp;gt;, context?: any): ReactElement&amp;lt;any, any&amp;gt; | null; propTypes?: WeakValidationMap&amp;lt;P&amp;gt; | undefined; contextTypes?: ValidationMap&amp;lt;any&amp;gt; | undefined; defaultProps?: Partial&amp;lt;P&amp;gt; | undefined; displayName?: string | undefined; } // ... type PropsWithChildren&amp;lt;P&amp;gt; = P &amp;amp; { children?: ReactNode | undefined }; FC の型パラメータ P は、上記のような PropsWithChildren 型にラップされるので、props の型定義をするときに明示的に children を含める必要はありません。 下記の ColorBox コンポーネントは、指定した背景色で子要素 (children) を表示します。</description></item><item><title>React の JSX 記述のコツ</title><link>https://maku.blog/p/xjv6gqy/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjv6gqy/</guid><description>React アプリケーションでは、コンポーネントの UI を JSX 構文を用いて記述します。 下記は、JSX コードを記述するときのポイントのまとめです。 通常の JavaScript コードとは異なる記述方法が必要になるため慣れが必要ですが、ここに挙げたポイントをおさえておけば大体対応できます。
JSX の最上位要素はひとつ JSX 要素を作成するとき、トップレベルの要素は 1 つだけにする必要があります。 次のコードでは、トップレベルに 2 つの p 要素が並んでいるのでエラーになります。
ダメな例 const MyComponent: React.FC = () =&amp;gt; { return ( &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; ) } これを解決するには、例えば次のようにルート要素として div を配置します。
return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ) もちろん、これはこれで動作するのですが、ルートに余計な div 要素が作られてしまうのを防ぎたいときは、次のように &amp;lt;&amp;gt;...&amp;lt;/&amp;gt; で囲います（これは &amp;lt;React.Fragment&amp;gt; の省略記法です）。
return ( &amp;lt;&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; ) 条件を満たすときのみ出力する 次のコードは、n &amp;gt; 0 を満たしたときに、後半の p 要素を表示します。
return &amp;lt;&amp;gt; {n &amp;gt; 0 &amp;amp;&amp;amp; &amp;lt;p&amp;gt;条件を満たしたよ&amp;lt;/p&amp;gt;} &amp;lt;/&amp;gt; JSX コードの中では、if や for といった値を返さない文 (statement) を記述することができません。 なので、出力を条件分岐させたいときは、この例のように、&amp;amp;&amp;amp; や || のような演算子を駆使する必要があります。</description></item><item><title>Apollo Client の useQuery 呼び出し部分をカスタムフックで分離する</title><link>https://maku.blog/p/kmj7sdv/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/kmj7sdv/</guid><description>Apollo Client で GraphQL クエリを実行するときは、カスタムフックとして useQuery 関数の呼び出し部分を抽出すると、コンポーネント側のコードをシンプルにすることができます。
分離前のコード 次のサンプルコードでは、GraphQL クエリで GitHub のログインユーザー情報を取得して表示する Viewer コンポーネントを実装しています。 GraphQL のクエリ呼び出し部分や、取得したデータを ViewerData オブジェクトに詰める部分などが混在しており、あまり整理されているとは言えません。
components/Viewer.tsx import { FC } from &amp;#39;react&amp;#39; import { gql, useQuery } from &amp;#39;@apollo/client&amp;#39; import { LoadingComponent } from &amp;#39;./LoadingComponent&amp;#39; import styles from &amp;#39;./Viewer.scss&amp;#39; const QUERY_VIEWER = gql` query QueryViewer { viewer { login url avatarUrl } } ` type ViewerData = { /** ログインID */ login: string /** ホームページのURL */ url: string /** アバター画像のURL */ avatarUrl: string } /** 「ユーザー情報」を表示するコンポーネント */ export const Viewer: FC = () =&amp;gt; { const {loading, error, data} = useQuery(QUERY_VIEWER) if (loading) return &amp;lt;LoadingComponent /&amp;gt; const viewer: ViewerData = data.</description></item><item><title>Apollo Client でクリック時に GraphQL クエリを実行する</title><link>https://maku.blog/p/m7ju6gr/</link><pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7ju6gr/</guid><description>図: useLazyQuery による GraphQL クエリ実行 はじめに Apollo Client の useQuery フックを使用すると、GraphQL を使って取得した情報を表示する React コンポーネントをシンプルに実装することができます。 useQuery フックによる GraphQL クエリは、React コンポーネントの表示時に実行されますが、代わりに useLazyQuery フックを使用すると、任意のタイミング、例えばボタンを押した時に GraphQL クエリを実行できるようになります。
前提として、Apollo Client の useQuery の基本的な使い方は下記の記事などで理解しているものとし、ここでは、useLazyQuery フックの使い方を説明します。
参考: Apollo Client で GitHub GraphQL API を使う (Node &amp;amp; React)&amp;quot; useQuery と useLazyQuery の違い 下記の抜粋コードは、useQuery 関数と useLazyQuery 関数の使い方の違いを表しています。
// const GET_ISSUES = gql`...`; const {loading, error, data} = useQuery(GET_ISSUES); const [getIssues, {loading, error, data}] = useLazyQuery(GET_ISSUES); useQuery 関数は呼び出し直後に GraphQL クエリが実行され、その状態や結果が直ちに loading、error、data といった戻り値に格納されます。 一方 useLazyQuery 関数の場合は、戻り値の最初の要素として、クエリ実行関数が返されます（上記の例では getIssues にしてるけど、変数名は executeQuery とか何でも OK）。 GraphQL クエリを実行するには、このクエリ実行関数を呼び出す必要があるので、例えば次のようにボタン要素の onClick で呼び出すようにしておきます。 あとは、useQuery 関数の使い方と同様です。</description></item><item><title>Apollo Client の Pagenation 機能を使って GraphQL API を呼び出す</title><link>https://maku.blog/p/cu6eox7/</link><pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cu6eox7/</guid><description>Apollo Client の Pagination 機能 GraphQL API では柔軟なクエリ発行が可能ですが、多数の要素を取得する場合は、Pagenation 処理 により何度かに分けて API 呼び出しを行う必要があります。 例えば、GitHub の GraphQL API では一度のクエリで取得可能な要素数は 100 件までであり、それを超える情報を取得する場合に Pagination 処理が必要です。
Apollo Client には、GraphQL の Pagination 処理を簡単に扱うための仕組み（fetchMore 関数）が用意されています。
参考: Pagination - Client (React) - Apollo GraphQL Docs と言っても、そこまで簡単ではないので、ここでは GitHub の GraphQL API における Pagination 処理の具体的な実装例を紹介します。
Pagination の実装例（フィールドポリシーを使う方法） 次のサンプルコードは、GitHub の myorg/myrepo リポジトリの Issue リストを表示する IssueList コンポーネントの実装例です。 Issue の数が 100 件を超える場合は、「さらに読み込む」ボタンを表示し、このボタンが押されたときに Pagination 処理（fetchMore 関数）で次のデータを取得するようにしています。
Apollo クライアントの useQuery 関数が返す fetchMore 関数を呼び出すと、再度 GraphQL クエリを実行することができます。 このとき、オプションで variables パラメータの値（クエリ変数）を変更できるので、Issue の読み出し開始位置を示す after の値を進めていくことで、100 件を超えるデータを順番に読み出すことができます。</description></item><item><title>GitHub Pages で React Router を使った SPA サイトを動かす方法</title><link>https://maku.blog/p/9u8it5f/</link><pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9u8it5f/</guid><description>React Router などを使った SPA (Single Page Application) な Web サイトは、GitHub Pages でそのまま動作させようとしてもうまく動きません。 ここでは、その理由と、対応方法について説明します。
GitHub Pages で SPA サイトが動作しない理由 たとえば、React Router を使った Web サイトは、次のような URL を使って目的のコンテンツ (/book/123) を表示するようルーティングします。
https://yourname.github.io/repo-name/book/123 React Router を使ったアプリで、この URL を実際に処理するファイルは、
https://yourname.github.io/repo-name/index.html であり、そこに記述された JavaScript ファイル内で、URL の末尾の /book/123 という部分をルーティング用のパス文字列として処理します。 つまり、前述の URL の /book/123 という部分は、単なるアプリ用のデータであり、実際に存在するファイルを示しているわけではありません。
一方、GitHub Pages はそのような事情を知らないので、/book/123 という URL でアクセスしようとすると、/book/123/index.html というファイルを見つけようとして 404 エラー になってしまいます。
先頭ページ (/index.html) を開いた後で、JavaScript でルーティング（React の Link コンポーネントによる遷移）を行っている間はうまく動作するのですが、ページをリロードしたり、Web ブラウザのアドレスバーに URL を直接入力したりすると、やはり 404 エラーになってしまいます。 OAuth 認証を使用した Web サイトの場合は、リダイレクトによって指定された URL へのアクセスが必要になるため、これは大きな制約になります。</description></item><item><title>React Router でコンポーネントの表示・非表示を切り替える</title><link>https://maku.blog/p/nfxds8n/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nfxds8n/</guid><description>React の Router 系コンポーネント (BrowserRouter / HashRouter / MemoryRouter) を使用すると、論理的なパス管理によって React コンポーネントの表示の On/Off を切り替えることができます。 例えば、/users というパスでアクセスしたときには Users コンポーネントを表示し、/projects というパスでアクセスしたときには Projects コンポーネントを表示する、といったことを実現できます。
react-router-dom のインストール Router 系のコンポーネントは react-router-dom モジュールで提供されているので、まずはこれをインストールします。 TypeScript を使用する場合は、型定義ファイルも一緒にインストールしておきます。
$ npm install --save react-router-dom $ npm install --save-dev @types/react-router-dom BrowserRouter による表示切り替え 図: Router による表示切り替え 次の App コンポーネントでは、BrowserRouter コンポーネントを使って、Page1 と Page2 コンポーネントの表示を切り替えます。 Router 系のコンポーネントには、Router というエイリアス名を付けるのが慣例なのでそれに従います。 Router コンポーネントの下には、表示切り替え用のリンク要素として Link コンポーネントを配置し、表示要素として Route コンポーネントを配置します。
components/App.tsx import * as React from &amp;#39;react&amp;#39; import { BrowserRouter as Router, Link, Route } from &amp;#39;react-router-dom&amp;#39; // 子コンポーネントを適当に用意 const Page1: React.</description></item><item><title>React でモーダルダイアログを表示する (react-modal)</title><link>https://maku.blog/p/q6fnu29/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q6fnu29/</guid><description>react-modal パッケージが提供する ReactModal コンポーネントを使用すると、React アプリ内で簡単にモーダルダイアログを実現することができます。
上記は、設定 ボタンを押してモーダルな設定ダイアログを開いたときの表示例です。
react-modal のインストール ReactModal コンポーネントを使うために、react-modal パッケージと TypeScript の型定義ファイルをインストールします。
$ npm install --save react-modal $ npm install --save-dev @types/react-modal ReactModal コンポーネントを使用する ReactModal の使い方 ReactModal コンポーネントは、isOpen プロパティでダイアログの表示・非表示を制御するようになっています。
// import ReactModal from &amp;#39;react-modal&amp;#39;; &amp;lt;ReactModal isOpen={this.props.isOpen} onAfterOpen={this.handleOpen} onRequestClose={this.handleClose} style={this.customStyles} contentLabel=&amp;#34;Settings&amp;#34; &amp;gt; // ... フォームの内容などをここに記述 ... &amp;lt;/ReactModal&amp;gt; onAfterOpen でオープン時、onRequestClose でクローズ時のイベントをハンドルすることができます。 ReactModal は自分自身のダイアログを自動で閉じたりしないので、onRequestClose に設定したハンドラ内で、isOpen プロパティに渡す値を false に設定してダイアログを閉じる必要があります。 onRequestClose ハンドラは、Esc キーを押したときや、ダイアログ外の領域をクリックしたときなどに呼び出されます。
コンポーネントの作成 下記のサンプルコードは ReactModal を使ったコンポーネントの作成例です。 ここでは、ユーザー名を入力可能な設定ダイアログを想定しています。 React を使ったフォームの作成方法などは次の記事を参照してください。
参考: React コンポーネントでフォームの入力を処理する components/settingsDialog.</description></item><item><title>React コンポーネントに CSS スタイルを設定する</title><link>https://maku.blog/p/eu4cksy/</link><pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/eu4cksy/</guid><description>React は Web サイトの View レイヤのコンポーネントを作るためのライブラリですが、CSS ファイルの扱い方は特に決められておらず、今でも多くの人が試行錯誤しています。 ここでは、React アプリにおける CSS の扱い方を、下記のように分類して順番に説明していきます。
従来通り HTML 起点でスタイルを読み込む方法 インラインスタイル CSS Modules CSS in JS ライブラリ HTML ファイルで読み込んだ CSS ファイルを参照する これは React を使わない従来の HTML/CSS のやり方に近い方法です。 HTML ファイル内の style 要素で定義した CSS クラスや、HTML から読み込んだ CSS ファイル内で定義した CSS クラスを React コンポーネントから使用します。
例えば、HTML ファイル内で次のようにスタイル定義されているとします。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;MyApp&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;style&amp;gt; .hello { color: blue; background: #aaccff; padding: 0.5em; font-weight: bolder; border-radius: 0.5em; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;index.</description></item></channel></rss>