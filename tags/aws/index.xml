<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AWS on まくろぐ</title><link>https://maku.blog/tags/aws/</link><description>Recent content in AWS on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 18 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/aws/index.xml" rel="self" type="application/rss+xml"/><item><title>Amazon Cognito (1) サインイン可能な Web サイトを作る (Cognito User Pool)</title><link>https://maku.blog/p/pufs8kx/</link><pubDate>Fri, 28 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pufs8kx/</guid><description>Cognito とは？ Amazon Cognito は、各種アプリケーションにユーザーの概念を取り入れて、サインアップやサインインなどを行えるようにするサービスです（OpenID Connect 準拠の Identity Provider (IdP) のひとつです）。 Cognito は大きく下記の 2 つの機能から成ります。
ユーザープール: ユーザーを管理する。任意のアプリに、ユーザー登録（サインアップ）や、認証（サインイン）の機能を付けることができる。 ID プール: 上記の仕組みでサインインしたユーザーに対して、AWS サービスへのアクセス権限を付加する。 単純にユーザー管理だけをしたいのであれば、前者の「ユーザープール」の機能だけを使うことができます。 実際には、認証後に AWS のリソースにアクセスさせることが多いと思いますので、後者の「ID プール」の仕組みを使って IAM の権限割り当てを行うことになります。
認証の仕組みに関しては、5 万 MAU（月間アクティブユーザー）まで無料で使えるので、個人で作成しているアプリでも使いやすいと思います。 ただし、無料枠を超えると 1 ユーザーあたり 1 円くらいかかり、多要素認証などを使おうとするともう少しお金がかかります。 詳しくは、Cognito の料金）のページを参照してください。
通常、Web サイトに認証機能を付けたいと思うと、ユーザー管理の仕組みや、サインイン画面などの UI を作成する必要がありますが、Cognito はこれらをまとめて提供してくれます。 ここでは、Cognito のユーザープールの作成から、React アプリでの認証までを説明します。
Cognito にユーザープールを作成する 準備として、Cognito のユーザープールを作成しておきます。
Cognito のマネージメントコンソールにアクセス ユーザープールの管理 → ユーザープールを作成する を選択します ユーザー作成時の条件 (Attribute) などを設定して作成ボタンを押します プール名は、適当に myapp-test とでも付けておけば大丈夫です。 本番環境用のユーザープールと、開発／テスト用のユーザープールは分けて作っておくのがよいので、ここではサフィックスとして -test を付けておきました。 デフォルト設定でサクッと作成してしまうこともできるし、いろいろな条件（メールアドレス必須とかパスワード強度とか）を指定することもできます。 ここでは、とりあえずデフォルト設定で適当に作成してしまいましょう。 ユーザー名でなく、メールアドレスでもログインできるようにしたいときは、属性 (Attribte) のタブで、ユーザー名 - 検証済みの E メールアドレスでのサインインも許可 にチェックをいれておきます。</description></item><item><title>Amazon Cognito (1) サインイン可能な Web サイトを作る (Cognito User Pool)</title><link>https://maku.blog/p/pufs8kx/</link><pubDate>Fri, 28 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pufs8kx/</guid><description>Cognito とは？ Amazon Cognito は、各種アプリケーションにユーザーの概念を取り入れて、サインアップやサインインなどを行えるようにするサービスです（OpenID Connect 準拠の Identity Provider (IdP) のひとつです）。 Cognito は大きく下記の 2 つの機能から成ります。
ユーザープール: ユーザーを管理する。任意のアプリに、ユーザー登録（サインアップ）や、認証（サインイン）の機能を付けることができる。 ID プール: 上記の仕組みでサインインしたユーザーに対して、AWS サービスへのアクセス権限を付加する。 単純にユーザー管理だけをしたいのであれば、前者の「ユーザープール」の機能だけを使うことができます。 実際には、認証後に AWS のリソースにアクセスさせることが多いと思いますので、後者の「ID プール」の仕組みを使って IAM の権限割り当てを行うことになります。
認証の仕組みに関しては、5 万 MAU（月間アクティブユーザー）まで無料で使えるので、個人で作成しているアプリでも使いやすいと思います。 ただし、無料枠を超えると 1 ユーザーあたり 1 円くらいかかり、多要素認証などを使おうとするともう少しお金がかかります。 詳しくは、Cognito の料金）のページを参照してください。
通常、Web サイトに認証機能を付けたいと思うと、ユーザー管理の仕組みや、サインイン画面などの UI を作成する必要がありますが、Cognito はこれらをまとめて提供してくれます。 ここでは、Cognito のユーザープールの作成から、React アプリでの認証までを説明します。
Cognito にユーザープールを作成する 準備として、Cognito のユーザープールを作成しておきます。
Cognito のマネージメントコンソールにアクセス ユーザープールの管理 → ユーザープールを作成する を選択します ユーザー作成時の条件 (Attribute) などを設定して作成ボタンを押します プール名は、適当に myapp-test とでも付けておけば大丈夫です。 本番環境用のユーザープールと、開発／テスト用のユーザープールは分けて作っておくのがよいので、ここではサフィックスとして -test を付けておきました。 デフォルト設定でサクッと作成してしまうこともできるし、いろいろな条件（メールアドレス必須とかパスワード強度とか）を指定することもできます。 ここでは、とりあえずデフォルト設定で適当に作成してしまいましょう。 ユーザー名でなく、メールアドレスでもログインできるようにしたいときは、属性 (Attribte) のタブで、ユーザー名 - 検証済みの E メールアドレスでのサインインも許可 にチェックをいれておきます。</description></item><item><title>AWS CloudFormation 入門 (Hello World)</title><link>https://maku.blog/p/h7arpdj/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h7arpdj/</guid><description>CloudFormation とは AWS CloudFormation を使用すると、テンプレートファイル (YAML or JSON) で定義した AWS リソース群をまとめて生成（更新）することができます。 いわゆる IaC (Infrastructure as Code) 環境を提供するものであり、Ansible や Chef を使ったことがあれば、それの AWS リソース構築用だと考えると分かりやすいです。
テンプレートから生成されるインフラ（AWS リソース群）は スタック と呼ばれ、テンプレートがあればスタックは何度でも生成することができます。 これはオブジェクト指向プログラミングにおける、クラスとインスタンスの関係に似ています。 必要のなくなったリソース群は、スタック単位でまとめて削除することができます。
CloudFormation の主な特徴は次の通りです。
何度でも同じ構成でリソースをセットアップできる（他のリージョンに複製したり、一時的に使うインフラを自動生成できる） テンプレートはテキストファイル (YAML/JSON) なので、GitHub などでバージョン管理することができ、PullRequest ベースのコードレビューを行える 冪等性が考慮されており、テンプレートには最終的な結果だけを定義しておけばよい（構成のアップデート時に差分を意識する必要はない） 例えば、次のようなテンプレートを使用すると、S3 サービスのバケットリソースを自動で作成することができます。
template.yml AWSTemplateFormatVersion:&amp;#34;2010-09-09&amp;#34;Resources:HelloBucket:Type:AWS::S3::Bucket 必須のルートプロパティは Resources だけですが、テンプレートフォーマットのバージョンを示す AWSTemplateFormatVersion は最低限指定しておくのがよいでしょう（2021年時点で、2010-09-09 が最新バージョンです）。
CloudFormation コンソールからスタックを生成する CloudFormation マネージメントコンソール を使うと、Web サイト上でスタックを生成することができます。
CloudFormation マネージメントコンソールを使ったスタックの生成手順は以下の通りです。
サイドバーから Stacks（スタック）を選択する CloudFormation で管理されているスタックの一覧が表示されます。 （スタックの作成）ボタンを押す テンプレートを指定する S3 上に置いたファイルを指定することもできますが、ここではローカルに作成した YAML ファイルをアップロードします。そのためには、Template is ready（テンプレートの準備完了） → Upload a template file（テンプレートファイルのアップロード）を選択し、YAML ファイルを選択します。 任意のスタック名（mystack など）を入力します テンプレートファイル内にパラメータ (Parameters) を定義している場合は、ここで具体的な値を入力できます。 あとはそのまま進めていって、Create stack（スタックの作成）を押せば、スタックの生成処理が始まります。 スタックの一覧画面に戻ると、作成中のスタックのステータスが CREATE_IN_PROGRESS となって表示されます。 しばらくしてスタックの生成処理が完了すると、ステータスが CREATE_COMPLETE に変わります。 これで、テンプレートで定義した AWS リソース群が使用できる状態になります。</description></item><item><title>AWS CloudFormation 入門 (Hello World)</title><link>https://maku.blog/p/h7arpdj/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h7arpdj/</guid><description>CloudFormation とは AWS CloudFormation を使用すると、テンプレートファイル (YAML or JSON) で定義した AWS リソース群をまとめて生成（更新）することができます。 いわゆる IaC (Infrastructure as Code) 環境を提供するものであり、Ansible や Chef を使ったことがあれば、それの AWS リソース構築用だと考えると分かりやすいです。
テンプレートから生成されるインフラ（AWS リソース群）は スタック と呼ばれ、テンプレートがあればスタックは何度でも生成することができます。 これはオブジェクト指向プログラミングにおける、クラスとインスタンスの関係に似ています。 必要のなくなったリソース群は、スタック単位でまとめて削除することができます。
CloudFormation の主な特徴は次の通りです。
何度でも同じ構成でリソースをセットアップできる（他のリージョンに複製したり、一時的に使うインフラを自動生成できる） テンプレートはテキストファイル (YAML/JSON) なので、GitHub などでバージョン管理することができ、PullRequest ベースのコードレビューを行える 冪等性が考慮されており、テンプレートには最終的な結果だけを定義しておけばよい（構成のアップデート時に差分を意識する必要はない） 例えば、次のようなテンプレートを使用すると、S3 サービスのバケットリソースを自動で作成することができます。
template.yml AWSTemplateFormatVersion:&amp;#34;2010-09-09&amp;#34;Resources:HelloBucket:Type:AWS::S3::Bucket 必須のルートプロパティは Resources だけですが、テンプレートフォーマットのバージョンを示す AWSTemplateFormatVersion は最低限指定しておくのがよいでしょう（2021年時点で、2010-09-09 が最新バージョンです）。
CloudFormation コンソールからスタックを生成する CloudFormation マネージメントコンソール を使うと、Web サイト上でスタックを生成することができます。
CloudFormation マネージメントコンソールを使ったスタックの生成手順は以下の通りです。
サイドバーから Stacks（スタック）を選択する CloudFormation で管理されているスタックの一覧が表示されます。 （スタックの作成）ボタンを押す テンプレートを指定する S3 上に置いたファイルを指定することもできますが、ここではローカルに作成した YAML ファイルをアップロードします。そのためには、Template is ready（テンプレートの準備完了） → Upload a template file（テンプレートファイルのアップロード）を選択し、YAML ファイルを選択します。 任意のスタック名（mystack など）を入力します テンプレートファイル内にパラメータ (Parameters) を定義している場合は、ここで具体的な値を入力できます。 あとはそのまま進めていって、Create stack（スタックの作成）を押せば、スタックの生成処理が始まります。 スタックの一覧画面に戻ると、作成中のスタックのステータスが CREATE_IN_PROGRESS となって表示されます。 しばらくしてスタックの生成処理が完了すると、ステータスが CREATE_COMPLETE に変わります。 これで、テンプレートで定義した AWS リソース群が使用できる状態になります。</description></item><item><title>AWS S3 をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/4ju5eow/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4ju5eow/</guid><description>AWS CLI で S3 バケットの操作を行う場合、大きく分けて以下の 2 種類のコマンドがあります。
aws s3 &amp;hellip; 高レベルコマンド aws s3api &amp;hellip; API レベルコマンド 基本的には、aws s3 コマンドでカバーできない操作が出てきたときに aws s3api コマンドの方を調べてみるというやり方でいいと思います。 aws s3 コマンドの方は、OS のコマンドラインシェルのファイル操作コマンドのような体系になっています（aws s3 ls とか aws s3 rm とか）。
S3 バケットの操作を行うには、IAM ユーザーに適切な権限が割り当てられている必要がありますが、AmazonS3FulAccess 管理ポリシーがあればほとんどの操作が可能です。
S3 バケットを作成する (s3 mb) $ aws s3 mb s3://&amp;lt;バケット名&amp;gt; 実行例 $ aws s3 mb s3://makutemp-123456789012-bucket-1 make_bucket: makutemp-123456789012-bucket-1 ☝️ 同名バケットの再生成でエラー バケットの削除後に、同名のバケットを再生成しようとすると、次のような conflicting conditional operation のエラーになることがあります。 この場合は、バケットの削除処理が完了するまでしばらく待つ必要があります。
make_bucket failed: s3://makutemp-123456789012-bucket-1 An error occurred (OperationAborted) when calling the CreateBucket operation: A conflicting conditional operation is currently in progress against this resource.</description></item><item><title>AWS の初期設定: AWS CLI と認証情報の設定</title><link>https://maku.blog/p/j5iu7it/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j5iu7it/</guid><description>AWS CLI とは？ AWS CLI (Command Line Interface) を使うと、AWS の各種サービスをコマンドラインから操作することができます。 例えば、次のように様々な処理を実行できます。
S3 にファイルをコピーする $ aws s3 cp ローカルファイル s3://バケット名/ディレクトリ名 IAM ユーザーのアクセスキーを表示する $ aws iam list-access-keys --user-name=ユーザー名 DynamoDB にテーブルを作成する $ aws dynamodb create-table --table-name テーブル名 ... AWS の各種サービスの設定は、それぞれのマネージメントコンソール（Web サイト）上で設定することができますが、AWS CLI を使うことで、Web ブラウザを開かずに設定を済ませられます。 頻繁に行う処理などは、シェルスクリプトなどにして自動化することができます。
AWS CLI を使用するには、下記のような IAM ユーザーのアクセスキー（及びシークレットアクセスキー）が必要です。 以降の説明では、これらの情報が取得できていることを前提とします。
API 用アクセスキー（例）: INMCAKIAQX77PNSXQAGP API 用シークレットアクセスキー（例）: 2ufOA3Q2KAmpNTo2GHPDXFJK7Jiv9yfZGegIdbCW 参考リンク IAM ユーザーのアクセスキーを作成するには - AWS CLI AWS CLI のインストール インストール方法 macOS の場合 &amp;hellip; AWSCLIV2.</description></item><item><title>AWS の初期設定: AWS CLI と認証情報の設定</title><link>https://maku.blog/p/j5iu7it/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j5iu7it/</guid><description>AWS CLI とは？ AWS CLI (Command Line Interface) を使うと、AWS の各種サービスをコマンドラインから操作することができます。 例えば、次のように様々な処理を実行できます。
S3 にファイルをコピーする $ aws s3 cp ローカルファイル s3://バケット名/ディレクトリ名 IAM ユーザーのアクセスキーを表示する $ aws iam list-access-keys --user-name=ユーザー名 DynamoDB にテーブルを作成する $ aws dynamodb create-table --table-name テーブル名 ... AWS の各種サービスの設定は、それぞれのマネージメントコンソール（Web サイト）上で設定することができますが、AWS CLI を使うことで、Web ブラウザを開かずに設定を済ませられます。 頻繁に行う処理などは、シェルスクリプトなどにして自動化することができます。
AWS CLI を使用するには、下記のような IAM ユーザーのアクセスキー（及びシークレットアクセスキー）が必要です。 以降の説明では、これらの情報が取得できていることを前提とします。
API 用アクセスキー（例）: INMCAKIAQX77PNSXQAGP API 用シークレットアクセスキー（例）: 2ufOA3Q2KAmpNTo2GHPDXFJK7Jiv9yfZGegIdbCW 参考リンク IAM ユーザーのアクセスキーを作成するには - AWS CLI AWS CLI のインストール インストール方法 macOS の場合 &amp;hellip; AWSCLIV2.</description></item><item><title>Next.js から AWS DynamoDB にアクセスする</title><link>https://maku.blog/p/xp8o5k2/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xp8o5k2/</guid><description>何をするか？ Next.js アプリの API routes (pages/*.ts) や、getServerSideProps などのサーバーサイドで実行される関数では、通常の Node.js モジュールを使うことができるため、AWS の DynamoDB からデータを取得する、といったことも自由に行えます。 ここでは、Next.js の API routes 機能を使って、DynamoDB から情報を取得する Web API を作ってみます。 具体的には次のようなことをします。
テスト用の DynamoDB テーブル (Books) を作成する Books テーブルを参照するためのアクセスキー（IAM ユーザー）を作成する Next.js の API routes の実装 (pages/api/books.ts) を行う AWS SDK を使って DynamoDB から情報を取得する /api/books/001 のような URL にアクセスすると JSON データを返す アクセスキーは環境変数で設定する ☝️ アクセスキーを使った AWS リソースのアクセスについて AWS のアクセスキーは、IAM ユーザーに設定されるものであり、このアクセスキーが漏洩すると、そのユーザーの権限で何でもできる ということになります。 そのため、アクセスキーを使用するときは、IAM ユーザーの権限を適切に絞ることが大切で、そもそも本当に必要なケースでのみアクセスキーを使うようにすべきです。 アクセスキーが必要になるのは、AWS の外から AWS リソースに直接アクセスするケースです。 例えば、AWS CLI のコマンドで AWS の制御を行う場合や、今回の例のように AWS 外のサーバーから AWS へアクセスするようなケースです。</description></item><item><title>Amazon Cognito (2) サインイン後に AWS リソースへのアクセス権限を与える (Cognito Identity Pool)</title><link>https://maku.blog/p/3mx8hr2/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3mx8hr2/</guid><description>何をやるか？ 参考: Amazon Cognito (1) サインイン可能な Web サイトを作る (with React) 上記記事では、Cognito のユーザープール機能を使って、Web サイトにサインイン（サインアップ）機能を付けるところまでを説明しています。 ここでは、さらに Cognito の ID プール機能を使い、認証後のユーザーに AWS リソースへのアクセス権限を割り当てる方法を説明します。
Amazon Cognito サービスは、大きくわけて下記の 2 つの機能を提供しています。
User Pool &amp;hellip; 認証 (Authentication) Identity Pool &amp;hellip; 認証後のユーザーに対する 認可 (Authorization) 「認証」の方は、Cognito の User Pool を使う方法以外にも、Amazon、Facebook、Google など、様々な認証サービス（これらを 認証プロバイダー (IdP) と呼びます）を使用することができますが、ここでは Cognito の User Pool でユーザー認証することを前提とします。
ここから先の説明は、「認可」に関しての説明になります。 Cognito Identity Pool は、何らかの認証プロバイダーによる認証済みユーザーに対して、IAM ロールを割り当てることによって、任意の AWS リソースへのアクセスを許可します。 また、認証していないユーザー（いわゆるゲストユーザー）に対して、リードオンリーな IAM ロールを割り当てたり、User Pool の方でユーザーをグループに登録しておいて、そのグループの IAM ロールをアクセス権限として割り当てるといったことも可能です。
ID プール（フェデレーティッドアイデンティティ） Cognito の ID プールを使うと、各種認証プロバイダーサービス（Cognito の場合は「ユーザープール」）でサインインしたユーザーに対して、AWS リソース（API Gateway や DynamoDB など）へのアクセス権限を割り当てることができます。 ざっくり言うと、ID プールは、ユーザーに対して IAM ロールを割り当てる仕組み です。</description></item><item><title>Amazon Cognito (2) サインイン後に AWS リソースへのアクセス権限を与える (Cognito Identity Pool)</title><link>https://maku.blog/p/3mx8hr2/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3mx8hr2/</guid><description>何をやるか？ 参考: Amazon Cognito (1) サインイン可能な Web サイトを作る (with React) 上記記事では、Cognito のユーザープール機能を使って、Web サイトにサインイン（サインアップ）機能を付けるところまでを説明しています。 ここでは、さらに Cognito の ID プール機能を使い、認証後のユーザーに AWS リソースへのアクセス権限を割り当てる方法を説明します。
Amazon Cognito サービスは、大きくわけて下記の 2 つの機能を提供しています。
User Pool &amp;hellip; 認証 (Authentication) Identity Pool &amp;hellip; 認証後のユーザーに対する 認可 (Authorization) 「認証」の方は、Cognito の User Pool を使う方法以外にも、Amazon、Facebook、Google など、様々な認証サービス（これらを 認証プロバイダー (IdP) と呼びます）を使用することができますが、ここでは Cognito の User Pool でユーザー認証することを前提とします。
ここから先の説明は、「認可」に関しての説明になります。 Cognito Identity Pool は、何らかの認証プロバイダーによる認証済みユーザーに対して、IAM ロールを割り当てることによって、任意の AWS リソースへのアクセスを許可します。 また、認証していないユーザー（いわゆるゲストユーザー）に対して、リードオンリーな IAM ロールを割り当てたり、User Pool の方でユーザーをグループに登録しておいて、そのグループの IAM ロールをアクセス権限として割り当てるといったことも可能です。
ID プール（フェデレーティッドアイデンティティ） Cognito の ID プールを使うと、各種認証プロバイダーサービス（Cognito の場合は「ユーザープール」）でサインインしたユーザーに対して、AWS リソース（API Gateway や DynamoDB など）へのアクセス権限を割り当てることができます。 ざっくり言うと、ID プールは、ユーザーに対して IAM ロールを割り当てる仕組み です。</description></item><item><title>AWS CLI: Windows で HOME 環境変数を設定したときに credentials が見つからなくなる場合の対処</title><link>https://maku.blog/p/2td9ouj/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2td9ouj/</guid><description>AWS CLI や AWS SDK が参照する共有認証ファイル（credentials および config）は、デフォルトでは下記のようなディレクトリになっています。
Linux の場合: ~/.aws/credentials Windows の場合: ~/%USERPROFILE%/.aws/credentials ところが、Windows を使用している場合に、環境変数 %HOME% を設定していると、CLI や SDK が %HOME%/.aws/credentials を見に行ったりして、credentials が見つからない系のエラーが出ることがあります。 一貫して %USERPROFILE% の方を見に行ってくれれればよいのですが、このあたりの振る舞いは結構ルーズなようです。
そこで、Windows のジャンクション機能 で、両方の .aws ディレクトリが同じディレクトリを指すようにしてみました。 ジャンクション生成のコマンドは、mklink /j &amp;lt;fromDir&amp;gt; &amp;lt;toDir&amp;gt; です。
ジャンクションで 2 つの .aws を同一にする C:\&amp;gt; mklink /j %HOME%\.aws %USERPROFILE%\.aws C:\home\.aws &amp;lt;&amp;lt;===&amp;gt;&amp;gt; C:\Users\maku\.aws のジャンクションが作成されました これで、%HOME%\.aws ディレクトリを参照したときの実体として、%USERPROFILE%\.aws ディレクトリが使われるようになります。 今のところ快適に動作しています。
ちなみに、ジャンクションを削除したいときは、ジャンクション元の %HOME%\.aws ディレクトリを削除するだけです。 実体の方の %USERPROFILET%\.aws は削除されないので安全です。</description></item><item><title>AWS CLI: Windows で HOME 環境変数を設定したときに credentials が見つからなくなる場合の対処</title><link>https://maku.blog/p/2td9ouj/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2td9ouj/</guid><description>AWS CLI や AWS SDK が参照する共有認証ファイル（credentials および config）は、デフォルトでは下記のようなディレクトリになっています。
Linux の場合: ~/.aws/credentials Windows の場合: ~/%USERPROFILE%/.aws/credentials ところが、Windows を使用している場合に、環境変数 %HOME% を設定していると、CLI や SDK が %HOME%/.aws/credentials を見に行ったりして、credentials が見つからない系のエラーが出ることがあります。 一貫して %USERPROFILE% の方を見に行ってくれれればよいのですが、このあたりの振る舞いは結構ルーズなようです。
そこで、Windows のジャンクション機能 で、両方の .aws ディレクトリが同じディレクトリを指すようにしてみました。 ジャンクション生成のコマンドは、mklink /j &amp;lt;fromDir&amp;gt; &amp;lt;toDir&amp;gt; です。
ジャンクションで 2 つの .aws を同一にする C:\&amp;gt; mklink /j %HOME%\.aws %USERPROFILE%\.aws C:\home\.aws &amp;lt;&amp;lt;===&amp;gt;&amp;gt; C:\Users\maku\.aws のジャンクションが作成されました これで、%HOME%\.aws ディレクトリを参照したときの実体として、%USERPROFILE%\.aws ディレクトリが使われるようになります。 今のところ快適に動作しています。
ちなみに、ジャンクションを削除したいときは、ジャンクション元の %HOME%\.aws ディレクトリを削除するだけです。 実体の方の %USERPROFILET%\.aws は削除されないので安全です。</description></item><item><title>Node.js で Amazon S3 を操作する (AWS SDK)</title><link>https://maku.blog/p/m8kv8it/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m8kv8it/</guid><description>ここでは、Node.js 用の AWS SDK を使って Amazon S3 を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
S3 用の Node.js SDK をインストールする AWS SDK version 3 の S3 用パッケージをインストールするには次のようにします。
### npm の場合 $ npm install @aws-sdk/client-s3 ### yarn の場合 $ yarn add @aws-sdk/client-s3 これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。
main.ts import { S3Client, ListBucketsCommand } from &amp;#39;@aws-sdk/client-s3&amp;#39;; S3Client インスタンスの生成 AWS SDK で S3 の操作を行うには、S3Client オブジェクトを使って各種コマンドを送ります。
new S3Client(configuration: S3ClientConfig): S3Client S3Client コンストラクタには S3ClientConfig オブジェクトを渡すようになっており、接続情報などを指定できます。 空オブジェクト ({}) を渡すと、現在の環境の default プロファイルの設定が使用されます（~/.</description></item><item><title>Amazon Cognito: Amplify SDK による認証まわりの UI 表示あれこれ</title><link>https://maku.blog/p/24p8jjx/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/24p8jjx/</guid><description>認証済みユーザーが admin グループに属しているか調べて UI を切り替える Cognito ユーザープールの「グループ」機能を使うと、既存のユーザーをグループ単位でまとめて、特別な IAM ロールを割り当てたりすることができます。 例えば、admin グループを作っておいて、そのグループに所属するユーザーに、DynamoDB の書き込み権限 (IAM role) を与える、といったことができます。
React アプリのレイヤでは、このような IAM ロールの権限うんぬんの前に、カレントユーザーがどのようなグループに所属しているかに応じて UI の表示分けをしたいことがあります。 例えば、admin グループのユーザーが Web ページを表示しているときは、管理者向けのメニュー表示をする、といったケースです。
幸い、aws-amplify モジュールの Auth オブジェクトが提供する認証情報を参照することで、認証済みのユーザーがどの Cognito グループに属しているかを調べることができます。 具体的には、Auth.currentAuthenticatedUser() などが返すユーザー情報のアクセストークンのペイロードに cognito:groups というプロパティがあり、そこに Cognito グループ名のリストが格納されています。
参考: Using the Access Token - Amazon Cognito 次のようなカスタムフック useAuthState を定義しておくと、戻り値の isAdmin プロパティを見るだけで、現在のユーザーが admin グループに属しているかを確認できます。
src/hooks/useAuthState.tsx import { useEffect, useState } from &amp;#39;react&amp;#39; import { Auth } from &amp;#39;aws-amplify&amp;#39; import { AuthState, CognitoUserInterface, onAuthUIStateChange, } from &amp;#39;@aws-amplify/ui-components&amp;#39; // ユーザーがこのグループ名の Cognito グループに所属しているときに、 // useAuthState フックが返す isAdmin プロパティを true にします。 const ADMIN_GROUP_NAME = &amp;#39;admin&amp;#39; /** useAuthState フックの戻り値の型 */ export type UseAuthStateOutput = { isSignedIn: boolean isAdmin: boolean user: CognitoUserInterface | undefined } /** 現在の認証状態を取得するためのフック関数です。 */ export const useAuthState = (): UseAuthStateOutput =&amp;gt; { // Cognito によるサインイン状態やユーザー情報を保持するステート const [authState, setAuthState] = useState&amp;lt;AuthState | undefined&amp;gt;() const [user, setUser] = useState&amp;lt;CognitoUserInterface | undefined&amp;gt;() useEffect(() =&amp;gt; { // 画面遷移時に onAuthUIStateChange が呼ばれないことへの対応 // https://github.</description></item><item><title>Amazon Cognito: Amplify SDK による認証まわりの UI 表示あれこれ</title><link>https://maku.blog/p/24p8jjx/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/24p8jjx/</guid><description>認証済みユーザーが admin グループに属しているか調べて UI を切り替える Cognito ユーザープールの「グループ」機能を使うと、既存のユーザーをグループ単位でまとめて、特別な IAM ロールを割り当てたりすることができます。 例えば、admin グループを作っておいて、そのグループに所属するユーザーに、DynamoDB の書き込み権限 (IAM role) を与える、といったことができます。
React アプリのレイヤでは、このような IAM ロールの権限うんぬんの前に、カレントユーザーがどのようなグループに所属しているかに応じて UI の表示分けをしたいことがあります。 例えば、admin グループのユーザーが Web ページを表示しているときは、管理者向けのメニュー表示をする、といったケースです。
幸い、aws-amplify モジュールの Auth オブジェクトが提供する認証情報を参照することで、認証済みのユーザーがどの Cognito グループに属しているかを調べることができます。 具体的には、Auth.currentAuthenticatedUser() などが返すユーザー情報のアクセストークンのペイロードに cognito:groups というプロパティがあり、そこに Cognito グループ名のリストが格納されています。
参考: Using the Access Token - Amazon Cognito 次のようなカスタムフック useAuthState を定義しておくと、戻り値の isAdmin プロパティを見るだけで、現在のユーザーが admin グループに属しているかを確認できます。
src/hooks/useAuthState.tsx import { useEffect, useState } from &amp;#39;react&amp;#39; import { Auth } from &amp;#39;aws-amplify&amp;#39; import { AuthState, CognitoUserInterface, onAuthUIStateChange, } from &amp;#39;@aws-amplify/ui-components&amp;#39; // ユーザーがこのグループ名の Cognito グループに所属しているときに、 // useAuthState フックが返す isAdmin プロパティを true にします。 const ADMIN_GROUP_NAME = &amp;#39;admin&amp;#39; /** useAuthState フックの戻り値の型 */ export type UseAuthStateOutput = { isSignedIn: boolean isAdmin: boolean user: CognitoUserInterface | undefined } /** 現在の認証状態を取得するためのフック関数です。 */ export const useAuthState = (): UseAuthStateOutput =&amp;gt; { // Cognito によるサインイン状態やユーザー情報を保持するステート const [authState, setAuthState] = useState&amp;lt;AuthState | undefined&amp;gt;() const [user, setUser] = useState&amp;lt;CognitoUserInterface | undefined&amp;gt;() useEffect(() =&amp;gt; { // 画面遷移時に onAuthUIStateChange が呼ばれないことへの対応 // https://github.</description></item><item><title>Amazon Cognito: Amplify SDK による認証まわりの UI 表示あれこれ</title><link>https://maku.blog/p/24p8jjx/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/24p8jjx/</guid><description>認証済みユーザーが admin グループに属しているか調べて UI を切り替える Cognito ユーザープールの「グループ」機能を使うと、既存のユーザーをグループ単位でまとめて、特別な IAM ロールを割り当てたりすることができます。 例えば、admin グループを作っておいて、そのグループに所属するユーザーに、DynamoDB の書き込み権限 (IAM role) を与える、といったことができます。
React アプリのレイヤでは、このような IAM ロールの権限うんぬんの前に、カレントユーザーがどのようなグループに所属しているかに応じて UI の表示分けをしたいことがあります。 例えば、admin グループのユーザーが Web ページを表示しているときは、管理者向けのメニュー表示をする、といったケースです。
幸い、aws-amplify モジュールの Auth オブジェクトが提供する認証情報を参照することで、認証済みのユーザーがどの Cognito グループに属しているかを調べることができます。 具体的には、Auth.currentAuthenticatedUser() などが返すユーザー情報のアクセストークンのペイロードに cognito:groups というプロパティがあり、そこに Cognito グループ名のリストが格納されています。
参考: Using the Access Token - Amazon Cognito 次のようなカスタムフック useAuthState を定義しておくと、戻り値の isAdmin プロパティを見るだけで、現在のユーザーが admin グループに属しているかを確認できます。
src/hooks/useAuthState.tsx import { useEffect, useState } from &amp;#39;react&amp;#39; import { Auth } from &amp;#39;aws-amplify&amp;#39; import { AuthState, CognitoUserInterface, onAuthUIStateChange, } from &amp;#39;@aws-amplify/ui-components&amp;#39; // ユーザーがこのグループ名の Cognito グループに所属しているときに、 // useAuthState フックが返す isAdmin プロパティを true にします。 const ADMIN_GROUP_NAME = &amp;#39;admin&amp;#39; /** useAuthState フックの戻り値の型 */ export type UseAuthStateOutput = { isSignedIn: boolean isAdmin: boolean user: CognitoUserInterface | undefined } /** 現在の認証状態を取得するためのフック関数です。 */ export const useAuthState = (): UseAuthStateOutput =&amp;gt; { // Cognito によるサインイン状態やユーザー情報を保持するステート const [authState, setAuthState] = useState&amp;lt;AuthState | undefined&amp;gt;() const [user, setUser] = useState&amp;lt;CognitoUserInterface | undefined&amp;gt;() useEffect(() =&amp;gt; { // 画面遷移時に onAuthUIStateChange が呼ばれないことへの対応 // https://github.</description></item><item><title>Amazon Cognito をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/yzjj4c7/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yzjj4c7/</guid><description>AWS CLI による Cognito 操作用のコマンドには、cognito-idp と cognito-identity があります。
aws cognito-idp &amp;hellip; Cognito User Pools の操作（ユーザープール／ID プロバイダー） ユーザープール自体の作成や、ユーザーの追加・削除などを行えます。ユーザープールでの認証に成功すると、ユーザー情報を参照するためのトークンが発行されます。一般的にいうところの ID プロバイダー (IdP) です。 aws cognito-identity &amp;hellip; Cognito Federated Identities の操作（フェデレーテッドアイデンティティー／ID プール） 何らかの ID プロバイダー (IdP) で認証されたユーザーに対して、AWS サービスにアクセスするための一時的なアクセストークンを発行します。ID プロバイダーは上記の Cognito ユーザープールでもよいし、Google や Facebook などのサードパーティ ID プロバイダーでもかまいません。 ユーザープールの操作 (cognito-idp) aws cognito-idp のサブコマンドには、admin- プレフィックスが付くものと付かないバージョンがあったりしますが、プレフィックスがない方は、ユーザー認証後に取得できるトークンの指定 (--access-token) が必要です。
ユーザープールを作成する (cognito-idp create-user-pool) $ aws cognito-idp create-user-pool --pool-name &amp;#34;Test user pool&amp;#34; ユーザープールの作成に成功すると、初期設定の内容（パスワードのルールなど）が出力されます。</description></item><item><title>Amazon Cognito をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/yzjj4c7/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/yzjj4c7/</guid><description>AWS CLI による Cognito 操作用のコマンドには、cognito-idp と cognito-identity があります。
aws cognito-idp &amp;hellip; Cognito User Pools の操作（ユーザープール／ID プロバイダー） ユーザープール自体の作成や、ユーザーの追加・削除などを行えます。ユーザープールでの認証に成功すると、ユーザー情報を参照するためのトークンが発行されます。一般的にいうところの ID プロバイダー (IdP) です。 aws cognito-identity &amp;hellip; Cognito Federated Identities の操作（フェデレーテッドアイデンティティー／ID プール） 何らかの ID プロバイダー (IdP) で認証されたユーザーに対して、AWS サービスにアクセスするための一時的なアクセストークンを発行します。ID プロバイダーは上記の Cognito ユーザープールでもよいし、Google や Facebook などのサードパーティ ID プロバイダーでもかまいません。 ユーザープールの操作 (cognito-idp) aws cognito-idp のサブコマンドには、admin- プレフィックスが付くものと付かないバージョンがあったりしますが、プレフィックスがない方は、ユーザー認証後に取得できるトークンの指定 (--access-token) が必要です。
ユーザープールを作成する (cognito-idp create-user-pool) $ aws cognito-idp create-user-pool --pool-name &amp;#34;Test user pool&amp;#34; ユーザープールの作成に成功すると、初期設定の内容（パスワードのルールなど）が出力されます。</description></item><item><title>AWS CloudFormation をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkxamw9/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkxamw9/</guid><description>テンプレートファイルが正しく記述できているか確認する (cloudformation validate-template) YAML や JSON 形式で作成した CloudFormation 用のテンプレートファイルが、正しく記述できているかを調べることができます。
正しく記述できている場合 $ aws cloudformation validate-template --template-body file://template.json Description: Sample template Parameters: [] 不正なフォーマットの場合 An error occurred (ValidationError) when calling the ValidateTemplate operation: Template format error: JSON not well-formed. (line 5, column 2) 不正なプロパティがある場合 An error occurred (ValidationError) when calling the ValidateTemplate operation: Invalid template property or properties [ABC] スタックを作成する (cloudformation create-stack) ローカルの YAML テンプレートから生成 $ aws cloudformation create-stack --stack-name mystack \ --template-body file://template.</description></item><item><title>AWS CloudFormation をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkxamw9/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkxamw9/</guid><description>テンプレートファイルが正しく記述できているか確認する (cloudformation validate-template) YAML や JSON 形式で作成した CloudFormation 用のテンプレートファイルが、正しく記述できているかを調べることができます。
正しく記述できている場合 $ aws cloudformation validate-template --template-body file://template.json Description: Sample template Parameters: [] 不正なフォーマットの場合 An error occurred (ValidationError) when calling the ValidateTemplate operation: Template format error: JSON not well-formed. (line 5, column 2) 不正なプロパティがある場合 An error occurred (ValidationError) when calling the ValidateTemplate operation: Invalid template property or properties [ABC] スタックを作成する (cloudformation create-stack) ローカルの YAML テンプレートから生成 $ aws cloudformation create-stack --stack-name mystack \ --template-body file://template.</description></item><item><title>Amazon EC2 で Hello World (1) キーペアの作成</title><link>https://maku.blog/p/pcp3doy/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pcp3doy/</guid><description>EC2 を使う前に SSH キーペアを作成しておく 立ち上げた EC2 インスタンスは SSH で接続して操作するため、まずはキーペア（公開鍵＋秘密鍵）を作成して、その公開鍵を EC2 に登録しておく必要があります。 一度公開鍵を登録すると、EC2 インスタンスを作成するときに、割り当てる公開鍵をプルダウンから選択できるようになります。
EC2 コンソールからキーペアを作成する SSH 接続用のキーペアは、ローカルで作成して EC2 に登録することもできますし、EC2 コンソール上で新規作成することもできます。 EC2 上で作成すると、公開鍵が自動的に EC2 に登録された状態になるのでちょっとだけ楽です。 ここでは、次のように EC2 上でキーペアを作成します。
EC2 マネージメントコンソール を開く サイドバーから キーペア を選択し、キーペアを作成 をクリック キーペアの作成画面で名前とファイル形式を入力し、キーペアを作成 をクリック 名前: ec2key など自由に入力 ファイル形式:（使用する SSH クライアントに合わせて選択） pem 形式 &amp;hellip; OpenSSH を使う場合（主に Linux/macOS） ppk 形式 &amp;hellip; PuTTY を使う場合（主に Windows） すると、自動的に ec2key.pem（秘密鍵）のダウンロードが始まるので、~/.ssh ディレクトリなどに確実に保存します。 この キーファイルを再度ダウンロードすることはできないので注意してください。
EC2 コンソール上に次のように表示されていれば、今後 EC2 インスタンスを生成するときにこのキーを選択できます。</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.3 の場合）</title><link>https://maku.blog/p/5mv5dkt/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5mv5dkt/</guid><description>ここでは、Node.js 用の AWS SDK ver.3 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
DynamoDB 用の Node.js SDK (ver.3) をインストールする まずは、AWS SDK version 3 の DynamoDB 用パッケージをインストールします。 DynamoDB を操作するときに主に次のようなクライアントクラスを使用するのですが、後者の DynamoDBDocumentClient の方は、前者の DynamoDBClient インスタンスをラップして扱いやすくするためのクラスなので、必要に応じてインストールしてください（主にテーブル内のアイテムを扱うときに便利です）。
DynamoDBClient DynamoDB を扱うための基本クラス（DB クライアントと呼ばれる） @aws-sdk/client-dynamodb パッケージが必要 DynamoDBDocumentClient 上記を扱いやすくするためのクラス（Document クライアントと呼ばれる） @aws-sdk/lib-dynamodb パッケージが必要 @aws-sdk/util-dynamodb パッケージも必要っぽい ### yarn の場合 $ yarn add @aws-sdk/client-dynamodb $ yarn add @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント ### npm の場合 $ npm install @aws-sdk/client-dynamodb $ npm install @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.3 の場合）</title><link>https://maku.blog/p/5mv5dkt/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5mv5dkt/</guid><description>ここでは、Node.js 用の AWS SDK ver.3 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
DynamoDB 用の Node.js SDK (ver.3) をインストールする まずは、AWS SDK version 3 の DynamoDB 用パッケージをインストールします。 DynamoDB を操作するときに主に次のようなクライアントクラスを使用するのですが、後者の DynamoDBDocumentClient の方は、前者の DynamoDBClient インスタンスをラップして扱いやすくするためのクラスなので、必要に応じてインストールしてください（主にテーブル内のアイテムを扱うときに便利です）。
DynamoDBClient DynamoDB を扱うための基本クラス（DB クライアントと呼ばれる） @aws-sdk/client-dynamodb パッケージが必要 DynamoDBDocumentClient 上記を扱いやすくするためのクラス（Document クライアントと呼ばれる） @aws-sdk/lib-dynamodb パッケージが必要 @aws-sdk/util-dynamodb パッケージも必要っぽい ### yarn の場合 $ yarn add @aws-sdk/client-dynamodb $ yarn add @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント ### npm の場合 $ npm install @aws-sdk/client-dynamodb $ npm install @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。</description></item><item><title>AWS の初期設定: 管理者用の IAM ユーザーを作成する</title><link>https://maku.blog/p/xbipv39/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xbipv39/</guid><description>何をするか？ AWS のベストプラクティスでは、管理者であっても普段の作業では AWS アカウントのルートユーザーを直接使うべきではないとされています。
参考: AWS アカウント、IAM ユーザー、グループ、ポリシーの違い そこで、まずは管理者の普段の作業用に IAM ユーザーを作成します。 この作成作業は、AWS アカウントのルートユーザーで行う必要があります（初期状態ではユーザー作成の権限がルートユーザーにしかないため）。
ここでは、下記のような名前の IAM ユーザーとグループを作成することにします。
IAM ユーザー: admin IAM グループ: Admins &amp;hellip; （AdministratorAccess ポリシーを割り当てます） 管理者用 IAM ユーザーの作成 AWS IAM コンソール にサインインし、次のような感じで IAM ユーザーを作成します。
アクセス管理 → ユーザー → ユーザーを追加 を選択し、次のように入力 ユーザー名: admin アクセスの種類: CLI などで操作するなら プログラムによるアクセス にチェック ユーザーをグループに追加 → グループの作成 を選択し、次のように入力 グループ名: Admins ポリシー: AdministratorAccess を選択 アクセスキーや、シークレットアクセスキーを作成したのであれば、このタイミングで表示されるので、なくさないよう厳重に保存します（後から確認することはできません）。</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.2 の場合）</title><link>https://maku.blog/p/8t7iu6g/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8t7iu6g/</guid><description>ここでは、Node.js 用の AWS SDK ver.2 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
SDK ver.3 を使う方法はこちらの記事 を参照してください。 基本的には ver.3 の使用が推奨されていますが、AWS の Lambda 実行環境は現時点（2021年5月）でも ver.2 がインストールされていたりするので、ver.2 の需要はまだあると思います。
Dynamo DB 用の SDK (ver.2) をインストールする AWS SDK version 2 で DynamoDB を扱うには、次のように AWS SDK パッケージ全体をインストールする必要があります（version 3 では DynamoDB サービスなどのパッケージを個別にインストールできます）。
$ npm install aws-sdk --save これで、TypeScript コードから次のように SDK モジュールをインポートできるようになります。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; AWS.DynamoDB だけ参照したければ、次のようにインポートできます。
import { DynamoDB } from &amp;#39;aws-sdk&amp;#39;; DynamoDB インスタンスの生成 基本 DynamoDB の API を呼び出すには、まずは AWS.</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.2 の場合）</title><link>https://maku.blog/p/8t7iu6g/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8t7iu6g/</guid><description>ここでは、Node.js 用の AWS SDK ver.2 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
SDK ver.3 を使う方法はこちらの記事 を参照してください。 基本的には ver.3 の使用が推奨されていますが、AWS の Lambda 実行環境は現時点（2021年5月）でも ver.2 がインストールされていたりするので、ver.2 の需要はまだあると思います。
Dynamo DB 用の SDK (ver.2) をインストールする AWS SDK version 2 で DynamoDB を扱うには、次のように AWS SDK パッケージ全体をインストールする必要があります（version 3 では DynamoDB サービスなどのパッケージを個別にインストールできます）。
$ npm install aws-sdk --save これで、TypeScript コードから次のように SDK モジュールをインポートできるようになります。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; AWS.DynamoDB だけ参照したければ、次のようにインポートできます。
import { DynamoDB } from &amp;#39;aws-sdk&amp;#39;; DynamoDB インスタンスの生成 基本 DynamoDB の API を呼び出すには、まずは AWS.</description></item><item><title>Amazon EC2 で Hello World (2) EC2 インスタンスの起動と接続</title><link>https://maku.blog/p/whu7hr3/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/whu7hr3/</guid><description>EC2 インスタンスの起動 EC2 インスタンスに接続するための キーペアを作成 したら、実際に EC2 インスタンスを起動してみます。 ここでは、マシンイメージ (AMI) として EC2 用に最適化された Amazon Linux 2 を選択することにします。
EC2 マネージメントコンソール を開く サイドバーの インスタンス を選択し、インスタンスを起動 ボタンを押す Amazon マシンイメージ (AMI) の選択画面で、Amazon Linux 2 を選択 インスタンスタイプの選択画面で、一番安い t2.nano や、一年間の無料枠がある t2.micro を選択（料金の参考: EC2Instances.info） 確認と作成 ボタンを押す 使用するキーペアを選択する画面が表示されるので、あらかじめ設定しておいた キーペアを選択して、インスタンスの作成 ボタンを押す 図: キーペアの選択 あとは数分待てば、EC2 インスタンスが起動します。
EC2 インスタンスへの SSH 接続 EC2 インスタンスが無事起動したら、SSH で接続してみます。 接続用のユーザー名やアドレスは、次のようにして確認することができます。
EC2 マネージメントコンソール を開く サイドバーの インスタンス を選択し、対象の EC2 インスタンスを選択 接続 ボタンを押す すると、次のような感じで接続先のユーザー名（ec2-user）や DNS アドレス（ec2-XXXXX) を確認することができます。</description></item><item><title>TypeScript で AWS SDK を使う開発環境を整える</title><link>https://maku.blog/p/taiqx6d/</link><pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/taiqx6d/</guid><description>TypeScript のプロジェクトを作成する 何をできるようにするか？ ここでは、Node.js はインストール済みであるという前提で、次のようなことを行える TypeScript 環境を整えます。
npm run build で src ディレクトリ以下の .ts ファイルをコンパイルする
（.js ファイルが build ディレクトリ以下に出力される） npm start でコンパイルされた build/main.js を起動する 下記のセットアップ手順の 詳しい意味はこちらを参照 していただくとして、ここでは一気にセットアップを終わらせてしまいます。
セットアップ # アプリ用のディレクトリを作成 $ mkdir myapp $ cd myapp # Node.js アプリの設定ファイル (package.json) を生成 $ npm init -y # TypeScript および Node 型情報をインストール $ npm install typescript -D $ npm install @types/node -D # TypeScript の設定ファイル (tsconfig.json) を生成 $ npx tsc --init package.</description></item><item><title>AWS CloudFormation で Lambda 関数のリソースを生成する</title><link>https://maku.blog/p/w8s8kx9/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w8s8kx9/</guid><description>何をするか？ AWS CloudFormation を使うと Lambda 関数を含むインフラ（AWS リソース群）をまとめて生成することができますが、AWS CloudFormation の拡張である AWS SAM を使うと、もっと簡潔に Lambda 関数のリソースを生成することができます。
例えば、CloudFormation テンプレートの AWS::Lambda::Function リソースでは、Role プロパティが必須でしたが、SAM テンプレートの AWS::Serverless::Function リソースでは、Role プロパティはオプショナルになっています。 Role プロパティを省略すると、Lambda 関数に付けた論理 ID (Logical ID) をもとに、&amp;lt;論理ID&amp;gt;Role という名前のロールが自動生成されます。
ここでは、AWS SAM を使った Lambda 関数生成の基本として、次のようなパターンで CloudFormation スタックを生成してみます。
SAM テンプレートに関数コードを埋め込んでデプロイ S3 バケット上の関数の ZIP ファイルを使ってデプロイ SAM テンプレートに関数コードを埋め込んでデプロイ まずは、一番シンプルな例として、SAM テンプレート内に Lambda 関数の実装をハードコーディングしてしまい、それをデプロイ（CloudFormation スタックの生成）してみます。
下記が SAM テンプレートです。 SAM で Lambda 関数のリソースを定義するときは、リソースタイプとして AWS::Serverless::Function を指定します（CloudFormation では AWS::Lambda::Function です）。 ここでは関数の実装を InlineCode プロパティでハードコーディングし、単純な Hello World! メッセージをレスポンスとして返すようにしています。</description></item><item><title>AWS CloudFormation で Lambda 関数のリソースを生成する</title><link>https://maku.blog/p/w8s8kx9/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w8s8kx9/</guid><description>何をするか？ AWS CloudFormation を使うと Lambda 関数を含むインフラ（AWS リソース群）をまとめて生成することができますが、AWS CloudFormation の拡張である AWS SAM を使うと、もっと簡潔に Lambda 関数のリソースを生成することができます。
例えば、CloudFormation テンプレートの AWS::Lambda::Function リソースでは、Role プロパティが必須でしたが、SAM テンプレートの AWS::Serverless::Function リソースでは、Role プロパティはオプショナルになっています。 Role プロパティを省略すると、Lambda 関数に付けた論理 ID (Logical ID) をもとに、&amp;lt;論理ID&amp;gt;Role という名前のロールが自動生成されます。
ここでは、AWS SAM を使った Lambda 関数生成の基本として、次のようなパターンで CloudFormation スタックを生成してみます。
SAM テンプレートに関数コードを埋め込んでデプロイ S3 バケット上の関数の ZIP ファイルを使ってデプロイ SAM テンプレートに関数コードを埋め込んでデプロイ まずは、一番シンプルな例として、SAM テンプレート内に Lambda 関数の実装をハードコーディングしてしまい、それをデプロイ（CloudFormation スタックの生成）してみます。
下記が SAM テンプレートです。 SAM で Lambda 関数のリソースを定義するときは、リソースタイプとして AWS::Serverless::Function を指定します（CloudFormation では AWS::Lambda::Function です）。 ここでは関数の実装を InlineCode プロパティでハードコーディングし、単純な Hello World! メッセージをレスポンスとして返すようにしています。</description></item><item><title>AWS CloudFormation で Lambda 関数のリソースを生成する</title><link>https://maku.blog/p/w8s8kx9/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w8s8kx9/</guid><description>何をするか？ AWS CloudFormation を使うと Lambda 関数を含むインフラ（AWS リソース群）をまとめて生成することができますが、AWS CloudFormation の拡張である AWS SAM を使うと、もっと簡潔に Lambda 関数のリソースを生成することができます。
例えば、CloudFormation テンプレートの AWS::Lambda::Function リソースでは、Role プロパティが必須でしたが、SAM テンプレートの AWS::Serverless::Function リソースでは、Role プロパティはオプショナルになっています。 Role プロパティを省略すると、Lambda 関数に付けた論理 ID (Logical ID) をもとに、&amp;lt;論理ID&amp;gt;Role という名前のロールが自動生成されます。
ここでは、AWS SAM を使った Lambda 関数生成の基本として、次のようなパターンで CloudFormation スタックを生成してみます。
SAM テンプレートに関数コードを埋め込んでデプロイ S3 バケット上の関数の ZIP ファイルを使ってデプロイ SAM テンプレートに関数コードを埋め込んでデプロイ まずは、一番シンプルな例として、SAM テンプレート内に Lambda 関数の実装をハードコーディングしてしまい、それをデプロイ（CloudFormation スタックの生成）してみます。
下記が SAM テンプレートです。 SAM で Lambda 関数のリソースを定義するときは、リソースタイプとして AWS::Serverless::Function を指定します（CloudFormation では AWS::Lambda::Function です）。 ここでは関数の実装を InlineCode プロパティでハードコーディングし、単純な Hello World! メッセージをレスポンスとして返すようにしています。</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数の設定いろいろ</title><link>https://maku.blog/p/pbo2dpy/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbo2dpy/</guid><description>タイムアウト時間 (Timeout) Lambda 関数のタイムアウト時間（最大実行可能時間）を設定するには、Timeout プロパティで秒単位の指定を行います。
例: タイムアウトを 15 秒にする AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:MyLambda:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xCodeUri:function.zipHandler:index.handlerTimeout:15 すべての Lambda 関数の Timeout 値をまとめて設定したいときは、Globals セクションを使います。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Globals:Function:Runtime:nodejs14.xCodeUri:function.zipTimeout:15Resources:MyLambda1:Type:AWS::Serverless::FunctionProperties:Handler:index.handler1MyLambda2:Type:AWS::Serverless::FunctionProperties:Handler:index.handler2 環境変数 (Environment) Lambda 関数の中から参照可能な環境変数を設定するには、Variables プロパティに、キーと値のペアを指定します。 すべての Lambda 関数に共通で設定する環境変数は、Globals セクションで定義します。
Globals:Function:Environment:Variables:STAGE:ProductionTABLE_NAME:global-tableResources:MyFunction:Type:AWS::Serverless::FunctionProperties:Environment:Variables:TABLE_NAME:resource-tableNEW_VAR:hello トリガー設定 (Events) Lambda 関数を呼び出すためのトリガー（イベント）は、Events プロパティで定義できます。 Resouces プロパティと同様に、Events プロパティの一階層目にはイベントの論理 ID (Logical ID) を記述して、その下にそのイベントの設定を記述します。
Events プロパティの構成 Resources:MyFunction:Type:AWS::Serverless::FunctionProperties:Events:イベントの論理ID1:イベントの設定...イベントの論理ID2:イベントの設定... 一定時間ごとに呼び出す (Type: Schedule) Lambda 関数を一定時間ごとに呼び出したり、毎日決まった時刻に呼び出したりするには、Type: Schedule のイベントを設定します。 実際に生成される AWS リソースは EventBridge (CloudWatch Events) ルールです（リソースタイプは AWS::Events::Rule）。
次の例では、5 分おきに Lambda 関数を呼び出すように設定しています。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:HelloFunction:Type:AWS::Serverless::FunctionProperties:Runtime:python3.7Handler:index.handlerCodeUri:src/Events:MySchedule:Type:ScheduleProperties:Schedule:&amp;#39;rate(5 minutes)&amp;#39;# Schedule: &amp;#39;cron(0 * * * ?</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数の設定いろいろ</title><link>https://maku.blog/p/pbo2dpy/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbo2dpy/</guid><description>タイムアウト時間 (Timeout) Lambda 関数のタイムアウト時間（最大実行可能時間）を設定するには、Timeout プロパティで秒単位の指定を行います。
例: タイムアウトを 15 秒にする AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:MyLambda:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xCodeUri:function.zipHandler:index.handlerTimeout:15 すべての Lambda 関数の Timeout 値をまとめて設定したいときは、Globals セクションを使います。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Globals:Function:Runtime:nodejs14.xCodeUri:function.zipTimeout:15Resources:MyLambda1:Type:AWS::Serverless::FunctionProperties:Handler:index.handler1MyLambda2:Type:AWS::Serverless::FunctionProperties:Handler:index.handler2 環境変数 (Environment) Lambda 関数の中から参照可能な環境変数を設定するには、Variables プロパティに、キーと値のペアを指定します。 すべての Lambda 関数に共通で設定する環境変数は、Globals セクションで定義します。
Globals:Function:Environment:Variables:STAGE:ProductionTABLE_NAME:global-tableResources:MyFunction:Type:AWS::Serverless::FunctionProperties:Environment:Variables:TABLE_NAME:resource-tableNEW_VAR:hello トリガー設定 (Events) Lambda 関数を呼び出すためのトリガー（イベント）は、Events プロパティで定義できます。 Resouces プロパティと同様に、Events プロパティの一階層目にはイベントの論理 ID (Logical ID) を記述して、その下にそのイベントの設定を記述します。
Events プロパティの構成 Resources:MyFunction:Type:AWS::Serverless::FunctionProperties:Events:イベントの論理ID1:イベントの設定...イベントの論理ID2:イベントの設定... 一定時間ごとに呼び出す (Type: Schedule) Lambda 関数を一定時間ごとに呼び出したり、毎日決まった時刻に呼び出したりするには、Type: Schedule のイベントを設定します。 実際に生成される AWS リソースは EventBridge (CloudWatch Events) ルールです（リソースタイプは AWS::Events::Rule）。
次の例では、5 分おきに Lambda 関数を呼び出すように設定しています。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:HelloFunction:Type:AWS::Serverless::FunctionProperties:Runtime:python3.7Handler:index.handlerCodeUri:src/Events:MySchedule:Type:ScheduleProperties:Schedule:&amp;#39;rate(5 minutes)&amp;#39;# Schedule: &amp;#39;cron(0 * * * ?</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数の設定いろいろ</title><link>https://maku.blog/p/pbo2dpy/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbo2dpy/</guid><description>タイムアウト時間 (Timeout) Lambda 関数のタイムアウト時間（最大実行可能時間）を設定するには、Timeout プロパティで秒単位の指定を行います。
例: タイムアウトを 15 秒にする AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:MyLambda:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xCodeUri:function.zipHandler:index.handlerTimeout:15 すべての Lambda 関数の Timeout 値をまとめて設定したいときは、Globals セクションを使います。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Globals:Function:Runtime:nodejs14.xCodeUri:function.zipTimeout:15Resources:MyLambda1:Type:AWS::Serverless::FunctionProperties:Handler:index.handler1MyLambda2:Type:AWS::Serverless::FunctionProperties:Handler:index.handler2 環境変数 (Environment) Lambda 関数の中から参照可能な環境変数を設定するには、Variables プロパティに、キーと値のペアを指定します。 すべての Lambda 関数に共通で設定する環境変数は、Globals セクションで定義します。
Globals:Function:Environment:Variables:STAGE:ProductionTABLE_NAME:global-tableResources:MyFunction:Type:AWS::Serverless::FunctionProperties:Environment:Variables:TABLE_NAME:resource-tableNEW_VAR:hello トリガー設定 (Events) Lambda 関数を呼び出すためのトリガー（イベント）は、Events プロパティで定義できます。 Resouces プロパティと同様に、Events プロパティの一階層目にはイベントの論理 ID (Logical ID) を記述して、その下にそのイベントの設定を記述します。
Events プロパティの構成 Resources:MyFunction:Type:AWS::Serverless::FunctionProperties:Events:イベントの論理ID1:イベントの設定...イベントの論理ID2:イベントの設定... 一定時間ごとに呼び出す (Type: Schedule) Lambda 関数を一定時間ごとに呼び出したり、毎日決まった時刻に呼び出したりするには、Type: Schedule のイベントを設定します。 実際に生成される AWS リソースは EventBridge (CloudWatch Events) ルールです（リソースタイプは AWS::Events::Rule）。
次の例では、5 分おきに Lambda 関数を呼び出すように設定しています。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:HelloFunction:Type:AWS::Serverless::FunctionProperties:Runtime:python3.7Handler:index.handlerCodeUri:src/Events:MySchedule:Type:ScheduleProperties:Schedule:&amp;#39;rate(5 minutes)&amp;#39;# Schedule: &amp;#39;cron(0 * * * ?</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数の設定いろいろ</title><link>https://maku.blog/p/pbo2dpy/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbo2dpy/</guid><description>タイムアウト時間 (Timeout) Lambda 関数のタイムアウト時間（最大実行可能時間）を設定するには、Timeout プロパティで秒単位の指定を行います。
例: タイムアウトを 15 秒にする AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:MyLambda:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xCodeUri:function.zipHandler:index.handlerTimeout:15 すべての Lambda 関数の Timeout 値をまとめて設定したいときは、Globals セクションを使います。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Globals:Function:Runtime:nodejs14.xCodeUri:function.zipTimeout:15Resources:MyLambda1:Type:AWS::Serverless::FunctionProperties:Handler:index.handler1MyLambda2:Type:AWS::Serverless::FunctionProperties:Handler:index.handler2 環境変数 (Environment) Lambda 関数の中から参照可能な環境変数を設定するには、Variables プロパティに、キーと値のペアを指定します。 すべての Lambda 関数に共通で設定する環境変数は、Globals セクションで定義します。
Globals:Function:Environment:Variables:STAGE:ProductionTABLE_NAME:global-tableResources:MyFunction:Type:AWS::Serverless::FunctionProperties:Environment:Variables:TABLE_NAME:resource-tableNEW_VAR:hello トリガー設定 (Events) Lambda 関数を呼び出すためのトリガー（イベント）は、Events プロパティで定義できます。 Resouces プロパティと同様に、Events プロパティの一階層目にはイベントの論理 ID (Logical ID) を記述して、その下にそのイベントの設定を記述します。
Events プロパティの構成 Resources:MyFunction:Type:AWS::Serverless::FunctionProperties:Events:イベントの論理ID1:イベントの設定...イベントの論理ID2:イベントの設定... 一定時間ごとに呼び出す (Type: Schedule) Lambda 関数を一定時間ごとに呼び出したり、毎日決まった時刻に呼び出したりするには、Type: Schedule のイベントを設定します。 実際に生成される AWS リソースは EventBridge (CloudWatch Events) ルールです（リソースタイプは AWS::Events::Rule）。
次の例では、5 分おきに Lambda 関数を呼び出すように設定しています。
AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:HelloFunction:Type:AWS::Serverless::FunctionProperties:Runtime:python3.7Handler:index.handlerCodeUri:src/Events:MySchedule:Type:ScheduleProperties:Schedule:&amp;#39;rate(5 minutes)&amp;#39;# Schedule: &amp;#39;cron(0 * * * ?</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数から S3 にアクセスできるようにする</title><link>https://maku.blog/p/dzdq3ep/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dzdq3ep/</guid><description>CloudFormation (SAM) を利用して、Lambda 関数および S3 バケットを作成し、Lambda 関数から S3 バケットにアクセスできるようにポリシー設定するテンプレートの例です。 参考までに Lambda 関数の TypeScript コードも載せましたが、あくまで SAM テンプレートの記述例を示すことを目的としています。
SAM テンプレートの記述例 次の SAM テンプレートでは、AWS リソースとして S3 バケット (MyBucket) と Lambda 関数 (MyFunction) を定義しています。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:# S3 バケットの定義MyBucket:Type:AWS::S3::Bucket# Lambda 関数の定義MyFunction:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xHandler:build/index.handlerCodeUri:function.zipPolicies:- S3CrudPolicy:BucketName:!Ref MyBucketEnvironment:Variables:BUCKET_NAME:!Ref MyBucket S3 バケットは単純にスタック内に新規作成するだけなので、何もプロパティ設定していません。 ポイントは、Lambda 関数側のポリシー設定（Policies プロパティ）です。
Policies:- S3CrudPolicy:BucketName:!Ref MyBucket ここでは、AWS が標準で用意している S3CrudPolicy というポリシーを使っています。 このポリシーの BucketName パラメータとして、作成した S3 バケットの物理 ID (Physical ID) を渡すことで、Lambda 関数から S3 バケットの読み書き（CRUD 操作）が可能になります。 S3 バケットの Physical ID は、Ref 関数に Logical ID を渡すことで取得することができます。</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数から S3 にアクセスできるようにする</title><link>https://maku.blog/p/dzdq3ep/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dzdq3ep/</guid><description>CloudFormation (SAM) を利用して、Lambda 関数および S3 バケットを作成し、Lambda 関数から S3 バケットにアクセスできるようにポリシー設定するテンプレートの例です。 参考までに Lambda 関数の TypeScript コードも載せましたが、あくまで SAM テンプレートの記述例を示すことを目的としています。
SAM テンプレートの記述例 次の SAM テンプレートでは、AWS リソースとして S3 バケット (MyBucket) と Lambda 関数 (MyFunction) を定義しています。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:# S3 バケットの定義MyBucket:Type:AWS::S3::Bucket# Lambda 関数の定義MyFunction:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xHandler:build/index.handlerCodeUri:function.zipPolicies:- S3CrudPolicy:BucketName:!Ref MyBucketEnvironment:Variables:BUCKET_NAME:!Ref MyBucket S3 バケットは単純にスタック内に新規作成するだけなので、何もプロパティ設定していません。 ポイントは、Lambda 関数側のポリシー設定（Policies プロパティ）です。
Policies:- S3CrudPolicy:BucketName:!Ref MyBucket ここでは、AWS が標準で用意している S3CrudPolicy というポリシーを使っています。 このポリシーの BucketName パラメータとして、作成した S3 バケットの物理 ID (Physical ID) を渡すことで、Lambda 関数から S3 バケットの読み書き（CRUD 操作）が可能になります。 S3 バケットの Physical ID は、Ref 関数に Logical ID を渡すことで取得することができます。</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数から S3 にアクセスできるようにする</title><link>https://maku.blog/p/dzdq3ep/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dzdq3ep/</guid><description>CloudFormation (SAM) を利用して、Lambda 関数および S3 バケットを作成し、Lambda 関数から S3 バケットにアクセスできるようにポリシー設定するテンプレートの例です。 参考までに Lambda 関数の TypeScript コードも載せましたが、あくまで SAM テンプレートの記述例を示すことを目的としています。
SAM テンプレートの記述例 次の SAM テンプレートでは、AWS リソースとして S3 バケット (MyBucket) と Lambda 関数 (MyFunction) を定義しています。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:# S3 バケットの定義MyBucket:Type:AWS::S3::Bucket# Lambda 関数の定義MyFunction:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xHandler:build/index.handlerCodeUri:function.zipPolicies:- S3CrudPolicy:BucketName:!Ref MyBucketEnvironment:Variables:BUCKET_NAME:!Ref MyBucket S3 バケットは単純にスタック内に新規作成するだけなので、何もプロパティ設定していません。 ポイントは、Lambda 関数側のポリシー設定（Policies プロパティ）です。
Policies:- S3CrudPolicy:BucketName:!Ref MyBucket ここでは、AWS が標準で用意している S3CrudPolicy というポリシーを使っています。 このポリシーの BucketName パラメータとして、作成した S3 バケットの物理 ID (Physical ID) を渡すことで、Lambda 関数から S3 バケットの読み書き（CRUD 操作）が可能になります。 S3 バケットの Physical ID は、Ref 関数に Logical ID を渡すことで取得することができます。</description></item><item><title>AWS CloudFormation の設定例: Lambda 関数から S3 にアクセスできるようにする</title><link>https://maku.blog/p/dzdq3ep/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dzdq3ep/</guid><description>CloudFormation (SAM) を利用して、Lambda 関数および S3 バケットを作成し、Lambda 関数から S3 バケットにアクセスできるようにポリシー設定するテンプレートの例です。 参考までに Lambda 関数の TypeScript コードも載せましたが、あくまで SAM テンプレートの記述例を示すことを目的としています。
SAM テンプレートの記述例 次の SAM テンプレートでは、AWS リソースとして S3 バケット (MyBucket) と Lambda 関数 (MyFunction) を定義しています。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Resources:# S3 バケットの定義MyBucket:Type:AWS::S3::Bucket# Lambda 関数の定義MyFunction:Type:AWS::Serverless::FunctionProperties:Runtime:nodejs14.xHandler:build/index.handlerCodeUri:function.zipPolicies:- S3CrudPolicy:BucketName:!Ref MyBucketEnvironment:Variables:BUCKET_NAME:!Ref MyBucket S3 バケットは単純にスタック内に新規作成するだけなので、何もプロパティ設定していません。 ポイントは、Lambda 関数側のポリシー設定（Policies プロパティ）です。
Policies:- S3CrudPolicy:BucketName:!Ref MyBucket ここでは、AWS が標準で用意している S3CrudPolicy というポリシーを使っています。 このポリシーの BucketName パラメータとして、作成した S3 バケットの物理 ID (Physical ID) を渡すことで、Lambda 関数から S3 バケットの読み書き（CRUD 操作）が可能になります。 S3 バケットの Physical ID は、Ref 関数に Logical ID を渡すことで取得することができます。</description></item><item><title>AWS CloudFormation で S3 バケットのリソースを作成する</title><link>https://maku.blog/p/ugt6gr4/</link><pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ugt6gr4/</guid><description>S3 バケット定義の基本 AWS CloudFormation で S3 バケットを作成・設定するには、次のようにテンプレートファイル内で AWS::S3::Bucket タイプのリソースを定義します。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Resources:MyBucket:Type:AWS::S3::Bucket 上記の例では、論理 ID (Logical ID) が MyBucket の S3 バケットを定義しています。 論理 ID はこのテンプレートで生成するスタック内で一意の ID です。 実際に生成される S3 バケット名（物理 ID）は CloudFormation が自動で生成します（後述）。
このテンプレートを使って、CloudFormation スタック（ここでは S3 バケットのみ含まれる）を生成するには、次のように aws cloudformation deploy コマンドを実行します。
mystack スタックを生成 $ aws cloudformation deploy --template-file template.yml --stack-name mystack スタック内に生成された AWS リソースの一覧は次のように確認できます。
$ aws cloudformation describe-stack-resources --stack-name mystack StackResources: - DriftInformation: StackResourceDriftStatus: NOT_CHECKED LogicalResourceId: MyBucket PhysicalResourceId: mystack-mybucket-bq8iux8uepew ResourceStatus: CREATE_COMPLETE ResourceType: AWS::S3::Bucket StackId: arn:aws:cloudformation:ap-northeast-1:123456789012:stack/mystack/c7e06a46-9902-11eb-9a29-8b1f770a16f7 StackName: mystack Timestamp: &amp;#39;2021-04-09T07:09:13.</description></item><item><title>AWS CloudFormation で S3 バケットのリソースを作成する</title><link>https://maku.blog/p/ugt6gr4/</link><pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ugt6gr4/</guid><description>S3 バケット定義の基本 AWS CloudFormation で S3 バケットを作成・設定するには、次のようにテンプレートファイル内で AWS::S3::Bucket タイプのリソースを定義します。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Resources:MyBucket:Type:AWS::S3::Bucket 上記の例では、論理 ID (Logical ID) が MyBucket の S3 バケットを定義しています。 論理 ID はこのテンプレートで生成するスタック内で一意の ID です。 実際に生成される S3 バケット名（物理 ID）は CloudFormation が自動で生成します（後述）。
このテンプレートを使って、CloudFormation スタック（ここでは S3 バケットのみ含まれる）を生成するには、次のように aws cloudformation deploy コマンドを実行します。
mystack スタックを生成 $ aws cloudformation deploy --template-file template.yml --stack-name mystack スタック内に生成された AWS リソースの一覧は次のように確認できます。
$ aws cloudformation describe-stack-resources --stack-name mystack StackResources: - DriftInformation: StackResourceDriftStatus: NOT_CHECKED LogicalResourceId: MyBucket PhysicalResourceId: mystack-mybucket-bq8iux8uepew ResourceStatus: CREATE_COMPLETE ResourceType: AWS::S3::Bucket StackId: arn:aws:cloudformation:ap-northeast-1:123456789012:stack/mystack/c7e06a46-9902-11eb-9a29-8b1f770a16f7 StackName: mystack Timestamp: &amp;#39;2021-04-09T07:09:13.</description></item><item><title>AWS CloudFormation で S3 バケットのリソースを作成する</title><link>https://maku.blog/p/ugt6gr4/</link><pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ugt6gr4/</guid><description>S3 バケット定義の基本 AWS CloudFormation で S3 バケットを作成・設定するには、次のようにテンプレートファイル内で AWS::S3::Bucket タイプのリソースを定義します。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Resources:MyBucket:Type:AWS::S3::Bucket 上記の例では、論理 ID (Logical ID) が MyBucket の S3 バケットを定義しています。 論理 ID はこのテンプレートで生成するスタック内で一意の ID です。 実際に生成される S3 バケット名（物理 ID）は CloudFormation が自動で生成します（後述）。
このテンプレートを使って、CloudFormation スタック（ここでは S3 バケットのみ含まれる）を生成するには、次のように aws cloudformation deploy コマンドを実行します。
mystack スタックを生成 $ aws cloudformation deploy --template-file template.yml --stack-name mystack スタック内に生成された AWS リソースの一覧は次のように確認できます。
$ aws cloudformation describe-stack-resources --stack-name mystack StackResources: - DriftInformation: StackResourceDriftStatus: NOT_CHECKED LogicalResourceId: MyBucket PhysicalResourceId: mystack-mybucket-bq8iux8uepew ResourceStatus: CREATE_COMPLETE ResourceType: AWS::S3::Bucket StackId: arn:aws:cloudformation:ap-northeast-1:123456789012:stack/mystack/c7e06a46-9902-11eb-9a29-8b1f770a16f7 StackName: mystack Timestamp: &amp;#39;2021-04-09T07:09:13.</description></item><item><title>AWS CloudFormation で DyanamoDB のリソースを作成する</title><link>https://maku.blog/p/h3gsjs2/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h3gsjs2/</guid><description>SAM で簡単な DynamoDB テーブルを生成してみる DynamoDB のテーブルリソースも、Lambda 関数などのリソースと同様に AWS SAM で自動生成＆更新することができます。 CloudFormation のテンプレートをそのまま記述するより、拡張された SAM テンプレートの形式で記述することで、シンプルにリソースを定義することができます。
SAM テンプレート内で DynamoDB のテーブルを定義するときは、リソースタイプとして AWS::Serverless::SimpleTable を指定します（CloudFormation スタック内に実際に生成されるリソースのタイプは AWS::DynamoDB::Table になります）。
DynamoDB テーブルを作成するための最低限の SAM テンプレートはとてもシンプルです。 次の例では、MyTable という 論理 ID (Logical ID) で DynamoDB のテーブルを定義しています。 論理 ID はスタック内でリソースを特定するための名前です。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Description:My sample appResources:MyTable:Type:AWS::Serverless::SimpleTable ひとつもプライマリキーを指定していませんが、その場合はデフォルトで id という名前のプライマリキー（String 型）が定義されます。 AWS CLI で次のように実行すると、CloudFormation のスタックを作成することができます。
$ aws cloudformation deploy --stack-name mystack \ --template-file template.yml CloudFormation スタック内に、実際にどのような AWS リソースが作成されたかを調べるには以下のようにします。 ここではリソースタイプと、その物理 ID (Pysical ID) を table 形式で出力してみました。</description></item><item><title>AWS CloudFormation で DyanamoDB のリソースを作成する</title><link>https://maku.blog/p/h3gsjs2/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h3gsjs2/</guid><description>SAM で簡単な DynamoDB テーブルを生成してみる DynamoDB のテーブルリソースも、Lambda 関数などのリソースと同様に AWS SAM で自動生成＆更新することができます。 CloudFormation のテンプレートをそのまま記述するより、拡張された SAM テンプレートの形式で記述することで、シンプルにリソースを定義することができます。
SAM テンプレート内で DynamoDB のテーブルを定義するときは、リソースタイプとして AWS::Serverless::SimpleTable を指定します（CloudFormation スタック内に実際に生成されるリソースのタイプは AWS::DynamoDB::Table になります）。
DynamoDB テーブルを作成するための最低限の SAM テンプレートはとてもシンプルです。 次の例では、MyTable という 論理 ID (Logical ID) で DynamoDB のテーブルを定義しています。 論理 ID はスタック内でリソースを特定するための名前です。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Description:My sample appResources:MyTable:Type:AWS::Serverless::SimpleTable ひとつもプライマリキーを指定していませんが、その場合はデフォルトで id という名前のプライマリキー（String 型）が定義されます。 AWS CLI で次のように実行すると、CloudFormation のスタックを作成することができます。
$ aws cloudformation deploy --stack-name mystack \ --template-file template.yml CloudFormation スタック内に、実際にどのような AWS リソースが作成されたかを調べるには以下のようにします。 ここではリソースタイプと、その物理 ID (Pysical ID) を table 形式で出力してみました。</description></item><item><title>AWS CloudFormation で DyanamoDB のリソースを作成する</title><link>https://maku.blog/p/h3gsjs2/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h3gsjs2/</guid><description>SAM で簡単な DynamoDB テーブルを生成してみる DynamoDB のテーブルリソースも、Lambda 関数などのリソースと同様に AWS SAM で自動生成＆更新することができます。 CloudFormation のテンプレートをそのまま記述するより、拡張された SAM テンプレートの形式で記述することで、シンプルにリソースを定義することができます。
SAM テンプレート内で DynamoDB のテーブルを定義するときは、リソースタイプとして AWS::Serverless::SimpleTable を指定します（CloudFormation スタック内に実際に生成されるリソースのタイプは AWS::DynamoDB::Table になります）。
DynamoDB テーブルを作成するための最低限の SAM テンプレートはとてもシンプルです。 次の例では、MyTable という 論理 ID (Logical ID) で DynamoDB のテーブルを定義しています。 論理 ID はスタック内でリソースを特定するための名前です。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Transform:AWS::Serverless-2016-10-31Description:My sample appResources:MyTable:Type:AWS::Serverless::SimpleTable ひとつもプライマリキーを指定していませんが、その場合はデフォルトで id という名前のプライマリキー（String 型）が定義されます。 AWS CLI で次のように実行すると、CloudFormation のスタックを作成することができます。
$ aws cloudformation deploy --stack-name mystack \ --template-file template.yml CloudFormation スタック内に、実際にどのような AWS リソースが作成されたかを調べるには以下のようにします。 ここではリソースタイプと、その物理 ID (Pysical ID) を table 形式で出力してみました。</description></item><item><title>AWS CloudFormation で SNS トピックのリソースを生成する</title><link>https://maku.blog/p/ymzbmx9/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ymzbmx9/</guid><description>CloudFormation で SNS トピックを作成する CloudFormation スタック内に SNS トピックを生成するには、CloudFormation テンプレートで AWS::SNS::Topic というタイプのリソースを定義します。
このリソースのプロパティはすべてオプショナル（省略可能）なので、最低限のリソース定義は次のようになります。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Resources:MyTopic:Type:AWS::SNS::Topic トピック名 (Properties.TopicName) すら指定していませんが、その場合は、CloudFormation のスタック名と、トピックの論理 ID（上記の場合は MyTopic）の組み合わせから、自動的にトピック名が割り当てられるようになっています（例: mystack-MyTopic-WMD9B9WWLEXN）。
上記のテンプレートから CloudFormation スタックを生成するには、AWS CLI を使って次のように実行します。
mystack スタックの生成 $ aws cloudformation deploy --stack-name mystack \ --template-file template.yml \ --capabilities CAPABILITY_IAM 無事スタックが生成されたら、次のようにして生成された SNS トピックの物理 ID (ARN) を調べることができます。
SNS トピックの ARN を調べる $ aws cloudformation describe-stack-resources \ --stack-name mystack \ --output text \ --query &amp;#34;StackResources[].PhysicalResourceId&amp;#34; arn:aws:sns:ap-northeast-1:123456789012:mystack-MyTopic-WMD9B9WWLEXN Lambda 関数や S3 バケットから SNS トピックに対して publish するときは、この ARN を指定することになります。</description></item><item><title>AWS CloudFormation で SNS トピックのリソースを生成する</title><link>https://maku.blog/p/ymzbmx9/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ymzbmx9/</guid><description>CloudFormation で SNS トピックを作成する CloudFormation スタック内に SNS トピックを生成するには、CloudFormation テンプレートで AWS::SNS::Topic というタイプのリソースを定義します。
このリソースのプロパティはすべてオプショナル（省略可能）なので、最低限のリソース定義は次のようになります。
template.yml AWSTemplateFormatVersion:&amp;#39;2010-09-09&amp;#39;Resources:MyTopic:Type:AWS::SNS::Topic トピック名 (Properties.TopicName) すら指定していませんが、その場合は、CloudFormation のスタック名と、トピックの論理 ID（上記の場合は MyTopic）の組み合わせから、自動的にトピック名が割り当てられるようになっています（例: mystack-MyTopic-WMD9B9WWLEXN）。
上記のテンプレートから CloudFormation スタックを生成するには、AWS CLI を使って次のように実行します。
mystack スタックの生成 $ aws cloudformation deploy --stack-name mystack \ --template-file template.yml \ --capabilities CAPABILITY_IAM 無事スタックが生成されたら、次のようにして生成された SNS トピックの物理 ID (ARN) を調べることができます。
SNS トピックの ARN を調べる $ aws cloudformation describe-stack-resources \ --stack-name mystack \ --output text \ --query &amp;#34;StackResources[].PhysicalResourceId&amp;#34; arn:aws:sns:ap-northeast-1:123456789012:mystack-MyTopic-WMD9B9WWLEXN Lambda 関数や S3 バケットから SNS トピックに対して publish するときは、この ARN を指定することになります。</description></item><item><title>AWS CloudFormation の設定例: SNS トピックを Lambda 関数からサブスクライブする</title><link>https://maku.blog/p/5q4epyb/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q4epyb/</guid><description>何をするか？ ここでは、CloudFormation (SAM) のテンプレートを使って、SNS トピックをサブスクライブする Lambda 関数を定義してみます。
サブスクライブ対象とする SNS トピック自体は、あらかじめ何らかの方法で作成済みであり、次のような ARN を取得できているものとします。
SNS トピックの ARN arn:aws:sns:ap-northeast-1:123456789012:mytopic 上記のような CloudFormation スタックが完成すると、マネージメントコンソールや CLI で SNS トピックのメッセージを発行して、Lambda 関数にイベントが届くことを確認できます。
参考リンク CloudFormation で SNS トピックの作成 CloudFormation の設定例: S3 通知を SNS トピックに Publish する テンプレートの記述例 次の SAM テンプレートでは、Lambda 関数を定義しつつ、そのイベントソースとして SNS トピックを設定しています。 イベントソースの指定は、実際には、SNS トピックに Lambda 関数をサブスクライブすることを意味しています。 SNS トピックの ARN は、入力パラメータ TopicArn のデフォルト値として指定しています。
template.yml AWSTemplateFormatVersion:2010-09-09Transform:AWS::Serverless-2016-10-31Parameters:TopicArn:Type:StringDefault:arn:aws:sns:ap-northeast-1:123456789012:mytopicResources:MyFunction:Type:AWS::Serverless::FunctionProperties:Runtime:python3.7Handler:index.handlerInlineCode:|import json def handler(event, context): s = json.dumps(event, indent=2) print(&amp;#39;Message received from SNS:&amp;#39; + s) return {&amp;#39;body&amp;#39;: s, &amp;#39;statusCode&amp;#39;: 200}# Lambda 関数を SNS トピックにサブスクライブするEvents:MySnsEvent:Type:SNSProperties:Topic:!</description></item><item><title>AWS CloudFormation の設定例: SNS トピックを Lambda 関数からサブスクライブする</title><link>https://maku.blog/p/5q4epyb/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/5q4epyb/</guid><description>何をするか？ ここでは、CloudFormation (SAM) のテンプレートを使って、SNS トピックをサブスクライブする Lambda 関数を定義してみます。
サブスクライブ対象とする SNS トピック自体は、あらかじめ何らかの方法で作成済みであり、次のような ARN を取得できているものとします。
SNS トピックの ARN arn:aws:sns:ap-northeast-1:123456789012:mytopic 上記のような CloudFormation スタックが完成すると、マネージメントコンソールや CLI で SNS トピックのメッセージを発行して、Lambda 関数にイベントが届くことを確認できます。
参考リンク CloudFormation で SNS トピックの作成 CloudFormation の設定例: S3 通知を SNS トピックに Publish する テンプレートの記述例 次の SAM テンプレートでは、Lambda 関数を定義しつつ、そのイベントソースとして SNS トピックを設定しています。 イベントソースの指定は、実際には、SNS トピックに Lambda 関数をサブスクライブすることを意味しています。 SNS トピックの ARN は、入力パラメータ TopicArn のデフォルト値として指定しています。
template.yml AWSTemplateFormatVersion:2010-09-09Transform:AWS::Serverless-2016-10-31Parameters:TopicArn:Type:StringDefault:arn:aws:sns:ap-northeast-1:123456789012:mytopicResources:MyFunction:Type:AWS::Serverless::FunctionProperties:Runtime:python3.7Handler:index.handlerInlineCode:|import json def handler(event, context): s = json.dumps(event, indent=2) print(&amp;#39;Message received from SNS:&amp;#39; + s) return {&amp;#39;body&amp;#39;: s, &amp;#39;statusCode&amp;#39;: 200}# Lambda 関数を SNS トピックにサブスクライブするEvents:MySnsEvent:Type:SNSProperties:Topic:!</description></item><item><title>AWS CDK 入門: cdk コマンドのインストールから Hello World まで</title><link>https://maku.blog/p/nujyfsy/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nujyfsy/</guid><description>CDK とは AWS CDK (Cloud Development Kit) を使うと、TypeScript や Python を使って AWS リソースの生成を自動化することができます。 大きなプロジェクトでは、CloudFormation や SAM によるスタック生成用のテンプレートが長大になりがちですが、CDK を使うことで CloudFormation テンプレートの生成処理を隠蔽し、効率的にインフラ定義を行うことができます。 CDK の利点 をざっと挙げると以下のような感じです。
TypeScript、Python などのパワフルな言語機能を使ってインフラ定義を行うことができる。 各種リソース間の参照を、オブジェクトのプロパティ参照という自然な形で表現できる。 コンストラクト (Construct Library) という再利用可能なライブラリの提供により、様々なユースケースに対応した AWS リソース群を短いコードで定義できる。 VS Code (TypeScript) 、PyCharm (Python) などで型情報の補完が効くため、AWS リソースに設定可能なプロパティを見つけやすい。明らかに間違った設定はコンパイル時に気付くことができる。 Lambda 関数デプロイ時などに必要になる ZIP パッケージング、および S3 一時バケットの生成を自動で行ってくれる。 一方、CDK の欠点 としては、基本的に AWS に特化したツールであるため、Terraform や Serverless Framework のように様々なクラウド (Azure, AWS, GCP) に対応できないという点が挙げられます。 Terraform などの汎用ツールに比べて、CDK は学習コストも比較的高いです。 Azure なども同じツールで構築したいとか、それほど細かい制御は必要ないということであれば、Terraform などを使った方がいいかもしれません。 ただ、CDK を使っている限り、AWS の最新のリソースにも即対応できることが保証されますし、AWS CloudFormation に関しての知識は身につけやすいでしょう。</description></item><item><title>AWS CDK 入門: cdk コマンドのインストールから Hello World まで</title><link>https://maku.blog/p/nujyfsy/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nujyfsy/</guid><description>CDK とは AWS CDK (Cloud Development Kit) を使うと、TypeScript や Python を使って AWS リソースの生成を自動化することができます。 大きなプロジェクトでは、CloudFormation や SAM によるスタック生成用のテンプレートが長大になりがちですが、CDK を使うことで CloudFormation テンプレートの生成処理を隠蔽し、効率的にインフラ定義を行うことができます。 CDK の利点 をざっと挙げると以下のような感じです。
TypeScript、Python などのパワフルな言語機能を使ってインフラ定義を行うことができる。 各種リソース間の参照を、オブジェクトのプロパティ参照という自然な形で表現できる。 コンストラクト (Construct Library) という再利用可能なライブラリの提供により、様々なユースケースに対応した AWS リソース群を短いコードで定義できる。 VS Code (TypeScript) 、PyCharm (Python) などで型情報の補完が効くため、AWS リソースに設定可能なプロパティを見つけやすい。明らかに間違った設定はコンパイル時に気付くことができる。 Lambda 関数デプロイ時などに必要になる ZIP パッケージング、および S3 一時バケットの生成を自動で行ってくれる。 一方、CDK の欠点 としては、基本的に AWS に特化したツールであるため、Terraform や Serverless Framework のように様々なクラウド (Azure, AWS, GCP) に対応できないという点が挙げられます。 Terraform などの汎用ツールに比べて、CDK は学習コストも比較的高いです。 Azure なども同じツールで構築したいとか、それほど細かい制御は必要ないということであれば、Terraform などを使った方がいいかもしれません。 ただ、CDK を使っている限り、AWS の最新のリソースにも即対応できることが保証されますし、AWS CloudFormation に関しての知識は身につけやすいでしょう。</description></item><item><title>AWS CDK メモ: ブートストラップ処理を実行する (cdk bootstrap)</title><link>https://maku.blog/p/q7q8p6m/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7q8p6m/</guid><description>CloudFormation のスタックを生成するときに、一時的なファイル置き場として S3 バケットが必要になることがあります。 例えば、Lambda 関数をデプロイするときに、ZIP パッケージを置くためのステージングバケットが必要になります。 このステージングバケットへの実際のアップロード処理は CDK が自動でやってくれるのですが、バケットの準備だけはあらかじめ手動で行っておく必要があります。 このためのコマンドが cdk bootstrap コマンドです。 AWS アカウント（およびリージョン）内で一度だけ実行しておけばよいので、このタイミングで実行しておきます。 実行時には次のように「アカウント番号」と「リージョン名」を指定する必要があります。
cdk bootstrap aws://&amp;lt;アカウント番号&amp;gt;/&amp;lt;リージョン名&amp;gt; 実際の実行例 $ cdk bootstrap aws://123456789012/ap-northeast-1 ⏳ Bootstrapping environment aws://123456789012/ap-northeast-1... CDKToolkit: creating CloudFormation changeset... ... ✅ Environment aws://123456789012/ap-northeast-1 bootstrapped. これにより、ステージング用のバケットを含む CDKToolkit という名前のブートストラップ・スタックが生成されます。
ちなみに、現在使用している「アカウント番号」と「リージョン名」は、AWS CLI を使って次のように確認できます。
アカウント番号の確認 $ aws sts get-caller-identity --output text --query Account [--profile xxxx] 123456789012 リージョン名の確認 $ aws configure get region [--profile xxxx] ap-northeast-1</description></item><item><title>AWS CDK メモ: ブートストラップ処理を実行する (cdk bootstrap)</title><link>https://maku.blog/p/q7q8p6m/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/q7q8p6m/</guid><description>CloudFormation のスタックを生成するときに、一時的なファイル置き場として S3 バケットが必要になることがあります。 例えば、Lambda 関数をデプロイするときに、ZIP パッケージを置くためのステージングバケットが必要になります。 このステージングバケットへの実際のアップロード処理は CDK が自動でやってくれるのですが、バケットの準備だけはあらかじめ手動で行っておく必要があります。 このためのコマンドが cdk bootstrap コマンドです。 AWS アカウント（およびリージョン）内で一度だけ実行しておけばよいので、このタイミングで実行しておきます。 実行時には次のように「アカウント番号」と「リージョン名」を指定する必要があります。
cdk bootstrap aws://&amp;lt;アカウント番号&amp;gt;/&amp;lt;リージョン名&amp;gt; 実際の実行例 $ cdk bootstrap aws://123456789012/ap-northeast-1 ⏳ Bootstrapping environment aws://123456789012/ap-northeast-1... CDKToolkit: creating CloudFormation changeset... ... ✅ Environment aws://123456789012/ap-northeast-1 bootstrapped. これにより、ステージング用のバケットを含む CDKToolkit という名前のブートストラップ・スタックが生成されます。
ちなみに、現在使用している「アカウント番号」と「リージョン名」は、AWS CLI を使って次のように確認できます。
アカウント番号の確認 $ aws sts get-caller-identity --output text --query Account [--profile xxxx] 123456789012 リージョン名の確認 $ aws configure get region [--profile xxxx] ap-northeast-1</description></item><item><title>AWS CDK メモ: コンストラクトの概念を理解する</title><link>https://maku.blog/p/nqkav2m/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nqkav2m/</guid><description>コンストラクト・ツリー (Construct Tree) AWS CDK を使って CloudFormation スタックを作成するとき、そのリソース構成は、論理的な コンストラクト (construct) のツリー構造によって表現します。 下記は、典型的な CDK アプリケーションにおけるコンストラクト・ツリー構造です。
App +-- Stack | +-- Construct | +-- Construct | +-- ... +-- Stack +-- Construct | +-- Construct | +-- Construct +-- Construct +-- ... App、Stack、Construct はそれぞれ抽象度の異なるオブジェクトですが、すべて IConstruct インタフェース を実装したコンストラクトの一種です。 CDK アプリ―ケーションには、構成のエントリポイントとなる App コンストラクト が 1 つあり、複数の Stack コンストラクトを含むことができます。
Stack コンストラクト は、その名の通り CloudFormation スタックを表現するコンストラクトです。 App が複数の Stack から構成されている場合、cdk deploy コマンドでデプロイを実行したときに複数の CloudFormation スタックが生成されることになります。 cdk deploy &amp;lt;Stack名&amp;gt; とすれば、特定のスタックのみをデプロイすることも可能です。 指定可能な Stack 名の一覧を確認したいときは、cdk ls コマンドを使います。</description></item><item><title>AWS CDK メモ: コンストラクトの概念を理解する</title><link>https://maku.blog/p/nqkav2m/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nqkav2m/</guid><description>コンストラクト・ツリー (Construct Tree) AWS CDK を使って CloudFormation スタックを作成するとき、そのリソース構成は、論理的な コンストラクト (construct) のツリー構造によって表現します。 下記は、典型的な CDK アプリケーションにおけるコンストラクト・ツリー構造です。
App +-- Stack | +-- Construct | +-- Construct | +-- ... +-- Stack +-- Construct | +-- Construct | +-- Construct +-- Construct +-- ... App、Stack、Construct はそれぞれ抽象度の異なるオブジェクトですが、すべて IConstruct インタフェース を実装したコンストラクトの一種です。 CDK アプリ―ケーションには、構成のエントリポイントとなる App コンストラクト が 1 つあり、複数の Stack コンストラクトを含むことができます。
Stack コンストラクト は、その名の通り CloudFormation スタックを表現するコンストラクトです。 App が複数の Stack から構成されている場合、cdk deploy コマンドでデプロイを実行したときに複数の CloudFormation スタックが生成されることになります。 cdk deploy &amp;lt;Stack名&amp;gt; とすれば、特定のスタックのみをデプロイすることも可能です。 指定可能な Stack 名の一覧を確認したいときは、cdk ls コマンドを使います。</description></item><item><title>AWS CDK メモ: CDK アプリのパッケージ管理に Yarn を使う方法</title><link>https://maku.blog/p/4h3jygw/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4h3jygw/</guid><description>cdk init app --language typescript で CDK アプリのひな型を生成すると、デフォルトではパッケージマネージャーとして NPM を使う想定になっています（package-lock.json などが作成されます）。 NPM の代わりに Yarn を使いたい場合は、次のように package-lock.json を削除して、yarn.lock ファイルを生成します。
$ git rm package-lock.json $ yarn install 生成された yarn.lock は忘れずに Git へコミットしてください。
ちなみに、package-lock.json が残っている状態で yarn install しようとすると、次のような感じの Warning が表示されます。
warning package-lock.json found. Your project contains lock files generated by tools other than Yarn. It is advised not to mix package managers in order to avoid resolution inconsistencies caused by unsynchronized lock files.</description></item><item><title>AWS CDK メモ: CDK アプリのパッケージ管理に Yarn を使う方法</title><link>https://maku.blog/p/4h3jygw/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4h3jygw/</guid><description>cdk init app --language typescript で CDK アプリのひな型を生成すると、デフォルトではパッケージマネージャーとして NPM を使う想定になっています（package-lock.json などが作成されます）。 NPM の代わりに Yarn を使いたい場合は、次のように package-lock.json を削除して、yarn.lock ファイルを生成します。
$ git rm package-lock.json $ yarn install 生成された yarn.lock は忘れずに Git へコミットしてください。
ちなみに、package-lock.json が残っている状態で yarn install しようとすると、次のような感じの Warning が表示されます。
warning package-lock.json found. Your project contains lock files generated by tools other than Yarn. It is advised not to mix package managers in order to avoid resolution inconsistencies caused by unsynchronized lock files.</description></item><item><title>AWS CDK メモ: 謎の CDKMetadata を生成しないようにする</title><link>https://maku.blog/p/2asq4k4/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2asq4k4/</guid><description>AWS CDK で CloudFormation スタックを生成すると、デフォルトで CDKMetadata というリソースが生成されます（cdk synth コマンドで CloudFormation テンプレートを出力してみると確認できます）。
Resources:CDKMetadata:Type:AWS::CDK::MetadataProperties:Analytics:v2:deflate64:IsH4AAAAAAAA/L9ZNTs....9mAAAAMetadata:aws:cdk:path:CdkStack/CDKMetadata/DefaultCondition:CDKMetadataAvailableConditions:CDKMetadataAvailable:Fn::Or:- Fn::Or:- Fn::Equals:- Ref:AWS::Region- af-south-1- Fn::Equals:- Ref:AWS::Region- ap-east-1... 自分で何もリソース生成していないのにテンプレートが汚されて邪魔だなぁと思っていたら、この情報は、CDK を開発しているチームが利用状況などを把握して今後の改善のために使うようです。 下記、CDK のドキュメント より抜粋。
Every generated template contains a AWS::CDK::Metadata resource by default. (We haven&amp;rsquo;t shown it here.) The AWS CDK team uses this metadata to gain insight into how the AWS CDK is used, so we can continue to improve it. For details, including how to opt out of version reporting, see Version reporting.</description></item><item><title>AWS CDK メモ: 謎の CDKMetadata を生成しないようにする</title><link>https://maku.blog/p/2asq4k4/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2asq4k4/</guid><description>AWS CDK で CloudFormation スタックを生成すると、デフォルトで CDKMetadata というリソースが生成されます（cdk synth コマンドで CloudFormation テンプレートを出力してみると確認できます）。
Resources:CDKMetadata:Type:AWS::CDK::MetadataProperties:Analytics:v2:deflate64:IsH4AAAAAAAA/L9ZNTs....9mAAAAMetadata:aws:cdk:path:CdkStack/CDKMetadata/DefaultCondition:CDKMetadataAvailableConditions:CDKMetadataAvailable:Fn::Or:- Fn::Or:- Fn::Equals:- Ref:AWS::Region- af-south-1- Fn::Equals:- Ref:AWS::Region- ap-east-1... 自分で何もリソース生成していないのにテンプレートが汚されて邪魔だなぁと思っていたら、この情報は、CDK を開発しているチームが利用状況などを把握して今後の改善のために使うようです。 下記、CDK のドキュメント より抜粋。
Every generated template contains a AWS::CDK::Metadata resource by default. (We haven&amp;rsquo;t shown it here.) The AWS CDK team uses this metadata to gain insight into how the AWS CDK is used, so we can continue to improve it. For details, including how to opt out of version reporting, see Version reporting.</description></item><item><title>AWS CDK で TypeScript で実装した Lambda 関数をデプロイする (NodejsFunction)</title><link>https://maku.blog/p/cj9i4m3/</link><pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cj9i4m3/</guid><description>何をするか？ ここでは、CDK アプリとして作成した CloudFormation スタック内に、TypeScript で実装した Lambda 関数 を追加してみます。 Lambda 関数のビルドもデプロイ時に自動で行われるようにします。
以降の説明では、CDK プロジェクトの作成自体は済んでいるものとします。
参考: AWS CDK 入門: cdk コマンドのインストールから Hello World まで TypeScript で Lambda 関数を実装する Lambda 関数のコードは、プロジェクトのルートに lambda ディレクトリを作成して、そこに配置していくことにします。
myapp/ +-- bin/ ... CDK の App コンストラクト (.ts) +-- lambda/ ... ラムダ関数の実装コード (.ts) ★これを追加 | +-- index.ts +-- lib/ ... CDK の Stack コンストラクトなど (.ts) ... Lambda 関数実装用の TypeScript 型情報をインストールします。
$ npm install @types/aws-lambda --save-dev # npm の場合 $ yarn add @types/aws-lambda --dev # yarn の場合 最低限の Hello World 的なラムダ関数を作成します。</description></item><item><title>AWS CDK で TypeScript で実装した Lambda 関数をデプロイする (NodejsFunction)</title><link>https://maku.blog/p/cj9i4m3/</link><pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cj9i4m3/</guid><description>何をするか？ ここでは、CDK アプリとして作成した CloudFormation スタック内に、TypeScript で実装した Lambda 関数 を追加してみます。 Lambda 関数のビルドもデプロイ時に自動で行われるようにします。
以降の説明では、CDK プロジェクトの作成自体は済んでいるものとします。
参考: AWS CDK 入門: cdk コマンドのインストールから Hello World まで TypeScript で Lambda 関数を実装する Lambda 関数のコードは、プロジェクトのルートに lambda ディレクトリを作成して、そこに配置していくことにします。
myapp/ +-- bin/ ... CDK の App コンストラクト (.ts) +-- lambda/ ... ラムダ関数の実装コード (.ts) ★これを追加 | +-- index.ts +-- lib/ ... CDK の Stack コンストラクトなど (.ts) ... Lambda 関数実装用の TypeScript 型情報をインストールします。
$ npm install @types/aws-lambda --save-dev # npm の場合 $ yarn add @types/aws-lambda --dev # yarn の場合 最低限の Hello World 的なラムダ関数を作成します。</description></item><item><title>AWS CDK で Go 言語で実装した Lambda 関数をデプロイする (GoFunction)</title><link>https://maku.blog/p/38jt3cm/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38jt3cm/</guid><description>何をするか？ ここでは、CDK アプリとして作成した CloudFormation スタック内に、Go 言語で実装した Lambda 関数 を追加してみます。 Lambda 関数のビルドもデプロイ時に自動で行われるようにします。
CDK のプロジェクト自体（スタックを定義する CDK コード）は TypeScript で作成します。 以降の説明では、CDK プロジェクトの作成自体は済んでいるものとします。
参考: AWS CDK 入門: cdk コマンドのインストールから Hello World まで Go 言語で Lambda 関数を実装する Lambda 関数のコードは、プロジェクトのルートに lambda ディレクトリを作成して、そこに配置していくことにします。
myapp/ +-- bin/ ... CDK の App コンストラクト (.ts) +-- lambda/ ... ラムダ関数用のディレクトリ (.go) | +-- go.mod | +-- go.sum | +-- main.go +-- lib/ ... CDK の Stack コンストラクトなど (.ts) .</description></item><item><title>AWS CDK で Go 言語で実装した Lambda 関数をデプロイする (GoFunction)</title><link>https://maku.blog/p/38jt3cm/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38jt3cm/</guid><description>何をするか？ ここでは、CDK アプリとして作成した CloudFormation スタック内に、Go 言語で実装した Lambda 関数 を追加してみます。 Lambda 関数のビルドもデプロイ時に自動で行われるようにします。
CDK のプロジェクト自体（スタックを定義する CDK コード）は TypeScript で作成します。 以降の説明では、CDK プロジェクトの作成自体は済んでいるものとします。
参考: AWS CDK 入門: cdk コマンドのインストールから Hello World まで Go 言語で Lambda 関数を実装する Lambda 関数のコードは、プロジェクトのルートに lambda ディレクトリを作成して、そこに配置していくことにします。
myapp/ +-- bin/ ... CDK の App コンストラクト (.ts) +-- lambda/ ... ラムダ関数用のディレクトリ (.go) | +-- go.mod | +-- go.sum | +-- main.go +-- lib/ ... CDK の Stack コンストラクトなど (.ts) .</description></item><item><title>AWS CDK のサンプルコード集（TypeScript 版）</title><link>https://maku.blog/p/gzkzbny/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gzkzbny/</guid><description>AWS CDK を使った TypeScript サンプルコードいろいろです。
リソースにタグを付ける import * as cdk from &amp;#39;@aws-cdk/core&amp;#39; import { MyappStack } from &amp;#39;../lib/myapp-stack&amp;#39; const app = new cdk.App() new MyappStack(app, &amp;#39;MyappStack&amp;#39;, { tags: { Owner: &amp;#39;TeamA&amp;#39;, Purpose: &amp;#39;Project1&amp;#39;, }, }) AWS リソース用のコンストラクトの props パラメーターで、tags プロパティを指定することで、そのリソースにタグを設定できます。
タグの設定方法は、どの AWS リソース用のコンストラクトでも同様です。 上記のように Stack コンストラクトに対してタグを設定すると、その中に配置した AWS リソースにもそのタグが設定されます。
S3 バケットや DynamoDB テーブルをスタック削除時に自動削除する バケットが空のときだけ自動削除する import * as cdk from &amp;#39;@aws-cdk/core&amp;#39; import * as s3 from &amp;#39;@aws-cdk/aws-s3&amp;#39; new s3.Bucket(this, &amp;#39;MyBucket&amp;#39;, { removalPolicy: cdk.</description></item><item><title>AWS CDK のサンプルコード集（TypeScript 版）</title><link>https://maku.blog/p/gzkzbny/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gzkzbny/</guid><description>AWS CDK を使った TypeScript サンプルコードいろいろです。
リソースにタグを付ける import * as cdk from &amp;#39;@aws-cdk/core&amp;#39; import { MyappStack } from &amp;#39;../lib/myapp-stack&amp;#39; const app = new cdk.App() new MyappStack(app, &amp;#39;MyappStack&amp;#39;, { tags: { Owner: &amp;#39;TeamA&amp;#39;, Purpose: &amp;#39;Project1&amp;#39;, }, }) AWS リソース用のコンストラクトの props パラメーターで、tags プロパティを指定することで、そのリソースにタグを設定できます。
タグの設定方法は、どの AWS リソース用のコンストラクトでも同様です。 上記のように Stack コンストラクトに対してタグを設定すると、その中に配置した AWS リソースにもそのタグが設定されます。
S3 バケットや DynamoDB テーブルをスタック削除時に自動削除する バケットが空のときだけ自動削除する import * as cdk from &amp;#39;@aws-cdk/core&amp;#39; import * as s3 from &amp;#39;@aws-cdk/aws-s3&amp;#39; new s3.Bucket(this, &amp;#39;MyBucket&amp;#39;, { removalPolicy: cdk.</description></item><item><title>AWS CDK で API Gateway に Cognito 認証によるアクセス制御を追加する</title><link>https://maku.blog/p/vujw9jv/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vujw9jv/</guid><description>何をするか？ ここでは、API Gateway で提供している REST API にアクセス制御を追加するため、既存の Cognito ユーザープールによるオーソライザーを API Gateway に設定してみます。 これにより、Cognito のユーザープールで認証済みのユーザーのみが REST API を呼び出せるようになります。
後述の CDK コードでは、API Gateway と Lambda 関数、オーソライザーを生成していますが、Cognito ユーザープールは既存のものを ARN で参照しています（こういったユースケースは多いと思います）。
なお、CDK による API Gateway の作成方法（Lambda プロキシ統合）については下記の記事を参考にしてください。 ここでは、Cognito ユーザープールによるオーソライザーの作成方法にフォーカスします。
AWS CDK で API Gateway の REST API を作成する Lambda 関数を作成する REST API のバックエンドである Lambda 関数は最低限の実装で用意します。 ユーザー認証後に、API Gateway 経由で正しくこのハンドラを呼び出せるかの確認用です。
lambda/info.ts import { APIGatewayProxyHandler } from &amp;#34;aws-lambda&amp;#34; /** GET /info */ export const handler: APIGatewayProxyHandler = async (event) =&amp;gt; { console.</description></item><item><title>AWS CDK で API Gateway に Cognito 認証によるアクセス制御を追加する</title><link>https://maku.blog/p/vujw9jv/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vujw9jv/</guid><description>何をするか？ ここでは、API Gateway で提供している REST API にアクセス制御を追加するため、既存の Cognito ユーザープールによるオーソライザーを API Gateway に設定してみます。 これにより、Cognito のユーザープールで認証済みのユーザーのみが REST API を呼び出せるようになります。
後述の CDK コードでは、API Gateway と Lambda 関数、オーソライザーを生成していますが、Cognito ユーザープールは既存のものを ARN で参照しています（こういったユースケースは多いと思います）。
なお、CDK による API Gateway の作成方法（Lambda プロキシ統合）については下記の記事を参考にしてください。 ここでは、Cognito ユーザープールによるオーソライザーの作成方法にフォーカスします。
AWS CDK で API Gateway の REST API を作成する Lambda 関数を作成する REST API のバックエンドである Lambda 関数は最低限の実装で用意します。 ユーザー認証後に、API Gateway 経由で正しくこのハンドラを呼び出せるかの確認用です。
lambda/info.ts import { APIGatewayProxyHandler } from &amp;#34;aws-lambda&amp;#34; /** GET /info */ export const handler: APIGatewayProxyHandler = async (event) =&amp;gt; { console.</description></item><item><title>AWS CDK で API Gateway に Cognito 認証によるアクセス制御を追加する</title><link>https://maku.blog/p/vujw9jv/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vujw9jv/</guid><description>何をするか？ ここでは、API Gateway で提供している REST API にアクセス制御を追加するため、既存の Cognito ユーザープールによるオーソライザーを API Gateway に設定してみます。 これにより、Cognito のユーザープールで認証済みのユーザーのみが REST API を呼び出せるようになります。
後述の CDK コードでは、API Gateway と Lambda 関数、オーソライザーを生成していますが、Cognito ユーザープールは既存のものを ARN で参照しています（こういったユースケースは多いと思います）。
なお、CDK による API Gateway の作成方法（Lambda プロキシ統合）については下記の記事を参考にしてください。 ここでは、Cognito ユーザープールによるオーソライザーの作成方法にフォーカスします。
AWS CDK で API Gateway の REST API を作成する Lambda 関数を作成する REST API のバックエンドである Lambda 関数は最低限の実装で用意します。 ユーザー認証後に、API Gateway 経由で正しくこのハンドラを呼び出せるかの確認用です。
lambda/info.ts import { APIGatewayProxyHandler } from &amp;#34;aws-lambda&amp;#34; /** GET /info */ export const handler: APIGatewayProxyHandler = async (event) =&amp;gt; { console.</description></item><item><title>AWS CDK で API Gateway に Cognito 認証によるアクセス制御を追加する</title><link>https://maku.blog/p/vujw9jv/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vujw9jv/</guid><description>何をするか？ ここでは、API Gateway で提供している REST API にアクセス制御を追加するため、既存の Cognito ユーザープールによるオーソライザーを API Gateway に設定してみます。 これにより、Cognito のユーザープールで認証済みのユーザーのみが REST API を呼び出せるようになります。
後述の CDK コードでは、API Gateway と Lambda 関数、オーソライザーを生成していますが、Cognito ユーザープールは既存のものを ARN で参照しています（こういったユースケースは多いと思います）。
なお、CDK による API Gateway の作成方法（Lambda プロキシ統合）については下記の記事を参考にしてください。 ここでは、Cognito ユーザープールによるオーソライザーの作成方法にフォーカスします。
AWS CDK で API Gateway の REST API を作成する Lambda 関数を作成する REST API のバックエンドである Lambda 関数は最低限の実装で用意します。 ユーザー認証後に、API Gateway 経由で正しくこのハンドラを呼び出せるかの確認用です。
lambda/info.ts import { APIGatewayProxyHandler } from &amp;#34;aws-lambda&amp;#34; /** GET /info */ export const handler: APIGatewayProxyHandler = async (event) =&amp;gt; { console.</description></item><item><title>AWS CDK で API Gateway の REST API を作成する</title><link>https://maku.blog/p/k7eoer5/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k7eoer5/</guid><description>概要 API Gateway は HTTPS で Lambda 関数を呼び出す API Gateway で REST API のエンドポイントを定義すると、HTTPS リクエストで Lambda 関数を呼び出せるようになります。
クライアント ─(HTTPS)─&amp;gt; API Gateway ─(AWS API)─&amp;gt; Lambda 関数 API Gateway には Cognito のユーザープールと連携する機能を備えており、認証済みのユーザーにのみ API 呼び出しを許可するといったことが可能です（具体的に言うと、API Gateway が見えないところで ID トークンの正当性を確認してくれたりします）。
☝️ 新しい Lambda 関数 URL 2022 年 4 月に公開された Lambda 関数 URL の仕組みを使うと、直接 Lambda 関数にエンドポイント URL を割り当てて呼び出すことができます。 Cognito 連携などを使わないシンプルな Web API であれば、Lambda 関数 URL の仕組みで作ってしまうのが手っ取り早いかもしれません。 Lambda プロキシ統合 Lambda 関数は様々な AWS サービスからのイベント通知によって起動する仕組みになっており、API Gateway からの HTTPS リクエストもそのうちのひとつです。 Lambda 関数のハンドラが呼び出されるとき、そのパラメーターとして「イベントオブジェクト」を受け取ることができるのですが、このイベントオブジェクトの中身は発生源によって異なります。</description></item><item><title>AWS CDK で API Gateway の REST API を作成する</title><link>https://maku.blog/p/k7eoer5/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k7eoer5/</guid><description>概要 API Gateway は HTTPS で Lambda 関数を呼び出す API Gateway で REST API のエンドポイントを定義すると、HTTPS リクエストで Lambda 関数を呼び出せるようになります。
クライアント ─(HTTPS)─&amp;gt; API Gateway ─(AWS API)─&amp;gt; Lambda 関数 API Gateway には Cognito のユーザープールと連携する機能を備えており、認証済みのユーザーにのみ API 呼び出しを許可するといったことが可能です（具体的に言うと、API Gateway が見えないところで ID トークンの正当性を確認してくれたりします）。
☝️ 新しい Lambda 関数 URL 2022 年 4 月に公開された Lambda 関数 URL の仕組みを使うと、直接 Lambda 関数にエンドポイント URL を割り当てて呼び出すことができます。 Cognito 連携などを使わないシンプルな Web API であれば、Lambda 関数 URL の仕組みで作ってしまうのが手っ取り早いかもしれません。 Lambda プロキシ統合 Lambda 関数は様々な AWS サービスからのイベント通知によって起動する仕組みになっており、API Gateway からの HTTPS リクエストもそのうちのひとつです。 Lambda 関数のハンドラが呼び出されるとき、そのパラメーターとして「イベントオブジェクト」を受け取ることができるのですが、このイベントオブジェクトの中身は発生源によって異なります。</description></item><item><title>AWS CDK で API Gateway の REST API を作成する</title><link>https://maku.blog/p/k7eoer5/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k7eoer5/</guid><description>概要 API Gateway は HTTPS で Lambda 関数を呼び出す API Gateway で REST API のエンドポイントを定義すると、HTTPS リクエストで Lambda 関数を呼び出せるようになります。
クライアント ─(HTTPS)─&amp;gt; API Gateway ─(AWS API)─&amp;gt; Lambda 関数 API Gateway には Cognito のユーザープールと連携する機能を備えており、認証済みのユーザーにのみ API 呼び出しを許可するといったことが可能です（具体的に言うと、API Gateway が見えないところで ID トークンの正当性を確認してくれたりします）。
☝️ 新しい Lambda 関数 URL 2022 年 4 月に公開された Lambda 関数 URL の仕組みを使うと、直接 Lambda 関数にエンドポイント URL を割り当てて呼び出すことができます。 Cognito 連携などを使わないシンプルな Web API であれば、Lambda 関数 URL の仕組みで作ってしまうのが手っ取り早いかもしれません。 Lambda プロキシ統合 Lambda 関数は様々な AWS サービスからのイベント通知によって起動する仕組みになっており、API Gateway からの HTTPS リクエストもそのうちのひとつです。 Lambda 関数のハンドラが呼び出されるとき、そのパラメーターとして「イベントオブジェクト」を受け取ることができるのですが、このイベントオブジェクトの中身は発生源によって異なります。</description></item><item><title>Go 言語で AWS CDK V2 を使う (1) 導入編</title><link>https://maku.blog/p/54s6es8/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/54s6es8/</guid><description>何をするか？ CDK プロジェクトでは多くのケースでは TypeScript を使ってコード記述されていると思いますが、Go 言語の勢いが出てきていることもあり、ここでは Go 言語を使った CDK プロジェクトを作成してみます。
CDK 自体の概要については下記に簡単にまとまっています。
参考: AWS CDK 入門 (1) インストールから Hello World まで 以下、Go 言語のインストールや、AWS の認証情報の設定 (~/.aws/credentials, ~/.aws/config) はできているものとします。
参考: Go 言語で AWS SDK を使う開発環境を整える AWS CDK のインストール Go 言語で CDK のコードを記述する場合でも、AWS CDK のコマンドラインツール (cdk) 自体は、Node.js の NPM パッケージで提供されているものを使います。
$ npm install -g aws-cdk ... $ cdk --version 2.20.0 (build 738ef49) CDK プロジェクトを作成する (cdk init) CDK の Scaffold 機能を使って、Go 言語用の CDK プロジェクトを生成します。</description></item><item><title>Go 言語で AWS CDK V2 を使う (1) 導入編</title><link>https://maku.blog/p/54s6es8/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/54s6es8/</guid><description>何をするか？ CDK プロジェクトでは多くのケースでは TypeScript を使ってコード記述されていると思いますが、Go 言語の勢いが出てきていることもあり、ここでは Go 言語を使った CDK プロジェクトを作成してみます。
CDK 自体の概要については下記に簡単にまとまっています。
参考: AWS CDK 入門 (1) インストールから Hello World まで 以下、Go 言語のインストールや、AWS の認証情報の設定 (~/.aws/credentials, ~/.aws/config) はできているものとします。
参考: Go 言語で AWS SDK を使う開発環境を整える AWS CDK のインストール Go 言語で CDK のコードを記述する場合でも、AWS CDK のコマンドラインツール (cdk) 自体は、Node.js の NPM パッケージで提供されているものを使います。
$ npm install -g aws-cdk ... $ cdk --version 2.20.0 (build 738ef49) CDK プロジェクトを作成する (cdk init) CDK の Scaffold 機能を使って、Go 言語用の CDK プロジェクトを生成します。</description></item><item><title>Amazon API Gateway をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/qwb6v89/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwb6v89/</guid><description>AWS CLI（コマンドラインkツール）で Amazon API Gateway を操作するには、aws apigatewayv2 コマンドを使用します。 API Gateway の作成や更新を行うためには、IAM ユーザーに適切な権限が必要ですが、AmazonAPIGatewayAdministrator 管理ポリシーを付けるとほとんどの操作が可能になります。 通常、REST API を作成する場合は、バックエンドの Lambda 関数も合わせて必要になるので、AWSLambdaFullAccess などの管理ポリシーも必要になります。
REST API を作成する (apigateway create-rest-api) リファレンス: apigateway create-rest-api
$ aws apigateway create-rest-api --name &amp;#34;My First API&amp;#34; \ --description &amp;#34;This is my first API&amp;#34; \ --region ap-northeast-1 apiKeySource: HEADER createdDate: &amp;#39;2022-04-18T15:46:00+09:00&amp;#39; description: This is my first API disableExecuteApiEndpoint: false endpointConfiguration: types: - EDGE id: mk6mj65po6 name: My First API --name オプションのみが必須です。 API の作成に成功すると、上記のように ID (mk6mj65po6) が返されます。</description></item><item><title>Amazon API Gateway をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/qwb6v89/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwb6v89/</guid><description>AWS CLI（コマンドラインkツール）で Amazon API Gateway を操作するには、aws apigatewayv2 コマンドを使用します。 API Gateway の作成や更新を行うためには、IAM ユーザーに適切な権限が必要ですが、AmazonAPIGatewayAdministrator 管理ポリシーを付けるとほとんどの操作が可能になります。 通常、REST API を作成する場合は、バックエンドの Lambda 関数も合わせて必要になるので、AWSLambdaFullAccess などの管理ポリシーも必要になります。
REST API を作成する (apigateway create-rest-api) リファレンス: apigateway create-rest-api
$ aws apigateway create-rest-api --name &amp;#34;My First API&amp;#34; \ --description &amp;#34;This is my first API&amp;#34; \ --region ap-northeast-1 apiKeySource: HEADER createdDate: &amp;#39;2022-04-18T15:46:00+09:00&amp;#39; description: This is my first API disableExecuteApiEndpoint: false endpointConfiguration: types: - EDGE id: mk6mj65po6 name: My First API --name オプションのみが必須です。 API の作成に成功すると、上記のように ID (mk6mj65po6) が返されます。</description></item><item><title>Amazon API Gateway をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/qwb6v89/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwb6v89/</guid><description>AWS CLI（コマンドラインkツール）で Amazon API Gateway を操作するには、aws apigatewayv2 コマンドを使用します。 API Gateway の作成や更新を行うためには、IAM ユーザーに適切な権限が必要ですが、AmazonAPIGatewayAdministrator 管理ポリシーを付けるとほとんどの操作が可能になります。 通常、REST API を作成する場合は、バックエンドの Lambda 関数も合わせて必要になるので、AWSLambdaFullAccess などの管理ポリシーも必要になります。
REST API を作成する (apigateway create-rest-api) リファレンス: apigateway create-rest-api
$ aws apigateway create-rest-api --name &amp;#34;My First API&amp;#34; \ --description &amp;#34;This is my first API&amp;#34; \ --region ap-northeast-1 apiKeySource: HEADER createdDate: &amp;#39;2022-04-18T15:46:00+09:00&amp;#39; description: This is my first API disableExecuteApiEndpoint: false endpointConfiguration: types: - EDGE id: mk6mj65po6 name: My First API --name オプションのみが必須です。 API の作成に成功すると、上記のように ID (mk6mj65po6) が返されます。</description></item><item><title>Go 言語で AWS SDK を使う開発環境を整える</title><link>https://maku.blog/p/xnogqgm/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xnogqgm/</guid><description>何をするか？ ここでは、Go 言語用の AWS SDK V2 をセットアップして、各種 AWS サービス用の API を呼び出す準備をします。
Go 言語は Google が開発したプログラミング言語で、ライブラリインポートの手軽さや、生成された実行バイナリの実行速度に定評があるため、今後も利用ユーザーは増えていきそうです。
参考: Go 言語とは？／Go をインストールする | まくまくHugo/Goノート Go の実行環境は Go のインストーラー で簡単にインストールできます。 これ以降の説明では、Go の実行環境はインストール済みであると想定しています。
テスト用の Go プロジェクトを作成する Go プロジェクト用に適当なディレクトリを作成し、その中で go mod init コマンドを実行して go.mod （依存関係などが保存されるファイル）を作成しておきます。 このファイルが存在するディレクトリを、Go はモジュールとして認識します。
$ mkdir aws-study $ cd aws-study $ go mod init aws-study 上記の例では、go mod init の引数（モジュールパス）を aws-study としましたが、GitHub リポジトリで管理する前提であれば、github.com/&amp;lt;user&amp;gt;/aws-study のようなモジュールパスを指定するようにしてください。 これで、Go 言語プロジェクトの準備完了です。
AWS SDK でコンフィグ情報を参照してみる AWS SDK を使って AWS のサービスにアクセスするには、認証情報として IAM ユーザーの「アクセスキー ID」や「シークレットアクセスキー」などが必要になります。 これらは、一般的には AWS CLI の aws configure コマンドによって、~/.</description></item><item><title>Go 言語と AWS SDK V2 で Amazon Cognito を操作する</title><link>https://maku.blog/p/nej9wjb/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nej9wjb/</guid><description>ここでは、AWS SDK for Go V2 を使って、Go 言語から Amazon Cognito を操作するサンプルコードを示します。 Go 言語で AWS SDK を使うための開発環境 は構築済みとします。
指定したユーザープール内のユーザーリストを取得する (ListUsers) list_users.go package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/aws&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/config&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider&amp;#34; ) var userPoolId = &amp;#34;ap-northeast-1_XXXXXXXXX&amp;#34; // ユーザープールの ID func main() { listUsers() } func listUsers() { client := cognitoidentityprovider.NewFromConfig(loadAwsConfig()) input := &amp;amp;cognitoidentityprovider.ListUsersInput { UserPoolId: &amp;amp;userPoolId, } output, err := client.ListUsers(context.TODO(), input) if err != nil { panic(err) } for _, user := range output.</description></item><item><title>Go 言語と AWS SDK V2 で Amazon Cognito を操作する</title><link>https://maku.blog/p/nej9wjb/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nej9wjb/</guid><description>ここでは、AWS SDK for Go V2 を使って、Go 言語から Amazon Cognito を操作するサンプルコードを示します。 Go 言語で AWS SDK を使うための開発環境 は構築済みとします。
指定したユーザープール内のユーザーリストを取得する (ListUsers) list_users.go package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/aws&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/config&amp;#34; &amp;#34;github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider&amp;#34; ) var userPoolId = &amp;#34;ap-northeast-1_XXXXXXXXX&amp;#34; // ユーザープールの ID func main() { listUsers() } func listUsers() { client := cognitoidentityprovider.NewFromConfig(loadAwsConfig()) input := &amp;amp;cognitoidentityprovider.ListUsersInput { UserPoolId: &amp;amp;userPoolId, } output, err := client.ListUsers(context.TODO(), input) if err != nil { panic(err) } for _, user := range output.</description></item><item><title>DynamoDB を Python で操作する (boto3)</title><link>https://maku.blog/p/wht5epz/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wht5epz/</guid><description>（AWS SDK を使うときは、aws configure によるアクセスキーの設定は完了しているものと想定します）
Boto3 のインストール Python 用の AWS SDK として Boto3 が用意されているので、これをインストールして使います。 PC のグローバル環境を汚さないように、venv による仮想環境を作って作業する ことをオススメします。
まず、仮想環境を作ってそこに入ります。
$ mkdir myapp &amp;amp;&amp;amp; cd myapp # アプリ用のディレクトリを作成 $ python3 -m venv .venv # 仮想環境の作成 $ source .venv/bin/activate # 仮想環境に入る 仮想環境 (.venv) 内に boto3 パッケージをインストールします。
(.venv) $ python3 -m pip install boto3 これで準備完了です。簡単！
高レベル API と低レベル API Boto3 の API は、抽象度の高い API と、低い API の二種類が用意されています。
高レベル API（リソース API） 各 AWS リソースを、オブジェクト指向なコードで扱うことができる。boto3.</description></item><item><title>DynamoDB を Python で操作する (boto3)</title><link>https://maku.blog/p/wht5epz/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wht5epz/</guid><description>（AWS SDK を使うときは、aws configure によるアクセスキーの設定は完了しているものと想定します）
Boto3 のインストール Python 用の AWS SDK として Boto3 が用意されているので、これをインストールして使います。 PC のグローバル環境を汚さないように、venv による仮想環境を作って作業する ことをオススメします。
まず、仮想環境を作ってそこに入ります。
$ mkdir myapp &amp;amp;&amp;amp; cd myapp # アプリ用のディレクトリを作成 $ python3 -m venv .venv # 仮想環境の作成 $ source .venv/bin/activate # 仮想環境に入る 仮想環境 (.venv) 内に boto3 パッケージをインストールします。
(.venv) $ python3 -m pip install boto3 これで準備完了です。簡単！
高レベル API と低レベル API Boto3 の API は、抽象度の高い API と、低い API の二種類が用意されています。
高レベル API（リソース API） 各 AWS リソースを、オブジェクト指向なコードで扱うことができる。boto3.</description></item><item><title>AWS SSM のポリシーステートメント例</title><link>https://maku.blog/p/s3o57jv/</link><pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s3o57jv/</guid><description>パラメーターの説明情報の取得 すべてのパラメーターの説明情報を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:DescribeParameters&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } ssm:DescribeParameters は、SSM パラメーターストアに格納されたパラメーターの説明情報を取得する権限です。 この権限だけでは、パラメーターの「値」自体は取得できないことに注意してください。
パラメーターの値の取得 prod- で始まるパラメーターの値を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:GetParameter*&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; } ] } パラメーターの Get 系アクションには、GetParameter/GetParameters/GetParameterHistory/GetParametersByPath など いろいろある ため、上記のように ssm:GetParameter* とワイルドカード指定しておくと確実に取得できるようになります。 GetParameter だけだと、パラメーターの一覧取得などが許可されません。
パラメーターの追加・削除 prod- で始まるパラメーターの追加と削除を許可する { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:PutParameter&amp;#34;, &amp;#34;ssm:DeleteParameter&amp;#34;, &amp;#34;ssm:DeleteParameters&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; } ] } 暗号化されたパラメーター (SecureString) の取得 暗号化された prod- で始まるパラメーターを読み込む { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:GetParameter*&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; ] }, { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;kms:Decrypt&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:kms:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:key/&amp;lt;KmsKey&amp;gt;&amp;#34; ] } ] } SSM パラメーターストアに SecureString タイプとして格納されたパラメーターは、KMS キーによって暗号化されています。 このパラメーターの値を取得するには、ssm:GetParameter* によるパラメーター読み取り権限と、kms:Decrypt による複合化の権限が必要です。</description></item><item><title>AWS SSM のポリシーステートメント例</title><link>https://maku.blog/p/s3o57jv/</link><pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s3o57jv/</guid><description>パラメーターの説明情報の取得 すべてのパラメーターの説明情報を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:DescribeParameters&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } ssm:DescribeParameters は、SSM パラメーターストアに格納されたパラメーターの説明情報を取得する権限です。 この権限だけでは、パラメーターの「値」自体は取得できないことに注意してください。
パラメーターの値の取得 prod- で始まるパラメーターの値を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:GetParameter*&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; } ] } パラメーターの Get 系アクションには、GetParameter/GetParameters/GetParameterHistory/GetParametersByPath など いろいろある ため、上記のように ssm:GetParameter* とワイルドカード指定しておくと確実に取得できるようになります。 GetParameter だけだと、パラメーターの一覧取得などが許可されません。
パラメーターの追加・削除 prod- で始まるパラメーターの追加と削除を許可する { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:PutParameter&amp;#34;, &amp;#34;ssm:DeleteParameter&amp;#34;, &amp;#34;ssm:DeleteParameters&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; } ] } 暗号化されたパラメーター (SecureString) の取得 暗号化された prod- で始まるパラメーターを読み込む { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;ssm:GetParameter*&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:ssm:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:parameter/prod-*&amp;#34; ] }, { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;kms:Decrypt&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:kms:&amp;lt;Region&amp;gt;:&amp;lt;Account&amp;gt;:key/&amp;lt;KmsKey&amp;gt;&amp;#34; ] } ] } SSM パラメーターストアに SecureString タイプとして格納されたパラメーターは、KMS キーによって暗号化されています。 このパラメーターの値を取得するには、ssm:GetParameter* によるパラメーター読み取り権限と、kms:Decrypt による複合化の権限が必要です。</description></item><item><title>AWS KMS をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/m8jv7hr/</link><pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m8jv7hr/</guid><description>SSM パラメーターストア用の AWS マネージドキーを確認する $ aws kms describe-key --key-id alias/aws/ssm 実行結果 KeyMetadata: AWSAccountId: &amp;#39;123456789012&amp;#39; Arn: arn:aws:kms:ap-northeast-1:123456789012:key/d7ce1afa-a7d4-fe43-2da2-4ddd769480d7 CreationDate: &amp;#39;2021-10-14T03:34:31.467000+09:00&amp;#39; CustomerMasterKeySpec: SYMMETRIC_DEFAULT Description: Default key that protects my SSM parameters when no other key is defined Enabled: true EncryptionAlgorithms: - SYMMETRIC_DEFAULT KeyId: d7ce1afa-a7d4-fe43-2da2-4ddd769480d7 KeyManager: AWS KeyState: Enabled KeyUsage: ENCRYPT_DECRYPT Origin: AWS_KMS KMS キーを作成する (kms create-key) aws kms create-key KMS キー (CMK: Customer Master Key) は作成は一瞬でできますが、削除は最低 7 日かかるので注意してください。</description></item><item><title>AWS KMS をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/m8jv7hr/</link><pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m8jv7hr/</guid><description>SSM パラメーターストア用の AWS マネージドキーを確認する $ aws kms describe-key --key-id alias/aws/ssm 実行結果 KeyMetadata: AWSAccountId: &amp;#39;123456789012&amp;#39; Arn: arn:aws:kms:ap-northeast-1:123456789012:key/d7ce1afa-a7d4-fe43-2da2-4ddd769480d7 CreationDate: &amp;#39;2021-10-14T03:34:31.467000+09:00&amp;#39; CustomerMasterKeySpec: SYMMETRIC_DEFAULT Description: Default key that protects my SSM parameters when no other key is defined Enabled: true EncryptionAlgorithms: - SYMMETRIC_DEFAULT KeyId: d7ce1afa-a7d4-fe43-2da2-4ddd769480d7 KeyManager: AWS KeyState: Enabled KeyUsage: ENCRYPT_DECRYPT Origin: AWS_KMS KMS キーを作成する (kms create-key) aws kms create-key KMS キー (CMK: Customer Master Key) は作成は一瞬でできますが、削除は最低 7 日かかるので注意してください。</description></item><item><title>AWS SSM をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/aug76s5/</link><pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aug76s5/</guid><description>パラメーターストアにパラメーターを格納する (ssm put-parameter) String（文字列） /myapp/param1 という名前のパラメーターとして value1 を格納 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;value1&amp;#34; --type String \ --tags &amp;#34;Key=key1,Value=value1&amp;#34; 既存のパラメーターの値を更新する場合は、--overwrite オプションが必要です（Version 情報がインクリメントされます）。
/myapp/param1 の値を value2 に書き換え $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;value2&amp;#34; --type String --overwrite Tier: Standard Version: 2 SecureString（暗号化された文字列） デフォルトの AWS マネージドキーを使って暗号化 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;secret_value&amp;#34; --type SecureString デフォルトのキーは、アカウントで共通のものになります。
作成した KMS キーを使って暗号化 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;secret_value&amp;#34; --type SecureString \ --key-id &amp;#34;&amp;lt;KeyId&amp;gt;&amp;#34; \ KeyId は次のいずれかの形式で指定できます。</description></item><item><title>AWS SSM をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/aug76s5/</link><pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aug76s5/</guid><description>パラメーターストアにパラメーターを格納する (ssm put-parameter) String（文字列） /myapp/param1 という名前のパラメーターとして value1 を格納 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;value1&amp;#34; --type String \ --tags &amp;#34;Key=key1,Value=value1&amp;#34; 既存のパラメーターの値を更新する場合は、--overwrite オプションが必要です（Version 情報がインクリメントされます）。
/myapp/param1 の値を value2 に書き換え $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;value2&amp;#34; --type String --overwrite Tier: Standard Version: 2 SecureString（暗号化された文字列） デフォルトの AWS マネージドキーを使って暗号化 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;secret_value&amp;#34; --type SecureString デフォルトのキーは、アカウントで共通のものになります。
作成した KMS キーを使って暗号化 $ aws ssm put-parameter --name /myapp/param1 \ --value &amp;#34;secret_value&amp;#34; --type SecureString \ --key-id &amp;#34;&amp;lt;KeyId&amp;gt;&amp;#34; \ KeyId は次のいずれかの形式で指定できます。</description></item><item><title>AWS CDK で外部パラメーターを扱う（コンテキスト・バリューと環境変数）</title><link>https://maku.blog/p/vx5ta85/</link><pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vx5ta85/</guid><description>CDK コードに外部パラメーターを与える方法 AWS CDK による CloudFormation スタックの構築時に、外部からキー＆バリューの形でパラメーターを設定したいときは、主に次の 3 つの方法があります（クラウド上に値を保存するパラメーターストアなどは対象外とします）。
Context values （コンテキスト・バリュー） Environment variables （環境変数） CloudFormation parameters （CloudFormation パラメーター） S3 バケットの名前をパラメーター化したり、デプロイターゲットを staging と production の間で切り替えたりするときに使えます。
Context values（コンテキスト・バリュー） コンテキスト・バリューは、CDK 特有の仕組みで、cdk deploy 実行時のコマンドライン引数や、cdk.json ファイルの中で、キー＆バリューのペアを設定することができます。 キーの型は string で、バリューの型は JSON がサポートするデータ型のいずれかです（string、number、オブジェクト、およびそれらの配列）。 コンテキスト・バリューは CDK の仕組みなので、CDK コードの中からしか参照できません。 Lambda 関数の中から値を参照したい場合は、Lambda 関数のコンストラクトを生成するときに、environment props などで間接的に渡す必要があります。
コマンドライン引数で指定する方法 cdk deploy コマンド（あるいは diff、synth）を実行するときに、--context (-c) オプションで、コンテキスト・バリューを設定できます。
$ cdk deploy --context key=value 複数のキー＆バリューペアを設定したいときは、単純にオプション指定を繰り返します。
$ cdk deploy -c key1=value1 -c key2=value2 コンテキスト・バリューは CDK アプリ内の全スタックに渡されますが、特定のスタックにのみ反映させることもできます。</description></item><item><title>AWS CDK で外部パラメーターを扱う（コンテキスト・バリューと環境変数）</title><link>https://maku.blog/p/vx5ta85/</link><pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vx5ta85/</guid><description>CDK コードに外部パラメーターを与える方法 AWS CDK による CloudFormation スタックの構築時に、外部からキー＆バリューの形でパラメーターを設定したいときは、主に次の 3 つの方法があります（クラウド上に値を保存するパラメーターストアなどは対象外とします）。
Context values （コンテキスト・バリュー） Environment variables （環境変数） CloudFormation parameters （CloudFormation パラメーター） S3 バケットの名前をパラメーター化したり、デプロイターゲットを staging と production の間で切り替えたりするときに使えます。
Context values（コンテキスト・バリュー） コンテキスト・バリューは、CDK 特有の仕組みで、cdk deploy 実行時のコマンドライン引数や、cdk.json ファイルの中で、キー＆バリューのペアを設定することができます。 キーの型は string で、バリューの型は JSON がサポートするデータ型のいずれかです（string、number、オブジェクト、およびそれらの配列）。 コンテキスト・バリューは CDK の仕組みなので、CDK コードの中からしか参照できません。 Lambda 関数の中から値を参照したい場合は、Lambda 関数のコンストラクトを生成するときに、environment props などで間接的に渡す必要があります。
コマンドライン引数で指定する方法 cdk deploy コマンド（あるいは diff、synth）を実行するときに、--context (-c) オプションで、コンテキスト・バリューを設定できます。
$ cdk deploy --context key=value 複数のキー＆バリューペアを設定したいときは、単純にオプション指定を繰り返します。
$ cdk deploy -c key1=value1 -c key2=value2 コンテキスト・バリューは CDK アプリ内の全スタックに渡されますが、特定のスタックにのみ反映させることもできます。</description></item><item><title>AWS CDK メモ: Lambda 関数コードだけ高速デプロイする (cdk deploy --hotswap)</title><link>https://maku.blog/p/ap8p7n4/</link><pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ap8p7n4/</guid><description>AWS CDK によるデプロイ (cdk deploy) の実行には結構時間がかかりますが、Lambda 関数のコードだけ更新したいときは、hotswap オプションを付けて実行することで高速にデプロイできます。
Lambda 関数だけ高速更新 $ cdk deploy --hotswap ただし、これは開発時のみ使うべき機能として提供されており、Production 環境においては、通常通り CDK アプリ全体のデプロイを行うことが推奨されています。</description></item><item><title>AWS CDK メモ: Lambda 関数コードだけ高速デプロイする (cdk deploy --hotswap)</title><link>https://maku.blog/p/ap8p7n4/</link><pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ap8p7n4/</guid><description>AWS CDK によるデプロイ (cdk deploy) の実行には結構時間がかかりますが、Lambda 関数のコードだけ更新したいときは、hotswap オプションを付けて実行することで高速にデプロイできます。
Lambda 関数だけ高速更新 $ cdk deploy --hotswap ただし、これは開発時のみ使うべき機能として提供されており、Production 環境においては、通常通り CDK アプリ全体のデプロイを行うことが推奨されています。</description></item><item><title>DynamoDB 用のポリシー設定例</title><link>https://maku.blog/p/gk6jx9k/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gk6jx9k/</guid><description>あるテーブルに対するすべての操作を可能にする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;AllAPIActionsOnBooks&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: &amp;#34;dynamodb:*&amp;#34;, &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] } Action に dynamodb:* というワイルド―カードを指定することで、DynamoDB のすべての API を使った操作を可能にしています。 通常は、特定のアクションのみを許可すべきです。
あるテーブルの読み取りを行えるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;DescribeQueryScanBooksTable&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:Query&amp;#34;, &amp;#34;dynamodb:Scan&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] } このポリシーステートメントは、アカウント 123456789012 が所有する Books テーブルの読み取り（Query や Scan）が可能であることを示します。
下記は、もう少し可能な操作を増やしたバージョンです。
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;ReadOnlyAPIActionsOnBooks&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:GetItem&amp;#34;, &amp;#34;dynamodb:BatchGetItem&amp;#34;, &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:Query&amp;#34;, &amp;#34;dynamodb:Scan&amp;#34;, &amp;#34;dynamodb:ConditionCheckItem&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] }</description></item><item><title>DynamoDB 用のポリシー設定例</title><link>https://maku.blog/p/gk6jx9k/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gk6jx9k/</guid><description>あるテーブルに対するすべての操作を可能にする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;AllAPIActionsOnBooks&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: &amp;#34;dynamodb:*&amp;#34;, &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] } Action に dynamodb:* というワイルド―カードを指定することで、DynamoDB のすべての API を使った操作を可能にしています。 通常は、特定のアクションのみを許可すべきです。
あるテーブルの読み取りを行えるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;DescribeQueryScanBooksTable&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:Query&amp;#34;, &amp;#34;dynamodb:Scan&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] } このポリシーステートメントは、アカウント 123456789012 が所有する Books テーブルの読み取り（Query や Scan）が可能であることを示します。
下記は、もう少し可能な操作を増やしたバージョンです。
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;ReadOnlyAPIActionsOnBooks&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:GetItem&amp;#34;, &amp;#34;dynamodb:BatchGetItem&amp;#34;, &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:Query&amp;#34;, &amp;#34;dynamodb:Scan&amp;#34;, &amp;#34;dynamodb:ConditionCheckItem&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:dynamodb:us-west-2:123456789012:table/Books&amp;#34; } ] }</description></item><item><title>Amazon S3: 未整理・雑多メモ</title><link>https://maku.blog/p/8cygv9k/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8cygv9k/</guid><description> S3 のストレージクラスの例 汎用ストレージ &amp;hellip; S3 STANDARD アクセス頻度小 &amp;hellip; S3 STANDARD_IA 長期アーカイブ &amp;hellip; S3 Glacier S3 のバケットポリシーでは、プレフィックスとか拡張子などを指定してアクセスコントロールが可能。 S3 へのアクセスは ACL（アクセスコントロールリスト）でもコントロールできるが、古い仕組みなので非推奨。今は IAM を使う。 S3 のバージョニング設定を有効にすると、オブジェクトの複数バージョンを管理できるようになる。 S3 のバケット名は世界で一意になるように命名する。 3～63 文字で、大文字は使えない。 先頭文字は小文字の英数字。 _ 2文字目以降は、小文字の英数字、ハイフン、ドットのいずれかで構成する。ただし、ドットは通常は使わない方がよい（ドメインの区切り文字と混ざるので、HTTPS の証明書検証などに影響が出る）。</description></item><item><title>DynamoDB の未整理・雑多メモ</title><link>https://maku.blog/p/38bpqjp/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38bpqjp/</guid><description> DynamoDB のテーブルは リージョンごとに独立 して存在する。例えば、us-east-2 リージョンの People テーブルと、us-west-2 リージョンの People テーブルは別物として扱われる。 DyanmoDB のテーブル名、属性名は CamelCase にするのが公式っぽい（-、_、. といった記号も使える） プライマリキー DynamoDB の プライマリキーの型 は、文字列／数値／バイナリ、といったスカラ値のみが使える。 DynamoDB のプライマリキーは 1 つ or 2 つ 1 つの場合 &amp;hellip; パーティションキーのみ（一意な ID） 2 つの場合 &amp;hellip; パーティションキー + ソートキー（パーティションが同じであれば、同じ物理ストレージ内にソートキー値でソートされた形で項目が保持される） DynamoDB のテーブルは、プライマリキーとなる属性以外はスキーマレスなので、テーブル作成時はプライマリーキー属性のみ定義すればよい。それ以外の部分には入れ子構造のデータも自由に入れられる。 DynamoDB に項目を追加するときに バイナリ型属性 の値を渡すときは、Base64 エンコードして渡す必要がある。 RCU の消費 基本的にクエリ (Query) は合計サイズ 4KB ごとに 1RCU 消費する。 GetItem の場合は、1 件ごとに 1RCU 消費する。 100 件以上とか大量に PutItem するときは、BatchWrite の仕組みを使うとめっちゃ速くなる。複数の要求をバッファリングして通信回数を減らしてくれるぽい。具体的な使い方は、各 SDK の API ドキュメントを参照。</description></item><item><title>DynamoDB の未整理・雑多メモ</title><link>https://maku.blog/p/38bpqjp/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/38bpqjp/</guid><description> DynamoDB のテーブルは リージョンごとに独立 して存在する。例えば、us-east-2 リージョンの People テーブルと、us-west-2 リージョンの People テーブルは別物として扱われる。 DyanmoDB のテーブル名、属性名は CamelCase にするのが公式っぽい（-、_、. といった記号も使える） プライマリキー DynamoDB の プライマリキーの型 は、文字列／数値／バイナリ、といったスカラ値のみが使える。 DynamoDB のプライマリキーは 1 つ or 2 つ 1 つの場合 &amp;hellip; パーティションキーのみ（一意な ID） 2 つの場合 &amp;hellip; パーティションキー + ソートキー（パーティションが同じであれば、同じ物理ストレージ内にソートキー値でソートされた形で項目が保持される） DynamoDB のテーブルは、プライマリキーとなる属性以外はスキーマレスなので、テーブル作成時はプライマリーキー属性のみ定義すればよい。それ以外の部分には入れ子構造のデータも自由に入れられる。 DynamoDB に項目を追加するときに バイナリ型属性 の値を渡すときは、Base64 エンコードして渡す必要がある。 RCU の消費 基本的にクエリ (Query) は合計サイズ 4KB ごとに 1RCU 消費する。 GetItem の場合は、1 件ごとに 1RCU 消費する。 100 件以上とか大量に PutItem するときは、BatchWrite の仕組みを使うとめっちゃ速くなる。複数の要求をバッファリングして通信回数を減らしてくれるぽい。具体的な使い方は、各 SDK の API ドキュメントを参照。</description></item><item><title>AWS CLI でアクセスできるのに AWS SDK で Access Denied (403) になるとき</title><link>https://maku.blog/p/7tds7bw/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7tds7bw/</guid><description>認証情報の食い違いを調べる 例えば、ローカルで AWS CLI を使って S3 の情報にアクセスできているのに、AWS SDK 使った Node.js プログラムで S3 にアクセスしたときに Access Denied (403) になるときは、異なる認証情報 (credentials) を使ってアクセスしている可能性 があります。
AWS CLI が、どのようなユーザーでアクセスしているかは、下記のようにして確認できます。
$ aws sts get-caller-identity Account: &amp;#39;123456789012&amp;#39; Arn: arn:aws:sts::123456789012:assumed-role/MyDeveloperRole/botocore-session-9876543210 UserId: A6B3EVWX58AR9AVTXAP5T:botocore-session-9876543210 次に、Node.js のプログラムなどで、AWS SDK を使って上記と同様の情報を取得します。 Node.js 用の SDK ver.2 では、AWS.STS.getCallerIdentity()、SDK ver.3 では STSClient.send() を使います。
参考: AWS.STS.getCallerIdentity() - AWS SDK v2 参考: GetCallerIdentityCommand() - AWS SDK v3 printCallerIdentity.ts（SDK ver.2 の場合） import { STS } from &amp;#39;aws-sdk&amp;#39;; async function printCallerIdentity() { try { const sts = new STS(); const result = await sts.</description></item><item><title>Lambda 実装例: S3 へのアップロードを SNS で通知して Lambda から読み込む</title><link>https://maku.blog/p/f2fq2cn/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/f2fq2cn/</guid><description>何をするか？ ここでは Lambda 関数の実装例として、SNS トピックから S3 バケットの PutObject イベント通知を受けて、アップロードされたファイルを読み込む例を示します。 S3 バケット、および SNS トピックの作成と、S3 → SNS の通知設定は完了していると想定します。
参考リンク CloudFormation の設定例: S3 通知を SNS トピックに Publish する CloudFormation の設定例: SNS トピックを Lambda 関数からサブスクライブする Lambda 関数の実装 AWS SDK のインストール ここでは、Node.js 用の AWS SDK ver.2 を使っているので、先にインストールしておく必要があります。 AWS 側の Lambda 実行環境には標準でインストールされているので、--save-dev（開発用）でインストールしておけば OK です。 ついでに TypeScript 用の型定義もインストールしておくと、Lambda ハンドラのパラメータを any 型ではなく、SNSEvent 型などで参照できて便利です。
$ npm install aws-sdk --save-dev $ npm install @types/aws-lambda --save-dev Lambda ハンドラの実装 先に、S3 バケット内のオブジェクトの内容を取得するユーティリティ関数を用意しておきます（AWS SDK ver.</description></item><item><title>AWS SNS トピックから通知されるイベントデータの例</title><link>https://maku.blog/p/qcpybnx/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcpybnx/</guid><description>AWS SNS トピックからメッセージが発行されたときに、サブスクライバー（Lambda 関数など）にどのようなイベントデータが配信されるかの例です。
基本的なメッセージの構造 Lambda 関数で受け取る場合 SNS トピックに対して Lambda 関数をサブスクライブしておくと、Lambda 関数の第一引数 (event) で、次のようなオブジェクトを受信できます。 重要な情報は、Records[0].Sns の下に格納されています。
{ &amp;#34;Records&amp;#34;: [ { &amp;#34;EventSource&amp;#34;: &amp;#34;aws:sns&amp;#34;, &amp;#34;EventVersion&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;EventSubscriptionArn&amp;#34;: &amp;#34;arn:aws:sns:ap-northeast-1:123456789012:mytopic:0884-5d81c0db-4e13-829f-596f7ea9f8ad&amp;#34;, &amp;#34;Sns&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;Notification&amp;#34;, ... &amp;#34;Subject&amp;#34;: &amp;#34;Message Title&amp;#34;, &amp;#34;Message&amp;#34;: &amp;#34;Message Body&amp;#34;, ... } } ] } メールで受け取る場合 SNS トピックに「JSON 形式のメール」をサブスクライブしておくと、SNS のメッセージが発行されたときに、次のような内容のメールが届きます。
{ &amp;#34;Type&amp;#34;: &amp;#34;Notification&amp;#34;, ... &amp;#34;Subject&amp;#34;: &amp;#34;Message Title&amp;#34;, &amp;#34;Message&amp;#34;: &amp;#34;Message Body&amp;#34;, ... } Lambda 関数の第一引数で渡される event オブジェクトで表現すると、event.Records[0].Sns に相当する部分の情報がメールで送られてきます。
具体的な SNS メッセージの例 下記の例では、Records[0].Sns 以下の情報のみを示しています（JSON 形式のメールで送られる内容です）。</description></item><item><title>AWS CloudFormation の設定例: S3 通知を SNS トピックに Publish する</title><link>https://maku.blog/p/3o2dpyb/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3o2dpyb/</guid><description>何をするか？ ここでは、CloudFormation のテンプレートを使って、次のような AWS リソースを定義してみます。
S3 バケット（Logical ID: MyBucket) SNS トピック (Logical ID: MyTopic) 上記の S3 バケットへの書き込み時に、SNS トピックへ publish 動作のイメージとしてはこんな感じです。
このような構成でリソースを作っておくと、S3 バケット上のデータ更新を、SNS トピックのサブスクライブによって監視できるようになります。 例えば、Lambda 関数を SNS トピックのサブスクライバーとして登録すれば、S3 バケットへの書き込みを Lambda 関数でハンドルできます。
参考情報 CloudFormation テンプレートで S3 バケットや SNS トピックを定義する方法は、下記の記事を参考にしてください。
CloudFormation で S3 バケットの作成 CloudFormation で SNS トピックの作成 テンプレートの記述例 次の CloudFormation テンプレートでは、S3 バケットと SNS トピックのリソースを定義しています。 デフォルトの名前はそれぞれ次のようになっています。
S3 バケット名: myapp-sample-bucket-&amp;lt;AccountId&amp;gt; SNS トピック名: myapp-sample-topic S3 バケット名は世界で一意でなければいけないため、末尾に使用中のアカウント ID を付加するようにしています。</description></item><item><title>AWS CloudFormation の設定例: S3 通知を SNS トピックに Publish する</title><link>https://maku.blog/p/3o2dpyb/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3o2dpyb/</guid><description>何をするか？ ここでは、CloudFormation のテンプレートを使って、次のような AWS リソースを定義してみます。
S3 バケット（Logical ID: MyBucket) SNS トピック (Logical ID: MyTopic) 上記の S3 バケットへの書き込み時に、SNS トピックへ publish 動作のイメージとしてはこんな感じです。
このような構成でリソースを作っておくと、S3 バケット上のデータ更新を、SNS トピックのサブスクライブによって監視できるようになります。 例えば、Lambda 関数を SNS トピックのサブスクライバーとして登録すれば、S3 バケットへの書き込みを Lambda 関数でハンドルできます。
参考情報 CloudFormation テンプレートで S3 バケットや SNS トピックを定義する方法は、下記の記事を参考にしてください。
CloudFormation で S3 バケットの作成 CloudFormation で SNS トピックの作成 テンプレートの記述例 次の CloudFormation テンプレートでは、S3 バケットと SNS トピックのリソースを定義しています。 デフォルトの名前はそれぞれ次のようになっています。
S3 バケット名: myapp-sample-bucket-&amp;lt;AccountId&amp;gt; SNS トピック名: myapp-sample-topic S3 バケット名は世界で一意でなければいけないため、末尾に使用中のアカウント ID を付加するようにしています。</description></item><item><title>AWS SDK for Node.js でプロキシ環境変数 (https_proxy) を反映させる</title><link>https://maku.blog/p/6vs27aa/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6vs27aa/</guid><description>AWS SDK for Node.js のプロキシ設定 社内のプロキシ環境下などから AWS SDK (for Node.js) を使って API 呼び出しを行うには、次のようにプロキシエージェント設定を行います。 ここでは、AWS SDK version 2 の設定例を示しています。
プロキシ設定の例 (AWS SDK v2) import * as AWS from &amp;#39;aws-sdk&amp;#39;; import { HttpsProxyAgent } from &amp;#39;https-proxy-agent&amp;#39;; AWS.config.update({ httpOptions: { agent: new HttpsProxyAgent(&amp;#39;http://proxy.example.com:8080&amp;#39;) } }); これで、それ以降の AWS サービス (AWS.S3 など）の API 呼び出しがプロキシ経由で行われるようになります。
環境変数 https_proxy の設定を使用する 次のようにすれば、環境変数 https_proxy に設定されたプロキシアドレスを、AWS SDK にも反映させることができます（といっても、process.env.https_proxy を参照しているだけです）。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; import { HttpsProxyAgent } from &amp;#39;https-proxy-agent&amp;#39;; // プロキシ設定を反映 function setupAwsProxy() { const proxy = process.</description></item><item><title>AWS SDK for Node.js でプロキシ環境変数 (https_proxy) を反映させる</title><link>https://maku.blog/p/6vs27aa/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6vs27aa/</guid><description>AWS SDK for Node.js のプロキシ設定 社内のプロキシ環境下などから AWS SDK (for Node.js) を使って API 呼び出しを行うには、次のようにプロキシエージェント設定を行います。 ここでは、AWS SDK version 2 の設定例を示しています。
プロキシ設定の例 (AWS SDK v2) import * as AWS from &amp;#39;aws-sdk&amp;#39;; import { HttpsProxyAgent } from &amp;#39;https-proxy-agent&amp;#39;; AWS.config.update({ httpOptions: { agent: new HttpsProxyAgent(&amp;#39;http://proxy.example.com:8080&amp;#39;) } }); これで、それ以降の AWS サービス (AWS.S3 など）の API 呼び出しがプロキシ経由で行われるようになります。
環境変数 https_proxy の設定を使用する 次のようにすれば、環境変数 https_proxy に設定されたプロキシアドレスを、AWS SDK にも反映させることができます（といっても、process.env.https_proxy を参照しているだけです）。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; import { HttpsProxyAgent } from &amp;#39;https-proxy-agent&amp;#39;; // プロキシ設定を反映 function setupAwsProxy() { const proxy = process.</description></item><item><title>Amazon S3 バケット用のポリシー設定例</title><link>https://maku.blog/p/r9kv6gq/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r9kv6gq/</guid><description>S3 用のポリシー設定例 指定したバケット内のオブジェクト一覧を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:ListBucket&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;&amp;#34; ] } ] } 指定したバケット内のオブジェクトの内容を取得できるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:GetObject&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;/*&amp;#34; ] } ] } 指定したバケットに対していろいろできるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:DeleteObject&amp;#34;, &amp;#34;s3:GetObject&amp;#34;, &amp;#34;s3:ListBucket&amp;#34;, &amp;#34;s3:PutObject&amp;#34;, &amp;#34;s3:PutObjectAcl&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;&amp;#34;, &amp;#34;arn:aws:s3:::&amp;lt;バケット名&amp;gt;/*&amp;#34; ] } ] } すべての S3 リソースに対して何でもできるようにする { &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: &amp;#34;s3:*&amp;#34;, &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } S3 で静的 Web サイトをホストするときは、バケットポリシーで s3:GetObject アクションのみを指定すればよい。ListObject や PutObject アクセス許可しなくても OK。 （おまけ）CORS 設定（JSON 形式） Web サイトの JavaScript などから S3 バケットにアクセスする場合は、バケットの設定で CORS アクセスを有効にしておく必要があります。 設定は次のように JSON 形式で行います。</description></item><item><title>AWS Lambda にデプロイするための ZIP パッケージを npm で作成する (npm-pack-zip)</title><link>https://maku.blog/p/zmydq3f/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zmydq3f/</guid><description>何をするか？ AWS Lambda で実行する関数は、ZIP ファイルの形でデプロイすることになります。 ここでは、Node.js で関数を実装しているという前提で、npm スクリプトで簡単にデプロイ用の ZIP パッケージを作成する方法を説明します。
Lambda 関数用の ZIP パッケージを作成するときは、次のようなことを考慮する必要があります。
実行時に必要な node_modules 以下のモジュールを含める（逆に devDependencies で指定したモジュールは含めない。例えば typescript とか eslint とかは含めない） AWS SDK (aws-sdk) は含めない（Lambda の実行環境にインストールされている） TypeScript を使っているのであれば、ビルド後の .js ファイルのみを含める（例えば、src/*.ts は含めず、build/*.js を含める） ☝️ AWS Lambda レイヤー Lambda の「レイヤー」という機能を使うと、関数の実行に必要な node_modules を ZIP パッケージとは別に管理して、Lambda 関数から参照するということができます。 でも設定にひと手間かかります。AWS のこういうところは嫌いです。
ここでは、レイヤーの機能は使わずに、ZIP パッケージに全部入れちゃう方法を説明しています。
npm-pack-zip で ZIP ファイルを作成する npm-pack-zip とは ここでは、npm-pack-zip パッケージを使って、Lambda 関数のデプロイ用 ZIP パッケージを作ってみます。
npm-pack-zip - npm NPM には、もともと標準で npm pack というデプロイ用の NPM パッケージを作成する仕組みが搭載されています。 Lambda 用にもこれが使えると楽なのですが、残念ながら npm pack は .</description></item><item><title>AWS Lambda をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/n9nydjc/</link><pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9nydjc/</guid><description>Lambda 関数の一覧を取得する (lambda list-functions) $ aws lambda list-functions --max-items 10 関数名だけ取り出す $ aws lambda list-functions --max-items 10 --query &amp;#34;Functions[].FunctionName&amp;#34; Node.js 10 を使ってる関数の ARN を調べる $ aws lambda list-functions --function-version ALL --output text --query &amp;#34;Functions[?Runtime==&amp;#39;nodejs10.x&amp;#39;].FunctionArn AWS から来た「Node.js 10 のサポート切れるから乗り換えてね」というメール (2021-06-04) に書かれていたやり方です。
Lambda 関数の情報を取得する (lambda get-function) $ aws lambda get-function --function-name my-function 実行結果 { &amp;#34;Configuration&amp;#34;: { &amp;#34;FunctionName&amp;#34;: &amp;#34;my-function&amp;#34;, &amp;#34;FunctionArn&amp;#34;: &amp;#34;arn:aws:lambda:ap-northeast-1:123456789012:function:my-function&amp;#34;, &amp;#34;Runtime&amp;#34;: &amp;#34;nodejs12.x&amp;#34;, &amp;#34;Role&amp;#34;: &amp;#34;arn:aws:iam::123456789012:role/lambda-ex&amp;#34;, &amp;#34;CodeSha256&amp;#34;: &amp;#34;FpFMvUhayLkOoVBpNuNiIVML/tuGv2iJQ7t0yWVTU8c=&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;$LATEST&amp;#34;, &amp;#34;TracingConfig&amp;#34;: { &amp;#34;Mode&amp;#34;: &amp;#34;PassThrough&amp;#34; }, &amp;#34;RevisionId&amp;#34;: &amp;#34;88ebe1e1-bfdf-4dc3-84de-3017268fa1ff&amp;#34;, .</description></item><item><title>AWS Lambda をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/n9nydjc/</link><pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/n9nydjc/</guid><description>Lambda 関数の一覧を取得する (lambda list-functions) $ aws lambda list-functions --max-items 10 関数名だけ取り出す $ aws lambda list-functions --max-items 10 --query &amp;#34;Functions[].FunctionName&amp;#34; Node.js 10 を使ってる関数の ARN を調べる $ aws lambda list-functions --function-version ALL --output text --query &amp;#34;Functions[?Runtime==&amp;#39;nodejs10.x&amp;#39;].FunctionArn AWS から来た「Node.js 10 のサポート切れるから乗り換えてね」というメール (2021-06-04) に書かれていたやり方です。
Lambda 関数の情報を取得する (lambda get-function) $ aws lambda get-function --function-name my-function 実行結果 { &amp;#34;Configuration&amp;#34;: { &amp;#34;FunctionName&amp;#34;: &amp;#34;my-function&amp;#34;, &amp;#34;FunctionArn&amp;#34;: &amp;#34;arn:aws:lambda:ap-northeast-1:123456789012:function:my-function&amp;#34;, &amp;#34;Runtime&amp;#34;: &amp;#34;nodejs12.x&amp;#34;, &amp;#34;Role&amp;#34;: &amp;#34;arn:aws:iam::123456789012:role/lambda-ex&amp;#34;, &amp;#34;CodeSha256&amp;#34;: &amp;#34;FpFMvUhayLkOoVBpNuNiIVML/tuGv2iJQ7t0yWVTU8c=&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;$LATEST&amp;#34;, &amp;#34;TracingConfig&amp;#34;: { &amp;#34;Mode&amp;#34;: &amp;#34;PassThrough&amp;#34; }, &amp;#34;RevisionId&amp;#34;: &amp;#34;88ebe1e1-bfdf-4dc3-84de-3017268fa1ff&amp;#34;, .</description></item><item><title>AWS のコスト情報をコマンドライン (CLI) で取得する</title><link>https://maku.blog/p/ct4ckt3/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ct4ckt3/</guid><description>aws ce get-cost-and-usage ... 次の例では、指定した期間の AWS 利用料金を求めています。
aws ce get-cost-and-usage \ --granularity MONTHLY \ --time-period Start=2021-01-01,End=2021-02-01 \ --metrics BlendedCost 実行結果 DimensionValueAttributes:[]ResultsByTime:- Estimated:falseGroups:[]TimePeriod:End:&amp;#39;2021-02-01&amp;#39;Start:&amp;#39;2021-01-01&amp;#39;Total:BlendedCost:Amount:&amp;#39;0.0900932477&amp;#39;Unit:USD 次の例では、サービスごとに料金表示しています。
aws ce get-cost-and-usage \ --granularity MONTHLY \ --time-period Start=2021-01-01,End=2021-02-01 \ --metrics BlendedCost \ --group-by Type=DIMENSION,Key=SERVICE 実行結果 DimensionValueAttributes:[]GroupDefinitions:- Key:SERVICEType:DIMENSIONResultsByTime:- Estimated:falseGroups:- Keys:- AWS CloudShellMetrics:BlendedCost:Amount:&amp;#39;0.0000032477&amp;#39;Unit:USD- Keys:- AWS CodeCommitMetrics:BlendedCost:Amount:&amp;#39;0&amp;#39;Unit:USD- Keys:- AWS Key Management ServiceMetrics:BlendedCost:Amount:&amp;#39;0&amp;#39;Unit:USD- Keys:- AWS LambdaMetrics:BlendedCost:Amount:&amp;#39;0&amp;#39;Unit:USD- Keys:- Amazon Simple Notification ServiceMetrics:BlendedCost:Amount:&amp;#39;0&amp;#39;Unit:USD- Keys:- Amazon Simple Storage ServiceMetrics:BlendedCost:Amount:&amp;#39;0.</description></item><item><title>DynamoDB Local で DynamoDB のローカルテスト環境を作る</title><link>https://maku.blog/p/rdq4eq2/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq4eq2/</guid><description>DynamoDB Local とは DynamoDB Local を使うと、Amazon DynamoDB サービスを模倣するローカルサーバーを立ち上げることができます。 DynamoDB Local サーバーは、デフォルトでは http://localhost:8000 で起動し、ここに対して AWS CLI や AWS SDK で接続して操作します。
DynamoDB ウェブサービスで複雑なデータ処理を行うときは、あらかじめ DynamoDB Local を使ってテストを行っておくと安心です。 DynamoDB の操作のために試行錯誤しても AWS の利用料金がかかることはありません。
DynamoDB Local のインストール 実行ファイルのダウンロード DynamoDB Local には、Java の実行ファイル (JAR) や、それを含む Docker コンテナとして提供されています。 Java のインストールされた環境では、JAR ファイルをダウンロードして起動するのが手っ取り早いです。 下記から ZIP ファイルでダウンロードできます。
DynamoDB Local のダウンロード ダウンロードした ZIP ファイルを展開すると、次のような構成のディレクトリが展開されます。
アーカイブの内容 dynamodb_local_latest/ +-- DynamoDBLocal_lib/ ... 本体が使う依存ライブラリ +-- DynamoDBLocal.jar ... 本体 +-- その他のドキュメント 起動に必要なのは、DynamoDBLocal_lib ディレクトリと DynamoDBLocal.jar だけなので、この 2 つを任意のディレクトリにコピーします。 ここでは、次のようなディレクトリにコピーすることにします（Windows であれば、$HOME は %USERPROFILE% に置き換えてください）。</description></item><item><title>DynamoDB Local で DynamoDB のローカルテスト環境を作る</title><link>https://maku.blog/p/rdq4eq2/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq4eq2/</guid><description>DynamoDB Local とは DynamoDB Local を使うと、Amazon DynamoDB サービスを模倣するローカルサーバーを立ち上げることができます。 DynamoDB Local サーバーは、デフォルトでは http://localhost:8000 で起動し、ここに対して AWS CLI や AWS SDK で接続して操作します。
DynamoDB ウェブサービスで複雑なデータ処理を行うときは、あらかじめ DynamoDB Local を使ってテストを行っておくと安心です。 DynamoDB の操作のために試行錯誤しても AWS の利用料金がかかることはありません。
DynamoDB Local のインストール 実行ファイルのダウンロード DynamoDB Local には、Java の実行ファイル (JAR) や、それを含む Docker コンテナとして提供されています。 Java のインストールされた環境では、JAR ファイルをダウンロードして起動するのが手っ取り早いです。 下記から ZIP ファイルでダウンロードできます。
DynamoDB Local のダウンロード ダウンロードした ZIP ファイルを展開すると、次のような構成のディレクトリが展開されます。
アーカイブの内容 dynamodb_local_latest/ +-- DynamoDBLocal_lib/ ... 本体が使う依存ライブラリ +-- DynamoDBLocal.jar ... 本体 +-- その他のドキュメント 起動に必要なのは、DynamoDBLocal_lib ディレクトリと DynamoDBLocal.jar だけなので、この 2 つを任意のディレクトリにコピーします。 ここでは、次のようなディレクトリにコピーすることにします（Windows であれば、$HOME は %USERPROFILE% に置き換えてください）。</description></item><item><title>Amazon EC2 をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkx9ju6/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkx9ju6/</guid><description>EC2 で使用可能なリージョンの一覧を取得する (ec2 describe-regions) $ aws ec2 describe-regions 実行結果 (YAML形式） Regions:- Endpoint:ec2.eu-north-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:eu-north-1- Endpoint:ec2.ap-south-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ap-south-1- Endpoint:ec2.eu-west-3.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:eu-west-3- Endpoint:ec2.eu-west-2.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:eu-west-2- Endpoint:ec2.eu-west-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:eu-west-1- Endpoint:ec2.ap-northeast-3.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ap-northeast-3- Endpoint:ec2.ap-northeast-2.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ap-northeast-2- Endpoint:ec2.ap-northeast-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ap-northeast-1- Endpoint:ec2.sa-east-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:sa-east-1- Endpoint:ec2.ca-central-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ca-central-1- Endpoint:ec2.ap-southeast-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ap-southeast-1- Endpoint:ec2.ap-southeast-2.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:ap-southeast-2- Endpoint:ec2.eu-central-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:eu-central-1- Endpoint:ec2.us-east-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:us-east-1- Endpoint:ec2.us-east-2.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:us-east-2- Endpoint:ec2.us-west-1.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:us-west-1- Endpoint:ec2.us-west-2.amazonaws.comOptInStatus:opt-in-not-requiredRegionName:us-west-2 EC2 インスタンスの情報を取得する (ec2 describe-instances) 作成済みの EC2 インスタンスの一覧、あるいは指定した EC2 インスタンスの情報を取得します。
$ aws ec2 describe-instances 実行結果（YAML形式） Reservations:- Groups:[]Instances:- AmiLaunchIndex:0Architecture:x86_64BlockDeviceMappings:- DeviceName:/dev/xvdaEbs:AttachTime:&amp;#39;2021-03-02T14:26:39+00:00&amp;#39;DeleteOnTermination:trueStatus:attachedVolumeId:vol-3b75f0f9090990420CapacityReservationSpecification:CapacityReservationPreference:openClientToken:&amp;#39;&amp;#39;CpuOptions:CoreCount:1ThreadsPerCore:1EbsOptimized:falseEnaSupport:trueEnclaveOptions:Enabled:falseHibernationOptions:Configured:falseHypervisor:xenImageId:ami-e2e9e713809d28faaInstanceId:i-757968a71071691b7InstanceType:t2.nanoKeyName:ec2keyLaunchTime:&amp;#39;2021-03-02T15:32:17+00:00&amp;#39;MetadataOptions:HttpEndpoint:enabledHttpPutResponseHopLimit:1HttpTokens:optionalState:appliedMonitoring:State:disabledNetworkInterfaces:- Attachment:AttachTime:&amp;#39;2021-03-02T14:26:38+00:00&amp;#39;AttachmentId:eni-attach-c1c18b4c61083b1eaDeleteOnTermination:trueDeviceIndex:0NetworkCardIndex:0Status:attachedDescription:&amp;#39;&amp;#39;Groups:- GroupId:sg-650f7192f60271eb7GroupName:launch-wizard-1InterfaceType:interfaceIpv6Addresses:[]MacAddress:0a:a0:bf:37:7f:c1NetworkInterfaceId:eni-c8aea6d54ac8cc0d0OwnerId:&amp;#39;049344049957&amp;#39;PrivateDnsName:ip-172-31-0-95.ap-northeast-1.compute.internalPrivateIpAddress:172.31.0.95PrivateIpAddresses:- Primary:truePrivateDnsName:ip-172-31-0-95.ap-northeast-1.compute.internalPrivateIpAddress:172.31.0.95SourceDestCheck:trueStatus:in-useSubnetId:subnet-13e65081VpcId:vpc-af6e084dPlacement:AvailabilityZone:ap-northeast-1cGroupName:&amp;#39;&amp;#39;Tenancy:defaultPrivateDnsName:ip-172-31-0-95.ap-northeast-1.compute.internalPrivateIpAddress:172.31.0.95ProductCodes:[]PublicDnsName:&amp;#39;&amp;#39;RootDeviceName:/dev/xvdaRootDeviceType:ebsSecurityGroups:- GroupId:sg-650f7192f60271eb7GroupName:launch-wizard-1SourceDestCheck:trueState:Code:80Name:stoppedStateReason:Code:Client.UserInitiatedShutdownMessage: &amp;#39;Client.UserInitiatedShutdown:User initiated shutdown&amp;#39;StateTransitionReason:User initiated (2021-03-03 16:24:03 GMT)SubnetId:subnet-6508113eTags:- Key:NameValue:maku-test-ec2VirtualizationType:hvmVpcId:vpc-af6e084dOwnerId:&amp;#39;493440499570&amp;#39;ReservationId:r-09d469440a8ee4861 AMI の情報を取得する (ec2 describe-images) $ aws ec2 describe-images 作成した Amazon マシンイメージ (AMI) の一覧を表示することができます。</description></item><item><title>AWS CodeBuild をコマンドライン (CLI) から操作する</title><link>https://maku.blog/p/bwamw8i/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bwamw8i/</guid><description>CodeBuild プロジェクトの一覧を取得する (codebuild list-projects) $ aws codebuild list-projects 例: すべてのプロジェクト名を取得 $ aws codebuild list-projects projects: - app1-codebuild - app2-codebuild - app3-codebuild 出力結果をソートするには、次のオプションが使用できます。
sort-by &amp;hellip; NAME / CREATED_TIME / LAST_MODIFIED_TIME のいずれかを指定 sort-order .. ASCENDING / DESCENDING のいずれかを指定 例: 最近作られたプロジェクトを 5 件表示 $ aws codebuild list-projects --sort-by CREATED_TIME --sort-order DESCENDING --max-items 5 実行結果 NextToken: eyJuZXh0VG9rZW4iOiBudWxsLCAiYm90b190cnVuY2F0ZV9hbW91bnQiOiA1fQ== projects: - myapp25-codebuild - myapp24-codebuild - myapp23-codebuild - myapp22-codebuild - myapp21-codebuild NextToken は、続きのエントリを取得したいときに、--starting-token オプションで指定します。</description></item><item><title>DynamoDB をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkzamw8/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkzamw8/</guid><description>テーブルを作成する (dynamodb create-table) aws dynamodb create-table --table-name &amp;lt;テーブル名&amp;gt; ... DynamoDB のテーブルを作成するときは、少なくともプライマリキーの設定や、課金モードの設定が必要になるので、少しだけコマンドが長くなります。
次の例では、DynamoDB に MusicCollection というテーブルを作成します。 Artist というパーティションキー (KeyType=HASH) と、Artist というソートキー (KeyType=RANGE) を定義しています。 課金体系は「プロビジョンドモード」で最小構成になるよう設定しています。
テーブル生成 (PartitionKey &amp;#43; SortKey) $ aws dynamodb create-table \ --table-name MusicCollection \ --attribute-definitions AttributeName=Artist,AttributeType=S AttributeName=SongTitle,AttributeType=S \ --key-schema AttributeName=Artist,KeyType=HASH AttributeName=SongTitle,KeyType=RANGE \ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 パーティションキーのみで良い場合（ソートキーなし）は、次のような感じになります。
テーブル生成 (PartitionKey) $ aws dynamodb create-table \ --table-name MusicCollection \ --attribute-definitions AttributeName=Artist,AttributeType=S \ --key-schema AttributeName=Artist,KeyType=HASH \ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 キャパシティモード（課金体系）をオンデマンド（本当にアクセスした分だけの支払い）にするには、--billing-mode PAY_PER_REQUEST オプションを指定し、プロビジョン設定 (--provisioned-throughput) を省略します。 一定間隔でそれなりにアクセスがある場合は、プロビジョンドモード (PROVISIONED) にして常時稼働の形にしておいた方が総合的に安くなるようですが、テスト用途で作成する場合などは PAY_PER_REQUEST にしておくのが無難かと思います。</description></item><item><title>DynamoDB をコマンドライン (CLI) で操作する</title><link>https://maku.blog/p/zkzamw8/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zkzamw8/</guid><description>テーブルを作成する (dynamodb create-table) aws dynamodb create-table --table-name &amp;lt;テーブル名&amp;gt; ... DynamoDB のテーブルを作成するときは、少なくともプライマリキーの設定や、課金モードの設定が必要になるので、少しだけコマンドが長くなります。
次の例では、DynamoDB に MusicCollection というテーブルを作成します。 Artist というパーティションキー (KeyType=HASH) と、Artist というソートキー (KeyType=RANGE) を定義しています。 課金体系は「プロビジョンドモード」で最小構成になるよう設定しています。
テーブル生成 (PartitionKey &amp;#43; SortKey) $ aws dynamodb create-table \ --table-name MusicCollection \ --attribute-definitions AttributeName=Artist,AttributeType=S AttributeName=SongTitle,AttributeType=S \ --key-schema AttributeName=Artist,KeyType=HASH AttributeName=SongTitle,KeyType=RANGE \ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 パーティションキーのみで良い場合（ソートキーなし）は、次のような感じになります。
テーブル生成 (PartitionKey) $ aws dynamodb create-table \ --table-name MusicCollection \ --attribute-definitions AttributeName=Artist,AttributeType=S \ --key-schema AttributeName=Artist,KeyType=HASH \ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 キャパシティモード（課金体系）をオンデマンド（本当にアクセスした分だけの支払い）にするには、--billing-mode PAY_PER_REQUEST オプションを指定し、プロビジョン設定 (--provisioned-throughput) を省略します。 一定間隔でそれなりにアクセスがある場合は、プロビジョンドモード (PROVISIONED) にして常時稼働の形にしておいた方が総合的に安くなるようですが、テスト用途で作成する場合などは PAY_PER_REQUEST にしておくのが無難かと思います。</description></item><item><title>AWS IAM の設定をコマンドライン (CLI) で行う</title><link>https://maku.blog/p/aov4bho/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aov4bho/</guid><description>AWS CLI（aws コマンド）を使うと、様々な IAM 系の操作をコマンドラインから実行できるようになります。 ただし、IAM の制御を行えるのは、AdministratorAccess ポリシーなどが割り当てられ、IAM 操作の権限が付いているユーザーに限られます。
iam &amp;ndash; AWS CLI Command Reference ユーザー関連 IAM ユーザーを作成する (iam create-user) aws iam create-user --user-name &amp;lt;ユーザー名&amp;gt; 実行例 $ aws iam create-user --user-name user-1 --output yamlUser:Arn:arn:aws:iam::049957049344:user/user-1CreateDate:&amp;#39;2021-11-01T08:41:29+00:00&amp;#39;Path:/UserId:AIDAQXINMCQAPJRMFE22HUserName:user-1 iam create-user コマンドを使うと、指定した名前の IAM ユーザーを作成できます。 作成したユーザーの情報は、iam get-user や iam list-users コマンドで取得できます。 作成したユーザー用の API アクセスキーを生成するには、ひきつづき iam create-access-key コマンドを使用します。
IAM ユーザーを削除する (iam delete-user) aws iam delete-user --user-name &amp;lt;ユーザー名&amp;gt; 指定したユーザーに何らかの設定情報（アクセスキーや SSH キー、MFA など）が設定されている場合は、先にそれらの情報を削除しておく必要があります。 例えば、アクセスキーが設定されている場合は、delete-access-key コマンドで削除してからユーザー自体を削除します。</description></item><item><title>AWS IAM の設定をコマンドライン (CLI) で行う</title><link>https://maku.blog/p/aov4bho/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aov4bho/</guid><description>AWS CLI（aws コマンド）を使うと、様々な IAM 系の操作をコマンドラインから実行できるようになります。 ただし、IAM の制御を行えるのは、AdministratorAccess ポリシーなどが割り当てられ、IAM 操作の権限が付いているユーザーに限られます。
iam &amp;ndash; AWS CLI Command Reference ユーザー関連 IAM ユーザーを作成する (iam create-user) aws iam create-user --user-name &amp;lt;ユーザー名&amp;gt; 実行例 $ aws iam create-user --user-name user-1 --output yamlUser:Arn:arn:aws:iam::049957049344:user/user-1CreateDate:&amp;#39;2021-11-01T08:41:29+00:00&amp;#39;Path:/UserId:AIDAQXINMCQAPJRMFE22HUserName:user-1 iam create-user コマンドを使うと、指定した名前の IAM ユーザーを作成できます。 作成したユーザーの情報は、iam get-user や iam list-users コマンドで取得できます。 作成したユーザー用の API アクセスキーを生成するには、ひきつづき iam create-access-key コマンドを使用します。
IAM ユーザーを削除する (iam delete-user) aws iam delete-user --user-name &amp;lt;ユーザー名&amp;gt; 指定したユーザーに何らかの設定情報（アクセスキーや SSH キー、MFA など）が設定されている場合は、先にそれらの情報を削除しておく必要があります。 例えば、アクセスキーが設定されている場合は、delete-access-key コマンドで削除してからユーザー自体を削除します。</description></item><item><title>AWS アカウント、IAM ユーザー、グループ、ポリシーの違い</title><link>https://maku.blog/p/4c7sdwg/</link><pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4c7sdwg/</guid><description> AWS を使う上で最初に理解しておくべき、「アカウント」と「ユーザー」まわりの概念についてまとめておきます。
簡単なイメージとしてはこんな感じ。 AWS アカウント &amp;hellip; 組織およびルートユーザーのこと。通称アカウント。 IAM ユーザー &amp;hellip; 組織内の個別ユーザー。通称ユーザー。 ちなみに、IAM は Identity and Access Management の略。
AWS アカウント（のルートユーザー） AWS サインアップ時に作られる、組織で 1 つだけ用意されるルートユーザーです。 AWS アカウントの ID は管理者のメールアドレスです。 AWS アカウントは、契約／支払い設定などを含むフルアクセス権限があるので、通常の業務ではこのアカウントは使わず、IAM ユーザーを使います。 IAM ユーザー AWS アカウントから作成されるユーザーで、通常の業務ではこの IAM ユーザーを使います。Linux の一般ユーザーのようなものです。 1 つの AWS アカウントから複数の IAM ユーザーを作成することができます。 IAM ユーザーに IAM ポリシーを割り当てることで、各種リソースへのアクセスが許可されます。IAM ユーザー作成直後は、何もアクセス権限がありません。ちなみに、IAM ポリシーは JSON 形式で記述されます。 IAM グループ 複数の IAM ユーザーをグルーピングするためのものです。 IAM グループに対しても IAM ポリシーを割り当てることができ、複数の IAM ユーザーにまとめて権限設定することができます。 IAM ロール 特定の AWS サービス、IAM ユーザー、IAM グループに一時的に権限を与えるために使われます。例えば、EC2 インスタンスへのアクセス権割り当てなどに使われます。 IAM ロールがどのような権限を表現するかは、IAM ロール自体に IAM ポリシーを割り当てることで制御します。 協力会社のメンバーに自社リソースの権限を与えたいときに、協力会社側で使っている IAM ユーザーに対して、自社で作成した IAM ロールを割り当てる、という使い方ができます。→ 参考: IAM ユーザーにアクセス権限を委任するロールの作成</description></item><item><title>AWS CodeBuild で Hello World（GitHub との連携）</title><link>https://maku.blog/p/xdnu3ah/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xdnu3ah/</guid><description>何をやるか？ CodeBuild は AWS が提供するビルドサービスです。 例えば、GitHub に buildspec.yml というビルド方法を記述したファイルを置いておくと、GitHub へのコードプッシュ時に、その設定通りビルドを行ってくれます。 GitHub Actions や Azure Pipelines といったサービスと同様です。
ここでは、CodeBuild 導入の第一歩として、次のような構成でセットアップしてみます。
ソースプロバイダ : GitHub（の適当なテストリポジトリ） ビルド内容 : &amp;ldquo;Hello World&amp;rdquo; と echo 表示する つまり、テスト用の GitHub リポジトリに何らかのファイルをプッシュしたときに、CodeBuild によるビルドを開始するところまでです。
ソースプロバイダとしては、GitHub だけではなく、AWS CodeCommit、Bitbucket、GitHub Enterpise といった Git リポジトリを選択できますが、おそらく GitHub が一番よく使われているので、ここでは GitHub を使うことにします。
最初の一歩はできるだけ簡単に済ませることが肝心です！
アカウントとリポジトリを準備する まず最低限の準備として、下記のアカウントは用意できているとします。
AWS アカウント GitHub アカウント 次に、GitHub にテスト用の リポジトリを作成 しておきます。 ここでは、リポジトリ名は hello-codebuild とでもしておきます。 README.md を自動生成しておくと、後のテストが楽です。
CodeBuild にビルドプロジェクトを作成する 次のようにして、CodeBuild に新規ビルドプロジェクトを作成します。
AWS CodeBuild console を開きます。 ビルド (CodeBuild) → ビルドプロジェクト → ビルドプロジェクトを作成する と選択します。 以下のような内容を入力してビルドプロジェクトを作成します。 プロジェクト名 : build-hello（名前は自由） ソースプロバイダ : GitHub → 作成しておいた hello-codebuild リポジトリを指定 ウェブフック : コードの変更がこのレポジトリにプッシュされるたびに再構築する にチェックを入れる（これで GitHub へのプッシュ時にビルドトリガがかかります） 環境イメージ : マネージド型イメージ → Amazon Linux 2 → ランタイムやイメージは適当に選択 サービスロール : 新しいサービスロール → codebuild-build-hello-service-role（デフォルト） ビルド仕様 : buildspec ファイルを使用する 以下のような感じでビルドプロジェクトが作成されれば成功です。</description></item><item><title>AWS のサービス一覧（2021年版）</title><link>https://maku.blog/p/t8fmsz5/</link><pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/t8fmsz5/</guid><description>AWS のサービスを概要説明付きでリスト化したものが欲しくて作っちゃったので置いておきます。 PDF 化したもの も置いておきます。
.local-aws td { padding: 0 0 0.2em 0.2em; background: #fafafa; } .local-aws th { padding-top: 1.5em; border: none; background: white; text-align: left; } .local-aws img { max-width: 1.5em; } 分析 (Analytics) Amazon Athena SQL を使用した S3 でのデータクエリ Amazon CloudSearch マネージド型検索サービス Amazon Elasticsearch Service Elasticsearch クラスターを実行し、スケールする Amazon EMR ホスト型 Hadoop フレームワーク Amazon Kinesis リアルタイムストリーミングデータとの連携 Amazon Managed Streaming for Apache Kafka フルマネージド型 Apache Kafka サービス Amazon Redshift 高速かつシンプルで、費用対効果の高いデータウェアハウス Amazon QuickSight 高速ビジネス分析サービス AWS Data Exchange クラウド内サードパーティのデータを検索、購読、および使用 AWS Data Pipeline 定期的なデータ駆動型ワークフローに対するオーケストレーションサービス AWS Glue シンプルでスケーラブルなサーバーレスデータ統合 AWS Lake Formation 安全なデータレイクを数日で構築 Application Integration（アプリケーション統合） AWS Step Functions 分散アプリケーションの調整 Amazon AppFlow SaaS アプリケーションと AWS のサービス向けのコード統合が不要 Amazon EventBridge SaaS アプリと AWS のサービス向けサーバーレスイベントバス Amazon Managed Workflows for Apache Airflow 可用性に優れたセキュアなマネージドワークフローオーケストレーション Amazon MQ マネージド型メッセージブローカーサービス Amazon Simple Notification Service (SNS) Pub/sub、SMS、E メール、およびモバイルプッシュ通知 Amazon Simple Queue Service (SQS) マネージド型メッセージキュー Amazon AppSync 多くのソースから適切なデータを使用して、大規模にアプリを強化 AWS Cost Management（AWS コスト管理） AWS Cost Explorer AWS のコストと使用状況を分析する AWS 予算 カスタムコストと使用予算を設定する AWS のコストと使用状況レポート 包括的なコストと使用状況情報へのアクセス リザーブドインスタンスレポート リザーブドインスタンス (RI) の詳細を把握する Savings Plans 柔軟な料金設定でコンピューティング使用コストを最大 72% 節約 Blockchain （ブロックチェーン） Amazon Managed Blockchain スケーラブルなブロックチェーンネットワークを作成および管理 Amazon Quantum Ledger Database (QLDB) フルマネージド型台帳データベース Business Application（ビジネスアプリケーション） Alexa for Business Alexa を使って組織を強化 Amazon Chime フラストレーションフリーの会議、ビデオ電話、チャット Amazon Honeycode (ベータ) プログラミングなしでモバイルおよびウェブアプリケーションを構築 Amazon WorkDocs エンタープライズドキュメントの安全なストレージと共有 Amazon WorkMail セキュリティで保護されたマネージド型の企業向け E メールおよびカレンダー Compute（コンピューティング） Amazon EC2 クラウド内の仮想サーバー Amazon EC2 Auto Scaling 需要に合わせてコンピューティング性能をスケール Amazon Lightsail 仮想プライベートサーバーを起動および管理 AWS Batch あらゆる規模でバッチジョブを実行 AWS Elastic Beanstalk ウェブアプリの実行と管理 AWS Lambda イベント発生時にコードを実行 AWS Outposts AWS サービスをオンプレミスで実行 AWS Serverless Application Repository サーバーレスアプリケーションを検索、デプロイ、公開する AWS Snow ファミリー エッジロケーションでデータを集約および処理して AWS に転送するデバイス AWS Wavelength 5G デバイスのための超低レイテンシーアプリケーションを提供 VMware Cloud on AWS カスタムハードウェアを使用せずにハイブリッドクラウドを構築する Containers（コンテナ） Amazon Elastic Container Registry コンテナイメージを簡単に保存、管理、デプロイ Amazon Elastic Container Service (ECS) コンテナを実行するためのきわめて安全で信頼性と拡張性が高い方法 Amazon ECS Anywhere (近日公開) インフラストラクチャでの ECS Amazon Elastic Kubernetes Service (EKS) 信頼性が最も高い Kubernetes の実行方法 Amazon EKS Anywhere (近日公開) インフラストラクチャでの Kubernetes Amazon EKS Distro 一貫した Kubernetes クラスターの実行 AWS App2Container 既存のアプリケーションのコンテナ化と移行 AWS Fargate コンテナ向けサーバーレスコンピューティング AWS での Red Hat OpenShift マネージド Red Hat OpenShift クラスター Customer Engagement（カスタマーエンゲージメント） Amazon Connect クラウドベースのコンタクトセンター Amazon Pinpoint チャンネル間でのパーソナライズされたユーザーエンゲージメント Amazon Simple Email Service (SES) E メールの送受信 Database（データベース） Amazon Aurora 高性能マネージドリレーショナルデータベース Amazon Aurora Serverless v2 (プレビュー) 毎秒 100,000 件を超えるトランザクションに瞬時にスケール Amazon DynamoDB マネージド型の NoSQL データベース Amazon DocumentDB (MongoDB 互換) フルマネージド型ドキュメントデータベース Amazon ElastiCache インメモリキャッシングシステム Amazon Keyspaces (Apache Cassandra 用) マネージド型の Cassandra 対応データベース Amazon Neptune フルマネージド型グラフデータベースサービス Amazon Quantum Ledger Database (QLDB) フルマネージド型台帳データベース Amazon RDS MySQL、PostgreSQL、Oracle、SQL Server、MariaDB 向けのマネージドリレーショナルデータベースサービス Amazon RDS on VMware オンプレミスデータベースの管理を自動化 Amazon Redshift 高速、シンプル、費用対効果の高いデータウェアハウジング Amazon Timestream フルマネージド型の時系列データベース AWS Database Migration Service 最小限のダウンタイムでデータベースを移行 AWS Glue シンプルでスケーラブルなサーバーレスデータ統合 Developer Tools（デベロッパーツール） Amazon CodeGuru 最もコストがかかるコード行を見つける Amazon Corretto 本番環境に向けて OpenJDK を配信 AWS Cloud Development Kit (CDK) コードを使用してクラウドインフラストラクチャをモデル化する AWS Cloud9 Cloud IDE でコードを記述、実行、デバッグ AWS CloudShell ブラウザベースのシェル環境 AWS CodeArtifact ソフトウェア開発のためのセキュアかつスケーラブルでコスト効率性に優れたアーティファクト管理 AWS CodeBuild コードのビルドとテスト AWS CodeCommit プライベート Git リポジトリでのコードの保存 AWS CodeDeploy コードデプロイの自動化 AWS CodePipeline 継続的デリバリーを使用したソフトウェアのリリース AWS CodeStar AWS アプリケーションの開発とデプロイ AWS コマンドラインインターフェイス AWS サービスを管理するための統合ツール AWS Device Farm AWS クラウド内の実際のデバイスを使った Android、iOS、ウェブアプリケーションのテスト AWS Fault Injection Simulator 完全マネージド型のカオスエンジニアリングサービス AWS ツールと SDK AWS のためのツールと SDK AWS X-Ray アプリケーションの分析とデバッグ End User Computing（エンドユーザーコンピューティング） Amazon AppStream 2.</description></item></channel></rss>