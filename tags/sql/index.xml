<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SQL on まくろぐ</title><link>https://maku.blog/tags/sql/</link><description>Recent content in SQL on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 20 Feb 2011 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>SQL の検索結果をソートする (ORDER BY)</title><link>https://maku.blog/p/6ebo58o/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6ebo58o/</guid><description>SELECT によるレコードの検索結果の並び順は不定なので、特定のカラムでソートしたい場合は、明示的に ORDER BY 指定を行う必要があります。
書式 SELECT*FROMtblORDERBYcol 複数のカラムでソートしたい場合は、カンマでチェック順にカラム名を並べます。
SELECT*FROMtblORDERBYa,b,c 昇順 (ASC)、降順 (DESC) を指定するには以下のように末尾に追加するだけです。
SELECT*FROMtblORDERBYcolASC-- 昇順 (default) SELECT*FROMtblORDERBYcolDESC-- 降順 NULL がどのように扱われるかはデータベースによって異なります。</description></item><item><title>SQLite のテーブル作成に関するメモ</title><link>https://maku.blog/p/2iccv8a/</link><pubDate>Sun, 01 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2iccv8a/</guid><description>SQLite 3 のフィールド型 テーブル作成時 (CREATE TABLE) に指定したフィールド定義に含まれているテキストにより、以下のようにフィールド型が決定されます。
INTEGER 型: INT という文字列を含む場合。 TEXT 型: CHAR、CLOB、TEXT を含む場合。 NONE 型: BLOB を含む型、あるいはデータ型が特定されない場合。 NUMERIC 型: それ以外の場合。 テーブルが存在しない場合だけテーブルを作成する (IF NOT EXISTS) CREATETABLEIFNOTEXISTStbl(idINTEGERPRIMARYKEY,nameTEXT,binBLOB); 逆に、テーブルが存在する場合だけテーブルを削除するということもできます。 この場合は、IF NOT EXISTS の代わりに、IF EXISTS を使用します。
DROPTABLEIFEXISTStbl; NULL の追加を禁止する (NOT NULL) フィールドの定義時に、NOT NULL というフィールド制約を加えておくと、データ追加時にそのフィールドの値を省略できないようになります。
CREATETABLEtbl(f1NOTNULL,f2,f3); 動作確認 sqlite&amp;gt; INSERT INTO tbl(f1, f2) VALUES(100, 200); sqlite&amp;gt; INSERT INTO tbl(f2, f3) VALUES(200, 300); SQL error: tbl.f1 may not be NULL 同じ値の入力を禁止する (UNIQUE) フィールドの定義時に、UNIQUE というフィールド制約を加えることで、別のレコードに入っている値と同じ値を追加できないようになります。</description></item><item><title>SQLite 雑多メモ</title><link>https://maku.blog/p/w5x4797/</link><pubDate>Sun, 16 Nov 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w5x4797/</guid><description>SQLite にできないこと SQL Features That SQLite Does Not Implement より。
ユーザごとにアクセス制限ができない。 GRANT によるアクセス権限の制御はできない。 SQLite にはデータベースサーバが存在せず、クライアントが直接 DB ファイルにアクセスする形式のため、サーバでの GRANT によるアクセス権限の制御ができない。 そのユーザーがファイルにアクセスできるということは、そのデータベースに対して何でもできるということを示す。 VIEW は使えるがリードオンリーである。 SQLite 2 と SQLite 3 の違い バージョン 3 では BLOB (Binary Large OBject) がサポートされた。 バージョン 3 のほうがデータベースファイルのサイズがコンパクトになる。 整数の連番を生成する ROWID がバージョン 2 では 32bit、バージョン 3 では 64bit。 SQLite 2 のデータベースファイルを SQLite 3 のデーターベース形式に変換する $ sqlite db2 .dump | sqlite3 db3 各言語用の SQLite ライブラリ SQLite Wrappers Python で SQLite を操作する PEP 249 &amp;ndash; Python Database API Specification v2.</description></item><item><title>SQLite の日時関連の処理</title><link>https://maku.blog/p/qwtoj94/</link><pubDate>Sat, 17 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qwtoj94/</guid><description>現在の日時を取得する（テキスト形式） 日付＋時刻 sqlite&amp;gt; select datetime(&amp;#39;now&amp;#39;) 2007-02-17 07:53:30 日付のみ sqlite&amp;gt; select date(&amp;#39;now&amp;#39;) 2007-02-17 時刻のみ sqlite&amp;gt; select time(&amp;#39;now&amp;#39;) 07:53:30 これらのデータ型は TEXT 型です。
sqlite&amp;gt; select typeof(datetime(&amp;#39;now&amp;#39;)); text 現在の日時を現地時間で取得する（テキスト形式） sqlite&amp;gt; select datetime(&amp;#39;now&amp;#39;, &amp;#39;localtime&amp;#39;) 2007-02-17 16:53:30 sqlite&amp;gt; select date(&amp;#39;now&amp;#39;, &amp;#39;localtime&amp;#39;) 2007-02-17 sqlite&amp;gt; select time(&amp;#39;now&amp;#39;, &amp;#39;localtime&amp;#39;) 16:53:30 ある標準時を現地時刻へ変換する sqlite&amp;gt; select datetime(&amp;#39;2007-02-17 21:30:00&amp;#39;, &amp;#39;localtime&amp;#39;); 2007-02-18 06:30:00 sqlite&amp;gt; select time(&amp;#39;21:30:00&amp;#39;, &amp;#39;localtime&amp;#39;); 06:30:00</description></item></channel></rss>