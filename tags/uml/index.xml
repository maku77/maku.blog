<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>UML on まくろぐ</title><link>https://maku.blog/tags/uml/</link><description>Recent content in UML on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 07 Mar 2019 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/uml/index.xml" rel="self" type="application/rss+xml"/><item><title>PlantUML の基本（インストール〜画像ファイルへの保存）</title><link>https://maku.blog/p/opxhnho/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/opxhnho/</guid><description>Graphviz のインストール PlantUML は図の生成のために内部で Graphviz の dot コマンドを使用するので、先に Graphviz をインストールしましょう。
Graphviz - Graph Visualization Software ここでは、上記のサイトから ZIP ファイル graphviz-2.38.zip をダウンロードし、展開してできた release ディレクトリ内のファイル群を C:\app\graphviz-2.38 というディレクトリ内に配置するとします。 Graphviz に含まれる dot コマンドのパスを環境変数 GRAPHVIZ_DOT に設定すれば Graphviz のインストールは完了です（この環境変数を PlantUML が参照します）。
環境変数 GRAPHVIZ_DOT の設定 GRAPHVIZ_DOT=C:\app\graphviz-2.38\bin\dot.exe PlantUML のインストール 下記から plantuml.jar をダウンロードして、適当なディレクトリに配置します。
PlantUML - plantuml.jar のダウンロード ここでは、C:\app\plantuml\plantuml.jar というパスで配置することにします。 コマンドプロンプトから、下記のように実行して、特にエラーが発生しなければ OK です。
実行テスト C:\&amp;gt; java -jar C:\app\plantuml\plantuml.jar -testdot The environment variable GRAPHVIZ_DOT has been set to C:\app\graphviz-2.38\bin\dot.exe Dot executable is C:\app\graphviz-2.</description></item><item><title>PlantUML でクラス図を作成する</title><link>https://maku.blog/p/tn6y85z/</link><pubDate>Thu, 07 Mar 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tn6y85z/</guid><description>クラスの箱を描く 基本 クラスの箱を描くには、class キーワードを使用します。 他にも、interface でインタフェース、abstract で抽象クラス、enum で列挙型を定義することができます。
@startuml class クラス interface インタフェース abstract 抽象クラス enum 列挙型 @enduml クラス名にスペースや記号を含んでいる場合 クラス名やインタフェース名にスペースや記号を含めたい場合は、その文字列全体をダブルクォート &amp;quot;&amp;quot; で囲みます。 さらに、as で別名を付けておくと、あとから参照しやすくなります。
@startuml class &amp;#34;This is a class A&amp;#34; as A class &amp;#34;This is a class B&amp;#34; as B A -&amp;gt; B @enduml ステレオタイプ クラス名の後ろに &amp;lt;&amp;lt;ステレオタイプ&amp;gt;&amp;gt; と記述することで、クラス名の上部に任意のステレオタイプを表示することができます。 独自のステレオタイプを表示することができますし、複数のステレオタイプを表示することもできます。
@startuml interface インタフェース &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; abstract 抽象クラス &amp;lt;&amp;lt;abstract&amp;gt;&amp;gt; class ほげほげ &amp;lt;&amp;lt;独自ステレオタイプ&amp;gt;&amp;gt; class へむへむ &amp;lt;&amp;lt;Serializable&amp;gt;&amp;gt; &amp;lt;&amp;lt;Model&amp;gt;&amp;gt; @enduml クラス名の横の記号を非表示にする クラス名の左側に表示される C の記号などを非表示するには、hide circle コマンドを使用します。 下記のようにすると、クラスやインタフェースの記号がすべて非表示になります。 インタフェースに &amp;lt;&amp;lt;inteface&amp;gt;&amp;gt; というステレオタイプを表示するのであれば、記号は冗長なので消しておいた方がよいかもしれません。</description></item><item><title>PlantUML でシーケンス図を作成する</title><link>https://maku.blog/p/n8p7qmw/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/n8p7qmw/</guid><description>シーケンス図は相互作用図 (interaction diagram) の代表的なダイアグラムです。 シーケンス図は、特定のユースケースに関するオブジェクトの典型例と、オブジェクト間のメッセージを示します。
要素の並び順の制御 (participant) 必須の定義ではないですが、participant であらかじめ要素を列挙しておくと、その後のメッセージ定義の順序に関係なく、participant に並べた順に左から要素が配置されます。
@startuml participant Class1 participant Class2 participant Class3 Class3 -&amp;gt; Class1 Class2 -&amp;gt; Class3 Class1 -&amp;gt; Class2 @enduml participant の代わりに actor というキーワードを使用すると、アクターのシンボルを表示することができます。
@startuml actor Class1 participant Class2 participant Class3 Class3 -&amp;gt; Class1 Class2 -&amp;gt; Class3 Class1 -&amp;gt; Class2 @enduml 同期メッセージと非同期メッセージ、リターン オブジェクト間のメッセージは、下記のように描き分けることができます。
-&amp;gt;: 同期メッセージ --&amp;gt;: 戻り値（リターン） -&amp;raquo;`: 非同期メッセージ 同期メッセージには戻り値（リターン）(--&amp;gt;) がありますが、UML の仕様としては省略することができます。
@startuml A -&amp;gt; B : 同期メッセージ A &amp;lt;-- B : リターン A -&amp;gt;&amp;gt; C : 非同期メッセージ @enduml ライフラインの活性区間 (activation) と終了 ライフラインの上に描かれる長方形は「活性区間 (activation)」で、その区間の間はオブジェクトがアクティブな状態になっていることを表します。 活性区間は、activate と deactivate で示します。</description></item><item><title>PlantUML でオブジェクト図を作成する</title><link>https://maku.blog/p/t7cfj92/</link><pubDate>Mon, 15 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/t7cfj92/</guid><description>オブジェクト図はクラス図と同様の文法で記述することができます。 下記のページも参考にしてください。
PlantUML でクラス図を作成する オブジェクト図の基本 オブジェクト図 (object diagram) は、システム内のオブジェクト群のある時点のスナップショットを表現します。 具体的なオブジェクト同士の関係を表現することができるため、複雑な依存関係を持つオブジェクト
インスタンス名は下線付きで「インスタンス名：クラス名」という形式で記述します。 インスタンス名とクラス名はどちらか一方を省略して記述することもできますが、クラス名だけを記述する場合は、「：クラス名」のようにコロン部分だけは残して記述します。
オブジェクト図は、メッセージなしのコミュニケーション図と考えることもできます。 ─『UMLモデリングのエッセンス第3版』マーチン・ファウラー
PlantUML で登場させるオブジェクト群は、object キーワードを使って定義します。 as を使って別名を付けておくことができます。
@startuml object object1 object &amp;#34;My second object&amp;#34; as o2 @enduml 関連の線を引く オブジェクト同士の依存関係を示すには、-- でオブジェクト名（あるいは別名）を繋ぎます。 代わりに .. を使用すると、破線 (dashed line) で繋ぐことができます。
@startuml object object1 object &amp;#34;Second object&amp;#34; as o2 object &amp;#34;Third object&amp;#34; as o3 object &amp;#34;Fourth object&amp;#34; as o4 object1 -- o2 object1 -- o3 object1 -- o4 o2 .. o3 o3 .. o4 @enduml ハイフンやドットの数を 1 つに減らすことで、オブジェクトを横方向に配置することができます。</description></item><item><title>UML ダイアグラムの一覧と分類</title><link>https://maku.blog/p/yzs49gv/</link><pubDate>Tue, 23 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/yzs49gv/</guid><description>構造図 (structual diagrams) クラス図: クラス、特性、関係 コンポーネント図: コンポーネントの構造と接続 コンポジット構造図（複合構造図）: クラスのランタイム分割 配置図: ノードへの成果物の配置 オブジェクト図: インスタンスの接続の基本例 パッケージ図: コンパイル時の階層構造 振る舞い図 (behavioral diagrams) アクティビティ図: 手続き的なまたは並行な振る舞い ユースケース図: ユーザーがシステムとどう対話（相互作用）するか ステートマシン図（状態マシン図）: オブジェクトの存続期間にイベントがオブジェクトに加える変更の内容 相互作用図 シーケンス図: オブジェクト間の相互作用（シーケンスを重視） コミュニケーション図: オブジェクト間の相互作用（リンクを重視）UML1ではコラボレーション図と呼ばれていた タイミング図: オブジェクト間の相互作用（タイミングを重視）(UML2) 相互作用概要図: シーケンス図とアクティビティ図を合わせたもの (UML2)</description></item><item><title>読書メモ『UMLモデリングのエッセンス第3版』マーチン・ファウラー</title><link>https://maku.blog/p/tc73ttt/</link><pubDate>Fri, 19 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tc73ttt/</guid><description>UMLモデリングのエッセンス第3版 マーチン・ファウラー 翔泳社 大きな仕様である UML の中で重要なポイントを簡潔にまとめた UML のバイブル的書籍です。 マーチンファウラーの名前は、『リファクタリング』や『アナリシスパターン』といった書籍で目にした人も多いでしょう。 長年オブジェクト指向に携わってきたファウラー氏のまとめたエッセンスに振れれば、UML の重要なポイントを効率よく一気に学ぶことができます。 本書は、UML を創ったスリーアミーゴ（Grady Booch、Ivar Jacobson、James Rumbaugh）の推薦図書でもあります。
第1章: UMLの概要 UML の使い方に関する面倒な論争に対するアプローチとして、Steve Mellow と Martin Fowler は、UML の使い方を 3 種類のモードに分類している。
スケッチ（もっとも一般的な使われ方） フォワードエンジニアリング: コードを記述する前に UML ダイアグラムを作成する。 リバースエンジニアリング: 既存のコードを理解する補助手段としてコードから UML ダイアグラムを作成する。 設計図面（blueprint。実装のため完全性を重視） プログラミング言語（Executable UML など。うまくいかず、流行らなかった） UML のユーザーは UML の本質はダイアグラムだと考えている人がほとんだが、UML の作成者は UML の本質はメタモデルであると考えている。ダイアグラムはメタモデルの表現にすぎない。
細部までフォワードエンジニアリングされた設計図面はうまく扱うのが難しく、開発作業の遅れに繋がる。 サブシステムのインタフェースレベルで設計図面を作成するのは合理的だが、実装するのに合わせてインタフェースが変わることを想定しておく必要がある。 このような考えから、著者のマーチン・ファウラーは、UML をスケッチとして使用することを重視している。
UMLダイアグラム一覧と分類 UMLダイアグラムが使用目的に適さない場合は、非UMLダイアグラムを積極的に使うべき。デシジョンテーブルや画面フロー図などは役に立つ。 まずクラス図とシーケンス図の基本形態に集中することをお勧めする。これらは最も一般的であり、最も便利なダイアグラムである。 第2章: 開発プロセス モデリング技術は、それがプロセスにどのように適合するかを理解しなければ、意味を成さない。UMLの使い方は、使用するプロセスのスタイルによってかなり異なる。 ウォーターフォール型プロセスでは、プロジェクトをアクティビティに基づいて分解する。要求分析、設計、コーディング、テストを順番に実行する。 反復型プロセスは、プロジェクトを機能のサブセットで分解する。1年間のプロジェクトでは、3ヵ月ごとの反復に分解することが考えられる。3ヵ月が終わるごとに、必要な機能の1/4がシステムに実装される。 Steve McConnell は、『ラピッドデベロップメント』 の中で、プロセスを組み合わせて使用する方法を説明している。最初の4ヵ月で要求分析と設計をウォーターフォール的に行い、コーディングとテストは2ヵ月の反復を4回繰り返す。 テストと統合は予測の難しいアクティビティであり、このような終了時期の見えにくいアクティビティをプロジェクトの最後に置かないことが重要。 経験から言うと、単体テストのコードは製品本体のコードと同程度の量が必要。 RUP (Rational Unified Process) RUP はプロセスと呼ばれているが、実際にはプロセスのフレームワークである。RUP はプロセスを説明するための語彙と柔軟な構造を提供する。 RUP は本質的に反復型プロセスであり、ウォーターフォール型は RUP の考え方に適合しない。 RUP は UP (Unified Process) に基づいた Rational 社の製品であると考えることができる。また、RUP と UP を同じものと考えることもできる。どちらも正しい。 反復型開発の最大の利点のひとつは、プロセスを頻繁に改良できること。 反復の最後に、チームでその反復を振り返り、次の3つのリスト (KPT) を作成するのがよい。 K: Keep（継続）: 有効に機能していて、今後も継続して行う事項 P: Problem（問題）: 有効に機能していない事項 T: Try（試み）: プロセスを改良するための変更 プロジェクトの最後、または主要なリリース時には、本格的にプロジェクトを振り返るのもよい。参考: https://en.</description></item><item><title>『オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて』スコット・W・アンブラー</title><link>https://maku.blog/p/9kuptdn/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/9kuptdn/</guid><description>オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて スコット・W・アンブラー 日経BP社 原題は『The Object Primer』。 スコット・アンブラーのフルライフサイクルオブジェクト指向テスト (FLOOT: Full Lifecycle Object-Oriented Testing) から、アジャイルな要求やアーキテクチャまでが、1 つにまとめられています。 実践 eXtreme プログラミングの共著者である Granville Miller は、「アジャイルになるとは、チームや自分自身に対する制約を取り払うこと」だと述べています。 本書ではその方法の神髄を学ぶことができます。
下記、重要そうなところや、個人的にビビッと来たところのメモです。
第1章: 最先端のソフトウェア開発 下記がアジャイルアライアンスのマニフェストであり、そこに集まった異なる方法論者全員に受け入れられたものである。 Individuals and interactions over processes and tools
プロセスやツールよりも個人や相互作用 すばらしいプロセスやツールは重要だが、結局は人の協力関係がすべて。 Working software over comprehensive documentation
わかりやすいドキュメントよりも動作するソフトウェア ドキュメントはシステムがなぜ、どのように構築されたか、どう使えばよいかを理解するためには重要。 Customer collaboration over contract negotiation
契約上の駆け引きよりも顧客との協調 契約は重要だが、契約を結んだからといってコミュニケーションが必要なくなるわけではない。 Responding to change over following a plan
計画を硬直的に守ることよりも変化への対応 プロジェクト計画は必要だが、柔軟でなければならない。ガントチャートを何枚も作成する必要はなく、非常に単純なものでよい。 自己組織化されたチームとは、チームのリーダーが開発メンバーの各自の役割や作業範囲を決めるのではなく、目標を共有するメンバーが共同作業を行う過程でチームの能力が最大限発揮されるようにメンバーの役割が自然に決まっていくようなチーム形態のこと。 成功を収めている組織は、大抵アジャイルなソフトウェア開発アプローチをとっているか、RUP または EUP を採用しているかのどちらかだ。RUP をアジャイルに使おうとしても現実には非常に困難（素材が多すぎてアジャイルなレベルまで切り詰められない）。アジャイルプロセスを取り入れたいなら、XP や FDD などを採用すべき。 MDA よりも、アジャイルモデル駆動開発 (AMDD: Agile Model-Driven Development) アプローチの方が、お絵かき式のモデリング方法に近く、現実的に大多数の開発者が採用できるアプローチである。 第2章: オブジェクト指向概念の基本 この章にはオブジェクト指向を知らない人のために、その概念について書かれています。</description></item><item><title>読書メモ『ワークブック形式で学ぶ UML オブジェクトモデリング─ユースケース駆動でソフトウェアを開発する』ダグ・ローゼンバーグ、ケンドール・スコット</title><link>https://maku.blog/p/d3ehztz/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/d3ehztz/</guid><description>ワークブック形式で学ぶ UML オブジェクトモデリング ダグ・ローゼンバーグ、ケンドール・スコット ソフトバンククリエイティブ 「ユースケースと UML モデリングの例題がもっと必要だ」という声がきっかけになり書かれた本です。 ユースケースという抽象的な表現から、どのようなステップで具体的なコードにまで落とし込んでいくかが説明されています。 このような開発をユースケース駆動と呼んでおり、提唱者の Ivar Jacobson によると、ユースケース駆動は下記のように説明されています。
システム機能を変更する場合は、適切なアクタとユースケースを再モデル化します。 システムアーキテクチャ全体は、ユーザの要求にそって構築されます。 すべてのモデルはトレースできるようにしておくと、新しい要求仕様が発生した際にもシステムの修正が可能になります。 ユーザに対し、変更したい部分（もしくは変更したいユースケース）の内容を確認し、ほかのモデルの中でどの部分を変更するかを見極めます。
本書の著者、ダグ・ローゼンバーグはこれを以下のように簡単に解釈しています。
ユーザマニュアルを書けば、コードも書ける。
第1章: はじめに ここで用いる ICONIX プロセスは、重量級の RUP（ラショナル統一プロセス）と、軽量級の XP (eXtreme Programming) の間に位置する。具体的で理解しやすいユースケースが作成できるという点で、Ivar Jacobson が構想した「ユースケース駆動」の意味に一致している。 ソフトウェアプロジェクトの進捗はどれだけのコードを書いたかによって測定されることが多いので、プロジェクトはコーディングに移行しようとする。そして、モデリングが十分にできていない段階でコーディングが始まってしまう。 本書の目的は、ソフトウェアプロジェクトにおいて、よい仕事をするために通常必要と思われる UML（およびモデリング全般）の、最小限ではあるが、十分なサブセットを定義すること。 what（要求）と how（詳細）のギャップを埋めることが ICONIX プロセスの中心課題である。ロバストネス図を使って、あいまいで漠然としたユースケース（要求レベルのビュー）と、詳細で正確なシーケンス図（設計レベルのビュー）のギャップを解消する。ロバストネス図を使用せずにユースケースからシーケンス図を作成することは非常に難しい。ロバストネス分析は、要求と設計のギャップを解消するのにとても役に立つ。 ギャップの解消するためには、ロバストネス分析の中で、下記のような作業を並行して行っていく。 見落としていたオブジェクトを見つける。 データフローをトレースする際に、クラスに属性を追加する。 ロバストネス図を描きながら、ユースケース記述を更新し洗練する。 ドメインモデルで定義した「用語」を使ってロバストネス図を描く。 ユースケースモデル ⇔ ロバストネス図 ⇒ シーケンス図 図: ICONIX プロセス全体像 ICONIX プロセス: プロトタイプを作る（おそらく画面の簡単な描画）。 クライアントに誤りがないかを確認してもらう。 ユースケース図のユースケースを識別する。 ユースケース記述を書く。 ロバストネス分析でユースケース記述を洗練する。 第2章: ドメインモデリング ドメインモデリングでは、UML モデルの静的な部分の基礎を形成する。 ドメインモデルは実世界の問題空間オブジェクトを中心に構成するので、ソフトウェアの要求ほど頻繁には変化しない。 ドメインモデルは、ユースケースを記述する作業の初期段階で使用できる「用語集」の役割を果たす。 ドメインモデリングでは、属性と操作の把握には時間を費やさない。後の作業で明らかになった属性と操作を追加していけばよい。 ドメインモデリングでは、オブジェクト間の関係（汎化や集約）を識別することに焦点を当てる。 ソフトウェアが再利用できるかどうかは、このドメインモデリング作業にかかっている。 ドメインモデリングの誤りトップ10 ドメインモデリングのコツはすばやく作ること。ブラッシュアップは後のロバスト分析などの過程で行っていけばよい。</description></item><item><title>読書メモ『ダイアグラム別 UML 徹底活用』井上樹</title><link>https://maku.blog/p/xfgoaq3/</link><pubDate>Wed, 30 May 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/xfgoaq3/</guid><description>ダイアグラム別UML徹底活用 第2版 井上 樹 翔泳社 （全13章）
1章: モデリングのメリットを考える モデリングの連続の末にプログラムというモデルの最終形態に辿り着くことが、システムを開発するということ。 図によるモデル化のメリット 情報量が多い 理解しやすい 誤解が少ない UML2.0 について ダイアグラムが10種類から13種類に増加（コンポジット図、相互作用概要図、タイミング図）し、次のようなことをモデル化できるようになった。 複数のインスタンスを内包するクラスの内部構造 複数のインタラクションの時系列上の流れ 複数のインスタンス間でのメッセージのやり取りと、それに伴う状態変化 ダイアグラム名称の一部変更 ステートチャート図 → ステートマシン図 コラボレーション図 → コミュニケーション図 「フレーム」が追加され、ダイアグラム全体を囲んだ入り、一部を囲んで説明を加えることができるようになった。ダイアグラムの一部をフレームとして囲んだところを畳み込めば、大きなダイアグラムでも全体を見渡しやすくなる。 2章: ユースケース図の注意点と使いどころ ユースケースは、**「こういうものを作るんだ」**ということを明らかにするために描く。 関連を結んだアクター＝ユースケースの起動者ではない。関連はあくまで関わり合いがあることだけを示す。 UML2.0 におけるユースケースの変更点は、extend の関係に対してノートで条件を書けるようになったこと。 役立つユースケースにするには 目的／読者を確認する 名前付けに注意する 抽象度: 「一般会員」や「レジ係」というように文章に出てくるくらいの抽象度がよい。 正確性: 対象を明示する（例: 貸出→ビデオを貸し出す、返却→ビデオの返却を受け付ける） 表現の統一: 同じ意味を示す言葉は揃える（例: 「貸し出す」と「レンタルする」） 粒度を揃える 機能分割にしない: 機能単位で描くと粒度が細かくなりすぎて、そのモデル化した対象がどんなサービスを提供しているのかわからなくなってしまう。サービスで分割することを意識する。 ≪include≫は1段階まで: 2段階以上にするとアクターにとって意味のある粒度のユースケースになりにくい。 ≪include≫、≪extend≫、汎化関係を混同しない ≪include≫: ≪include≫先のユースケースは必ず必要になることを意味する。プログラムの関数呼び出しのような感じで、複数のユースケースから共有できる（例: ビデオを借りる─include→会員かどうかを確認する）。 ≪extend≫: ≪extend≫でベースになっているユースケースにサービスを付加した場合は、ベースとなるユースケースの実行には≪extend≫で定義したユースケースは必ずしも必要ない（例: ビデオを借りる←extend─カードで料金を払う）。逆に、≪extend≫で定義されたユースケースを実行するには、必ずベースのユースケースが必要になる。 汎化関係: 汎化関係は機能を追加するのではなく、概念だけ共通だがまったく新しいユースケースを定義する（例: ビデオを借りる←汎化─ビデオを宅配で借りる）。 ユースケース記述と合わせる: ユースケース図だけでは誤解を招きやすいので、ユースケース図を描いたら、ユースケース記述も合わせて作成する。ユースケース図とユースケース記述を合わせて**「ユースケースモデル」**と呼んだりする。 3章: ユースケース記述の注意点と使いどころ ユースケース記述の概要 ユースケース記述はシステム開発の初期にユースケース図と一緒に作られ、システム外部から（利用者から）見たときの振る舞いを明確にする。 特に担当者を入れ替えながら開発が進んでいくプロジェクトなどでは、開発者間でシステムイメージを共有できるということは重要。 ユースケース記述は書くのに非常に手間のかかる成果物だが、システム開発に一貫したゴールを与えることができるのは大きなメリット。ユースケースのレベルで再利用できるようになると、より楽をできるようになる。 ユースケース駆動開発 ユースケースは進捗を計るベースとして使用できる。ユースケースを一単位とすると、代替フローや例外フローが含まれているため、作業単位の粒度としては大きくなりすぎることがある。そのような場合、ユースケース記述に書かれた**「シナリオ」を作業単位とする**とよい。 ユースケース駆動開発では、ユースケースのシナリオごとに、(1)分析、(2)設計、(3)実装、(4)テストという作業を進めていく。ユースケースを実現できたかどうか（それぞれのステップが完了したかどうか）のポイントは下記の通り。 分析: 分析のクラス図に書かれているクラス群を使って、ユースケース記述に書かれたシナリオを実現する相互作用図（シーケンス図、コレボレーション図）を作ることができる 設計: 設計のクラス図に書かれているクラス群を使って、ユースケース記述に書かれたシナリオを実現する相互作用図（シーケンス図、コラボレーション図）を作ることができる 実装: シナリオを実現するためのプログラムが書けている テスト: シナリオに書いてある通りにシステムが動いている ユースケース記述のテストへの活用 ユースケース記述に書かれた振る舞いは、要求元と合意されたものとなるので、テストケースの元ネタとして使うことができる。 テストケースとシナリオは対応するものなので、テストを意識してシナリオリストを作成すると、テストケースの作成が容易になる。イベントフロー（メインフロー＋代替フロー＋例外フロー）の組み合わせを網羅する形でシナリオリストを作るのがコツ。 イベントフローは３種類 メインフロー: 正常に処理が進んだ場合。 代替フロー: 正常系の代わり（エラーが発生した場合など）。代替フローを実行した場合でも事後条件は満たされる。 例外フロー: ユースケースの実行を断念しなければならないような場合。例外フローを実行した場合は事後条件は満たされない。 ユースケース記述のポイント 厳密に漏れなく書く 曖昧性のない厳密な記述がされており、システムの振る舞いが具体的に理解できること。 ユースケース記述の作成と合わせて用語集を作成するとよい。 イベントフローの書き出しは「アクターは～」、「システムは～」と動作の主語を必ず書く。 システムで実現すべきことはすべてユースケースに書かれているようにする 仕様変更が発生した場合など、ユースケース記述はこまめにメンテナンスする。 細かくしすぎない エンドユーザにもわかるレベルで記述する（エンドユーザーと開発者が共有するものなので）。ユーザマニュアルのようなレベルを想定するとちょうどよい。 データベースのテーブルや、画面レイアウト、画面遷移を意識する記述が出てきたら危険。 イベントフローに「システムは～する」という記述が連続して 4 ～ 5 ステップ続いたら詳細になりすぎている可能性が高い。 危険なワード: DB、テーブル、クエリ、キー、ID、コネクション、チャネル、セッション、トランザクション、ロック、ボタン、クリック、入力欄、インタフェース 補足資料を使う 文章だけで記述するのではなく、アクティビティ図や、スケッチ、表なども併用すればよい。 空欄を作らない ユースケース記述のフォーマットには項目がたくさんあるが、空白状態で放置しない。「T.</description></item></channel></rss>