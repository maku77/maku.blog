<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>プログラム on まくろぐ</title><link>https://maku.blog/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0/</link><description>Recent content in プログラム on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Wed, 18 Jul 2018 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>１時間で分かる GoF デザインパターン</title><link>https://maku.blog/p/7gmjvza/</link><pubDate>Tue, 13 May 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/7gmjvza/</guid><description>&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797311126/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/61zDpaqhh7L.jpg" alt="オブジェクト指向における再利用のためのデザインパターン">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">オブジェクト指向における再利用のためのデザインパターン&lt;/div>
 &lt;div class="xAmazon_info_author">エリック ガンマ, ラルフ ジョンソン, リチャード ヘルム, ジョン ブリシディース&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797327030/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/71aAui0y3bL.jpg" alt="増補改訂版Java言語で学ぶデザインパターン入門">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">増補改訂版Java言語で学ぶデザインパターン入門&lt;/div>
 &lt;div class="xAmazon_info_author">結城 浩&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,R0lGODlhbQAcAPYVAAAAABANBx8ZDSghEDQpFT4yGQAAZhkXbjAseUs8HlVEIl9MJmtWK3NcLntjMW5YZUE/kFNSln9/soZsNo9zOZp7PplmZqKBQauJRbaRSb2XS7iUU8yZM/+ZAf+nC/+lF/+tJP+0Lv+4O8SdT8uiUdCmU9OpVditVt2xWeuzT+O2W+a4XOq8X+6+X/++Rf/ATv/EVvLBYPfGY/zJZP/MZv7UeK+vz/zXgf/hmv/oucfH3tra6fXuyv//zO3t9P///6usrQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAUAAEAALAAAAABtABwAAAf+gD+Cg4SFhoeIiYqLjI2OiBCRkpIGlZaXmJmam5ydnp+eBxARhxA6jz2pqqusra6vsLGys6o5NxsPpISmPzw0OYy0wsPExa84NBsQg7w0v4I6EhAHBqISpz+2ztvc3d7f4OHi4+TbNTg1NLmCy77AOxLUmQcSO9np5fn6++EkACbibqRQxu7HMx0RPEU4lYOfw4f5YlyQEZDDiQMF3yX8FMEeMm4ZJlA44exEhhkaKlDEoHJbyAkAaZjIoKFmzBMVLsxwRkIDDZYUXTbAsK3FBAckt6GgQQLlBJImTKxwZtFAQUESMB1AwJWrPAMSfvTA16IAgLMAMtBQAIDAWQL+bAEMcJYALQCfZtEWoHEBrQAWNAQAyEtgG4W2ABrQWBFAgFufTAHEGECgMYASKBhMoMrB6o9lP3R8hWBjhw8fgnzAq3SAobMJbVcwAJBgLYAADc4GmA2Ahb8BKxwAWEBjRAXYACrMOKshtwIaAwAI4L10+QUaGQC0SCDAmYIAPAHIEByDBoG5LcrT4ND5atZqNhLtsBS2IY0YJ1SwEF54AQAK5qUVGABLnYACC7A954x/e/W1VwtnBeiTYCQUB8A2DpQAwHUyAUCShuM54Ex2LXDDnmegQVAJAhJEEAlXEIT1w3yVtLPNBAHoRYN/15lVoWBLUZDjWQr2FUCJwj3+txwAKrhVAnSX0VABeNvEAMAIzqxwFw0gClCBMyZ4aGJ7PyAgyFeb2GODJRgZRENuA8SAwWA7JhcgloKxoIF0LexJnJYAEEUDbLUtyYJbFUb3JAZU3qelWjSoAECFXQLY4VLbnHimIPMs9J4971UiiDPRKTZbd/596RaeveVGXG57uSVdARhoCN6ec0WXaJQQTqXlCQIQJ+WFHY5X26AA7JQpmWb+IM8BEdSDlQHNblTNqHVKh5YK/gEYnU85rjCntmcBOoBg4NU1pFo5YtluAyMoIMAFAsw15wQVADBBBkiJF50D+Yo4JoqCuGgDaoO8J+NoYjkTQwMEFGBCBV/+XpAAlg4kQBIDCSAZcQk50aCBei0QNQMDjgnaQAJLrYxCAhjIkEAAHTtDgQACbEbBAif4u7IAinWj6WepFWKDtaeEClY24bjwkAsgeOBBCBCRo+EMXoYzNATAELKDtQaQQiNrroEjggci8APD2lFXHU4MCwQwVwCbgbN1Dl3bEA8m8alIX8PivOBBByC8UM4LIHSAONVufyMDAwwAlgGm39ytkSbRXNLRDx+NI0IHoH8AggguvGC6CyKE8EHoL8zggbKNV303DdCAzZrmZecjwuqg9+474YbTAIPTsbvNXptcO/PO3vNIywM+xUcvPQ0pcIBBs5EARjs00lBjDTZd2kwvfuPVc7AOOxCwxwELXR+SAwvqxy///PTXb//9+Od/vwUs7pJ+/CkIoADLp78CGvCACLQfBh7Qv0JMYhIIAIUEJ0jBCkpwK9F6hAY3yMEOevCDIAyhCEf4g0AAADs=" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>デザインパターンの輪講をしたときのメモ。&lt;/p>
&lt;h2 id="生成に関するパターン-creational-patterns">生成に関するパターン (Creational Patterns)&lt;/h2>
&lt;h3 id="1-abstract-factory-パターン">(1) Abstract Factory パターン&lt;/h3>
&lt;p>同種の複数のオブジェクト生成を concrete factory クラスとして種類ごとにまとめ、実際の生成は abstract factory クラスの抽象化されたインタフェース経由で行う。&lt;strong>一貫した種類のインスタンスを作ることができる&lt;/strong>。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実装イメージ&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">TvFactory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tvFactory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SonyTvFactory&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// Sony 製の TV を作るための TvFactory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">tvFactory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">CreatePanel&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// SonyPanel を生成&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">tvFactory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">CreateTuner&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// SonyTuner を生成&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>どのような手順で factory method を呼び出すかを定義すると、それは Builder パターンになる。&lt;/p>
&lt;h3 id="2-builder-パターン">(2) Builder パターン&lt;/h3>
&lt;p>オブジェクトの&lt;strong>生成手順を共通化&lt;/strong>して使いまわし、異なるオブジェクトを作成。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実装イメージ&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Product&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Director&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">CreateProduct&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Builder&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CreateStep1&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CreateStep2&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CreateStep3&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">GetProduct&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記のメソッドに異なる Builder オブジェクトを渡せば、異なる Product が生成される。ただし、作成手順は共通化されている。&lt;/p></description></item><item><title>『オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて』スコット・W・アンブラー</title><link>https://maku.blog/p/9kuptdn/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/9kuptdn/</guid><description>&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4822282376/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/51RhYKQT2qL.jpg" alt="オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">オブジェクト開発の神髄 UML2.0を使ったアジャイルモデル駆動開発のすべて&lt;/div>
 &lt;div class="xAmazon_info_author">スコット・W・アンブラー&lt;/div>
 &lt;div class="xAmazon_info_publisher">日経BP社&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>原題は『The Object Primer』。
スコット・アンブラーのフルライフサイクルオブジェクト指向テスト (FLOOT: Full Lifecycle Object-Oriented Testing) から、アジャイルな要求やアーキテクチャまでが、1 つにまとめられています。
実践 eXtreme プログラミングの共著者である Granville Miller は、「アジャイルになるとは、チームや自分自身に対する制約を取り払うこと」だと述べています。
本書ではその方法の神髄を学ぶことができます。&lt;/p>
&lt;p>下記、重要そうなところや、個人的にビビッと来たところのメモです。&lt;/p>
&lt;h2 id="第1章-最先端のソフトウェア開発">第1章: 最先端のソフトウェア開発&lt;/h2>
&lt;ul>
&lt;li>下記が&lt;a href="https://www.agilealliance.org">アジャイルアライアンス&lt;/a>のマニフェストであり、そこに集まった異なる方法論者全員に受け入れられたものである。
&lt;ul>
&lt;li>&lt;b>&lt;strong>Individuals and interactions&lt;/strong> over processes and tools&lt;/b>&lt;br>
プロセスやツールよりも個人や相互作用
&lt;ul>
&lt;li>すばらしいプロセスやツールは重要だが、結局は人の協力関係がすべて。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>&lt;strong>Working software&lt;/strong> over comprehensive documentation&lt;/b>&lt;br>
わかりやすいドキュメントよりも動作するソフトウェア
&lt;ul>
&lt;li>ドキュメントはシステムがなぜ、どのように構築されたか、どう使えばよいかを理解するためには重要。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>&lt;strong>Customer collaboration&lt;/strong> over contract negotiation&lt;/b>&lt;br>
契約上の駆け引きよりも顧客との協調
&lt;ul>
&lt;li>契約は重要だが、契約を結んだからといってコミュニケーションが必要なくなるわけではない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>&lt;strong>Responding to change&lt;/strong> over following a plan&lt;/b>&lt;br>
計画を硬直的に守ることよりも変化への対応
&lt;ul>
&lt;li>プロジェクト計画は必要だが、柔軟でなければならない。ガントチャートを何枚も作成する必要はなく、非常に単純なものでよい。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>自己組織化されたチーム&lt;/strong>とは、チームのリーダーが開発メンバーの各自の役割や作業範囲を決めるのではなく、目標を共有するメンバーが共同作業を行う過程でチームの能力が最大限発揮されるようにメンバーの役割が自然に決まっていくようなチーム形態のこと。&lt;/li>
&lt;li>成功を収めている組織は、大抵アジャイルなソフトウェア開発アプローチをとっているか、RUP または EUP を採用しているかのどちらかだ。RUP をアジャイルに使おうとしても現実には非常に困難（素材が多すぎてアジャイルなレベルまで切り詰められない）。アジャイルプロセスを取り入れたいなら、XP や FDD などを採用すべき。&lt;/li>
&lt;li>MDA よりも、アジャイルモデル駆動開発 (AMDD: Agile Model-Driven Development) アプローチの方が、お絵かき式のモデリング方法に近く、現実的に大多数の開発者が採用できるアプローチである。&lt;/li>
&lt;/ul>
&lt;h2 id="第2章-オブジェクト指向概念の基本">第2章: オブジェクト指向概念の基本&lt;/h2>
&lt;p>この章にはオブジェクト指向を知らない人のために、その概念について書かれています。&lt;/p></description></item><item><title>読書メモ『パターン指向リファクタリング入門』ジョシュア・ケリーエブスキー</title><link>https://maku.blog/p/2j4w6nn/</link><pubDate>Fri, 29 Jun 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/2j4w6nn/</guid><description>&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4822282384/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/51FBETlRf5L.jpg" alt="パターン指向リファクタリング入門">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">パターン指向リファクタリング入門&lt;/div>
 &lt;div class="xAmazon_info_author">ジョシュア・ケリーエブスキー&lt;/div>
 &lt;div class="xAmazon_info_publisher">日経BP社&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>マーチン・ファウラーの『リファクタリング』の続編のような本で、デザインパターンを活用しながら、どのようにソフトウェアの設計を改善しけばよいかを示しています。
パターンの知識を付けるだけでなく、&lt;strong>パターンの賢い使い方を知る&lt;/strong>ことをテーマとしています。&lt;/p>
&lt;p>この本の特徴として、現実のコード、あるいは実際に使用したコードを元にしたコードが使用されている点が挙げられます。
実際のプロジェクトにはリファクタリングに関して多くの制約があり、それは作り物のコードでは体験できないものです。&lt;/p>
&lt;p>以下は全11章のメモです。&lt;/p>
&lt;h2 id="第1章-本書を執筆した理由">第1章: 本書を執筆した理由&lt;/h2>
&lt;ul>
&lt;li>コードを必要以上に柔軟にしたり洗練させることは、作り込みすぎ (over-engineering) である。チームのプログラマたち（特に新しく参加した人たち）は、無意味に大きく複雑なコードベースを扱わなければならなくなる。&lt;strong>作り込みすぎは生産性を低下させる&lt;/strong>。作り込みすぎな設計を引き継ぐ場合、&lt;strong>拡張や保守を行うのに多大な時間がかかる&lt;/strong>。&lt;/li>
&lt;li>とはいうものの、作り込み不足 (under-engineering) は作り込みすぎよりずっと多い。&lt;/li>
&lt;li>&lt;strong>TDD と継続的なリファクタリングのリズムを身に着ける&lt;/strong>には経験と時間が必要だが、この開発スタイルに慣れてしまえば、&lt;strong>別の方法で実稼働するコードを作成することは奇妙で、不安で、プロフェッショナルらしくないと感じるようになる&lt;/strong>。&lt;/li>
&lt;li>優れた設計を行いたいなら、設計そのものを調べるよりも、&lt;strong>その設計がどのように進化してきたかを知らべる方が有益だ&lt;/strong>。真の知恵は進化の中に存在する。&lt;/li>
&lt;/ul>
&lt;h2 id="第2章-リファクタリング">第2章: リファクタリング&lt;/h2>
&lt;ul>
&lt;li>コードが明確でない臭いの元は、リファクタリングで取り除くべきであって、コメントで脱臭するべきではない。そのようなコードをリファクタリングをするときは、そのコードをよく理解している人に立ち会ってもらうのが一番である。&lt;/li>
&lt;li>実際に&lt;strong>リファクタリングを促すものは感情だ&lt;/strong>。私はコーディングの不快感を少しでも減らすためだけにリファクタリングを行うことがよくある。&lt;/li>
&lt;li>マーチンファウラーの言葉「コンパイラが理解できるコードは誰にでも書ける。&lt;strong>すぐれたプログラマは、人間にとってわかりやすいコードを書く&lt;/strong>。」&lt;/li>
&lt;li>小さい単純なステップに分けることで、大きなステップよりも間違いなく早く目標にたどり着くことができる。&lt;/li>
&lt;li>&lt;strong>アプリチームとフレームワークチームを1つのチームに&lt;/strong>しておけば、それらがちぐはぐになることがない。フレームワークはアプリのニーズにもとづいて作られるので、価値のあるフレームワークのコードだけが作成される。ただし、&lt;strong>このプロセスには継続的なリファクタリングが必須&lt;/strong>である。それによって、フレームワークとアプリを分けておくことができる。&lt;/li>
&lt;/ul>
&lt;h2 id="第3章-パターン">第3章: パターン&lt;/h2>
&lt;ul>
&lt;li>パターン魔 (patterns happy) は、パターンに魅了され、コードでパターンを使わずにいられなくなった人。誰しもがパターンを学ぶ過程でパターン魔になる。リファクタリングによってパターンを徐々にシステムに組み込んでいくようにすれば、パターンによって作り込みすぎる可能性は低くなる。&lt;/li>
&lt;li>残念なことに&lt;strong>多くプログラマは、デザインパターン本に例示されている各パターンの構造の図が、そのパターンを実装する唯一の方法だと間違えて捉えている&lt;/strong>。『デザインパターン』の共著者の一人であるジョン・ブリシデスも、「実際のコードにはいろいろなニーズや制約があり、示されている構造の図とは大きく異なってくる」と述べている。例示されている構造をそのまま実装するのではなく、&lt;strong>パターンの実装を必要最小限に抑えることは、進化的設計のプラクティスである&lt;/strong>。目的は設計をよりよくすることであって、パターンを実装することではないことを忘れないこと。&lt;/li>
&lt;li>一般的には、パターンを実装することで、コードの重複を取り除き、ロジックを単純化し、意図を伝えやすくし、柔軟性を高めることができるはずである。しかし、パターンに慣れていない人がコードを読むと、わかりにくい、複雑すぎると感じることがある。このような&lt;strong>意見の食い違いが発生した場合は、パターンの使用をやめるより、チームがパターンを学ぶ方がよい&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="第4章-コードの臭い">第4章: コードの臭い&lt;/h2>
&lt;ul>
&lt;li>もっともよくある設計の問題は、次のようなコードが原因である。
&lt;ul>
&lt;li>重複している&lt;/li>
&lt;li>不明確である&lt;/li>
&lt;li>複雑である&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>メソッドの適した行数はどのくらいであろうか？&lt;strong>ほとんどのメソッドが1～5行のコードからできているものが適切&lt;/strong>だと私は考えている。小さなメソッドを連鎖させても、性能はほとんど低下しない。プロファイラを使えば明らかである。&lt;/li>
&lt;/ul>
&lt;h2 id="第5章-パターンを取り入れるリファクタリングのカタログ">第5章: パターンを取り入れるリファクタリングのカタログ&lt;/h2>
&lt;p>この章では、この本の読み進め方が述べられています。&lt;/p>
&lt;h2 id="第6章-生成">第6章: 生成&lt;/h2>
&lt;h3 id="creation-method-によるコンストラクタの置き換え-replace-constructors-with-creation-methods">Creation Method によるコンストラクタの置き換え (Replace Constructors with Creation Methods)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 1つのクラスに複数のコンストラクタがあると、開発時にどのコンストラクタを使うかの判断が難しくなる。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: コンストラクタの代わりに、意図がわかりやすい Creation Method を作成し、それがオブジェクトのインスタンスを返すようにする。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>どのような種類のインスタンスが返されるかがコンストラクトよりもよく伝わる。&lt;/li>
&lt;li>引数の数と型が同じであるコンストラクタを2つ作成できないといった、コンストラクタの制限事項を回避できる。&lt;/li>
&lt;li>使われていない生成コードを見つけるのが簡単になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 生成方法が標準に準拠しなくなる。new によってインスタンスを生成するクラスと「Creation Method」を使うクラスとが混在する。&lt;/li>
&lt;/ul>
&lt;h3 id="factory-による生成処理の置き換え-move-creation-knowledge-to-factory">Factory による生成処理の置き換え (Move Creation Knowledge to Factory)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: クラスのインスタンス化に使うデータやコードが数多くのクラスに散在している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 生成に関する知識を1つの Factory クラスに移動する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>生成ロジックとインスタンス化／設定のための情報をまとめられる。&lt;/li>
&lt;li>クライアントを生成ロジックから切り離すことができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 直接のインスタンス化に比べて設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;h3 id="factory-によるクラス群の隠蔽-encapsulate-classes-with-factory">Factory によるクラス群の隠蔽 (Encapsulate Classes with Factory)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 1つのパッケージ内に存在して共通のインタフェースを実装しているクラス群を、クライアントが直接インスタンス化している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: クラスのコンストラクタをパブリックでなくし、クライアントには Factory 経由でインスタンスを生成させる。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>さまざまな種類のインスタンスの生成を、意図が明確なメソッド経由で行うことで、単純化できる。&lt;/li>
&lt;li>公開する必要のないクラスが隠蔽されるため、パッケージの「概念的重み」(by Bloch) を減らすことができる。&lt;/li>
&lt;li>「インタフェースに対してプログラミングするのであって、実装に対してプログラミングするのではない」（書籍『デザインパターン』より）という原理を厳しく適用できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>
&lt;ul>
&lt;li>新しい種類のインスタンスを生成しなければならない場合には、Creation Method の新規作成や変更が必要になる。&lt;/li>
&lt;li>Factory のソースコードではなくバイナリコードにしかアクセスできない場合には、カスタマイズが制限される。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="factory-method-によるポリモーフィックな生成の導入-introduce-polymorphic-creation-with-factory-method">Factory Method によるポリモーフィックな生成の導入 (Introduce Polymorphic Creation with Factory Method)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 階層内のクラスが、オブジェクトの生成ステップを除いて同じようにメソッドを実装している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: そういったメソッドをスーパークラスで1つにまとめ、そこで Factory Method を呼び出してインスタンス化の処理を行う。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>オブジェクトを生成するステップが異なることが原因で生じている重複が減る。&lt;/li>
&lt;li>どこで生成が行われているか、どのようにオーバーライドされているかが効果的に伝えられる。&lt;/li>
&lt;li>Factory Method で使うためにクラスがどの型を実装しなければならないのかが明確になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: Factory Method を実装するクラスに不必要な引数を渡さなければならないことがある。&lt;/li>
&lt;/ul>
&lt;h3 id="builder-による-composite-の隠蔽-encapsulate-composite-with-builder">Builder による Composite の隠蔽 (Encapsulate Composite with Builder)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: Composite の構築処理が何度も出現したり、複雑であったり、あるいはエラーを起こしやすいものになっている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 詳細部分を Builder に任せることで、構築を単純化する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>Composite を構築するクライアントコードを単純化できる。&lt;/li>
&lt;li>Compsoite の生成にまつわる繰り返しやエラーを軽減できる。&lt;/li>
&lt;li>クライアントと Composite の間の結合度が低くなる。&lt;/li>
&lt;li>カプセル化された Composite や複合オブジェクトを異なった形式で表現できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: インタフェースの意図が伝わりにくくなる可能性がある。&lt;/li>
&lt;/ul>
&lt;h3 id="singleton-のインライン化">Singleton のインライン化&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: コードからあるオブジェクトにアクセスしなければならないが、グローバルなアクセス方法は必要でない。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Singleton の機能を1つのクラスに移し、そのクラスにオブジェクトを格納してアクセス手段を提供する。Singleton は削除する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>オブジェクトの協調関係がより見えやすく明示的になる。&lt;/li>
&lt;li>唯一のインスタンスを保護するための特別なコードを必要としない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: いくつもの層を経由してオブジェクトインスタンスを渡すのが面倒だったり困難だったりする場合には、設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;h2 id="第7章-単純化">第7章: 単純化&lt;/h2>
&lt;h3 id="メソッドの構造化-compose-method">メソッドの構造化 (Compose Method)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: メソッドのロジックをすぐに理解できない。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 意図の伝わりやすい、詳細レベルが揃った小さなステップ群にロジックを変換する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>メソッドが何をし、それをどのように行うかが効果的に伝わる。&lt;/li>
&lt;li>詳細レベルが揃った、わかりやすい名前がついた振る舞いに分割することで、メソッドを単純化できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>小さなメソッドが増えすぎることがある。&lt;/li>
&lt;li>多数の小さなメソッドにロジックが分散するため、デバッグが困難になることがある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="strategy-による条件判断の置き換え-replace-conditional-logic-with-strategy">Strategy による条件判断の置き換え (Replace Conditional Logic with Strategy)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: いくつかの計算方法のうちどれを実行するかを、メソッド内の条件ロジックで制御している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 計算方法ごとに Strategy を作成し、元のメソッドは計算処理を Strategy のインスタンスに委譲する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>条件ロジックが減る、あるいは取り除かれるため、アルゴリズムが明白になる。&lt;/li>
&lt;li>アルゴリズムのバリエーションをクラス階層に移すため、個々のクラスが単純になる。&lt;/li>
&lt;li>実行時にアルゴリズムを別のものに置き換えることができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>継承による解決策や「条件記述の単純化」のリファクタリングを使った方が簡単な場合には、それよりも設計が複雑になる。&lt;/li>
&lt;li>アルゴリズムがコンテキストクラスとデータをやり取りする方法が複雑になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="decorator-による拡張機能の書き換え-move-embellishment-to-decorator">Decorator による拡張機能の書き換え (Move Embellishment to Decorator)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: コードがクラスの核となる責務に対する拡張機能を提供している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 拡張機能を Decorator に移動する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>拡張機能が取り除かれるのでクラスを単純にできる。&lt;/li>
&lt;li>クラスの核となる責務と拡張機能とを効果的に区別できる。&lt;/li>
&lt;li>関連する複数のクラスに含まれる重複した拡張ロジックを取り除くことができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>装飾対象のオブジェクトと装飾後のオブジェクトは異なるものになってしまう。&lt;/li>
&lt;li>コードを理解したりデバッグしたりするのが困難な場合がある。&lt;/li>
&lt;li>Decorator を組み合わせた際、互いに悪影響を及ぼす場合には、設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="state-による状態変化のための条件判断の置き換え-replace-state-altering-conditionals-with-state">State による状態変化のための条件判断の置き換え (Replace State-Altering Conditionals with State)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: オブジェクトの状態遷移を制御する条件式が複雑である。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 条件式ではなく、個々の状態とその間の遷移を扱う State クラスを使う。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>状態を変えるための条件ロジックがなくなる、あるいは減る。&lt;/li>
&lt;li>状態を変える複雑なロジックが単純になる。&lt;/li>
&lt;li>状態を変えるロジックを俯瞰することができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 状態遷移ロジックがもともとわかりやすい場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h3 id="composite-による暗黙的なツリー構造の置き換え-replace-implicit-tree-with-composite">Composite による暗黙的なツリー構造の置き換え (Replace Implicit Tree with Composite)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: String などの基本データ型の表現によって、暗黙的なツリー構造を作っている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 基本データ型の表現を Composite で置き換える。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>ノードの形成、追加、削除といった手順の繰り返しをカプセル化できる。&lt;/li>
&lt;li>同じようなロジックの増殖に対処する汎用的な方法となる。&lt;/li>
&lt;li>クライアントの構築作業が簡単になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 暗黙的なツリー構造を作成するほうが簡単な場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h3 id="command-による条件付きディスパッチャの置き換え-replace-conditional-dispatcher-with-command">Command による条件付きディスパッチャの置き換え (Replace Conditional Dispatcher with Command)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 条件ロジックによってリクエストを振り分け、アクションを実行している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: アクションごとに Command を作成する。Command をコレクションに格納し、条件ロジックを Command を取り出して実行するコードに置き換える。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>一律に同じやり方で、さまざまな振る舞いを実行するためのシンプルなメカニズムである。&lt;/li>
&lt;li>どのリクエストをどのように処理するかを実行時に変更できる。&lt;/li>
&lt;li>実装するためのコードが少ししか必要でない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 条件付きディスパッチャで用が足りる場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h2 id="第8章-汎用化">第8章: 汎用化&lt;/h2>
&lt;h3 id="template-method-の形成-form-template-method">Template Method の形成 (Form Template Method)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 複数のサブクラスの2つのメソッドが、同じ順番で似たようなステップを実行しているが、それらのステップはまったく同じではない。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 各ステップを同じシグニチャを持つメソッド群に抽出してメソッドを汎用化し、それから汎用メソッドを引き上げて Template Method を形成する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>不変な振る舞いをスーパークラスに移すことで、サブクラス間の重複したコードを取り除くことができる。&lt;/li>
&lt;li>汎用のアルゴリズムのステップを簡潔にし、効果的に伝えることができる。&lt;/li>
&lt;li>サブクラスで簡単にアルゴリズムをカスタマイズできるようになる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: アルゴリズムを肉付けするためにサブクラスで多くのメソッドを実装しなければならない場合には、設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;h3 id="composite-の抽出-extract-composite">Composite の抽出 (Extract Composite)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 階層内のサブクラスが同じ Composite を実装している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Composite を実装するスーパークラスを抽出する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>子に関する格納と処理の両ロジックの重複をなくすことができる。&lt;/li>
&lt;li>子を処理するロジックを継承することが効果的に伝わる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 特になし。&lt;/li>
&lt;/ul>
&lt;h3 id="composite-による単数複数別の処理の置き換え-replace-onemany-distinctions-with-composite">Composite による単数・複数別の処理の置き換え (Replace One/Many Distinctions with Composite)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: あるクラスが、1つのオブジェクトの場合と複数のオブジェクトの場合とを別のコードで処理している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Composite を使って、1つのコードで、1つのオブジェクトの場合と複数オブジェクトの場合との両方を処理できるようにする。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>単数または複数のオブジェクト処理に関するコードの重複を取り除く。&lt;/li>
&lt;li>単数または複数のオブジェクトを統一したやり方で処理できる。&lt;/li>
&lt;li>複数オブジェクトの処理機能が豊富になる（OR表現など）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: Composite の構築時にタイプセーフかどうかの実行時チェックが必要なことがある。&lt;/li>
&lt;/ul>
&lt;h3 id="observer-によるハードコードされた通知の置き換え-replace-hard-coded-notifications-with-observer">Observer によるハードコードされた通知の置き換え (Replace Hard-Coded Notifications with Observer)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 別のクラスの1つのインスタンスに対する通知がサブクラスにハードコーディングされている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Observer インタフェースを実装した任意のクラスの任意の数のインスタンスにスーパークラスが通知を送れるようにし、サブクラスを削除する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>観察対象と観察者の間の結合度が低くなる。&lt;/li>
&lt;li>観察者が単数の場合にも複数の場合にも対処できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>ハードコーディングされた通知で用が足りる場合には、設計が複雑になる。&lt;/li>
&lt;li>通知がカスケードしている場合には、設計が複雑になる。&lt;/li>
&lt;li>観察対象から観察者が削除されないと、メモリリークが起きる可能性がある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="adapter-によるインタフェースの統合-unify-interfaces-with-adapter">Adapter によるインタフェースの統合 (Unify Interfaces with Adapter)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: クライアントが2つのクラスと相互作用していて、その1つが好ましいインタフェースを持っている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Adapter によってインタフェースを統合する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>クライアントコードが同じインタフェースを通じて複数のクラスとやり取りできるため、コードの重複をなくしたり減らしたりできる。&lt;/li>
&lt;li>共通のインタフェースを通じてオブジェクトやり取りできるため、クライアントコードが簡潔になる。&lt;/li>
&lt;li>クライアントが複数のクラスとやり取りする方法を統合できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: アダプタを作らなくてもクラスのインタフェースを変更できる場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h3 id="adapter-の抽出-extract-adapter">Adapter の抽出 (Extract Adapter)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 1つのクラスが、コンポーネント、ライブラリ、API、あるいは他のエンティティの複数バージョンに対するアダプタになっている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: コンポーネント、ライブラリ、API、あるいは他のエンティティのバージョンごとに Adapter を1つ抽出する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>コンポーネントやライブラリや API のバージョンごとの違いを切り分けることができる。&lt;/li>
&lt;li>クラスの責務を1つのバージョンに対応することだけに限定できる。&lt;/li>
&lt;li>頻繁なコードの変更が必要な部分を限定できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: Adapter で提供されていない重要な振る舞いをクライアントが使えなくなることがある。&lt;/li>
&lt;/ul>
&lt;h3 id="interpreter-による暗黙的な言語処理の置き換え-replace-implicit-language-with-interpreter">Interpreter による暗黙的な言語処理の置き換え (Replace Implicit Language with Interpreter)&lt;/h3>
&lt;p>ある言語の文法に関して、実装する必要のあるクラスが10程度までなら、Interpreter パターンを使ってモデリングするのが有効かもしれない。&lt;/p></description></item><item><title>C# で Microsoft Outlook の情報を取得する</title><link>https://maku.blog/p/eb5nx4z/</link><pubDate>Mon, 18 Jun 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/eb5nx4z/</guid><description>&lt;p>組織内で Outlook を使用している場合は、プログラムから Outlook の情報（Exchange サーバの情報）を取得してごにょごにょすると、日々の作業を効率化できるかもしれません。
ここでは、C# から Outlook の情報を取得する方法を紹介します。&lt;/p>
&lt;p>プログラミング言語に C# を使っていますが、もともとは VBA などのインタフェース (COM) として使われていたものなので、本格的にコーディングするときは、VBA のリファレンスが参考になります。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://msdn.microsoft.com/ja-jp/vba/vba-outlook">Outlook VBA リファレンス｜MSDN&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以下のサンプルは、Visual Studio Community 2017 を使って確認しています。
Visual Studio で新規のプロジェクト（ここではシンプルにコンソールアプリを選択）を作成したら、まずは次のようにして Outlook のインタフェースの参照を追加してください。&lt;/p>
&lt;ol>
&lt;li>プロジェクト(P) → 参照の追加(R)&lt;/li>
&lt;li>COM → &lt;strong>Microsoft Outlook 14.0 Object Library&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>次のコードは、現在 Outlook を使用しているユーザの名前とメールアドレス、および上司の名前とメールアドレスを表示します。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="nn">System&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="nn">Outlook&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Microsoft&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Office&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Interop&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Outlook&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">namespace&lt;/span> &lt;span class="nn">ConsoleApp1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">class&lt;/span> &lt;span class="nc">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="n">Outlook&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Application&lt;/span> &lt;span class="n">outlookApp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Outlook&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Application&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Exchange ユーザの情報を表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ShowRecipientInfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Outlook&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ExchangeUser&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Name&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 名前&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">PrimarySmtpAddress&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// メールアドレス&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">Main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// カレントユーザーの情報を表示&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Outlook&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Recipient&lt;/span> &lt;span class="n">rcp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">outlookApp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">CurrentUser&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Outlook&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ExchangeUser&lt;/span> &lt;span class="n">currentUser&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">rcp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">AddressEntry&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetExchangeUser&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ShowRecipientInfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currentUser&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 上司の情報を表示&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Outlook&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ExchangeUser&lt;/span> &lt;span class="n">manager&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">currentUser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetExchangeUserManager&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">manager&lt;/span> &lt;span class="p">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ShowRecipientInfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">manager&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>


&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">Yamada Taro
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yamada-taro@example.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Tokoro George
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tokoro-george@example.com&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://msdn.microsoft.com/ja-jp/library/office/bb612741.aspx">Office - Dev Center - 操作方法 (Outlook リファレンス)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Groovy をインストールする</title><link>https://maku.blog/p/vtfddwb/</link><pubDate>Fri, 30 May 2014 00:00:00 +0900</pubDate><guid>https://maku.blog/p/vtfddwb/</guid><description>&lt;h2 id="macosx-に-groovy-をインストールする">MacOSX に Groovy をインストールする&lt;/h2>
&lt;p>&lt;strong>GVM: Groovy enVironment Manager&lt;/strong> を使うと複数バージョンの Groovy を管理することができます。
ここでは、GVM を使って Groovy の環境をインストールする手順を示します。&lt;/p>
&lt;h3 id="1-gvm-のインストール">1. GVM のインストール&lt;/h3>
&lt;pre tabindex="0">&lt;code>$ curl -s get.gvmtool.net | bash
&lt;/code>&lt;/pre>&lt;p>これで、&lt;code>.bash_profile&lt;/code> に以下のように追加されて &lt;code>gvm&lt;/code> コマンドにパスが通ります。&lt;/p>
&lt;pre tabindex="0">&lt;code>#THIS MUST BE AT THE END OF THE FILE FOR GVM TO WORK!!!
[[ -s &amp;#34;/Users/maku/.gvm/bin/gvm-init.sh&amp;#34; ]] &amp;amp;&amp;amp; source &amp;#34;/Users/maku/.gvm/bin/gvm-init.sh&amp;#34;
&lt;/code>&lt;/pre>&lt;h3 id="2-gvm-で-groovy-のインストール">2. GVM で groovy のインストール&lt;/h3>
&lt;pre tabindex="0">&lt;code>$ gvm list groovy # インストール可能なバージョン確認
$ gvm install groovy # 最新版のインストール
$ gvm install groovy 2.3.2 # バージョンを指定してインストール
&lt;/code>&lt;/pre>&lt;p>これで、&lt;code>groovy&lt;/code> や &lt;code>groovysh&lt;/code> コマンドが使用できるようになります。
使用中の &lt;code>groovy&lt;/code> のバージョンの確認、切り替えは以下のように行います。&lt;/p></description></item><item><title>ソフトウェア開発手法のまとめ</title><link>https://maku.blog/p/herfwex/</link><pubDate>Sun, 04 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/herfwex/</guid><description>&lt;ul>
&lt;li>XP (eXtream Programming)
&lt;ul>
&lt;li>Kent Beck が指揮。&lt;/li>
&lt;li>12 のプラクティスがあり、それぞれが連携している。&lt;/li>
&lt;li>顧客との連携を重視する。「オンサイト顧客」というプラクティスでは、開発チームに顧客を含めてしまう。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SCRUM
&lt;ul>
&lt;li>マイクロソフトで発祥。&lt;/li>
&lt;li>マネジメントに焦点を当てたプロセス。&lt;/li>
&lt;li>それぞれの役割に、強い権力付けがされているのが特徴。&lt;/li>
&lt;li>1ヶ月のスプリントの間、スクラムマスターはスクラムチームを外の雑音から守る。&lt;/li>
&lt;li>約10分で終わるスタンドアップミーティングで一日を始める。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>クリスタル
&lt;ul>
&lt;li>Alistair Cockburn が提唱するプロジェクトのテンプレート群。&lt;/li>
&lt;li>メンバー数などから、クリスタルクリア、イエロー、オレンジ、レッドと分類される。&lt;/li>
&lt;li>規模が大きくなると、ドキュメントを多く作るような規則になっていく。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ASD (Adaptive Software Development)
&lt;ul>
&lt;li>Jim Highsmith と Sam Bayer が作成。&lt;/li>
&lt;li>RAD (Rapid Application Development) の考えから作成されたアジャイル開発プロセス。&lt;/li>
&lt;li>複雑性の理論により、「Speculate（推測） ➡ Collaborate（強調） ➡ Learn（学習）」の繰り返しでプロジェクトを順応させていく。&lt;/li>
&lt;li>大規模開発は、メンバー数を増やすことで可能にする。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>リーン開発
&lt;ul>
&lt;li>Poppendieck 夫妻が提唱。&lt;/li>
&lt;li>無駄を省きながらプロジェクトを進める開発手法。&lt;/li>
&lt;li>プロジェクト開発中の待ち時間になっている部分を少なくすることでプロジェクトを短期間に終わらせようとする考え。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FDD (Feature Driven Development)
&lt;ul>
&lt;li>ボーランドが提唱。&lt;/li>
&lt;li>開発の単位を「機能」とする。&lt;/li>
&lt;li>機能のリリースは2週間単位。&lt;/li>
&lt;li>機能の完成度は「赤：未着手」「黄：作業中」「緑：完成」の3段階のみで表現。&lt;/li>
&lt;li>機能単位で担当を割り当てる。クラス単位で担当を決めることで、人同士のやり取りが、クラス間のやり取りに等しくなるという利点がある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TDD (Test Driven Development)
&lt;ul>
&lt;li>XP と同じ Kent Beck が提唱。&lt;/li>
&lt;li>XP のテストファーストの考え方を、プロセス全体に適用したもの。&lt;/li>
&lt;li>GUI の開発であっても、クラスを疎結合にすることで、テストの自動化を考える。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Linux の system 関数で任意のプログラムを実行する</title><link>https://maku.blog/p/neegpac/</link><pubDate>Wed, 22 Jun 2011 00:00:00 +0900</pubDate><guid>https://maku.blog/p/neegpac/</guid><description>&lt;p>Linux の &lt;code>system&lt;/code> 関数は、プログラムの起動に失敗すると -1 を返します。
また、戻り値を &lt;code>WEXITSTATUS&lt;/code> マクロにかけると、呼び出したプログラム自体の終了コード（正常時は 0）を取得することができます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp"> &lt;/span>&lt;span class="c1">// system(), WEXITSTATUS
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">bool&lt;/span> &lt;span class="nf">doSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">command&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;ERROR: Cannot execute [%s]&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">command&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">exitStatus&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">WEXITSTATUS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">exitStatus&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;ERROR: [%s] returns error %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">exitStatus&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>『アジャイルソフトウェア開発の奥義』ロバート・C・マーチン（輪講メモ）</title><link>https://maku.blog/p/fn9ris5/</link><pubDate>Mon, 27 Oct 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/fn9ris5/</guid><description>&lt;p>今回読み進める本は、『アジャイルソフトウェア開発の奥義』です。
第2版までは日本語版が出てます。内容的にはどの版のものを読んでも大丈夫。&lt;/p>
&lt;h3 id="第1版">第1版&lt;/h3>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797323361/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/51YANQY595L.jpg" alt="アジャイルソフトウェア開発の奥義">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">アジャイルソフトウェア開発の奥義&lt;/div>
 &lt;div class="xAmazon_info_author">ロバート・C・マーチン&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;h3 id="第2版">第2版&lt;/h3>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797347783/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/71cDOUiJvPL.jpg" alt="アジャイルソフトウェア開発の奥義 第2版 オブジェクト指向開発の神髄と匠の技">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">アジャイルソフトウェア開発の奥義 第2版 オブジェクト指向開発の神髄と匠の技&lt;/div>
 &lt;div class="xAmazon_info_author">ロバート・C・マーチン&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;h3 id="第3版">第3版&lt;/h3>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/0131857258/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/81EjDm%2BYl8L.jpg" alt="Agile Principles, Patterns, and Practices in C#">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">Agile Principles, Patterns, and Practices in C#&lt;/div>
 &lt;div class="xAmazon_info_author">Robert C. Martin&lt;/div>
 &lt;div class="xAmazon_info_publisher">Prentice Hall&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>ちなみに版が進むごとにサンプルコードの言語がより高水準な言語に変わっています。&lt;/p>
&lt;ul>
&lt;li>第1版: C/C++&lt;/li>
&lt;li>第2版: Java&lt;/li>
&lt;li>第3版: C#&lt;/li>
&lt;/ul>
&lt;p>第1版と第2版の内容はほとんど一緒だけど、第3版には各種ダイアグラムに関する説明の Chapter.14～20 が追加で挿入されています。
C/C++ のコードで読みたい場合は、書店からなくなる前に第1版を買っておいた方がよいです。&lt;/p>
&lt;p>以下、各章ごとのポイントや議論のメモです。&lt;/p>
&lt;h2 id="preface序文----2006-05-30---">Preface（序文） &lt;!-- 2006-05-30 -->&lt;/h2>
&lt;ul>
&lt;li>単なるパターン集ではなく、そのパターンが「なぜ」生き残ったのかという過程を知ることが大切。&lt;/li>
&lt;li>著者 Robert C. Martin（Object Mentor 社の創設者。社長）は、11個のオブジェクト指向の原則をまとめている。それに従って設計することで、デザインパターンですら導き出される。&lt;/li>
&lt;/ul>
&lt;h2 id="section-i-agile-developmentアジャイル開発">Section I: Agile Development（アジャイル開発）&lt;/h2>
&lt;h4 id="議論">▼議論&lt;/h4>
&lt;ul>
&lt;li>&lt;b>Q. アジャイルを大規模な開発に適用できるか？&lt;/b>&lt;br>
当初は大規模開発に適さないのでは？という懸念があったが、結果として大規模開発においてもアジャイル開発が主流になりつつある。ただ、いつものことだが日本では普及が遅れている。&lt;/li>
&lt;/ul>
&lt;p>大規模プロジェクトにおけるアジャイル開発に関しては、下記の記事や書籍が参考になる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www-06.ibm.com/jp/software/rational/agile/index.html">IBM Rational アジャイル開発&lt;/a>
&lt;ul>
&lt;li>(そのうち3分の1は従業員数10,000人以上) の88%がアジャイル・プロセスを使用中または評価中である&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>書籍: 『The Object Primer（邦題: オブジェクト開発の神髄）』
&lt;ul>
&lt;li>アジャイルソフトウェア開発の長所の一つ: 規模の大小を問わずうまくいく。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="http://www.atmarkit.co.jp/im/carc/serial/redge/72/01.html">The Rational Edge (72) アジャイル開発の広範な普及を目指して&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.atmarkit.co.jp/farc/rensai/redge27/redge27a.html">The Rational Edge (28) 大規模プロジェクトにアジャイルを適用する方法&lt;/a>
&lt;ul>
&lt;li>「この大規模プロジェクトがアジャイル手法で管理できるのか？ 」という疑問が出てくる。その答えはイエスだ。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="http://martinfowler.com/articles/agileOffshore.html">アジャイルソフトウェアプロセスを使ってオフショア開発（English）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://andore.com/money/trans/agileOffshore_ja.html">アジャイルソフトウェアプロセスを使ってオフショア開発（日本語）&lt;/a>
&lt;ul>
&lt;li>分析と設計はオンショアで行い、構築をオフショアで行い、そして受入試験をオンショアで行うというやり方よりも、&lt;strong>オフショアのチームにできるだけ多くの工程をやらせると問題が改善される&lt;/strong>。&lt;strong>作業工程に沿って分けるのではなく、機能面に沿った分割を行う&lt;/strong>。&lt;/li>
&lt;li>バグフィクスからやらせると、開発者は変更するよりも多くのコードを読むことになるので、コードベースに精通することができた。&lt;/li>
&lt;li>&lt;strong>オフショア開発においては、ドキュメントを作成するための時間を確保する&lt;/strong>必要がある。&lt;/li>
&lt;li>最低限、IM と Wiki、良質の電話回線を用意すること。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="chapter-1-agile-practicesアジャイルプラクティス----2006-05-30---">Chapter 1. Agile Practices（アジャイルプラクティス） &lt;!-- 2006-05-30 -->&lt;/h3>
&lt;ul>
&lt;li>プロジェクトをうまくまわすために&lt;strong>ルールやプロセスをどんどん導入してしまうと、逆に重くなってうまくいかない&lt;/strong>。
&lt;ul>
&lt;li>重いプロセスのせいで開発ペースが落ちる ⇒ まだプロセスが足りないと思い込む ⇒ ルールやプロセスを追加する ⇒ 悪循環…&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>マネージャーは開発環境を構築する前にチームを構築するべき。環境はチームメンバーに最適化させるのがよい。&lt;/li>
&lt;li>高価なツールを導入する前に小さなところから始める。
&lt;ul>
&lt;li>まずはフリーのツールを実際に使ってみて、本当に使えるのか試してみる。&lt;/li>
&lt;li>CASE (Computer-Aided Software Engineering) ツールの前にホワイトボードやグラフ用紙を使ってみる。&lt;/li>
&lt;li>大きなデータベースを使う前にプレーンテキストファイルを使ってみる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドキュメントに関して
&lt;ul>
&lt;li>&lt;b>Martin のドキュメントに関する第一法則&lt;/b> … &lt;strong>重要で差し迫った必要のあるドキュメント以外は作成しない&lt;/strong>。&lt;/li>
&lt;li>読みやすいドキュメントを用意する必要はあるが、多すぎるドキュメントは、少なすぎるドキュメントよりもたちが悪い。ドキュメントが多すぎると、ソースコードを変更したときにドキュメントを修正して整合性を保つのに時間がかかる。&lt;strong>メンテナンスされていないドキュメントが存在していると、そこには嘘が書かれていることになり、逆に混乱を招く&lt;/strong>。ソースコードは嘘をつかない。&lt;/li>
&lt;li>ドキュメントは手短に、洗練されたものだけ用意するのがよい。ドキュメントは長くても12ページ～24ページ（1、2ダース）に保ち、&lt;strong>抽象度の高い設計構造を示したドキュメントを用意するとよい&lt;/strong>。新メンバーが参入した場合に、より&lt;strong>詳細な設計構造を教えたい場合は、隣に座ってコミュニケーションを取るのが効率がよい&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>プロジェクト成功の鍵
&lt;ul>
&lt;li>顧客との密接な協調関係を築くこと。&lt;/li>
&lt;li>「コスト」や「納期」などの条件を決める契約ではなく、&lt;strong>「相互の協調関係」について取り決めた契約書を用意する&lt;/strong>。「近くで一緒に働こう」といったものがよい。&lt;/li>
&lt;li>うまくいった一例としては、「顧客側の受け入れテストに合格した機能ブロックの分だけ対価を支払う」という契約がある。どのように受け入れテストを行うかなどの詳細は契約では決めていない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>計画は日程がずれるだけでなく、形そのものが変わっていくもの。
&lt;ul>
&lt;li>&lt;b>詳細な予定&lt;/b> … 2週間先まで決める。&lt;/li>
&lt;li>&lt;b>大まかな計画&lt;/b> … 3ヶ月先まで決める。&lt;/li>
&lt;li>それ以外は柔軟にしておく。システムがどんな形になるのかを把握するくらいでよい。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="chapter-2-overview-of-extreme-programming----2006-05-30---">Chapter 2. Overview of Extreme Programming &lt;!-- 2006-05-30 -->&lt;/h3>
&lt;p>この章には XP の概要が書かれている。&lt;/p></description></item><item><title>クワイン・マクラスキー法 (Quine-McCluskey algorithm)</title><link>https://maku.blog/p/m4x8mcw/</link><pubDate>Fri, 20 Jun 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/m4x8mcw/</guid><description>&lt;p>カルノー・マップを用いた Bool 演算の簡易化のような処理を、単純な処理の繰り返しで行えるようにしたもの。コンピュータでの処理に向いている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%82%A4%E3%83%B3%E3%83%BB%E3%83%9E%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%AD%E3%83%BC%E6%B3%95">クワイン・マクラスキー法 - Wikipedia&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Petrick%27s_Method">Petrick&amp;rsquo;s method - Wikipedia&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>無名サブルーチンとクロージャ</title><link>https://maku.blog/p/r58xbyk/</link><pubDate>Wed, 30 Apr 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/r58xbyk/</guid><description>&lt;p>『初めての Perl 第3版』より&lt;/p>
&lt;blockquote>
&lt;p>クロージャ (closure) は非常に強力な概念で、Lisp の世界から持ってきたものです。クロージャとは、（荒っぽい言い方をすれば）自分自身のプライベートなデータを持っている無名サブルーチンです。&lt;/p>
&lt;/blockquote>
&lt;p>『続・初めての Perl』より&lt;/p>
&lt;blockquote>
&lt;p>その時点で存在するすべてのレキシカル変数に、宣言された時点からアクセスできるサブルーチンをクロージャ (closure) と呼びます（クロージャは、もともとは数学用語です）。&lt;/p>
&lt;/blockquote>
&lt;p>例えば、以下の &lt;code>callback&lt;/code> サーブルーチンは、レキシカル変数 &lt;code>$count&lt;/code> を参照するクロージャといえます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-perl" data-lang="perl">&lt;span class="line">&lt;span class="cl">&lt;span class="k">my&lt;/span> &lt;span class="nv">$count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">sub&lt;/span> &lt;span class="nf">callback&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="nv">$count&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>数値計算系のプログラムメモ</title><link>https://maku.blog/p/m3p8hh6/</link><pubDate>Sat, 20 Oct 2001 00:00:00 +0900</pubDate><guid>https://maku.blog/p/m3p8hh6/</guid><description>&lt;h2 id="n-が-2-のべき乗か判定する">n が 2 のべき乗か判定する&lt;/h2>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">long&lt;/span> &lt;span class="nf">powerof2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item></channel></rss>