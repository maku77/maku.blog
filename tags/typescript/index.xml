<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on まくろぐ</title><link>https://maku.blog/tags/typescript/</link><description>Recent content in TypeScript on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 02 Oct 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScriptの型: 基本型（プリミティブタイプ）の一覧</title><link>https://maku.blog/p/2uds9o4/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/2uds9o4/</guid><description>プリミティブ型 (primitive types) 下記のプリミティブ型は、JavaScript が内部的な型情報として扱うものであり、TypeScript のタイプアノテーションでも同様に使用することができます。 型名がすべて小文字になっているのが特徴的です。
boolean（真偽値） let isDone: boolean = false; （true または false） number（数値） let decimal: number = 6; （10進数リテラル） let hex: number = 0xf00d; （16進数リテラル） let octal: number = 0o744; （8進数リテラル） let binary: number = 0b1010; （2進数リテラル） string（文字列） let name: string = 'Maku'; （シングルクォートとダブルクォートは同様） let msg: string = `Hello, ${name}`;（変数展開する場合はバッククォート） function（関数） function foo(): number { return 100; } let bar: () =&amp;gt; number = foo bigint（巨大整数） let x: bigint = 1n; （ES2020 移行） symbol（ユニークなシンボル） let sym: symbol = Symbol('key'); （ES2015 移行） undefined（変数が初期化されていないことを示す） オブジェクト型 (object) 上記の型以外は、JavaScript の世界ではすべて object 型とみなされます。 TypeScript のタイプアノテーションでは、変数に格納できる値の型をより明確に示すことができます。</description></item><item><title>TypeScript とは</title><link>https://maku.blog/p/tdouo5p/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tdouo5p/</guid><description>TypeScript は、JavaScript に静的な型付けを行えるようにしたプログラミング言語です。 トランスパイラ (tsc コマンド）を使って、TypeScript で記述したコードを JavaScript のコードに変換するのが主な使い方になります。 大規模な JavaScript アプリケーションを開発するときに TypeScript を導入すると、品質の高いコードを効率よく作成できるようになります。
TypeScript はマイクロソフトによって開発が進められており、同じくマイクロソフトによって開発されている Visual Studio Code でコーディングを行うのがよいとされています。
数年前に CoffeeScript と呼ばれる同様の言語が一時的にブームになりましたが、現在は TypeScript が主流です。 TypeScript には下記のような特徴があり、しばらくは JavaScript alternative として主流であり続けるでしょう。
Microsoft により強力にサポートされており、Visual Studio Code が最新の TypeScript バージョンに迅速に対応します。 静的な型付けにより、実行前（トランスパイル時）にコーディングのミスを発見しやすくなります。型の推論がしやすくなるため、IDE（VS Code など）のプロパティ名の自動補完が効くようになります。これがほんとに便利で、特にサードパーティ製のライブラリを使っているときにありがたみが分かります。 JavaScript (ECMAScript) の新しい仕様を使ってコーディングできます。TypeScript が新しい構文で書かれたコードを過去バージョンの JavaScript コードに変換してくれるため、各ブラウザベンダーが新しい仕様に対応するのを待つ必要がありません。 JavaScript のコードは有効な TypeScript のコードとして動作します（構文に互換性があります。専門用語では JavaScript の「スーパーセット」であると言う）。そのため、既存の JavaScript プロジェクトに TypeScript を導入しようとするとき、既存の JavaScript コードを修正する必要がありません。また、これまでに身に着けた JavaScript のノウハウをそのまま活かし続けることができます。</description></item><item><title>Node.js で Amazon S3 を操作する (AWS SDK)</title><link>https://maku.blog/p/m8kv8it/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/m8kv8it/</guid><description>ここでは、Node.js 用の AWS SDK を使って Amazon S3 を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
S3 用の Node.js SDK をインストールする AWS SDK version 3 の S3 用パッケージをインストールするには次のようにします。
### npm の場合 $ npm install @aws-sdk/client-s3 ### yarn の場合 $ yarn add @aws-sdk/client-s3 これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。
main.ts import { S3Client, ListBucketsCommand } from &amp;#39;@aws-sdk/client-s3&amp;#39;; S3Client インスタンスの生成 AWS SDK で S3 の操作を行うには、S3Client オブジェクトを使って各種コマンドを送ります。
new S3Client(configuration: S3ClientConfig): S3Client S3Client コンストラクタには S3ClientConfig オブジェクトを渡すようになっており、接続情報などを指定できます。 空オブジェクト ({}) を渡すと、現在の環境の default プロファイルの設定が使用されます（~/.aws/config と ~/.aws/credentials に設定されたもの）。</description></item><item><title>TypeScript のコーディング規約（ルール／ガイドライン）</title><link>https://maku.blog/p/avssq37/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/avssq37/</guid><description>有名な JavaScript/TypeScript スタイル TypeScript のコーディングスタイルは下記のサイトが参考になります。
スタイルガイド（コーディング規約） - TypeScript Deep Dive 日本語版 TypeScript Deep Dive のスタイルガイドは、重要なポイントが簡潔にまとまっていてわかりやすいです。 standard/standard: JavaScript Standard Style セミコロンの省略を推奨していますが、2021 年時点ではまだセミコロン有り派の方が多いようです。モダンなプログラミング言語では行末にセミコロンを付けないものが多いので、セミコロン省略派が増えてきているというのも何となく頷けます。 関数定義の際に、カッコの前にスペースを強制するところがちょっと気持ち悪いです。 Node.js、npm、GitHub、Electron など有名どころが採用しています。 ドキュメントサイト airbnb/javascript: JavaScript Style Guide Airbnb は JS スタイルを細かく定義しています。ただ、長大すぎるので、重要なポイントをかいつまんで読むのには向いてません。ESLint などのツールを使ってスタイル強制する 場合にもよく使われますが、TypeScript 対応が不完全で、モジュールインポート時の拡張子省略がエラーになったりします（2021-05 時点）。 Coding guidelines · microsoft/TypeScript Wiki TypeScript 自体のコントリビューター用のコーディングガイドラインです。ユーザーレベルの開発プロジェクトに強制するものではないと注記がありますが、多くのルールはそのまま採用できると思います。インデントサイズは 4 とされていますが、多くの TypeScript プロジェクトではインデントサイズは 2 が採用されているので、ここだけ例外的です。 google/styleguide: Google Style Guides JavaScript/TypeScript 以外にもいろいろな言語の Google スタイルが説明されています。 JavaScript/TypeScript の世界では、上記の JavaScript Standard か Airbnb のスタイルの方が人気があるようです。 ESLint 用の設定ファイルはこちら まとめると、多くのスタイルガイドでは次のようなルールが採用されています。
インデントは 2 文字（4 文字を採用しているのはごく一部のプロジェクトのみ） ドキュメンテーションコメントには JSDoc の記法を使う 命名規則 型名（クラス名、列挙型、エイリアスなど）は PascalCase 変数名や関数名は camelCase プライベートプロパティ名を _ で始めない 文字列リテラル は 'シングルクォーテーション' で囲む シングルクォーテーションを含む文字列はダブルクォーテーションで囲んで OK 比較には == ではなく === を使用する。ただし、下記は例外。 obj == undefined &amp;hellip; null あるいは undefined であることのチェック obj !</description></item><item><title>TypeScriptの型: 変数の型指定（タイプアノテーション）の基本</title><link>https://maku.blog/p/ugyw5ee/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/ugyw5ee/</guid><description>TypeScript の特徴は、変数の型を明示的に指定できることです。 この型指定のことを タイプアノテーション (Type annotation) と呼びます。
単純な変数のタイプアノテーション 下記は、文字列、数値、真偽値、配列のタイプアノテーションの例です。
let user: string = &amp;#39;まく&amp;#39;; let age: number = 14; let isActive: boolean = true; let titles: string[] = [&amp;#39;名前1&amp;#39;, &amp;#39;名前2&amp;#39;, &amp;#39;名前3&amp;#39;]; 指定した型と異なる型の値を代入しようとするとエラーになります。
let age: number = 14; age = &amp;#39;100歳&amp;#39;; エラーメッセージ Cannot assign to &amp;#39;age&amp;#39; because it is a constant. 配列や辞書、クラスなどの使い方は下記のページを参考にしてください。
配列を定義する (Array) 辞書型を定義する (Dictionary) クラス定義の基本 (class) 関数のタイプアノテーション 関数の型もアノテーションで示すことができます。
// 文字列を受け取り、何も返さない関数 let logger: (name: string) =&amp;gt; void; // 2つの数値を受け取り、真偽値を返す関数 let equal: (a: number, b: number) =&amp;gt; boolean; これらの変数には、パラメータと戻り値の型が等しく定義された関数のみ代入することができます。</description></item><item><title>TypeScriptの型: 値の型を typeof で調べる</title><link>https://maku.blog/p/ods6iv8/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/ods6iv8/</guid><description>次のサンプルコードでは、それぞれの変数値の型情報を、JavaScript の typeof で調べています（ついでに、Object.prototype.toString.call でもう少し詳しい情報も表示）。
// ヘルパ関数 function printType(x: any) { console.log(`${typeof(x)} ${Object.prototype.toString.call(x)}`); } let booleanValue: boolean = true; printType(booleanValue); //=&amp;gt; boolean [object Boolean] let numberValue: number = 100; printType(numberValue); //=&amp;gt; number [object Number] let stringValue: string = &amp;#39;Hello&amp;#39;; printType(stringValue); //=&amp;gt; string [object String] function func(): number { return 100; } printType(func); //=&amp;gt; function [object Function] let undefinedValue: undefined = undefined; printType(undefinedValue); //=&amp;gt; undefined [object Undefined] let tupleValue: [string, number] = [&amp;#39;Hello&amp;#39;, 100]; printType(tupleValue); //=&amp;gt; object [object Array] let arrayValue: number[] = [1, 2, 3]; printType(arrayValue); //=&amp;gt; object [object Array] let nullValue: null = null; printType(nullValue); //=&amp;gt; object [object Null] let general: any = { name: &amp;#39;Mofu&amp;#39; }; printType(general); //=&amp;gt; object [object Object] let sym: symbol = Symbol(&amp;#39;key&amp;#39;); // ES2015 printType(sym); //=&amp;gt; symbol [object Symbol] let x: bigint = 1n; // ES2020 printType(x); //=&amp;gt; bigint [object BigInt] enum Color { Red, Green, Yellow }; // これは数値と同じ扱い printType(Color.</description></item><item><title>TypeScriptの型: 辞書型を定義する (Dictionary)</title><link>https://maku.blog/p/x3ocp9a/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/x3ocp9a/</guid><description>辞書オブジェクトを作成する JavaScript の配列は、もともと「キー＆値」を扱う連想配列として使用することができますが、TypeScript のタイプアノテーションを使うと、キーの型と値の型 を明示した辞書 (Dictionary) オブジェクトを作成することができます。
次の例では、文字列のキーと、数値の値を持つ辞書オブジェクトを作成しています。
// 辞書オブジェクトを作成する const userAges: { [name: string]: number } = {}; // 辞書オブジェクトを使用する userAges[&amp;#39;maku&amp;#39;] = 14; userAges[&amp;#39;hemu&amp;#39;] = 6; console.log(userAges[&amp;#39;maku&amp;#39;]); //=&amp;gt; 14 console.log(userAges[&amp;#39;hemu&amp;#39;]); //=&amp;gt; 6 間違った型のキーや値を格納しようとするとエラーになります。
userAges[14] = &amp;#39;maku&amp;#39;; // Error!! 辞書型のインタフェースを定義する 単純な辞書 上記の例では、辞書オブジェクトを生成するときに同時にその型を指定していましたが、あらかじめ辞書型を表すインタフェースだけを定義しておくこともできます。 次の UserAges インタフェースは、文字列型のキーと数値型の値を持つ、よくある辞書の定義例です。
// 辞書オブジェクトを作成する interface UserAges { [name: string]: number; } // 使用例 const userAges: UserAges = {}; userAges[&amp;#39;maku&amp;#39;] = 14; console.log(userAges[&amp;#39;maku&amp;#39;]); //=&amp;gt; 14 任意のオブジェクトを値にする辞書 次の UserDictionary インタフェースは、文字列型のキーと User 型の値を持つ辞書型を表しています。</description></item><item><title>TypeScriptの型: 配列を定義する (Array)</title><link>https://maku.blog/p/ttwoetd/</link><pubDate>Wed, 22 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/ttwoetd/</guid><description>TypeScript で配列を定義するには、次のいずれかの方法を使います。
文字列配列を作成する const strArr: string[] = []; const strArr: Array&amp;lt;string&amp;gt; = []; ここでは初期値として空の配列 [] を代入しています。
const で変数を作成していますが、JavaScript の const は変数自体への代入を制限するだけなので、配列の内容を変更することは可能です。
const nums: number[] = []; nums.push(100); nums.push(200); nums.push(300); for (const x of nums) { console.log(x); } 実行結果 100 200 300 参考 TypeScript: タプルを定義する (Tuple types)</description></item><item><title>TypeScriptの型: タプルを定義する (Tuple types)</title><link>https://maku.blog/p/6uzqf4q/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6uzqf4q/</guid><description>タプルの基本 TypeScript のタプル型は、複数の値を保持することのできる型です。 [] 記号を使うところも配列によく似ていますが、それぞれの位置の要素の型を明示しておくことができます。
文字列と数値のタプルを定義する例 let vote: [string, number] vote = [&amp;#39;red&amp;#39;, 100]; // OK vote = [&amp;#39;green&amp;#39;, 200]; // OK vote = [&amp;#39;yellow&amp;#39;, 300]; // OK vote = [&amp;#39;AAA&amp;#39;, &amp;#39;BBB&amp;#39;]; // Error 上記の例では、2 つの値を保持するタプル型変数を定義していますが、3 つ以上の値を保持するタプルを定義することもできます。 配列と同様、タプルの各要素にはインデックスでアクセスできます。
let data: [string, number, number] data = [&amp;#39;maku&amp;#39;, 100, 5]; // インデックスで各要素を参照 console.log(data[0]); //=&amp;gt; maku console.log(data[1]); //=&amp;gt; 100 console.log(data[2]); //=&amp;gt; 5 // ループで各要素を取り出す for (const x of data) { console.log(x); } タプルによる多値関数 タプルを関数の戻り値として使用すると、複数の値を返す「多値関数」として扱うことができます。</description></item><item><title>TypeScriptの型: 関数を定義する (function)</title><link>https://maku.blog/p/tiwamzb/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tiwamzb/</guid><description>TypeScript の関数定義は JavaScript とほぼ同じですが、各パラメータと戻り値に型アノテーション付けることができます。
簡単な関数 次の indent 関数は、指定したレベルのインデント文字列（レベル数x2 の半角スペース）を返します。 TypeScript の型アノテーションで、number 型のパラメータと、string 型の戻り値を持つことを示しています。
function indent(level: number): string { return &amp;#39; &amp;#39;.repeat(level); } console.log(indent(0) + &amp;#39;AAA&amp;#39;); //=&amp;gt; &amp;#39;AAA&amp;#39; console.log(indent(1) + &amp;#39;BBB&amp;#39;); //=&amp;gt; &amp;#39; BBB&amp;#39; console.log(indent(2) + &amp;#39;CCC&amp;#39;); //=&amp;gt; &amp;#39; CCC&amp;#39; 関数オブジェクト 名前なしの関数オブジェクトやアロー関数を使用するときも同様に、パラメータや戻り値の型をアノテートできます。
const add = function(a: number, b: number) { return a + b; }; const sub = (a: number, b: number) =&amp;gt; { return a - b; }; console.log(add(1, 2)); //=&amp;gt; 3 console.</description></item><item><title>TypeScriptの型: インタフェースを定義する (interface)</title><link>https://maku.blog/p/5q5gs4f/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/5q5gs4f/</guid><description>プロパティを定義する 次の例では、2 つのプロパティ x、y を持つインタフェース Point を定義しています。
// Point インタフェースの定義 interface Point { x: number; y: number; } このインタフェースを使って、次のようにオブジェクトを生成することができます。 オブジェクトを生成するときには、インタフェースで定義されているすべてのプロパティに値を設定してやる必要があります。
// Point 型のオブジェクトを生成 const p: Point = { x: 10, y: 20 }; // 内容を出力してみる console.log(`x=${p.x}, y=${p.y}`); //=&amp;gt; x=10, y=20 Java などと異なり、TypeScript ではインタフェース定義さえあれば、上記のようにその型のオブジェクトを生成することができます（Java では厳密にはクラス定義がないとオブジェクトを生成できません）。 そのため、TypeScript では、interface キーワードを使ったインタフェース定義の頻度が高くなります。
TypeScript のインタフェースは、拡張に対してオープンであり、次のように後付けでプロパティを追加することができます。
interface Point { x: number; y: number; } // Point インタフェースにプロパティを追加 interface Point { z: number; } const p: Point = { x: 1, y: 2, z: 3 }; メソッドを定義する インタフェースでは、オブジェクトが持つべきメソッドを定義することができます。 次の Product インタフェースは、2 つのプロパティ name、price の他に、1 つのメソッド calcTotal() を持つ型を示しています。</description></item><item><title>TypeScriptの型: インタフェースのプロパティをオプショナルにする</title><link>https://maku.blog/p/rpfr5fr/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/rpfr5fr/</guid><description>オプショナルプロパティの定義 TypeScript でインタフェースを定義するとき、プロパティ名の末尾に ? を付けると、そのプロパティをオプショナルプロパティとすることができます（関数のオプショナルパラメータと同様です）。
例えば、次の User インタフェースの age プロパティはオプショナルになっているため、User オブジェクトを生成するときに age プロパティの値を省略することができます。
interface User { name: string; age?: number; // age プロパティはオプショナル } const u1: User = { name: &amp;#39;Maku&amp;#39;, age: 5 }; // OK const u2: User = { name: &amp;#39;Maku&amp;#39; }; // OK console.log(u1.age); //=&amp;gt; 5 console.log(u2.age); //=&amp;gt; undefined インタフェースを定義せずに、変数の定義時に型情報を指定する場合も同様です。
let user: { name: string, age?: number }; user = { name: &amp;#39;Maku&amp;#39;, age: 5 }; // OK user = { name: &amp;#39;Maku&amp;#39; }; // OK user = { age: 5 }; // Error オプショナルなプロパティを定義する代わりに、特定の値（例えば -1）を、値がないことを示すために使用するという方法もありますが、プロパティ自体格納せずに undefined としておく方が分かりやすいでしょう。</description></item><item><title>TypeScriptの型: インタフェースのプロパティを読み取り専用にする (readonly)</title><link>https://maku.blog/p/p8ir2ai/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/p8ir2ai/</guid><description>インタフェースのプロパティの前に、 readonly キーワードを付けると、そのプロパティは読み取り専用になり、オブジェクト生成時に格納した値を変更できなくなります。
次の Book インタフェースは 3 つのプロパティを持ちますが、そのうち id プロパティだけがリードオンリーとして定義されています。
interface Book { readonly id: string; // id プロパティはリードオンリー title: string; price: number; } 次の例では Book オブジェクトを作成した後で各プロパティの値を変更しようとしていますが、id プロパティを変更しようとしている部分でトランスパイルエラーになります。
const book: Book = { id: &amp;#39;001&amp;#39;, title: &amp;#39;TypeScript is Awesome&amp;#39;, price: 2300 }; book.id = &amp;#39;002&amp;#39;; // Error: リードオンリープロパティ book.title = &amp;#39;TypeScript is Horrible&amp;#39;; book.price = 800;</description></item><item><title>TypeScriptの型: インタフェースを結合する (交差型: Intersection types)</title><link>https://maku.blog/p/b4i46ah/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/b4i46ah/</guid><description>2 つのインタフェースを &amp;amp; で結ぶと、両方のインタフェースを備えていることを示す新しい型 (交差型: Intersection type) を定義することができます。
interface Foo { foo(): void; } interface Bar { bar(): void; } // インタフェースの結合 type FooAndBar = Foo &amp;amp; Bar; 上記のように定義された FooAndBar インタフェースを実装するクラスは、Foo インタフェースと Bar インタフェースの両方を実装しなければいけません。
class Hoge implements FooAndBar { foo(): void { console.log(&amp;#39;foo!!&amp;#39;); } bar(): void { console.log(&amp;#39;bar!!&amp;#39;); } } const h = new Hoge(); h.foo(); h.bar(); ☝️ 共用体は OR、交差型は AND どちらかの型になることができること示す共用体 (union) が | （OR記号）で定義されるのに対し、両方の性質を持つ交差型 (intersection type) は &amp;amp;（AND記号）を使って定義されます。 意味が直感的に分かりやすいですね。</description></item><item><title>React + TypeScript の環境を整える (1) 自力で webpack 設定する方法</title><link>https://maku.blog/p/m4dmt3a/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/m4dmt3a/</guid><description>React とは Web サイトを作成するときに React を採用すると、HTML をフラットな形でゴリゴリ記述していくのではなく、独自コンポーネント（例: &amp;lt;MyButton&amp;gt; コンポーネント）を定義してまとまりのある単位でサイトを構築していくことができます。 Web Components という同様な技術の標準化が進んでいますが、しばらくは React のようなコンポーネントライブラリが使われるでしょう。
React – ユーザインターフェース構築のための JavaScript ライブラリ ここでは React を使った Web サイト開発用に、下記のようなツールを組み合わた環境を構築します。
React &amp;hellip; コンポーネントベースで Web サイト構築するためのライブラリ TypeScript &amp;hellip; JavaScript を型付けできるようにした言語 webpack &amp;hellip; Web サイトのリソースをバンドルするためのツール この環境構築方法を理解すれば、React を利用した Web サイトをどんどん作ることができます。 ちなみに、上記のすべてのツールは Node.js 上で動作するため、Node.js がインストールされていない場合は先にインストールしてください。
TypeScript、React、webpack のインストール チュートリアルなどでは、create-react-app を使って React アプリの雛形を生成する方法がよく載っていますが、よくわからないモジュールが勝手にインストールされるのは気持ち悪いので、ここでは自力で各モジュールをインストールしてきます。
☝️ create-react-app は使わない方がいい TypeScript ベースの React アプリの雛形を生成するには、create-react-app myapp --template typescript のように実行します。 このコマンドによって作成された雛形をリファレンスにするのがよいかなと思ったのですが、少なくともバージョン 3.4.1 時点で生成される雛形はかなり怪しいです。 例えば、TypeScript の処理系や型定義ファイルが devDependencies ではなく、dependencies でインストールされるようになっていたりします。 最終的に Web サーバーにデプロイするファイル群は webpack で生成（バンドル）することを想定しているので、npm (or yarn) でインストールするモジュールは、 すべて devDependencies（開発用モジュール）としてインストール していきます（Web サーバー側で npm install を実行することはないということです）。</description></item><item><title>TypeScriptの型: クラス定義の基本 (class)</title><link>https://maku.blog/p/qhxet9n/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/qhxet9n/</guid><description>TypeScript のクラスは、Java や Kotlin に似た文法で定義します。 インタフェースの定義に似ていますが、コンストラクタやメソッドを持つことができるという大きな違いがあります。
簡単なクラス 次の Greeter クラスは、1 つのプロパティ、1 つのコンストラクタ、1 つのメソッドを持っています。
class Greeter { // プロパティの定義（デフォルトで public） private name: string; // コンストラクタの定義 constructor(name: string) { this.name = name; } // メソッドの定義（デフォルトで public） greet() { console.log(`Hello, ${this.name}`); } } コンストラクタやメソッドの前に function というキーワードは必要ないことに注意してください。 プロパティやメソッドの可視性は デフォルトで public になるため、外部からアクセスできないようにするには、明示的に private と指定する必要があります。
クラスのインスタンスを生成するには、次のように new キーワードを使用します。
const greeter = new Greeter(&amp;#39;Maku&amp;#39;); greeter.greet(); //=&amp;gt; &amp;#39;Hello, Maku&amp;#39; プロパティ定義の省略 コンストラクタ (constructor()) のパラメータ名の前に、private や public といった可視性を指定すると、プロパティ定義とその値を設定するコードを省略することができます。
次のようなコードは、
class Book { private name: string; constructor(name: string) { this.</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.3 の場合）</title><link>https://maku.blog/p/5mv5dkt/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/5mv5dkt/</guid><description>ここでは、Node.js 用の AWS SDK ver.3 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
DynamoDB 用の Node.js SDK (ver.3) をインストールする まずは、AWS SDK version 3 の DynamoDB 用パッケージをインストールします。 DynamoDB を操作するときに主に次のようなクライアントクラスを使用するのですが、後者の DynamoDBDocumentClient の方は、前者の DynamoDBClient インスタンスをラップして扱いやすくするためのクラスなので、必要に応じてインストールしてください（主にテーブル内のアイテムを扱うときに便利です）。
DynamoDBClient DynamoDB を扱うための基本クラス（DB クライアントと呼ばれる） @aws-sdk/client-dynamodb パッケージが必要 DynamoDBDocumentClient 上記を扱いやすくするためのクラス（Document クライアントと呼ばれる） @aws-sdk/lib-dynamodb パッケージが必要 @aws-sdk/util-dynamodb パッケージも必要っぽい ### yarn の場合 $ yarn add @aws-sdk/client-dynamodb $ yarn add @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント ### npm の場合 $ npm install @aws-sdk/client-dynamodb $ npm install @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb # Document クライアント これで、TypeScript コードから次のようにパッケージ内のクラスをインポートできるようになります。</description></item><item><title>React + TypeScript の環境を整える (2) Parcel を使う方法</title><link>https://maku.blog/p/r7fov4b/</link><pubDate>Sat, 15 Aug 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/r7fov4b/</guid><description>Parcel とは Parcel は、ゼロ設定 をウリとした Web アプリバンドラーです。 React + TypeScript + SCSS + CSS Modules といった環境を自力でセットアップしようとすると なかなか大変な設定が必要 なのですが、Parcel を使うと、開発環境がサクサクッと完成します。
React プロジェクトを作成するときは、create-react-app を使って雛形を生成する方法もありますが、余計なファイルがたくさん作られたりして、あまり分かりやすいとは言えません。 そんなときは Parcel を使ってみると、そのシンプルさに驚くと思います。
Parcel を使うと、次のような機能がほとんど設定なしでいきなり使えます。 コマンドラインオプションの一覧 を見ると、どのような機能があるかをざっと把握することができます。
開発用の Web サーバー機能（HMR: Hot Module Replacement 対応） TypeScript の自動変換（HTML ファイルから直接ロードする記述が可能） PostCSS による CSS 生成（SCSS、ベンダープレフィックス） CSS ファイルのインポート (CSS Modules) JSON ファイルのインポート PNG ファイルのインポート Pug (Jade) による HTML 生成 リリース用の minify また、Parcel は Node モジュールの自動インストール機能を備えており、parcel コマンドで開発用 Web サーバーを起動すると、自動的に依存モジュールをインストールしてくれます。 例えば、HTML ファイルから TypeScript ファイルを読み込んでいると、typescript モジュールが自動的にインストールされます。</description></item><item><title>TypeScriptの型: クラスに static プロパティを定義する</title><link>https://maku.blog/p/2snuk25/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/2snuk25/</guid><description>TypeScript のクラス内に、static（静的）なプロパティを定義するには、その名の通り static キーワードを付けるだけで済みます。
下記の例では、MyClass クラスの中に DEBUG という static プロパティを定義しています。 このプロパティを参照するときは、クラス名を前に付けて、MyClass.DEBUG と記述します。
class MyClass { static DEBUG: boolean = true; hello() { if (MyClass.DEBUG) { console.log(&amp;#39;hello!&amp;#39;); } } } const obj = new MyClass(); obj.hello(); static プロパティに、さらに readonly キーワードを付加することで、読み取り専用にすることができます（TypeScript 2.0 移行）。
static readonly DEBUG: boolean = true; 参考 TypeScript: クラス定数を定義する (static readonly)</description></item><item><title>TypeScriptの環境: tsconfig.json の基本</title><link>https://maku.blog/p/27m3brm/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/27m3brm/</guid><description>tsconfig.json があれば TypeScript プロジェクト tsconfig.json は TypeScript の設定ファイルであり、このファイルが置かれたディレクトリが TypeScript プロジェクトのルートディレクトリだとみなされます。 tsconfig.json の記述内容は空っぽ（{} の2文字）でも正しい設定ファイルであり、その場合は、すべてデフォルトの設定値で動作することになります。
TypeScript のトランスパイラである tsc コマンドを実行すると、カレントディレクトリにある tsconfig.json が読み込まれてトランスパイラの動作設定が行われます。 tsconfig.json が見つからない場合は、親ディレクトリを上りながらファイルを探します。 つまり、tsc コマンドは TypeScript のプロジェクト内であれば、どのディレクトリからでも実行できます。
変換対象とするファイルを指定する (files/include/exclude) 最も大切な設定は、TypeScript のトランスパイラがどのファイルを変換対象とみなすかの設定です。 入力ファイルの指定は、設定ファイルの最上位プロパティとして指定する files、include、exclude プロパティを使って行います。
ファイル名を 1 つずつ指定する (files) tsconfig.json { &amp;#34;files&amp;#34;: [ &amp;#34;index.ts&amp;#34;, &amp;#34;module1.ts&amp;#34;, &amp;#34;module2.ts&amp;#34; ] } files プロパティを使って、変換対象の TypeScript ファイルを 1 ファイルずつ指定することができます。
ファイル名のパターン（グロブ）で指定する (include) tsconfig.json { &amp;#34;includes&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;exclude&amp;#34;: [ &amp;#34;node_modules&amp;#34;, &amp;#34;**/*.spec.ts&amp;#34; ] } include プロパティを使用すると、ファイルグロブを使って変換対象とするファイルを指定できます。 ファイルグロブは、下記のようなワイルドカードを使ってファイル名をパターン指定する仕組みです。
** は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータも含みます） * は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータは含みません） ?</description></item><item><title>DynamoDB を Node.js で操作する（SDK ver.2 の場合）</title><link>https://maku.blog/p/8t7iu6g/</link><pubDate>Sat, 01 May 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/8t7iu6g/</guid><description>ここでは、Node.js 用の AWS SDK ver.2 を使って Amazon DynamoDB を操作する方法を説明します。 TypeScript の基本的な環境構築 は終わっているものとします。
SDK ver.3 を使う方法はこちらの記事 を参照してください。 基本的には ver.3 の使用が推奨されていますが、AWS の Lambda 実行環境は現時点（2021年5月）でも ver.2 がインストールされていたりするので、ver.2 の需要はまだあると思います。
Dynamo DB 用の SDK (ver.2) をインストールする AWS SDK version 2 で DynamoDB を扱うには、次のように AWS SDK パッケージ全体をインストールする必要があります（version 3 では DynamoDB サービスなどのパッケージを個別にインストールできます）。
$ npm install aws-sdk --save これで、TypeScript コードから次のように SDK モジュールをインポートできるようになります。
import * as AWS from &amp;#39;aws-sdk&amp;#39;; AWS.DynamoDB だけ参照したければ、次のようにインポートできます。
import { DynamoDB } from &amp;#39;aws-sdk&amp;#39;; DynamoDB インスタンスの生成 基本 DynamoDB の API を呼び出すには、まずは AWS.</description></item><item><title>Electron で Hello World (2) TypeScript で開発できるようにする</title><link>https://maku.blog/p/78whxix/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/78whxix/</guid><description>概要 前回の記事（Electron で Hello World (1) 最小構成で作る）では、プレーンな JavaScript を使用して簡単な Electron アプリを作成しましたが、本格的な開発を始めるときは TypeScript の環境を導入しておいた方がよいでしょう。
ここでは、上記のプレーンな JavaScript による Hello World ができているとして、TypeScript の環境を追加でセットアップします。 次のように、src ディレクトリ内に .ts ファイルを作成し、トランスパイルされた .js ファイルを build ディレクトリに出力するように設定することにします。
myapp/ +-- build/ # トランスパイル後の .js ファイルを格納 +-- src/ # .ts ファイルを格納 +-- public/ # そのままパッケージングするもの | +-- index.html +-- package.json # Node.js 用設定ファイル +-- tsconfig.json # TypeScript 用設定ファイル ビルド設定 TypeScript をインストールします。
$ npm install typescript --save-dev Node.js ライブラリ用の型宣言ファイル (node.d.ts) をインストールします。
$ npm install @types/node --save-dev ☝️ ワンポイント Electron の型定義については、Electron パッケージにデフォルトで含まれているので、型定義ファイルを別途インストールする必要はありません。 TypeScript の設定ファイル (tsconfig.</description></item><item><title>TypeScriptの型: クラス定数を定義する (static readonly)</title><link>https://maku.blog/p/nky6cbb/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/nky6cbb/</guid><description>static readonly プロパティを定義する TypeScript 2.0 以降では、クラス内の static プロパティに readonly キーワードを付けて読み取り専用であることを示すことができます。
class SiteInfo { // クラス定数の定義 static readonly FAQ_URL = &amp;#39;https://example.com/faq/&amp;#39;; } クラス定数を別ファイルから参照する このようなクラスをモジュールとして公開 (export) すれば、アプリ全体でそのクラス定数を共有できます。
（export側）siteInfo.ts export class SiteInfo { static readonly FAQ_URL = &amp;#39;https://example.com/faq/&amp;#39;; } （import側）index.ts import { SiteInfo } from &amp;#39;siteInfo&amp;#39;; console.log(SiteInfo.FAQ_URL); 配列をクラス定数にする (ReadonlyArray) readonly キーワードは、その変数への代入を禁止するだけなので、オブジェクト自体のセット系メソッドは呼び出せてしまいます。 配列に関しても各要素の値が変更できてしまうのは同様ですが、TypeScript にはそれを禁止するための ReadonlyArray&amp;lt;T&amp;gt; というジェネリッククラスが用意されています。
クラス定数として読み取り専用配列を定義 class Coordinates { static readonly ORIGIN: ReadonlyArray&amp;lt;number&amp;gt; = [0, 0]; } Coordinates.ORIGIN = [1, 1]; // Error (readonly により防止) Coordinates.</description></item><item><title>TypeScriptの環境: Visual Studio Code で TypeScript の開発環境を構築する</title><link>https://maku.blog/p/ak7u3h3/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/ak7u3h3/</guid><description>はじめに TypeScript は Microsoft が開発している言語で、同じく Microsoft が開発している IDE である Visual Studio Code（以下 VS Code）が TypeScript コードの編集に適しています。
VS Code による TypeScript の開発環境を構築するには、下記をインストールする必要があります。
Visual Studio Code Node.js（npm コマンド） TypeScript（tsc コマンド) 開発環境をインストールする Visual Studio Code のインストール VS Code は下記からインストーラーをダウンロードしてインストールできます。
Download Visual Studio Code TypeScript のソースコード (.ts) ファイルは、単純なテキストエディタでも編集できますが、この VS Code を使って編集すると、プロパティ名の自動補完などができて効率的に開発を行えます。
コマンドラインから code と入力して、VS Code を起動できるようになれば OK です。 VS Code をインストールしたのに code コマンドが認識されない場合は、こちらの記事 を参考にしてパスを通してください。
Node.js のインストール TypeScript のトランスパイラである tsc コマンドは、Node.js のパッケージとして提供されているため、先に Node.js をインストールしておく必要があります。 Node.js は下記からインストーラーをダウンロードしてインストールできます。</description></item><item><title>TypeScript で AWS SDK を使う開発環境を整える</title><link>https://maku.blog/p/taiqx6d/</link><pubDate>Thu, 25 Feb 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/taiqx6d/</guid><description>TypeScript のプロジェクトを作成する 何をできるようにするか？ ここでは、Node.js はインストール済みであるという前提で、次のようなことを行える TypeScript 環境を整えます。
npm run build で src ディレクトリ以下の .ts ファイルをコンパイルする
（.js ファイルが build ディレクトリ以下に出力される） npm start でコンパイルされた build/main.js を起動する 下記のセットアップ手順の 詳しい意味はこちらを参照 していただくとして、ここでは一気にセットアップを終わらせてしまいます。
セットアップ # アプリ用のディレクトリを作成 $ mkdir myapp $ cd myapp # Node.js アプリの設定ファイル (package.json) を生成 $ npm init -y # TypeScript および Node 型情報をインストール $ npm install typescript -D $ npm install @types/node -D # TypeScript の設定ファイル (tsconfig.json) を生成 $ npx tsc --init package.json を次のような感じで修正します。 主に scripts の定義です。</description></item><item><title>React コンポーネント実装の基本（関数コンポーネントとクラスコンポーネント）</title><link>https://maku.blog/p/vfr3cnw/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/vfr3cnw/</guid><description>React で独自コンポーネントを作成する方法として、大きく次の 2 種類の方法があります。
関数コンポーネント (Function Components) クラスコンポーネント (Class Components) 昔は、ステートを持つコンポーネントは「クラスコンポーネント」で作成し、ステートを持たないものは「関数コンポーネント」として作成するという使い分けがありました。 現在は、関数コンポーネントでも Hook の仕組みでステートを管理することができるようになったため、関数コンポーネントの使用が推奨されています。
関数コンポーネント 関数コンポーネントの基本 下記は、固定のテキストを表示するシンプルな関数コンポーネントの定義例です。 TypeScript (@types/react) では、関数コンポーネントの型は React.FunctionComponent インタフェースとして定義されています。 エイリアスとして React.FC が定義されているので、こちらを使えばより短く記述できます。
components/Hello.tsx import * as React from &amp;#39;react&amp;#39;; // Hello コンポーネントの定義 export const Hello: React.FC = () =&amp;gt; { return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; }; HTML ファイルから読み込む JS ファイルでは、ReactDOM.render() で上記の Hello コンポーネントを描画します。 次のコードを実行すると、&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt; 要素の内容が、Hello コンポーネントの内容に置き換えられます。
index.tsx（使用例） import * as React from &amp;#39;react&amp;#39;; import * as ReactDOM from &amp;#39;react-dom&amp;#39;; import { Hello } from &amp;#39;.</description></item><item><title>TypeScriptの型: リテラル型を定義する (Literal types)</title><link>https://maku.blog/p/6iuo8aj/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/6iuo8aj/</guid><description>TypeScript のリテラル型は enum 型（列挙型）の制約を緩めたようなものです。 enum 型は 整数値 で値を保持しますが、リテラル型は 任意の型 で格納可能な値を定義します。
例えば、次のように定義した Answer 型は、その値として yes あるいは no という文字列のみ格納できるようになります。
// Answer というリテラル型を定義する type Answer = `yes` | `no`; // Answer 型の変数には &amp;#39;yes&amp;#39; か &amp;#39;no&amp;#39; のみ格納可能 let answer: Answer answer = &amp;#39;yes&amp;#39;; // OK answer = &amp;#39;no&amp;#39;; // OK answer = &amp;#39;maybe&amp;#39;; // Error answer = 100; // Error 参考 TypeScript: 列挙型を定義する (enum) TypeScript: タイプエイリアスを定義する (type)</description></item><item><title>TypeScriptの型: タイプエイリアスを定義する (type)</title><link>https://maku.blog/p/5zoqtmi/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/5zoqtmi/</guid><description>TypeScript の タイプエイリアス (Type alias) を使用すると、既存の型を組み合わせて新たな型を定義することができます。
下記の例では、string 型と number 型の 2 つの値を保持する Person という型を定義しています。 タイプエイリアスの定義では、代入 (=) の構文を使用すること注意してください。
type Person = { name: string; age: number; }; let p: Person = { name: &amp;#39;Maku&amp;#39;, age: 14 }; console.log(p.name); console.log(p.age); Person 型の変数を初期化するときは、上記のように各プロパティの値を漏れなく明示する必要があります。 次のように、プロパティの指定に過不足があるとコンパイルエラーが発生します。
間違った例 let p1: Person = { name: &amp;#39;Maku&amp;#39; }; // プロパティが不足 let p2: Person = { name: &amp;#39;Maku&amp;#39;, age: 14, xxx: 20 }; // 未知のプロパティ エラーメッセージ sample.ts:6:5 - error TS2741: Property &amp;#39;age&amp;#39; is missing in type &amp;#39;{ name: string; }&amp;#39; but required in type &amp;#39;Person&amp;#39;.</description></item><item><title>TypeScriptの型: 共用体を定義する (Union types)</title><link>https://maku.blog/p/cdazjwv/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/cdazjwv/</guid><description>共用体 (union) の基本 変数の型をタイプアノテーションで指定するときに、複数の型を | (or) でつなげて指定すると、それらのいずれの型の値でも格納できる 共用体 (union) となります。
例: 文字列と数値を格納できる変数 let a: string | number; a = &amp;#39;Hello&amp;#39;; // OK a = 123; // OK a = true; // NG 例: 文字列あるいは数値のパラメータをとる関数 function foo(value: string | number) { // ... } 共用体のタイプエイリアスを定義する ある種類の共用体を繰り返し使用する場合、タイプエイリアスを定義しておくと、何度も同じ記述をしなくて済みます。
// interface Context {}; type ContextOrString = Context | string; 定義したタイプエイリアスは、通常の型と同様に使用することができます。
function onMessage(context: ContextOrString) { // ... }</description></item><item><title>TypeScriptの型: 列挙型を定義する (enum)</title><link>https://maku.blog/p/fdjk4hh/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/fdjk4hh/</guid><description>列挙型 (enum) の基本 TypeScript で列挙型を定義するには、enum キーワードを使用します。
enum Fruits { Apple, //= 0 Banana, //= 1 Orange //= 2 } console.log(Fruits.Apple); //=&amp;gt; 0 console.log(Fruits[Fruits.Apple]); //=&amp;gt; Apple デフォルトでは、各要素の値として先頭から順番に 0、1、2 という連番の 整数値 が内部的に割り当てられます（C 言語や Java と同様です）。 この値は任意の数値に変更することができます。
次の例は、ビットフラグとして使用することを想定した enum の定義例です。 各値が 2 のべき乗の値になっていることに注意してください。
enum OpenModes { Read = 1, Write = 2, Append = 4 } const mode = OpenModes.Read | OpenModes.Write; if ((mode &amp;amp; OpenModes.Write) == OpenModes.Write) { console.log(&amp;#39;Write フラグが指定されています&amp;#39;); } enum 値をインライン展開する (Constant enumeration) enum 定義を行うときに const キーワードを付加すると、その enum 値を使用した場所に値がハードコードされる形で展開されます（JavaScript のコードに変換するときに、0 や 1 といった値をインライン展開する）。</description></item><item><title>TypeScriptでモジュールを作成する／インポートする (export, import)</title><link>https://maku.blog/p/fbu8k8j/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/fbu8k8j/</guid><description>モジュールとは TypeScript で大きなプログラムを作成するときは、モジュールの仕組みを使って 複数のファイルに分割 していきます。 ファイルを分割することでコードを管理しやすくなるだけでなく、名前空間のコンテキストが分けられることになるので、 名前の衝突の問題も解決 することができます。
モジュールを作るのは簡単で、export キーワードを含む .ts ファイルを作ればそれがモジュールになります。 export キーワードでは、クラスやインタフェースをまるごと公開することもできるし、関数や変数の単位で公開することもできます。
export の使い方のポイントは、次のように、 クラスや変数を定義するときにプレフィックスとして付加する というところです。 基本的には、定義済みのオブジェクトを後から export するという使い方はしません。
export class &amp;hellip; export interface &amp;hellip; export const &amp;hellip; export let &amp;hellip; ここからは、具体的な export の使い方を見ていきます。
クラスやインタフェースの定義を export する 下記の lib/mylib.ts ファイルでは、MyInterface インタフェースと、MyClass クラスを公開しています。 それぞれの定義の前に export キーワードを付けるだけでよいので簡単ですね。
lib/mylib.ts export interface MyInterface { name: string; } export class MyClass implements MyInterface { constructor(public name: string) {} } 次の index.ts ファイルからは、上記のクラスモジュールを import して読み込んでいます。</description></item><item><title>TypeScriptのモジュールのインポートには import を使う</title><link>https://maku.blog/p/emdtiio/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/emdtiio/</guid><description>require ではなく import を使う TypeScript で型情報付きのモジュールをインポートするときは、ECMAScript 2015 の module 構文 で定義されている import を使うようにすると、VSCode などで型情報を使った補完がうまく効くようにになります。
これを使う // Good import * as mod from &amp;#39;mod&amp;#39;; 下記のように、Node.js で一般的に使用されていた CommonJS 形式の require を使ってもインポートできますが、any 型の変数を定義していることになるため、型情報を用いた補完が効きません。
これは使わない // NG const mod = require(&amp;#39;mod&amp;#39;); TypeScript でモジュールをインポートするときには、できるだけ import を使う ようにしましょう。
インポートの例（関数ベースのモジュール） Node.js のコアモジュール（os や path など）は、もともと TypeScript 用に作成されたものではありませんが、TypeScript 用の型情報が @types/node モジュールとして提供されています。
Node.js コアモジュールの型情報をインストール $ npm install --save-dev @types/node これで、Node.js のコアモジュールを下記のように型情報付きでインポートできるようになります。 これは、複数の関数を export する TypeScript モジュールをインポートする方法のよい例です。
よい例: 型として認識される import * as path from &amp;#39;path&amp;#39;; // 全ての関数をインポート import { join } from &amp;#39;path&amp;#39;; // 個別の関数をインポート これで、VSCode などの IDE で次のように補完が聞くようになります。</description></item><item><title>TypeScriptで名前空間を定義する (namespace)</title><link>https://maku.blog/p/a3eh9w2/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/a3eh9w2/</guid><description>namespace ではなくモジュールの仕組みを使うべし TypeScript では、namespace キーワードを使って名前空間を定義することができますが、通常はより柔軟性の高い モジュールの仕組み を使うようにしてください（といっても .ts ファイルを分けるだけですが）。
namespace を使うと、同じファイル内で階層化された名前空間を作ることができますが、あくまでその階層構造はグローバルに共有されています。 一方、モジュールの仕組みを使うと、ファイル単位で名前空間のコンテキストを分けることができます。 大きなプロジェクトであっても、適切な単位でモジュール（ファイル）を分割している限り、名前の衝突は本質的には発生しません。
とはいえ、これは namespace の記事なので、ここからは namespace の使い方の説明をします。
namespace による名前空間の定義 namespace による名前空間の定義は簡単で、namespace Xxx { ... } というブロックで囲むだけです。 次の例では、First と Second という名前空間を作成し、それぞれに同じ名前の Person というクラスを定義しています。
namespace First { export class Person { greet() { console.log(&amp;#39;First.Person&amp;#39;); } } } namespace Second { export class Person { greet() { console.log(&amp;#39;Second.Person&amp;#39;); } } } const p1 = new First.Person(); const p2 = new Second.Person(); p1.greet(); //=&amp;gt; First.</description></item><item><title>React コンポーネントのプロパティでハンドラメソッドを渡す</title><link>https://maku.blog/p/e2dpycn/</link><pubDate>Sat, 18 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/e2dpycn/</guid><description>ここでは、次のようにプロパティ（属性）でハンドラメソッドを設定可能な React コンポーネントの実装例を示します。
&amp;lt;MyButton onClick={handleClick} /&amp;gt; ハンドラメソッドを設定可能なコンポーネントを実装する 次の MyButton コンポーネントは、ボタンクリック時に呼び出されるイベントハンドラを、onClick プロパティで設定できるようにしています。 この MyButton コンポーネントは、クリックするたびに内部のカウンタ (state.count) を +1 し、その値を指定されたイベントハンドラへ通知します。
components/myButton.tsx import * as React from &amp;#39;react&amp;#39;; // MyButton のプロパティ（属性）の型 export interface MyButtonProps { onClick?: (count: number) =&amp;gt; void; } // MyButton の状態（ステート）の型 interface MyButtonState { count: number; } // MyButton コンポーネント export class MyButton extends React.Component&amp;lt;MyButtonProps, MyButtonState&amp;gt; { constructor(props: MyButtonProps) { super(props); this.state = {count: 0}; } public render(): React.ReactNode { const {count} = this.</description></item><item><title>React コンポーネントのプロパティで配列データを渡す</title><link>https://maku.blog/p/av9mxak/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/av9mxak/</guid><description>React コンポーネントのプロパティには、文字列や数値などの単純なスカラ値だけではなく、配列などの複雑なオブジェクトを渡すことができます。 使用イメージは次のような感じです。
&amp;lt;MyComponent values={配列変数} /&amp;gt; 配列型のプロパティを扱うコンポーネントを作成する 次の Books コンポーネントは、プロパティ titles で文字列配列を受け取り、それぞれの値を li 要素で描画します。 配列の map メソッドを使用すると、複数の li 要素を簡単に生成することができます。
components/books.tsx（Books コンポーネント） import * as React from &amp;#39;react&amp;#39;; // Books コンポーネントのプロパティの型 export interface BooksProps { titles: string[] } // Books コンポーネントの定義 export const Books: React.FC&amp;lt;BooksProps&amp;gt; = (props) =&amp;gt; { // titles プロパティの要素数が 0 であれば何も描画しない if (props.titles.length == 0) return null; // titles プロパティの値を使って、複数の li 要素を作る const listItems = props.titles.map((title: string) =&amp;gt; &amp;lt;li&amp;gt;{title}&amp;lt;/li&amp;gt; ); // ul 要素の描画 return &amp;lt;ul&amp;gt;{listItems}&amp;lt;/ul&amp;gt;; }; この Books コンポーネントは次のような感じで使用します。</description></item><item><title>TypeScriptの型: 既存の JavaScript ライブラリに型情報を追加する（.d.ts ファイル）</title><link>https://maku.blog/p/s7wk5k3/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/s7wk5k3/</guid><description>アンビエント宣言とは TypeScript の アンビエント宣言 (Ambient Declarations) を行うと、既存の JavaScript ライブラリに型情報を付加することができます。 この仕組みを利用すると、
サードパーティ製の JavaScript ライブラリ（npm パッケージ）や、自作の JavaScript ライブラリ（ただし TypeScript 化はしたくないもの）を TypeScript コードから使用する jQuery などのブラウザ上でロードされるライブラリを TypeScript コードから使用する といったことが可能になります。 ようするに、TypeScript トランスパイラに対して、このオブジェクトはこういう型のものとして外から提供されているので、型チェックエラーを出さないでね、と知らせることができます。
さらに、VisualStudio Code などのエディタを使用している場合は、アンビエント型宣言があることにより、エディタ上での補完入力ができるようになります。
アンビエント宣言 (declare) 参考: TypeScript - Declaration Reference どこか別の場所でロードされる予定の JavaScript モジュールに対して、自力で型情報を付けたい場合は declare キーワードを使用します。 例えば、jQuery はもともと JavaScript 用のライブラリなので、TypeScript 用の型情報は提供していませんが、次のように自力で型情報を付けることで、TypeScript コードから利用できるようになります（実際には、DefinitelyTyped プロジェクトが提供する @types/jquery を使用するのが簡単です）。
index.ts // $ という変数を参照できるようにする（実体は実行時に後付けで定義される予定） declare var $: any; // これで、$ という未定義の変数を参照してもエラーにならない $(&amp;#39;#id&amp;#39;).html(&amp;#39;Hello!&amp;#39;); この仕組みを使わずに、いきなり $ を参照してしまうと、そのような変数は定義されていないというエラーになってしまいます。 TypeScript トランスパイラは、declare によって付けられた型情報を正しいものと判断するため、この型情報は間違えないように指定する必要があります。 また、実行時にはそのオブジェクトの実体がどこかで生成されていなければいけません。</description></item><item><title>TypeScriptの型: 環境変数 (process.env) 用の型情報を定義する</title><link>https://maku.blog/p/r8iry9g/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/r8iry9g/</guid><description>Node.js で環境変数を参照するためのオブジェクト process.env の型情報は、@types/node で次のように文字列型ディクショナリ Dict&amp;lt;string&amp;gt; として定義されています。
node_modules/@types/node/process.d.ts（抜粋） declare module &amp;#34;process&amp;#34; { global { var process: NodeJS.Process; namespace NodeJS { interface ProcessEnv extends Dict&amp;lt;string&amp;gt; {} //... } } export = process; } この型定義は @types/node モジュールをインストールするだけで簡単に使用できるようになるのですが、具体的なキー名（環境変数名）が定義されていないので、Visual Studio Code などで process.env 以降の入力補完が効きません。
VS Code 上で環境変数名を補完入力 できるようにするには、次のような型定義ファイル (globals.d.ts) をソースツリーのルートに作成します。
globals.d.ts declare namespace NodeJS { // 環境変数名の定義 interface ProcessEnv { /** 現在の Node.js 実行環境 */ readonly NODE_ENV: &amp;#39;development&amp;#39; | &amp;#39;production&amp;#39; | &amp;#39;test&amp;#39;; /** GitHub アクセストークン */ readonly MYAPP_GITHUB_TOKEN: string; } } 環境変数 NODE_ENV の値は、決められた 3 種類の値 (development/production/test) のいずれかであると定義しているので、それ以外の値と比較しようとしたときに警告してくれます。</description></item><item><title>React コンポーネントで入力フォームを作成する (1) 自力編</title><link>https://maku.blog/p/tdpybmw/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tdpybmw/</guid><description>制御コンポーネント (controlled components) React コンポーネントでフォームを構成する場合、コンポーネントの状態 (state) に基づいて表示を行うように実装すると、フォームの表示内容を制御しやすくなります。
このように、コンポーネントの表示内容が、完全にその状態 (state) によって決まるように実装されたものを、制御されたコンポーネント (controlled components) と呼びます。
このように設計することで、若干コード量は増えますが、表示内容を変更したいときはコンポーネントの state を変更するだけで済むようになります。 例えば、ネットワークから取得したデータをフォームに表示するような場合、そのフォームの構造を知る必要はなく、単純に state を更新するだけでよくなります。 これは、データとビューが分離された設計になっており、アプリ設計におけるベストプラクティスのひとつです。
input 要素の実装例 下記は、&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt; 要素と &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt; 要素を持つ MessageForm コンポーネントの実装例です。 ユーザーがテキストを入力するたびに handleChange() が呼び出され、コンポーネントの状態 (state) が更新されます。 setState() の呼び出しにより state が変更が変更されると、再度 render() が実行され、表示内容が state の値に基づいて更新されます。
まずは、クラスコンポーネント形式での実装例。
components/MessageForm.tsx import * as React from &amp;#39;react&amp;#39;; interface IState { msg: string; } // テキスト入力エリアと、submit ボタンを持つフォームを表示するコンポーネント export class MessageForm extends React.Component&amp;lt;{}, IState&amp;gt; { constructor(props: {}) { super(props); // ステートの初期化（最初は入力エリアは空っぽ） this.</description></item><item><title>React コンポーネントで入力フォームを作成する (2) react-hook-form 編</title><link>https://maku.blog/p/k7it5fp/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/k7it5fp/</guid><description>React Hook Form とは React アプリで入力フォームを自力で作ろうとすると、各入力エリアのステート管理などが 意外と大変だったりします。 React Hook Form ライブラリ (react-hook-form) を使用すると、そのあたりの定型処理をシンプルに記述することができます。
React Hook Form / npm / GitHub React Hook Form は次のような特徴を備えています。
軽量（別のライブラリに依存しない） TypeScript をサポート パフォーマンスがよい（不要なレンダリングを軽減） HTML 標準のフォームバリデーション との互換性 required / min / max / minLength / maxLength / pattern / validate React Native でも使える 2022 年 2 月時点で活発に開発が進められており、npm のダウンロード数は右肩上がりに増えています。 GitHub のスター数も 25,000 を超えているため、しばらくは安心して使えそうなライブラリです。
React Hook Form を導入する react-hook-form パッケージは、npm あるいは yarn で簡単にインストールできます。 既存の React プロジェクト内で次のように実行してください。
$ npm install react-hook-form あるいは $ yarn add react-hook-form React Hook Form の基本的な使い方 次の MyForm コンポーネントは、1 つのテキスト入力フィールドと、1 つの数値入力フィールドを持つフォームの実装例です。 ここでは TypeScript を使い、フォームの入力要素の型を FormData と定義しています。</description></item><item><title>React Context で複数のコンポーネント間でデータを共有する</title><link>https://maku.blog/p/qoz8fow/</link><pubDate>Thu, 27 Aug 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/qoz8fow/</guid><description>Context とは React の Context（コンテクスト） は、いわゆるグローバル変数の格納領域のようなもので、複数のコンポーネント間でのデータ共有に使用できます。 各コンポーネントから Context 情報にダイレクトにアクセスできるため、prop のように上位のコンポーネントから情報を伝搬させていく必要がありません。
Context をむやみに使うと、コンポーネントの再利用性が下がってしまいますが、アプリケーション全体で使用する次のような情報を Context で管理するとコードがすっきりします。
ログイン中のユーザー情報（認証情報） 言語設定 テーマ設定 Context の使い方 Context を作成する (createContext) Context オブジェクトは、React.createContext() で作成することができます。 複数のコンポーネントから参照することになるので、Context オブジェクトは単独のファイルとしてモジュール化しておきます。
React.createContext() の引数に任意のオブジェクトを渡すと、その値を初期値とする Context オブジェクトが生成されます。 次の例では、string 型のデータを保持する Context オブジェクトを生成しています。
MyContext.ts import * as React from &amp;#39;react&amp;#39;; export const MyContext: React.Context&amp;lt;string&amp;gt; = React.createContext&amp;lt;string&amp;gt;(&amp;#39;Default message&amp;#39;); Context を参照する (useContext) 関数コンポーネント内で、Context が保持するデータを参照するには、React.useContext() を使用します。 デフォルトでは、React.createContext() の引数に設定したデフォルト値が返されます。 上記の例では、Default message というデフォルトテキストを設定しているので、その値が返されることになります。
App.tsx import * as React from &amp;#39;react&amp;#39;; import { MyContext } from &amp;#39;.</description></item><item><title>React Context の情報をローカルストレージに保存する</title><link>https://maku.blog/p/bv9kv7h/</link><pubDate>Sat, 29 Aug 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/bv9kv7h/</guid><description>何をするか？ ここでは、React の Context オブジェクトにセットした値をローカルストレージに保存し、次回のアプリ起動時にそこから値を復帰させる方法を説明します。 Context の使い方の基本は、次の記事を参照してください。
React Context で複数のコンポーネント間でデータを共有する Context の実装 下記の UserContext.tsx モジュールでは、React.createContext() で UserContext というオブジェクトを作成しています。 このオブジェクトは、gitHubToken という文字列データと、その値を更新するための setGitHubToken 関数を保持しています。 次のように実装することで、UserContext のデータをローカルストレージと同期させることができます。
gitHubToken の初期値に localStorage.getItem() から取得した値を設定する setGitHubToken の呼び出し時に localStorage.setItem() で値を保存する UserContext.tsx import * as React from &amp;#39;react&amp;#39;; // UserContext が保持する値の型 export interface UserContextType { gitHubToken: string; setGitHubToken: (token: string) =&amp;gt; void; } // ローカルストレージ用のキー const KEY_GITHUB_TOKEN = &amp;#39;gitHubToken&amp;#39;; // UserContext の生成 export const UserContext = React.createContext&amp;lt;UserContextType&amp;gt;({ gitHubToken: localStorage.getItem(KEY_GITHUB_TOKEN), // デフォルト値 setGitHubToken: (token: string) =&amp;gt; {} // ダミーセッター }); // UserContext にセッター関数を登録するためのコンポーネント export const UserContextProvider: React.</description></item><item><title>Vite で複数の TypeScript ファイルやリソースファイルを 1 つの JavaScript ライブラリとしてバンドルする</title><link>https://maku.blog/p/59mfj7b/</link><pubDate>Wed, 02 Oct 2024 00:00:00 +0900</pubDate><guid>https://maku.blog/p/59mfj7b/</guid><description>何をするか Vite は TypeScript ビルドや、開発用サーバー、バンドリングなどの機能を備えた統合的なフロントエンド開発ツールです。 ここでは、Vite で複数の TypeScript ファイルを 1 つの JavaScript ファイルの形にビルドする方法を説明します（この作業をバンドルと呼びます）。
図: 複数の .ts/.css/.svg ファイルを 1 つの JavaScript ファイルに結合 最終的な成果物として、複数の Web サイトから &amp;lt;script&amp;gt; 要素で読み込み可能な JavaScript ライブラリ を作成することを想定しています。 画像ファイルやスタイルシート (CSS) などのリソースファイルも、単一の JavaScript に埋め込む形でバンドルできます。
Vite プロジェクトの作成 npm create vite コマンドを使って Vite のプロジェクトを作成します。 React などのフレームワークを使わず、純粋な TypeScript ファイルをビルドするだけであれば、ウィザードに従って、Vinilla → TypeScript と選択していきます。
Vite プロジェクト (myscript) を生成する $ npm create vite@latest myscript ✔ Select a framework: › Vanilla ✔ Select a variant: › TypeScript $ cd myscript 次のようなファイルが生成されます。</description></item><item><title>Jest で TypeScript コードのユニットテストを記述する</title><link>https://maku.blog/p/9xxpe4t/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/9xxpe4t/</guid><description>Jest とは Jest は Facebook が公開した JavaScript 用のシンプルなテストフレームワークで、Node.js 環境で実行することができます。
Jest · 🃏 Delightful JavaScript Testing Jest は下記のような特徴を持っています。
ゼロコンフィグで使い始められる（設定ファイルなしで実行可能） テストを並列実行するので高速 コードカバレッジレポートの出力を標準搭載 わかりやすいマッチャー表現 (expect ～ toBe、toContain など、自然な文章として読める） TypeScript に対応（ts-jest を利用） Jest 用のテストコードは、次のようなコードジェネレーターでも採用されており、利用者は増え続けています（2022 年現在）。
create-react-app &amp;hellip; React アプリのジェネレーター cdk init app &amp;hellip; AWS のインフラ生成コードのジェネレーター Jest のインストール Jest 本体の jest モジュールをインストールします。 TypeScript を使用する場合は、Jest ライブラリの型情報である @types/jest と、Jest 用の TypeScript プロセッサ (ts-jest) もインストールする必要があります。 これらはすべてテスト時のみ使用する NPM モジュールなので、devDependencies としてインストールします。
Jest 本体と TypeScript 関連モジュールをインストール ### npm の場合 $ npm install --save-dev jest @types/jest ts-jest ### yarn の場合 $ yarn add --dev jest @types/jest ts-jest package.</description></item><item><title>TypeScriptの型: 既存の型をちょっと変えた型を作る（ユーティリティ型）</title><link>https://maku.blog/p/9t6gr3c/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/9t6gr3c/</guid><description>ユーリティティ型とは？ TypeScript には、既存の型を加工して新しい型を生み出す ユーティリティ型 (Utility Types) というものが用意されています。 例えば、Partial を使用すると、ある型のプロパティをすべてオプショナルにした型を簡単に作ことができます。 以下、使いやすそうなユーティリティ型を紹介しておきます。
ユーティリティ型 概要 Omit 指定したプロパティを取り除く Pick 指定したプロパティだけ抽出する Partial 全プロパティをオプショナルにする Required 全プロパティを必須にする Readonly 全プロパティを readonly にする ユーティリティ関数の使用例 Omit / Pick &amp;hellip; プロパティを削除・抽出する Omit を使用すると、既存の型から指定したプロパティを取り除いた型を作成できます。 次の例では、Book 型から id プロパティを取り除いて、新しい NewBook 型を定義しています。
type Book = { id: string title: string price: number } type NewBook = Omit&amp;lt;Book, &amp;#39;id&amp;#39;&amp;gt; // 上記は以下と同様 // type NewBook = { // title: string // price: number // } // 使用例: 新しい書籍を登録する関数（id は自動生成する想定） function addBook(book: NewBook): Book { // .</description></item><item><title>React の props.children の型定義には ReactNode を使う</title><link>https://maku.blog/p/xenv4bh/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/xenv4bh/</guid><description>children の型定義 TypeScript で React の関数コンポーネントを定義するときには、下記のような React.FC (React.FunctionComponent) を使用します。
type FC&amp;lt;P = {}&amp;gt; = FunctionComponent&amp;lt;P&amp;gt;; interface FunctionComponent&amp;lt;P = {}&amp;gt; { (props: PropsWithChildren&amp;lt;P&amp;gt;, context?: any): ReactElement&amp;lt;any, any&amp;gt; | null; propTypes?: WeakValidationMap&amp;lt;P&amp;gt; | undefined; contextTypes?: ValidationMap&amp;lt;any&amp;gt; | undefined; defaultProps?: Partial&amp;lt;P&amp;gt; | undefined; displayName?: string | undefined; } // ... type PropsWithChildren&amp;lt;P&amp;gt; = P &amp;amp; { children?: ReactNode | undefined }; FC の型パラメータ P は、上記のような PropsWithChildren 型にラップされるので、props の型定義をするときに明示的に children を含める必要はありません。 下記の ColorBox コンポーネントは、指定した背景色で子要素 (children) を表示します。</description></item><item><title>TypeScript で JSON オブジェクトに型情報を付加する</title><link>https://maku.blog/p/2hr3eqx/</link><pubDate>Sat, 26 Jun 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/2hr3eqx/</guid><description>何が問題か？ JSON テキストファイルの内容を JSON.parse した結果や、fetch API のレスポンスを json() 関数にかけた結果は、型情報のない any 型のオブジェクトになります。 TypeScript コードから、このオブジェクトのプロパティを参照しようとすると、「定義されていないプロパティを参照している」という感じの ESLint エラーになってしまいます。 何より、型情報がないデータをそのまま扱おうとすると、VS Code などでプロパティ名の入力補完機能が働きません。
ここでは、サンプルデータとして次のような JSON 形式の文字列を使うことにします。
const jsonText = `{ &amp;#34;games&amp;#34;: [ { &amp;#34;title&amp;#34;: &amp;#34;Title1&amp;#34;, &amp;#34;genres&amp;#34;: [&amp;#34;ACT&amp;#34;] }, { &amp;#34;title&amp;#34;: &amp;#34;Title2&amp;#34;, &amp;#34;genres&amp;#34;: [&amp;#34;ACT&amp;#34;, &amp;#34;RPG&amp;#34;] }, { &amp;#34;title&amp;#34;: &amp;#34;Title3&amp;#34;, &amp;#34;genres&amp;#34;: [&amp;#34;STG&amp;#34;], &amp;#34;note&amp;#34;: &amp;#34;Fantastic shooting game&amp;#34; } ] } ` この JSON 文字列を JSON.parse 関数でオブジェクトに変換して、そのプロパティを参照しようとすると、ESLint がエラーを出します。
// Unsafe assignment of an `any` value (@typescript-eslint/no-unsafe-assignment) const jsonObj = JSON.</description></item><item><title>TypeScript で undefined/null をうまく扱う (nullish coalescing (??), optional chaining (?.))</title><link>https://maku.blog/p/5oyaju5/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/5oyaju5/</guid><description>Null 合体演算子 (??) ES2020 で Null 合体演算子 (Nullish Coalescing Operator) の ?? が導入されました。
☝️ nullish とは？ JavaScript において nullish とは、「undefined あるいは null」を示します。 coalescing には、「癒合、合体」という意味があります。 よって、nullish coalescing は、「null っぽかったら合体させるよ」という意味になります。 ?? 演算子を使うと、ある変数の値が undefined（あるいは null）だったときの代替となる値を指定することができます。 つまり、
A ?? B は、次のように記述するのと同等です。
A != undefined ? A : B 下記は、?? 演算子の振る舞いの一覧です。 ?? 演算子はあくまで undefined と null だけを判別するものであって、左側に偽となる値（false や空文字）をおいた場合は、その値がそのまま使われることに注意してください。
// 右側の値が（代わりに）使われるパターン const a = undefined ?? &amp;#39;default&amp;#39; //=&amp;gt; &amp;#39;default&amp;#39; const b = null ?? &amp;#39;default&amp;#39; //=&amp;gt; &amp;#39;default&amp;#39; // 左側の値が（そのまま）使われるパターン const c = &amp;#39;&amp;#39; ?</description></item><item><title>TypeScript コードを Prettier で自動整形する</title><link>https://maku.blog/p/au8iu6u/</link><pubDate>Wed, 26 May 2021 00:00:00 +0900</pubDate><guid>https://maku.blog/p/au8iu6u/</guid><description>Prettier とは？ Prettier は、TypeScript や JavaScript などのソースコードを自動フォーマットするためのツールです。 HTML や CSS など様々なファイルに対応していますが、主に TypeScript や JavaScript のフォーマッターとして使用されています。 実際にどのようにフォーマットされるかは、Playground のページ で試すことができます。
特徴と思想 Prettier の一番の特徴は、Opinionated（独断的な） コードフォーマッターであることを標榜していることです。 これは、ユーザーに自由なカスタマイズを許さず、「Prettier 自身が定義しているスタイルに強制的にフォーマットするよ」ということです（セミコロンの有無など最低限の設定はできます）。 これにより、コーディングスタイルに関する 不毛な議論を避ける ことができ、プロジェクト内のコーディングスタイルを簡単に統一することができます。
もちろん、自分がベストだと思っているスタイルでフォーマットすることはできなくなるかもしれませんが、そんな些細なことよりも、アプリケーション（成果物）を作り上げることに集中すべきだという考え方です。
Prettier がやらないこと Prettier はあくまでコードのフォーマットのみを行います。 コードの意味を解析して危険な部分（潜在的バグ）を検出してくれたりはしないので、そういったことを行いたい場合は、他の静的解析ツール（ESLint など）を使う必要があります。 ESLint にもコードフォーマット機能がありますが、フォーマッターとしては Prettier が優れており、「Prettier による整形 ＋ ESLint による静的解析」という形で組み合わせて使うのが一般的です。
あと、import 文のソートなど、一見やってくれてもよさそうなフォーマットもしてくれなかったりします。 これは、その import 順序がロジック的に意味を持っていたりする場合に、Prettier が判断できないからです。 このように、いろいろと想像と異なるフォーマット結果になることがありますが、そこにはちゃんと理由があります（参考: Rationale）。 あまり気にせずにそんなものだと考えるのがよいです。 ちなみに、ESLint の方には import 文のソートを行うプラグイン (eslint-plugin-import) があります。
Prettier をインストールする Prettier は npm で簡単にインストールすることができます。 TypeScript のプロジェクトは作成済み で、package.json がすでに存在すると想定します。
### yarn の場合 $ yarn add prettier --dev --exact ### npm の場合 $ npm install prettier --save-dev --save-exact Prettier は、パッチバージョンが上がるだけで、出力結果に微妙な差分が生まれる可能性があります。 そのため、インストール時のオプションとして --save-exact を指定することで、明確なバージョンを package.</description></item><item><title>Node.js で GitHub GraphQL API を使用する (@octokit/graphql)</title><link>https://maku.blog/p/h5s6ht5/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/h5s6ht5/</guid><description>概要 GitHub 上の情報を扱う API として、GitHub は GraphQL API を提供しています。
GitHub GraphQL API v4 | GitHub Developer Guide Node.js で GraphQL を扱う方法としては、Apollo ライブラリを使った方法 などがありますが、GitHub の GraphQL API を呼び出したいのであれば、GitHub が提供している GraphQL パッケージ @octokit/graphql を使うのが手っ取り早いかもしれません（エンドポイントの URL などを省略できます）。
octokit/graphql.js: GitHub GraphQL API client for browsers and Node @octokit/graphql - npm ここでは、TypeScript からこの @octokit/graphql パッケージを使用する方法を紹介します。
☝️ REST API と GraphQL API GitHub API バージョン 3 は REST API でしたが、柔軟性などの観点 から、GitHub API バージョン 4 の GraphQL 版の API を使用することが推奨されています。 GraphQL API を使用することで、REST API で複数のリクエストが必要だったものを 1 度のリクエストで取得できたりします。 また、GraphQL API でしか取得できない情報もあったりします。 セットアップ まず、TypeScript のプロジェクトを作成します。</description></item><item><title>React コンポーネントに CSS スタイルを設定する</title><link>https://maku.blog/p/eu4cksy/</link><pubDate>Sun, 12 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/eu4cksy/</guid><description>React は Web サイトの View レイヤのコンポーネントを作るためのライブラリですが、CSS ファイルの扱い方は特に決められておらず、今でも多くの人が試行錯誤しています。 ここでは、React アプリにおける CSS の扱い方を、下記のように分類して順番に説明していきます。
従来通り HTML 起点でスタイルを読み込む方法 インラインスタイル CSS Modules CSS in JS ライブラリ HTML ファイルで読み込んだ CSS ファイルを参照する これは React を使わない従来の HTML/CSS のやり方に近い方法です。 HTML ファイル内の style 要素で定義した CSS クラスや、HTML から読み込んだ CSS ファイル内で定義した CSS クラスを React コンポーネントから使用します。
例えば、HTML ファイル内で次のようにスタイル定義されているとします。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;MyApp&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;style&amp;gt; .hello { color: blue; background: #aaccff; padding: 0.5em; font-weight: bolder; border-radius: 0.5em; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;index.</description></item><item><title>webpack と TypeScript を組み合わせて使用する</title><link>https://maku.blog/p/ucnv6en/</link><pubDate>Sun, 05 Jul 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/ucnv6en/</guid><description>はじめに TypeScript は JavaScript コードに型付けすることができる優れたトランスパイラですが、変換後の .js ファイル群をまとめる（バンドルする）機能は備えていません。 また、モダンな Web サイトを構築するときは、CSS Modules や Sass/Less/Stylus といった仕組みを使用するのが常套手段となっています。
そのため、Web サイト用の .js ファイルを TypeScript を使って作成する場合、webpack などのバンドルツールを組み合わせて使用する必要があります。
TypeScript &amp;hellip; .ts ファイルから .js ファイルへの変換 webpack &amp;hellip; Web サイト用の各種リソースをバンドルする バンドルツールには様々なものがありますが、大きなシェアを占めているのは webpack なので（2020年現在）、ここでは TypeScript と webpack を組み合わせて使用する方法を説明します。
☝️ webpack は必要なくなる？ ES Module の仕組みにより、Web ブラウザからモジュール化された .js ファイルをインポートすることが可能になりつつあります。 しかし、Web サイトの最終的なデプロイ時には、各種リソースを最適化（minify など）する必要があるため、まだまだ webpack などのバンドルツールが必要です。 関連パッケージのインストール TypeScript のインストール プロジェクト用のディレクトリと package.json を作成し、TypeScript をインストールします。
$ mkdir myapp &amp;amp;&amp;amp; cd $_ $ npm init -y $ npm install --save-dev typescript webpack のインストール webpack 関連のパッケージをインストールします。</description></item><item><title>Node.js で GitHub REST API を使用する (@octokit/rest)</title><link>https://maku.blog/p/7r6gr3d/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/7r6gr3d/</guid><description>概要 Octokit は、様々な言語から GitHub API を使用するためのライブラリを提供しています。 ここでは、TypeScript (JavaScript) 用の GitHub API v3 (REST API) ライブラリである、@octokit/rest を使用する方法を紹介します。
インストール @octokit/rest は次のようにインストールします（npm init で package.json を作成済みだと想定します）。
$ npm install @octokit/rest --save 実装（基本） 基本的には下記の API ドキュメントを参照しながら実装していくことになります。
octokit/rest.js API ドキュメント Octokit インスタンスを生成する main.ts import { Octokit } from &amp;#39;@octokit/rest&amp;#39;; const octokit = new Octokit(); このように生成した Octokit インスタンスを使って、様々な REST API を呼び出します。
リポジトリの一覧を取得する (repos.listForOrg) API ドキュメント (Repos - Get a repository)
次の例では、組織名 sony のパブリックなリポジトリを 5 件分取得しています。
octokit .</description></item><item><title>Azure Table Stroage を使ってみる: TableService を Promise 化して使いやすくする</title><link>https://maku.blog/p/4m96s2r/</link><pubDate>Thu, 04 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/4m96s2r/</guid><description>PromiseTableService クラスの概要 Node.js から Azure Table Storage を操作する場合は、azure-storage パッケージの TableService クラス を使用するのですが、このクラスは残念ながら Promise 対応 対応されておらず、旧式のコールバック形式での呼び出しが強制されます。
下記の azure-table-promise パッケージが提供している PromiseTableService クラスを使用すると、TableService を Promise 化して使用することができます。
azure-table-promise - npm パッケージ ちなみに、下記の Issue で公式パッケージの Promise 化の議論がされているのですが、TableService クラスはいまだに対応されてませんね（2020年6月現在）。
参考: Promise support · Issue #110 · Azure/azure-storage-node こういった対応は本家の方でサクッとやってくれれば 3rd パーティライブラリの乱立が防げるんですけどね。。。
PromiseTableService を使ってみる まず必要なモジュールをインストールします。 azure-storage は本家 Microsoft の TableService クラスを使うためのモジュールで、azure-table-promise がそれを Promise ラップするためのモジュールです。 ここでは TypeScript を使うので、Node.js 型定義もインストールしておきます。
npm モジュールのインストール $ npm install --save-dev @types/node $ npm install --save azure-storage $ npm install --save azure-table-promise 次の MyTableStorage クラスは、PromiseTableService を使って TableStroage から情報を取得するサンプルです。 コンストラクタで PromiseTableService インスタンスを生成し、getRandomMessage() メソッドで、randommessage テーブルの値をランダムに取得しています。</description></item><item><title>TypeScript: 2つの変数の値をスワップする</title><link>https://maku.blog/p/k8kw8it/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/k8kw8it/</guid><description>TypeScript 独自の構文ではありませんが、ECMAScript 2015 (ES6) で導入された 分割代入 (Destructuring assignment) 構文 を使用すると、2 つ以上の変数を簡単に入れ替えることができます。
let a = 1; let b = 2; [a, b] = [b, a]; 参考: 配列の分割代入で複数の値を同時に代入する (Array destructuring) ｜ まくまくJavaScriptノート</description></item><item><title>TypeScriptの環境/設定: 厳格な型チェックを有効にする (strict)</title><link>https://maku.blog/p/7b9432m/</link><pubDate>Fri, 08 May 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/7b9432m/</guid><description>厳格モードに関するオプション TypeScript の設定ファイル (tsconfig.json) には、厳格な型チェックを有効にするための strict オプションが用意されています。
プロパティ名 デフォルト値 説明 strict false Enable all strict type checking options. コンパイル時の様々な厳格な型チェック機能を有効にします。 tsconfig.json の記述例 { &amp;#34;include&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;ES2015&amp;#34;, &amp;#34;module&amp;#34;: &amp;#34;commonjs&amp;#34;, &amp;#34;allowJs&amp;#34;: true, &amp;#34;outDir&amp;#34;: &amp;#34;./build&amp;#34;, &amp;#34;strict&amp;#34;: true /* Enable all strict type-checking options. */ } } 上記の例では、tsconfig.json で strict オプションを有効にしていますが、tsc コマンドのオプションで --strict と直接指定する方法もあります。
$ tsc --strict 実は、strict オプションは、下記のようなオプション群をまとめて true にするためのオプションです。
プロパティ名 デフォルト値 説明 noImplicitAny false Raise error on expressions and declarations with an implied any type.</description></item><item><title>TypeScriptサンプル: ジェネリッククラスの定義例（MyStackクラス）</title><link>https://maku.blog/p/tkwj6bw/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tkwj6bw/</guid><description>TypeScript で型パラメータを使用したジェネリッククラスの定義サンプルとして、簡単なスタッククラスの実装例です。 TypeScript の配列がスタックの代わりになるので、スタッククラスなど作る必要はありませんが、Generics の使用例ということで。
myStack.ts export class MyStack&amp;lt;T&amp;gt; { private items: T[] = []; push(item: T): void { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } } 使用例 (main.ts) import { MyStack } from &amp;#39;./myStack&amp;#39;; const stack = new MyStack&amp;lt;number&amp;gt;(); stack.push(1); stack.push(2); stack.push(3); console.log(stack.pop()); //=&amp;gt; 3 console.log(stack.pop()); //=&amp;gt; 2 console.log(stack.pop()); //=&amp;gt; 1 console.log(stack.pop()); //=&amp;gt; undefined</description></item><item><title>TypeScriptサンプル: 文字列内のひらがなとカタカナを変換する (hiraToKana, kanaToHira)</title><link>https://maku.blog/p/tzjvcad/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tzjvcad/</guid><description> util.ts export class Util { /** * 文字列に含まれているすべてのひらがなをカタカナに変換した文字列を作成します。 * ただし、半角文字は変換しません。 * @param str ひらがなを含む文字列 */ static hiraToKata(str: string): string { return str.replace(/[\u3041-\u3096]/g, ch =&amp;gt; String.fromCharCode(ch.charCodeAt(0) + 0x60) ); } /** * 文字列に含まれているすべてのカタカナをひらがなに変換した文字列を作成します。 * ただし、半角文字は変換しません。 * @param str カタカナを含む文字列 */ static kataToHira(str: string): string { return str.replace(/[\u30A1-\u30FA]/g, ch =&amp;gt; String.fromCharCode(ch.charCodeAt(0) - 0x60) ); } } 使用例 import { Util } from &amp;#39;./util&amp;#39;; console.log(Util.hiraToKata(&amp;#39;あいうアイウ&amp;#39;)); //=&amp;gt; アイウアイウ console.log(Util.kataToHira(&amp;#39;あいうアイウ&amp;#39;)); //=&amp;gt; あいうあいう 参考 ひらがなとカタカナを正規表現で表す</description></item><item><title>TypeScriptの環境: tsc-watch で ts ファイルの変更監視＆アプリの再起動を自動化する</title><link>https://maku.blog/p/nxzsnkf/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/nxzsnkf/</guid><description>TypeScript の監視と JavaScript の監視の両立 tsc --watch コマンドを使うと、TypeScript (.ts) ファイルの変更を監視して自動的に tsc （トランスパイル）を実行してくれるようになります。 nodemon コマンドを使うと、JavaScript (.js) ファイルの変更を監視して自動的に node コマンドを再起動してくれるようになります。
これらを組みあわせれば、TypeScript (.ts) ファイルの変更時に、自動的に Node.js アプリを再起動できそうな気がしますが、一連のコマンドとしてこれら 2 つを組み合わせて実行するのにはみんな苦労しているようです（もちろんコマンドシェルを 2 つ立ち上げればできますが）。
そこで便利なのが tsc-watch コマンド です。
tsc-watch パッケージでまるごと解決 tsc-watch という NPM パッケージ（コマンド）を使用すると、TypeScript の変更監視と Node アプリの再起動の連動を簡単に行えるようになります。 まず、必要なパッケージを下記のようにインストールします。 nodemon は使わなくて済むので、ここでは依存パッケージとして typescript と tsc-watch をインストールしておきます。 --save-dev オプションを付加して、package.json の devDependencies に登録するのを忘れないようにしましょう。
$ npm install --save-dev typescript $ npm install --save-dev tsc-watch tsc-watch コマンドはほとんど tsc --watch のラッパーなので、そのまま実行すると、TypeScript ファイルの変更を監視してトランスパイルを実行するという動作になります。 これだけの用途であれば tsc コマンドで十分なのですが、tsc-watch コマンドに追加されている --onSuccess オプションを使うと、トランスパイル後に任意の追加コマンドを実行することができます。 この追加コマンドとして npm start などを実行するように設定しておけば、TypeScript のトランスパイル後に Node.</description></item><item><title>TypeScriptの環境: 既存の JavaScript プロジェクトを TypeScript に乗り換える</title><link>https://maku.blog/p/3eccb2t/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/3eccb2t/</guid><description>TypeScript プロジェクトへの移行は簡単！ TypeScript の構文は、JavaScript のコードとの互換性を考慮して仕様が決められているため、既存の JavaScript プロジェクトを簡単に TypeScript プロジェクトに移行することができます。 後述するように設定をうまく行えば、JavaScript ファイルの拡張子を .ts に変える必要すらありません。
TypeScript の構文を使わないと意味がないのでは？と思うかもしれませんが、TypeScript のトランスパイラ (tsc) には、強力な静的解析の仕組みが備わっているため、この機能を既存の JavaScript ファイルに適用するだけでも TypeScript を導入する価値があります。
ここでは、tsc コマンドは下記のようにグローバルにインストールしてあることを前提とします。
$ npm install -g typescript おすすめのディレクトリ構成 既存の JavaScript コードを TypeScript トランスパイラ (tsc) の変換対象にする場合は、入力ファイルとなる .js ファイルと、生成される .js ファイルのディレクトリを明確に区別しておくべきです。 そうしておかないと、どのファイルが自分が作成したファイルで、どのファイルが自動生成されたファイルなのか分かりにくくなってしまいます。
ここでは、既存の JavaScript プロジェクトのソースコード (.js) を、下記のように src ディレクトリに格納します。 このディレクトリには、最終的に .js ファイルと .ts ファイルが混在していても構いません。
project/ +-- tsconfig.js （設定ファイル） +-- build/ （出力用ディレクトリ） +-- src/ （入力用ディレクトリ） +-- main.js +-- module1.js +-- module2.js 上記では、src ディレクトリの直下に .</description></item></channel></rss>