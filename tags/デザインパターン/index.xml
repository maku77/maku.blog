<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>デザインパターン on まくろぐ</title><link>https://maku.blog/tags/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/</link><description>Recent content in デザインパターン on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Fri, 12 Oct 2018 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/index.xml" rel="self" type="application/rss+xml"/><item><title>１時間で分かる GoF デザインパターン</title><link>https://maku.blog/p/7gmjvza/</link><pubDate>Tue, 13 May 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/7gmjvza/</guid><description>&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797311126/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/61zDpaqhh7L.jpg" alt="オブジェクト指向における再利用のためのデザインパターン">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">オブジェクト指向における再利用のためのデザインパターン&lt;/div>
 &lt;div class="xAmazon_info_author">エリック ガンマ, ラルフ ジョンソン, リチャード ヘルム, ジョン ブリシディース&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797327030/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/71aAui0y3bL.jpg" alt="増補改訂版Java言語で学ぶデザインパターン入門">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">増補改訂版Java言語で学ぶデザインパターン入門&lt;/div>
 &lt;div class="xAmazon_info_author">結城 浩&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>デザインパターンの輪講をしたときのメモ。&lt;/p>
&lt;h2 id="生成に関するパターン-creational-patterns">生成に関するパターン (Creational Patterns)&lt;/h2>
&lt;h3 id="1-abstract-factory-パターン">(1) Abstract Factory パターン&lt;/h3>
&lt;p>同種の複数のオブジェクト生成を concrete factory クラスとして種類ごとにまとめ、実際の生成は abstract factory クラスの抽象化されたインタフェース経由で行う。&lt;strong>一貫した種類のインスタンスを作ることができる&lt;/strong>。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実装イメージ&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">TvFactory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tvFactory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SonyTvFactory&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// Sony 製の TV を作るための TvFactory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">tvFactory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">CreatePanel&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// SonyPanel を生成&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">tvFactory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">CreateTuner&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// SonyTuner を生成&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>どのような手順で factory method を呼び出すかを定義すると、それは Builder パターンになる。&lt;/p>
&lt;h3 id="2-builder-パターン">(2) Builder パターン&lt;/h3>
&lt;p>オブジェクトの&lt;strong>生成手順を共通化&lt;/strong>して使いまわし、異なるオブジェクトを作成。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実装イメージ&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Product&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Director&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">CreateProduct&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Builder&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CreateStep1&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CreateStep2&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CreateStep3&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">GetProduct&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記のメソッドに異なる Builder オブジェクトを渡せば、異なる Product が生成される。ただし、作成手順は共通化されている。&lt;/p></description></item><item><title>デザインパターン: MVC パターンのメモ</title><link>https://maku.blog/p/cps3nt8/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/cps3nt8/</guid><description>&lt;h2 id="mvc-パターンの構造">MVC パターンの構造&lt;/h2>
&lt;h3 id="オブジェクト図">オブジェクト図&lt;/h3>


&lt;figure class="xImage">
 &lt;img style="" width="341" height="184" src="../../p/cps3nt8/mvc-object.png" alt="/p/cps3nt8/mvc-object.png" />
 &lt;figcaption> &lt;span class="xImage_codeLink">≪&lt;a href="mvc-object.puml.txt">生成コード&amp;#x1F4D6;&lt;/a>≫&lt;/span>&lt;/figcaption>
&lt;/figure>

&lt;h3 id="シーケンス図">シーケンス図&lt;/h3>


&lt;figure class="xImage">
 &lt;img style="" width="365" height="346" src="../../p/cps3nt8/mvc-sequence.png" alt="/p/cps3nt8/mvc-sequence.png" />
 &lt;figcaption>図: シーケンス図 &lt;span class="xImage_codeLink">≪&lt;a href="mvc-sequence.puml.txt">生成コード&amp;#x1F4D6;&lt;/a>≫&lt;/span>&lt;/figcaption>
&lt;/figure>

&lt;h3 id="m-model">M (Model)&lt;/h3>
&lt;p>&lt;strong>処理。ビジネス・ロジック。&lt;/strong>&lt;/p>
&lt;p>アプリケーションが使用するデータを保持し、アプリケーション固有の処理を実行する。
外部のストレージ（データベース）に保存するためのインタフェースなどを備えていてもよい。&lt;/p>
&lt;p>特に、保持するデータを参照するための public インタフェースだけを備えているものを Model ということもある。J2EE デザインパターンでは、純粋にデータのみを保持するものを Value Object と呼んでいる。&lt;/p>
&lt;p>&lt;strong>View、Controller とは関連性を持たないのが望ましい。&lt;/strong>
Model オブジェクトは、自分自身がどのように表示されるかを知らない。&lt;/p>
&lt;p>&lt;strong>特定の実行環境に依存しないのが望ましい。&lt;/strong>
例えば、特定のフレームワーク上に構築されたアプリケーションであっても、Model クラスだけは別のフレームワークでも使用できるようにするべき。つまり、フレームワークに特化したインタフェースを備えてはいけない。&lt;/p>
&lt;h3 id="v-view">V (View)&lt;/h3>
&lt;p>&lt;strong>表示。プレゼンテーション・ロジック。&lt;/strong>&lt;/p>
&lt;p>データを目に見える形で表示するためのコード。ウィンドウアプリケーションでは、ウィンドウ内に表示するウィジット等の表示、Web アプリケーションでは、HTML の出力などが View に当たる。&lt;/p>
&lt;h3 id="c-controller">C (Controller)&lt;/h3>
&lt;p>&lt;strong>入力。インタラクション・ロジック。&lt;/strong>&lt;/p>
&lt;p>ユーザやシステムからのイベントを受けとり、Model や View の作成、更新、相互作用を管理する。&lt;/p>
&lt;h2 id="mvc-パターンの-pros-and-cons">MVC パターンの Pros and Cons&lt;/h2>
&lt;ul>
&lt;li>利点 (Pros.)
&lt;ul>
&lt;li>UI コードにビジネスロジックが入るのを防ぐことができる。&lt;/li>
&lt;li>ユニットテストしやすい。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>欠点 (Cons.)
&lt;ul>
&lt;li>スケールしない（UI は個々に作成できるが、モデルを分離しにくい）&lt;/li>
&lt;li>Contoller が肥大化しやすい（View からの処理がすべて Controller 経由になる）&lt;/li>
&lt;li>SOLID 原則の S (Single responsibility principle) と I (Interface segregation principle) に違反してしまう。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="view-と-controller-の関連">View と Controller の関連&lt;/h2>
&lt;p>多くの GUI toolkit では、V (View) と C (Controller) は複雑に絡み合っている。なぜなら、C (Controller) は、それ自体が画面上に表示される widget であることが多いから。&lt;/p></description></item><item><title>デザインパターン: MVP パターンのメモ</title><link>https://maku.blog/p/5wu6fbv/</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/5wu6fbv/</guid><description>&lt;p>MVP (Model-View-Presenter) パターンでは、MVC (Model-View-Controller) パターンと異なり、View と Model が直接やり取りせず、すべて Presenter 経由でのやり取りになります（亜種としてデータバインディングを使用するケースもあります）。&lt;/p>
&lt;h2 id="mvp-パターンの構造">MVP パターンの構造&lt;/h2>
&lt;h4 id="オブジェクト図">オブジェクト図&lt;/h4>


&lt;figure class="xImage">
 &lt;img style="" width="714" height="102" src="../../p/5wu6fbv/mvp-object.png" alt="/p/5wu6fbv/mvp-object.png" />
 &lt;figcaption> &lt;span class="xImage_codeLink">≪&lt;a href="mvp-object.puml.txt">生成コード&amp;#x1F4D6;&lt;/a>≫&lt;/span>&lt;/figcaption>
&lt;/figure>

&lt;h4 id="シーケンス図">シーケンス図&lt;/h4>


&lt;figure class="xImage">
 &lt;img style="" width="836" height="358" src="../../p/5wu6fbv/mvp-sequence.png" alt="/p/5wu6fbv/mvp-sequence.png" />
 &lt;figcaption> &lt;span class="xImage_codeLink">≪&lt;a href="mvp-sequence.puml.txt">生成コード&amp;#x1F4D6;&lt;/a>≫&lt;/span>&lt;/figcaption>
&lt;/figure>

&lt;h2 id="mvp-の構成要素">MVP の構成要素&lt;/h2>
&lt;ul>
&lt;li>&lt;b>View&lt;/b>: 描画ロジックを持つ。自分自身が能動的に描画処理を行うことはなく、Presenter からの要求で描画処理を行うため、Passive View と呼ばれる。Presenter に言われたとおりに、渡されたデータを描画するだけ。ユーザの入力を受け、Presenter へ通知する。&lt;/li>
&lt;li>&lt;b>Presenter&lt;/b>: ユーザイベントをハンドルし、具体的なアクションを実行する (Proxy)。データを Model から取得し、View が扱える形に加工して描画情報として渡す。&lt;/li>
&lt;li>&lt;b>Model&lt;/b>: ビジネスロジックとデータ保持（およびデータ取得処理）を担う。DB や Web サービスと通信してデータを取得する役割を持つ。必要に応じて Presenter へ変更通知を送る。&lt;/li>
&lt;/ul>
&lt;h2 id="mvp-の-pros-and-cons">MVP の Pros and Cons&lt;/h2>
&lt;ul>
&lt;li>Pros.
&lt;ul>
&lt;li>複雑なタスクをシンプルなタスクに分割できる。&lt;/li>
&lt;li>クラスが小さくなり、不具合が入りにくくデバッグしやすくなる。&lt;/li>
&lt;li>ユニットテストできる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cons.
&lt;ul>
&lt;li>各レイヤを繋ぐ退屈な作業が必要。&lt;/li>
&lt;li>Model が特定のユースケースに結びついてしまい再利用しにくい。&lt;/li>
&lt;li>View と Presenter が特定のデータ形式により結び付けられてしまう（Model の提供するデータを Presenter 経由で View に渡すときにデータの依存ができる）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="mvp-の各コンポーネントの生成過程">MVP の各コンポーネントの生成過程&lt;/h2>
&lt;p>MVP パターンを導入しようとするときに、最初に迷うのがオブジェクトの所有関係をどうするかだと思います。
下記は MVP の一般的なオブジェクトの生成過程です。&lt;/p>
&lt;ol>
&lt;li>アプリを起動すると &lt;strong>View が生成される&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>View は&lt;/strong>自分自身を制御してもらうための &lt;strong>Presenter を生成する&lt;/strong>。Presenter に自分自身の参照を渡しておく（これは、Presenter から View を制御してもらう必要があるため）。&lt;/li>
&lt;li>&lt;strong>Presenter は&lt;/strong>ビジネスロジックを実行するための &lt;strong>Model を生成する&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>Presenter は、View や Model の参照を持つ必要があるわけですが、このとき View の具象クラスの参照を保持するのではなく、インタフェース型の参照（IView的な）として保持するのがポイントです。
こうすることにより、Presenter の単体テストが可能になります（View のモックを作成する）。&lt;/p></description></item><item><title>読書メモ『J2EE パターン』 Deepak Alur、John Crupi、Dan Malks</title><link>https://maku.blog/p/saanpfh/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/saanpfh/</guid><description>&lt;p>J2EE のパターンコレクションを示した本です。
有名な GoF のデザインパターンとは異なる、21 のパターンが紹介されています。
既存のプロジェクトにパターンを適用するにはリファクタリングが必要になりますが、その方法も示されています。&lt;/p>
&lt;h3 id="grady-boochrational-software-corporation-主任研究員のまえがき">Grady Booch（Rational Software Corporation 主任研究員）のまえがき&lt;/h3>
&lt;p>パターンに名前を付けることによって、新たな語彙を手に入れ、それまでは気付かなかったであろう方法でパターンを適用できるようになる。&lt;/p>
&lt;p>慢性的に時間に余裕がないところでは、美しいソフトウェアはなかなか書けない。
しかし、適切なパターンを選んで適用すれば、システムにある程度の優雅さをもたらすことができる。&lt;/p>
&lt;h3 id="マイクロアーキテクチャとは">マイクロアーキテクチャとは&lt;/h3>
&lt;p>マイクロアーキテクチャは、アプリケーションおよびシステムの構築に利用できるビルディングブロック。個々のパターンよりも抽象度が高く、複数のパターンをリンクさせ組み合わせて表現することができる。&lt;/p>
&lt;h2 id="第1章-パターンとj2ee">第1章: パターンとJ2EE&lt;/h2>
&lt;h3 id="パターンの定義">パターンの定義&lt;/h3>
&lt;blockquote>
&lt;p>パターンとは、特定の文脈、問題、および解決策の相関関係を表した、3要素から成る規則である。&lt;/p>
&lt;div style="text-align:right">─Christopher Alexander 『A Pattern Language』&lt;/div>
&lt;/blockquote>
&lt;blockquote>
&lt;p>パターンとは、「特定の文脈」、「その文脈において繰り返し発生する問題」、および「これらの問題を解決する特定のソフトウェア構造」の3要素の相関関係を表した規則である。&lt;/p>
&lt;div style="text-align:right">─Richard Gabriel『A Timeless Way of Hacking』&lt;/div>
&lt;/blockquote>
&lt;blockquote>
&lt;p>パターンとは、ある現実の文脈の中で有用であって、他の文脈の中でもおそらく有用であろうと思われるアイデアである。&lt;/p>
&lt;div style="text-align:right">─Martin Fowler『Analysis Patterns』&lt;/div>
&lt;/blockquote>
&lt;p>&lt;b>&lt;strong>繰り返し発生する問題&lt;/strong>と、その解決策に関する知識を表現して伝えるには、パターンが理想的なツールである&lt;/b>。
考慮事項、アイデア、メモなどの知識を公式に文書化して伝えることができるようになる。&lt;/p>
&lt;h2 id="第2章-プレゼンテーション層における設計上の考慮事項とバッドプラクティス">第2章: プレゼンテーション層における設計上の考慮事項とバッドプラクティス&lt;/h2>
&lt;p>この章では、ユーザセッションやクライアントアクセスの制限に関しての概要が述べられている。
プレゼンテーション層におけるバッドプラクティスがざっと羅列してあるが、特に目新しさは感じられない（コントローラーが肥大化したら他のオブジェクトに処理を委譲する、といった程度のことしか書いてない）。
第6章以降のパターンカタログの方を見ていくのがよい。&lt;/p>
&lt;h2 id="第3章-ビジネス層における設計上の考慮事項とバッドプラクティス">第3章: ビジネス層における設計上の考慮事項とバッドプラクティス&lt;/h2>
&lt;p>ステートレスなセッションBeanであれば、Beanをプールしておいて、複数のクライアントで使いまわせる。
スケーラビリティの問題のほとんどは、ステートフルセッションBeanや、ステートレスセッションBeanの誤用によるものである。
スケーラビリティが必要なシステムでは、ステートレスセッションBeanを使用することがより実用的な設計戦略となり得る。
1回のメソッド呼び出しでサービスが完了するビジネスプロセス（非対話型ビジネスプロセス）を実装するには、ステートレスセッションBeanを使うとよい。&lt;/p>
&lt;p>スケーラビリティの向上を狙って、どのようなケースでもステートレスセッションBeanを選択する設計者もいる。
しかし、こうした設計を行ったために、ネットワークトラフィックのオーバーヘッド、再構築時間、アクセス時間などが絡んできて、かえってスケーラビリティが低下してしまっては本末転倒である。&lt;/p></description></item><item><title>読書メモ『パターン指向リファクタリング入門』ジョシュア・ケリーエブスキー</title><link>https://maku.blog/p/2j4w6nn/</link><pubDate>Fri, 29 Jun 2018 00:00:00 +0900</pubDate><guid>https://maku.blog/p/2j4w6nn/</guid><description>&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4822282384/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/51FBETlRf5L.jpg" alt="パターン指向リファクタリング入門">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">パターン指向リファクタリング入門&lt;/div>
 &lt;div class="xAmazon_info_author">ジョシュア・ケリーエブスキー&lt;/div>
 &lt;div class="xAmazon_info_publisher">日経BP社&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>マーチン・ファウラーの『リファクタリング』の続編のような本で、デザインパターンを活用しながら、どのようにソフトウェアの設計を改善しけばよいかを示しています。
パターンの知識を付けるだけでなく、&lt;strong>パターンの賢い使い方を知る&lt;/strong>ことをテーマとしています。&lt;/p>
&lt;p>この本の特徴として、現実のコード、あるいは実際に使用したコードを元にしたコードが使用されている点が挙げられます。
実際のプロジェクトにはリファクタリングに関して多くの制約があり、それは作り物のコードでは体験できないものです。&lt;/p>
&lt;p>以下は全11章のメモです。&lt;/p>
&lt;h2 id="第1章-本書を執筆した理由">第1章: 本書を執筆した理由&lt;/h2>
&lt;ul>
&lt;li>コードを必要以上に柔軟にしたり洗練させることは、作り込みすぎ (over-engineering) である。チームのプログラマたち（特に新しく参加した人たち）は、無意味に大きく複雑なコードベースを扱わなければならなくなる。&lt;strong>作り込みすぎは生産性を低下させる&lt;/strong>。作り込みすぎな設計を引き継ぐ場合、&lt;strong>拡張や保守を行うのに多大な時間がかかる&lt;/strong>。&lt;/li>
&lt;li>とはいうものの、作り込み不足 (under-engineering) は作り込みすぎよりずっと多い。&lt;/li>
&lt;li>&lt;strong>TDD と継続的なリファクタリングのリズムを身に着ける&lt;/strong>には経験と時間が必要だが、この開発スタイルに慣れてしまえば、&lt;strong>別の方法で実稼働するコードを作成することは奇妙で、不安で、プロフェッショナルらしくないと感じるようになる&lt;/strong>。&lt;/li>
&lt;li>優れた設計を行いたいなら、設計そのものを調べるよりも、&lt;strong>その設計がどのように進化してきたかを知らべる方が有益だ&lt;/strong>。真の知恵は進化の中に存在する。&lt;/li>
&lt;/ul>
&lt;h2 id="第2章-リファクタリング">第2章: リファクタリング&lt;/h2>
&lt;ul>
&lt;li>コードが明確でない臭いの元は、リファクタリングで取り除くべきであって、コメントで脱臭するべきではない。そのようなコードをリファクタリングをするときは、そのコードをよく理解している人に立ち会ってもらうのが一番である。&lt;/li>
&lt;li>実際に&lt;strong>リファクタリングを促すものは感情だ&lt;/strong>。私はコーディングの不快感を少しでも減らすためだけにリファクタリングを行うことがよくある。&lt;/li>
&lt;li>マーチンファウラーの言葉「コンパイラが理解できるコードは誰にでも書ける。&lt;strong>すぐれたプログラマは、人間にとってわかりやすいコードを書く&lt;/strong>。」&lt;/li>
&lt;li>小さい単純なステップに分けることで、大きなステップよりも間違いなく早く目標にたどり着くことができる。&lt;/li>
&lt;li>&lt;strong>アプリチームとフレームワークチームを1つのチームに&lt;/strong>しておけば、それらがちぐはぐになることがない。フレームワークはアプリのニーズにもとづいて作られるので、価値のあるフレームワークのコードだけが作成される。ただし、&lt;strong>このプロセスには継続的なリファクタリングが必須&lt;/strong>である。それによって、フレームワークとアプリを分けておくことができる。&lt;/li>
&lt;/ul>
&lt;h2 id="第3章-パターン">第3章: パターン&lt;/h2>
&lt;ul>
&lt;li>パターン魔 (patterns happy) は、パターンに魅了され、コードでパターンを使わずにいられなくなった人。誰しもがパターンを学ぶ過程でパターン魔になる。リファクタリングによってパターンを徐々にシステムに組み込んでいくようにすれば、パターンによって作り込みすぎる可能性は低くなる。&lt;/li>
&lt;li>残念なことに&lt;strong>多くプログラマは、デザインパターン本に例示されている各パターンの構造の図が、そのパターンを実装する唯一の方法だと間違えて捉えている&lt;/strong>。『デザインパターン』の共著者の一人であるジョン・ブリシデスも、「実際のコードにはいろいろなニーズや制約があり、示されている構造の図とは大きく異なってくる」と述べている。例示されている構造をそのまま実装するのではなく、&lt;strong>パターンの実装を必要最小限に抑えることは、進化的設計のプラクティスである&lt;/strong>。目的は設計をよりよくすることであって、パターンを実装することではないことを忘れないこと。&lt;/li>
&lt;li>一般的には、パターンを実装することで、コードの重複を取り除き、ロジックを単純化し、意図を伝えやすくし、柔軟性を高めることができるはずである。しかし、パターンに慣れていない人がコードを読むと、わかりにくい、複雑すぎると感じることがある。このような&lt;strong>意見の食い違いが発生した場合は、パターンの使用をやめるより、チームがパターンを学ぶ方がよい&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="第4章-コードの臭い">第4章: コードの臭い&lt;/h2>
&lt;ul>
&lt;li>もっともよくある設計の問題は、次のようなコードが原因である。
&lt;ul>
&lt;li>重複している&lt;/li>
&lt;li>不明確である&lt;/li>
&lt;li>複雑である&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>メソッドの適した行数はどのくらいであろうか？&lt;strong>ほとんどのメソッドが1～5行のコードからできているものが適切&lt;/strong>だと私は考えている。小さなメソッドを連鎖させても、性能はほとんど低下しない。プロファイラを使えば明らかである。&lt;/li>
&lt;/ul>
&lt;h2 id="第5章-パターンを取り入れるリファクタリングのカタログ">第5章: パターンを取り入れるリファクタリングのカタログ&lt;/h2>
&lt;p>この章では、この本の読み進め方が述べられています。&lt;/p>
&lt;h2 id="第6章-生成">第6章: 生成&lt;/h2>
&lt;h3 id="creation-method-によるコンストラクタの置き換え-replace-constructors-with-creation-methods">Creation Method によるコンストラクタの置き換え (Replace Constructors with Creation Methods)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 1つのクラスに複数のコンストラクタがあると、開発時にどのコンストラクタを使うかの判断が難しくなる。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: コンストラクタの代わりに、意図がわかりやすい Creation Method を作成し、それがオブジェクトのインスタンスを返すようにする。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>どのような種類のインスタンスが返されるかがコンストラクトよりもよく伝わる。&lt;/li>
&lt;li>引数の数と型が同じであるコンストラクタを2つ作成できないといった、コンストラクタの制限事項を回避できる。&lt;/li>
&lt;li>使われていない生成コードを見つけるのが簡単になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 生成方法が標準に準拠しなくなる。new によってインスタンスを生成するクラスと「Creation Method」を使うクラスとが混在する。&lt;/li>
&lt;/ul>
&lt;h3 id="factory-による生成処理の置き換え-move-creation-knowledge-to-factory">Factory による生成処理の置き換え (Move Creation Knowledge to Factory)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: クラスのインスタンス化に使うデータやコードが数多くのクラスに散在している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 生成に関する知識を1つの Factory クラスに移動する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>生成ロジックとインスタンス化／設定のための情報をまとめられる。&lt;/li>
&lt;li>クライアントを生成ロジックから切り離すことができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 直接のインスタンス化に比べて設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;h3 id="factory-によるクラス群の隠蔽-encapsulate-classes-with-factory">Factory によるクラス群の隠蔽 (Encapsulate Classes with Factory)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 1つのパッケージ内に存在して共通のインタフェースを実装しているクラス群を、クライアントが直接インスタンス化している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: クラスのコンストラクタをパブリックでなくし、クライアントには Factory 経由でインスタンスを生成させる。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>さまざまな種類のインスタンスの生成を、意図が明確なメソッド経由で行うことで、単純化できる。&lt;/li>
&lt;li>公開する必要のないクラスが隠蔽されるため、パッケージの「概念的重み」(by Bloch) を減らすことができる。&lt;/li>
&lt;li>「インタフェースに対してプログラミングするのであって、実装に対してプログラミングするのではない」（書籍『デザインパターン』より）という原理を厳しく適用できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>
&lt;ul>
&lt;li>新しい種類のインスタンスを生成しなければならない場合には、Creation Method の新規作成や変更が必要になる。&lt;/li>
&lt;li>Factory のソースコードではなくバイナリコードにしかアクセスできない場合には、カスタマイズが制限される。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="factory-method-によるポリモーフィックな生成の導入-introduce-polymorphic-creation-with-factory-method">Factory Method によるポリモーフィックな生成の導入 (Introduce Polymorphic Creation with Factory Method)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 階層内のクラスが、オブジェクトの生成ステップを除いて同じようにメソッドを実装している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: そういったメソッドをスーパークラスで1つにまとめ、そこで Factory Method を呼び出してインスタンス化の処理を行う。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>オブジェクトを生成するステップが異なることが原因で生じている重複が減る。&lt;/li>
&lt;li>どこで生成が行われているか、どのようにオーバーライドされているかが効果的に伝えられる。&lt;/li>
&lt;li>Factory Method で使うためにクラスがどの型を実装しなければならないのかが明確になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: Factory Method を実装するクラスに不必要な引数を渡さなければならないことがある。&lt;/li>
&lt;/ul>
&lt;h3 id="builder-による-composite-の隠蔽-encapsulate-composite-with-builder">Builder による Composite の隠蔽 (Encapsulate Composite with Builder)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: Composite の構築処理が何度も出現したり、複雑であったり、あるいはエラーを起こしやすいものになっている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 詳細部分を Builder に任せることで、構築を単純化する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>Composite を構築するクライアントコードを単純化できる。&lt;/li>
&lt;li>Compsoite の生成にまつわる繰り返しやエラーを軽減できる。&lt;/li>
&lt;li>クライアントと Composite の間の結合度が低くなる。&lt;/li>
&lt;li>カプセル化された Composite や複合オブジェクトを異なった形式で表現できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: インタフェースの意図が伝わりにくくなる可能性がある。&lt;/li>
&lt;/ul>
&lt;h3 id="singleton-のインライン化">Singleton のインライン化&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: コードからあるオブジェクトにアクセスしなければならないが、グローバルなアクセス方法は必要でない。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Singleton の機能を1つのクラスに移し、そのクラスにオブジェクトを格納してアクセス手段を提供する。Singleton は削除する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>オブジェクトの協調関係がより見えやすく明示的になる。&lt;/li>
&lt;li>唯一のインスタンスを保護するための特別なコードを必要としない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: いくつもの層を経由してオブジェクトインスタンスを渡すのが面倒だったり困難だったりする場合には、設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;h2 id="第7章-単純化">第7章: 単純化&lt;/h2>
&lt;h3 id="メソッドの構造化-compose-method">メソッドの構造化 (Compose Method)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: メソッドのロジックをすぐに理解できない。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 意図の伝わりやすい、詳細レベルが揃った小さなステップ群にロジックを変換する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>メソッドが何をし、それをどのように行うかが効果的に伝わる。&lt;/li>
&lt;li>詳細レベルが揃った、わかりやすい名前がついた振る舞いに分割することで、メソッドを単純化できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>小さなメソッドが増えすぎることがある。&lt;/li>
&lt;li>多数の小さなメソッドにロジックが分散するため、デバッグが困難になることがある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="strategy-による条件判断の置き換え-replace-conditional-logic-with-strategy">Strategy による条件判断の置き換え (Replace Conditional Logic with Strategy)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: いくつかの計算方法のうちどれを実行するかを、メソッド内の条件ロジックで制御している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 計算方法ごとに Strategy を作成し、元のメソッドは計算処理を Strategy のインスタンスに委譲する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>条件ロジックが減る、あるいは取り除かれるため、アルゴリズムが明白になる。&lt;/li>
&lt;li>アルゴリズムのバリエーションをクラス階層に移すため、個々のクラスが単純になる。&lt;/li>
&lt;li>実行時にアルゴリズムを別のものに置き換えることができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>継承による解決策や「条件記述の単純化」のリファクタリングを使った方が簡単な場合には、それよりも設計が複雑になる。&lt;/li>
&lt;li>アルゴリズムがコンテキストクラスとデータをやり取りする方法が複雑になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="decorator-による拡張機能の書き換え-move-embellishment-to-decorator">Decorator による拡張機能の書き換え (Move Embellishment to Decorator)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: コードがクラスの核となる責務に対する拡張機能を提供している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 拡張機能を Decorator に移動する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>拡張機能が取り除かれるのでクラスを単純にできる。&lt;/li>
&lt;li>クラスの核となる責務と拡張機能とを効果的に区別できる。&lt;/li>
&lt;li>関連する複数のクラスに含まれる重複した拡張ロジックを取り除くことができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>装飾対象のオブジェクトと装飾後のオブジェクトは異なるものになってしまう。&lt;/li>
&lt;li>コードを理解したりデバッグしたりするのが困難な場合がある。&lt;/li>
&lt;li>Decorator を組み合わせた際、互いに悪影響を及ぼす場合には、設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="state-による状態変化のための条件判断の置き換え-replace-state-altering-conditionals-with-state">State による状態変化のための条件判断の置き換え (Replace State-Altering Conditionals with State)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: オブジェクトの状態遷移を制御する条件式が複雑である。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 条件式ではなく、個々の状態とその間の遷移を扱う State クラスを使う。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>状態を変えるための条件ロジックがなくなる、あるいは減る。&lt;/li>
&lt;li>状態を変える複雑なロジックが単純になる。&lt;/li>
&lt;li>状態を変えるロジックを俯瞰することができる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 状態遷移ロジックがもともとわかりやすい場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h3 id="composite-による暗黙的なツリー構造の置き換え-replace-implicit-tree-with-composite">Composite による暗黙的なツリー構造の置き換え (Replace Implicit Tree with Composite)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: String などの基本データ型の表現によって、暗黙的なツリー構造を作っている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 基本データ型の表現を Composite で置き換える。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>ノードの形成、追加、削除といった手順の繰り返しをカプセル化できる。&lt;/li>
&lt;li>同じようなロジックの増殖に対処する汎用的な方法となる。&lt;/li>
&lt;li>クライアントの構築作業が簡単になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 暗黙的なツリー構造を作成するほうが簡単な場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h3 id="command-による条件付きディスパッチャの置き換え-replace-conditional-dispatcher-with-command">Command による条件付きディスパッチャの置き換え (Replace Conditional Dispatcher with Command)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 条件ロジックによってリクエストを振り分け、アクションを実行している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: アクションごとに Command を作成する。Command をコレクションに格納し、条件ロジックを Command を取り出して実行するコードに置き換える。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>一律に同じやり方で、さまざまな振る舞いを実行するためのシンプルなメカニズムである。&lt;/li>
&lt;li>どのリクエストをどのように処理するかを実行時に変更できる。&lt;/li>
&lt;li>実装するためのコードが少ししか必要でない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 条件付きディスパッチャで用が足りる場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h2 id="第8章-汎用化">第8章: 汎用化&lt;/h2>
&lt;h3 id="template-method-の形成-form-template-method">Template Method の形成 (Form Template Method)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 複数のサブクラスの2つのメソッドが、同じ順番で似たようなステップを実行しているが、それらのステップはまったく同じではない。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: 各ステップを同じシグニチャを持つメソッド群に抽出してメソッドを汎用化し、それから汎用メソッドを引き上げて Template Method を形成する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>不変な振る舞いをスーパークラスに移すことで、サブクラス間の重複したコードを取り除くことができる。&lt;/li>
&lt;li>汎用のアルゴリズムのステップを簡潔にし、効果的に伝えることができる。&lt;/li>
&lt;li>サブクラスで簡単にアルゴリズムをカスタマイズできるようになる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: アルゴリズムを肉付けするためにサブクラスで多くのメソッドを実装しなければならない場合には、設計が複雑になる。&lt;/li>
&lt;/ul>
&lt;h3 id="composite-の抽出-extract-composite">Composite の抽出 (Extract Composite)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 階層内のサブクラスが同じ Composite を実装している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Composite を実装するスーパークラスを抽出する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>子に関する格納と処理の両ロジックの重複をなくすことができる。&lt;/li>
&lt;li>子を処理するロジックを継承することが効果的に伝わる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: 特になし。&lt;/li>
&lt;/ul>
&lt;h3 id="composite-による単数複数別の処理の置き換え-replace-onemany-distinctions-with-composite">Composite による単数・複数別の処理の置き換え (Replace One/Many Distinctions with Composite)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: あるクラスが、1つのオブジェクトの場合と複数のオブジェクトの場合とを別のコードで処理している。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Composite を使って、1つのコードで、1つのオブジェクトの場合と複数オブジェクトの場合との両方を処理できるようにする。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>単数または複数のオブジェクト処理に関するコードの重複を取り除く。&lt;/li>
&lt;li>単数または複数のオブジェクトを統一したやり方で処理できる。&lt;/li>
&lt;li>複数オブジェクトの処理機能が豊富になる（OR表現など）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: Composite の構築時にタイプセーフかどうかの実行時チェックが必要なことがある。&lt;/li>
&lt;/ul>
&lt;h3 id="observer-によるハードコードされた通知の置き換え-replace-hard-coded-notifications-with-observer">Observer によるハードコードされた通知の置き換え (Replace Hard-Coded Notifications with Observer)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 別のクラスの1つのインスタンスに対する通知がサブクラスにハードコーディングされている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Observer インタフェースを実装した任意のクラスの任意の数のインスタンスにスーパークラスが通知を送れるようにし、サブクラスを削除する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>観察対象と観察者の間の結合度が低くなる。&lt;/li>
&lt;li>観察者が単数の場合にも複数の場合にも対処できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>:
&lt;ul>
&lt;li>ハードコーディングされた通知で用が足りる場合には、設計が複雑になる。&lt;/li>
&lt;li>通知がカスケードしている場合には、設計が複雑になる。&lt;/li>
&lt;li>観察対象から観察者が削除されないと、メモリリークが起きる可能性がある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="adapter-によるインタフェースの統合-unify-interfaces-with-adapter">Adapter によるインタフェースの統合 (Unify Interfaces with Adapter)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: クライアントが2つのクラスと相互作用していて、その1つが好ましいインタフェースを持っている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: Adapter によってインタフェースを統合する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>クライアントコードが同じインタフェースを通じて複数のクラスとやり取りできるため、コードの重複をなくしたり減らしたりできる。&lt;/li>
&lt;li>共通のインタフェースを通じてオブジェクトやり取りできるため、クライアントコードが簡潔になる。&lt;/li>
&lt;li>クライアントが複数のクラスとやり取りする方法を統合できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: アダプタを作らなくてもクラスのインタフェースを変更できる場合には、設計が複雑になるだけである。&lt;/li>
&lt;/ul>
&lt;h3 id="adapter-の抽出-extract-adapter">Adapter の抽出 (Extract Adapter)&lt;/h3>
&lt;ul>
&lt;li>&lt;b>問題&lt;/b>: 1つのクラスが、コンポーネント、ライブラリ、API、あるいは他のエンティティの複数バージョンに対するアダプタになっている。&lt;/li>
&lt;li>&lt;b>対策&lt;/b>: コンポーネント、ライブラリ、API、あるいは他のエンティティのバージョンごとに Adapter を1つ抽出する。&lt;/li>
&lt;li>&lt;b>利点&lt;/b>:
&lt;ul>
&lt;li>コンポーネントやライブラリや API のバージョンごとの違いを切り分けることができる。&lt;/li>
&lt;li>クラスの責務を1つのバージョンに対応することだけに限定できる。&lt;/li>
&lt;li>頻繁なコードの変更が必要な部分を限定できる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;b>欠点&lt;/b>: Adapter で提供されていない重要な振る舞いをクライアントが使えなくなることがある。&lt;/li>
&lt;/ul>
&lt;h3 id="interpreter-による暗黙的な言語処理の置き換え-replace-implicit-language-with-interpreter">Interpreter による暗黙的な言語処理の置き換え (Replace Implicit Language with Interpreter)&lt;/h3>
&lt;p>ある言語の文法に関して、実装する必要のあるクラスが10程度までなら、Interpreter パターンを使ってモデリングするのが有効かもしれない。&lt;/p></description></item><item><title>Kent Beck の CollectingParameter パターン</title><link>https://maku.blog/p/8yhxet9/</link><pubDate>Sun, 10 Apr 2011 00:00:00 +0900</pubDate><guid>https://maku.blog/p/8yhxet9/</guid><description>&lt;h2 id="collecting-parameter-の特徴">Collecting Parameter の特徴&lt;/h2>
&lt;p>巡回するオブジェクトの戻り値をベースに目的のデータを構築するのではなく、パラメータに渡したオブジェクトを使ってデータを構築する。&lt;/p>
&lt;ul>
&lt;li>戻り値となるオブジェクトのインスタンス化を防ぐことができるので、コードの実行速度が上がる。&lt;/li>
&lt;li>戻り値をベースにしたデータ構築よりも、より柔軟なタイミングでデータの構築が行える（例えば、メソッドの実行途中で結果を append できる）ようになり、コードを分割しやすくなる。&lt;/li>
&lt;/ul>
&lt;p>参考文献: &lt;a target="_blank" href="https://www.amazon.co.jp/dp/4822282384?tag=maku04-22">『パターン思考リファクタリング入門』&lt;/a>
 第10章 累積処理&lt;/p>
&lt;h2 id="collecting-parameter-を使わない場合の実装例">Collecting Parameter を使わない場合の実装例&lt;/h2>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">extractText&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuilder&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">results&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuilder&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">nodeList&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">results&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 戻り値をベースにしたデータ構築&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">results&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="collecting-parameter-を使う場合の実装例">Collecting Parameter を使う場合の実装例&lt;/h2>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">extractText&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuilder&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">results&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuilder&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">nodeList&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getText&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">results&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// パラメータをベースにデータ構築&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">results&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>巡回される要素の方で、Collecting Parameter を使ってデータを構築します。&lt;/p></description></item><item><title>『アジャイルソフトウェア開発の奥義』ロバート・C・マーチン（輪講メモ）</title><link>https://maku.blog/p/fn9ris5/</link><pubDate>Mon, 27 Oct 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/fn9ris5/</guid><description>&lt;p>今回読み進める本は、『アジャイルソフトウェア開発の奥義』です。
第2版までは日本語版が出てます。内容的にはどの版のものを読んでも大丈夫。&lt;/p>
&lt;h3 id="第1版">第1版&lt;/h3>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797323361/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/51YANQY595L.jpg" alt="アジャイルソフトウェア開発の奥義">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">アジャイルソフトウェア開発の奥義&lt;/div>
 &lt;div class="xAmazon_info_author">ロバート・C・マーチン&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;h3 id="第2版">第2版&lt;/h3>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/4797347783/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/71cDOUiJvPL.jpg" alt="アジャイルソフトウェア開発の奥義 第2版 オブジェクト指向開発の神髄と匠の技">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">アジャイルソフトウェア開発の奥義 第2版 オブジェクト指向開発の神髄と匠の技&lt;/div>
 &lt;div class="xAmazon_info_author">ロバート・C・マーチン&lt;/div>
 &lt;div class="xAmazon_info_publisher">ソフトバンククリエイティブ&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;h3 id="第3版">第3版&lt;/h3>
&lt;div class="xAmazon">
 &lt;a href="https://www.amazon.co.jp/exec/obidos/ASIN/0131857258/maku04-22/ref=nosim/" target="_blank">
 &lt;div class="xAmazon_image">
 &lt;img src="https://images-na.ssl-images-amazon.com/images/I/81EjDm%2BYl8L.jpg" alt="Agile Principles, Patterns, and Practices in C#">
 &lt;/div>
 &lt;div class="xAmazon_info">
 &lt;div class="xAmazon_info_title">Agile Principles, Patterns, and Practices in C#&lt;/div>
 &lt;div class="xAmazon_info_author">Robert C. Martin&lt;/div>
 &lt;div class="xAmazon_info_publisher">Prentice Hall&lt;/div>
 &lt;div class="xAmazon_info_icon">&lt;img src="data:image/gif;base64,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" alt="アマゾンのロゴ">&lt;/div>
 &lt;/div>
 &lt;/a>
&lt;/div>
&lt;p>ちなみに版が進むごとにサンプルコードの言語がより高水準な言語に変わっています。&lt;/p>
&lt;ul>
&lt;li>第1版: C/C++&lt;/li>
&lt;li>第2版: Java&lt;/li>
&lt;li>第3版: C#&lt;/li>
&lt;/ul>
&lt;p>第1版と第2版の内容はほとんど一緒だけど、第3版には各種ダイアグラムに関する説明の Chapter.14～20 が追加で挿入されています。
C/C++ のコードで読みたい場合は、書店からなくなる前に第1版を買っておいた方がよいです。&lt;/p>
&lt;p>以下、各章ごとのポイントや議論のメモです。&lt;/p>
&lt;h2 id="preface序文----2006-05-30---">Preface（序文） &lt;!-- 2006-05-30 -->&lt;/h2>
&lt;ul>
&lt;li>単なるパターン集ではなく、そのパターンが「なぜ」生き残ったのかという過程を知ることが大切。&lt;/li>
&lt;li>著者 Robert C. Martin（Object Mentor 社の創設者。社長）は、11個のオブジェクト指向の原則をまとめている。それに従って設計することで、デザインパターンですら導き出される。&lt;/li>
&lt;/ul>
&lt;h2 id="section-i-agile-developmentアジャイル開発">Section I: Agile Development（アジャイル開発）&lt;/h2>
&lt;h4 id="議論">▼議論&lt;/h4>
&lt;ul>
&lt;li>&lt;b>Q. アジャイルを大規模な開発に適用できるか？&lt;/b>&lt;br>
当初は大規模開発に適さないのでは？という懸念があったが、結果として大規模開発においてもアジャイル開発が主流になりつつある。ただ、いつものことだが日本では普及が遅れている。&lt;/li>
&lt;/ul>
&lt;p>大規模プロジェクトにおけるアジャイル開発に関しては、下記の記事や書籍が参考になる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www-06.ibm.com/jp/software/rational/agile/index.html">IBM Rational アジャイル開発&lt;/a>
&lt;ul>
&lt;li>(そのうち3分の1は従業員数10,000人以上) の88%がアジャイル・プロセスを使用中または評価中である&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>書籍: 『The Object Primer（邦題: オブジェクト開発の神髄）』
&lt;ul>
&lt;li>アジャイルソフトウェア開発の長所の一つ: 規模の大小を問わずうまくいく。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="http://www.atmarkit.co.jp/im/carc/serial/redge/72/01.html">The Rational Edge (72) アジャイル開発の広範な普及を目指して&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.atmarkit.co.jp/farc/rensai/redge27/redge27a.html">The Rational Edge (28) 大規模プロジェクトにアジャイルを適用する方法&lt;/a>
&lt;ul>
&lt;li>「この大規模プロジェクトがアジャイル手法で管理できるのか？ 」という疑問が出てくる。その答えはイエスだ。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="http://martinfowler.com/articles/agileOffshore.html">アジャイルソフトウェアプロセスを使ってオフショア開発（English）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://andore.com/money/trans/agileOffshore_ja.html">アジャイルソフトウェアプロセスを使ってオフショア開発（日本語）&lt;/a>
&lt;ul>
&lt;li>分析と設計はオンショアで行い、構築をオフショアで行い、そして受入試験をオンショアで行うというやり方よりも、&lt;strong>オフショアのチームにできるだけ多くの工程をやらせると問題が改善される&lt;/strong>。&lt;strong>作業工程に沿って分けるのではなく、機能面に沿った分割を行う&lt;/strong>。&lt;/li>
&lt;li>バグフィクスからやらせると、開発者は変更するよりも多くのコードを読むことになるので、コードベースに精通することができた。&lt;/li>
&lt;li>&lt;strong>オフショア開発においては、ドキュメントを作成するための時間を確保する&lt;/strong>必要がある。&lt;/li>
&lt;li>最低限、IM と Wiki、良質の電話回線を用意すること。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="chapter-1-agile-practicesアジャイルプラクティス----2006-05-30---">Chapter 1. Agile Practices（アジャイルプラクティス） &lt;!-- 2006-05-30 -->&lt;/h3>
&lt;ul>
&lt;li>プロジェクトをうまくまわすために&lt;strong>ルールやプロセスをどんどん導入してしまうと、逆に重くなってうまくいかない&lt;/strong>。
&lt;ul>
&lt;li>重いプロセスのせいで開発ペースが落ちる ⇒ まだプロセスが足りないと思い込む ⇒ ルールやプロセスを追加する ⇒ 悪循環…&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>マネージャーは開発環境を構築する前にチームを構築するべき。環境はチームメンバーに最適化させるのがよい。&lt;/li>
&lt;li>高価なツールを導入する前に小さなところから始める。
&lt;ul>
&lt;li>まずはフリーのツールを実際に使ってみて、本当に使えるのか試してみる。&lt;/li>
&lt;li>CASE (Computer-Aided Software Engineering) ツールの前にホワイトボードやグラフ用紙を使ってみる。&lt;/li>
&lt;li>大きなデータベースを使う前にプレーンテキストファイルを使ってみる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドキュメントに関して
&lt;ul>
&lt;li>&lt;b>Martin のドキュメントに関する第一法則&lt;/b> … &lt;strong>重要で差し迫った必要のあるドキュメント以外は作成しない&lt;/strong>。&lt;/li>
&lt;li>読みやすいドキュメントを用意する必要はあるが、多すぎるドキュメントは、少なすぎるドキュメントよりもたちが悪い。ドキュメントが多すぎると、ソースコードを変更したときにドキュメントを修正して整合性を保つのに時間がかかる。&lt;strong>メンテナンスされていないドキュメントが存在していると、そこには嘘が書かれていることになり、逆に混乱を招く&lt;/strong>。ソースコードは嘘をつかない。&lt;/li>
&lt;li>ドキュメントは手短に、洗練されたものだけ用意するのがよい。ドキュメントは長くても12ページ～24ページ（1、2ダース）に保ち、&lt;strong>抽象度の高い設計構造を示したドキュメントを用意するとよい&lt;/strong>。新メンバーが参入した場合に、より&lt;strong>詳細な設計構造を教えたい場合は、隣に座ってコミュニケーションを取るのが効率がよい&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>プロジェクト成功の鍵
&lt;ul>
&lt;li>顧客との密接な協調関係を築くこと。&lt;/li>
&lt;li>「コスト」や「納期」などの条件を決める契約ではなく、&lt;strong>「相互の協調関係」について取り決めた契約書を用意する&lt;/strong>。「近くで一緒に働こう」といったものがよい。&lt;/li>
&lt;li>うまくいった一例としては、「顧客側の受け入れテストに合格した機能ブロックの分だけ対価を支払う」という契約がある。どのように受け入れテストを行うかなどの詳細は契約では決めていない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>計画は日程がずれるだけでなく、形そのものが変わっていくもの。
&lt;ul>
&lt;li>&lt;b>詳細な予定&lt;/b> … 2週間先まで決める。&lt;/li>
&lt;li>&lt;b>大まかな計画&lt;/b> … 3ヶ月先まで決める。&lt;/li>
&lt;li>それ以外は柔軟にしておく。システムがどんな形になるのかを把握するくらいでよい。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="chapter-2-overview-of-extreme-programming----2006-05-30---">Chapter 2. Overview of Extreme Programming &lt;!-- 2006-05-30 -->&lt;/h3>
&lt;p>この章には XP の概要が書かれている。&lt;/p></description></item></channel></rss>