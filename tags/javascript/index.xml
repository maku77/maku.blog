<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on まくろぐ</title><link>https://maku.blog/tags/javascript/</link><description>Recent content in JavaScript on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Thu, 26 Nov 2020 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript とは</title><link>https://maku.blog/p/tdouo5p/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tdouo5p/</guid><description>&lt;p>TypeScript は、JavaScript に静的な型付けを行えるようにしたプログラミング言語です。
トランスパイラ (&lt;code>tsc&lt;/code> コマンド）を使って、TypeScript で記述したコードを JavaScript のコードに変換するのが主な使い方になります。
大規模な JavaScript アプリケーションを開発するときに TypeScript を導入すると、品質の高いコードを効率よく作成できるようになります。&lt;/p>
&lt;p>TypeScript はマイクロソフトによって開発が進められており、同じくマイクロソフトによって開発されている &lt;a href="../../p/ak7u3h3">Visual Studio Code でコーディングを行う&lt;/a>のがよいとされています。&lt;/p>
&lt;p>数年前に CoffeeScript と呼ばれる同様の言語が一時的にブームになりましたが、現在は TypeScript が主流です。
TypeScript には下記のような特徴があり、しばらくは JavaScript alternative として主流であり続けるでしょう。&lt;/p>
&lt;ul>
&lt;li>Microsoft により強力にサポートされており、&lt;strong>Visual Studio Code が最新の TypeScript バージョンに迅速に対応します&lt;/strong>。&lt;/li>
&lt;li>静的な型付けにより、実行前（トランスパイル時）に&lt;strong>コーディングのミスを発見しやすくなります&lt;/strong>。型の推論がしやすくなるため、IDE（VS Code など）のプロパティ名の&lt;strong>自動補完が効く&lt;/strong>ようになります。これがほんとに便利で、特にサードパーティ製のライブラリを使っているときにありがたみが分かります。&lt;/li>
&lt;li>JavaScript (ECMAScript) の&lt;strong>新しい仕様を使ってコーディングできます&lt;/strong>。TypeScript が新しい構文で書かれたコードを過去バージョンの JavaScript コードに変換してくれるため、各ブラウザベンダーが新しい仕様に対応するのを待つ必要がありません。&lt;/li>
&lt;li>JavaScript のコードは有効な TypeScript のコードとして動作します（構文に互換性があります。専門用語では JavaScript の「スーパーセット」であると言う）。そのため、既存の JavaScript プロジェクトに TypeScript を導入しようとするとき、&lt;strong>既存の JavaScript コードを修正する必要がありません&lt;/strong>。また、これまでに身に着けた JavaScript のノウハウをそのまま活かし続けることができます。&lt;/li>
&lt;/ul></description></item><item><title>TypeScriptの環境: tsconfig.json の基本</title><link>https://maku.blog/p/27m3brm/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/27m3brm/</guid><description>&lt;h2 id="tsconfigjson-があれば-typescript-プロジェクト">tsconfig.json があれば TypeScript プロジェクト&lt;/h2>
&lt;p>&lt;strong>&lt;code>tsconfig.json&lt;/code>&lt;/strong> は TypeScript の設定ファイルであり、このファイルが置かれたディレクトリが TypeScript プロジェクトのルートディレクトリだとみなされます。
&lt;code>tsconfig.json&lt;/code> の記述内容は空っぽ（&lt;code>{}&lt;/code> の2文字）でも正しい設定ファイルであり、その場合は、すべてデフォルトの設定値で動作することになります。&lt;/p>
&lt;p>TypeScript のトランスパイラである &lt;strong>&lt;code>tsc&lt;/code>&lt;/strong> コマンドを実行すると、カレントディレクトリにある &lt;code>tsconfig.json&lt;/code> が読み込まれてトランスパイラの動作設定が行われます。
&lt;code>tsconfig.json&lt;/code> が見つからない場合は、親ディレクトリを上りながらファイルを探します。
つまり、&lt;code>tsc&lt;/code> コマンドは TypeScript のプロジェクト内であれば、どのディレクトリからでも実行できます。&lt;/p>
&lt;h2 id="変換対象とするファイルを指定する-filesincludeexclude">変換対象とするファイルを指定する (files/include/exclude)&lt;/h2>
&lt;p>最も大切な設定は、TypeScript のトランスパイラがどのファイルを変換対象とみなすかの設定です。
入力ファイルの指定は、設定ファイルの最上位プロパティとして指定する &lt;code>files&lt;/code>、&lt;code>include&lt;/code>、&lt;code>exclude&lt;/code> プロパティを使って行います。&lt;/p>
&lt;h3 id="ファイル名を-1-つずつ指定する-files">ファイル名を 1 つずつ指定する (files)&lt;/h3>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">tsconfig.json&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;files&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;index.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;module1.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;module2.ts&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;strong>&lt;code>files&lt;/code>&lt;/strong> プロパティを使って、変換対象の TypeScript ファイルを 1 ファイルずつ指定することができます。&lt;/p>
&lt;h3 id="ファイル名のパターングロブで指定する-include">ファイル名のパターン（グロブ）で指定する (include)&lt;/h3>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">tsconfig.json&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;includes&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;src/**/*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;exclude&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;node_modules&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;**/*.spec.ts&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;strong>&lt;code>include&lt;/code>&lt;/strong> プロパティを使用すると、ファイルグロブを使って変換対象とするファイルを指定できます。
ファイルグロブは、下記のようなワイルドカードを使ってファイル名をパターン指定する仕組みです。&lt;/p>
&lt;ul>
&lt;li>&lt;code>**&lt;/code> は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータも含みます）&lt;/li>
&lt;li>&lt;code>*&lt;/code> は 0 文字以上の任意の文字にマッチします（ディレクトリセパレータは含みません）&lt;/li>
&lt;li>&lt;code>?&lt;/code> は 1 文字の任意の文字にマッチします&lt;/li>
&lt;/ul>
&lt;p>つまり、上記の &lt;code>src/**/*&lt;/code> という表現は、&lt;code>src&lt;/code> ディレクトリ以下のすべてのファイルにマッチします。
ただし、パスの末尾が &lt;code>*&lt;/code> で終わっている場合、&lt;strong>デフォルトでは TypeScript の拡張子 (&lt;code>.ts&lt;/code> / &lt;code>.tsx&lt;/code> / &lt;code>.d.ts&lt;/code>) を持つファイルにだけマッチする&lt;/strong>ようになっています。&lt;/p></description></item><item><title>TypeScriptの環境: Visual Studio Code で TypeScript の開発環境を構築する</title><link>https://maku.blog/p/ak7u3h3/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/ak7u3h3/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>TypeScript は Microsoft が開発している言語で、同じく Microsoft が開発している IDE である Visual Studio Code（以下 VS Code）が TypeScript コードの編集に適しています。&lt;/p>
&lt;p>VS Code による TypeScript の開発環境を構築するには、下記をインストールする必要があります。&lt;/p>
&lt;ul>
&lt;li>Visual Studio Code&lt;/li>
&lt;li>Node.js（npm コマンド）&lt;/li>
&lt;li>TypeScript（tsc コマンド)&lt;/li>
&lt;/ul>
&lt;h2 id="開発環境をインストールする">開発環境をインストールする&lt;/h2>
&lt;h3 id="visual-studio-code-のインストール">Visual Studio Code のインストール&lt;/h3>
&lt;p>VS Code は下記からインストーラーをダウンロードしてインストールできます。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://code.visualstudio.com/download">Download Visual Studio Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>TypeScript のソースコード (.ts) ファイルは、単純なテキストエディタでも編集できますが、この VS Code を使って編集すると、&lt;strong>プロパティ名の自動補完などができて効率的&lt;/strong>に開発を行えます。&lt;/p>
&lt;p>コマンドラインから &lt;code>code&lt;/code> と入力して、VS Code を起動できるようになれば OK です。
VS Code をインストールしたのに &lt;code>code&lt;/code> コマンドが認識されない場合は、&lt;a href="../../p/f5iv9kx">こちらの記事&lt;/a> を参考にしてパスを通してください。&lt;/p>
&lt;h3 id="nodejs-のインストール">Node.js のインストール&lt;/h3>
&lt;p>TypeScript のトランスパイラである &lt;code>tsc&lt;/code> コマンドは、Node.js のパッケージとして提供されているため、先に Node.js をインストールしておく必要があります。
Node.js は下記からインストーラーをダウンロードしてインストールできます。&lt;/p></description></item><item><title>TypeScriptでモジュールを作成する／インポートする (export, import)</title><link>https://maku.blog/p/fbu8k8j/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/fbu8k8j/</guid><description>&lt;h2 id="モジュールとは">モジュールとは&lt;/h2>
&lt;p>TypeScript で大きなプログラムを作成するときは、モジュールの仕組みを使って &lt;strong>複数のファイルに分割&lt;/strong> していきます。
ファイルを分割することでコードを管理しやすくなるだけでなく、名前空間のコンテキストが分けられることになるので、 &lt;strong>名前の衝突の問題も解決&lt;/strong> することができます。&lt;/p>
&lt;p>モジュールを作るのは簡単で、&lt;strong>&lt;code>export&lt;/code>&lt;/strong> キーワードを含む &lt;code>.ts&lt;/code> ファイルを作ればそれがモジュールになります。
&lt;code>export&lt;/code> キーワードでは、クラスやインタフェースをまるごと公開することもできるし、関数や変数の単位で公開することもできます。&lt;/p>
&lt;p>&lt;code>export&lt;/code> の使い方のポイントは、次のように、 &lt;strong>クラスや変数を定義するときにプレフィックスとして付加する&lt;/strong> というところです。
基本的には、定義済みのオブジェクトを後から &lt;code>export&lt;/code> するという使い方はしません。&lt;/p>
&lt;ul>
&lt;li>export class &amp;hellip;&lt;/li>
&lt;li>export interface &amp;hellip;&lt;/li>
&lt;li>export const &amp;hellip;&lt;/li>
&lt;li>export let &amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>ここからは、具体的な &lt;code>export&lt;/code> の使い方を見ていきます。&lt;/p>
&lt;h2 id="クラスやインタフェースの定義を-export-する">クラスやインタフェースの定義を export する&lt;/h2>
&lt;p>下記の &lt;code>lib/mylib.ts&lt;/code> ファイルでは、&lt;code>MyInterface&lt;/code> インタフェースと、&lt;code>MyClass&lt;/code> クラスを公開しています。
それぞれの定義の前に &lt;code>export&lt;/code> キーワードを付けるだけでよいので簡単ですね。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">lib/mylib.ts&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">interface&lt;/span> &lt;span class="nx">MyInterface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">MyClass&lt;/span> &lt;span class="kr">implements&lt;/span> &lt;span class="nx">MyInterface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">public&lt;/span> &lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>次の &lt;code>index.ts&lt;/code> ファイルからは、上記のクラスモジュールを &lt;strong>&lt;code>import&lt;/code>&lt;/strong> して読み込んでいます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">index.ts（個別に import）&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">MyInterface&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">MyClass&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s1">&amp;#39;./lib/mylib&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">obj&lt;/span>: &lt;span class="kt">MyInterface&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">MyClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Maku&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//=&amp;gt; Maku
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>from&lt;/code> の後ろに指定するファイルパスには、 &lt;strong>拡張子の &lt;code>.ts&lt;/code> を記述しない&lt;/strong> ことに注意してください（実際に読み込むファイルは &lt;code>.js&lt;/code> なので、&lt;code>.ts&lt;/code> の指定は意味的にも間違っています）。
上記の例では、インタフェースやクラスの名前を直接指定して、個別の変数に読み込んでいますが、次のようにワイルドカードを使って &lt;code>export&lt;/code> されているものを 1 つの変数にすべて読み込むこともできます。&lt;/p></description></item><item><title>TypeScriptのモジュールのインポートには import を使う</title><link>https://maku.blog/p/emdtiio/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/emdtiio/</guid><description>&lt;h2 id="require-ではなく-import-を使う">require ではなく import を使う&lt;/h2>
&lt;p>TypeScript で型情報付きのモジュールをインポートするときは、&lt;a href="https://www.ecma-international.org/ecma-262/6.0/#table-40">ECMAScript 2015 の module 構文&lt;/a> で定義されている &lt;strong>&lt;code>import&lt;/code>&lt;/strong> を使うようにすると、VSCode などで型情報を使った補完がうまく効くようにになります。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">これを使う&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Good
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">import&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="nx">mod&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s1">&amp;#39;mod&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>下記のように、Node.js で一般的に使用されていた CommonJS 形式の &lt;code>require&lt;/code> を使ってもインポートできますが、&lt;code>any&lt;/code> 型の変数を定義していることになるため、型情報を用いた補完が効きません。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">これは使わない&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// NG
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">mod&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kr">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mod&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;strong>TypeScript でモジュールをインポートするときには、できるだけ &lt;code>import&lt;/code> を使う&lt;/strong> ようにしましょう。&lt;/p>
&lt;h2 id="インポートの例関数ベースのモジュール">インポートの例（関数ベースのモジュール）&lt;/h2>
&lt;p>Node.js のコアモジュール（&lt;code>os&lt;/code> や &lt;code>path&lt;/code> など）は、もともと TypeScript 用に作成されたものではありませんが、TypeScript 用の型情報が &lt;code>@types/node&lt;/code> モジュールとして提供されています。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Node.js コアモジュールの型情報をインストール&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">$ npm install --save-dev @types/node&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>これで、Node.js のコアモジュールを下記のように型情報付きでインポートできるようになります。
これは、複数の関数を &lt;code>export&lt;/code> する TypeScript モジュールをインポートする方法のよい例です。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">よい例: 型として認識される&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="nx">path&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s1">&amp;#39;path&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 全ての関数をインポート
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">join&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s1">&amp;#39;path&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 個別の関数をインポート
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>これで、VSCode などの IDE で次のように補完が聞くようになります。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="border: solid #ccc 2px;" width="984" height="206" src="../../p/emdtiio/img-001.png" alt="/p/emdtiio/img-001.png" />
&lt;/figure>

&lt;p>逆に、次のようにインポートしてしまうと、&lt;code>any&lt;/code> 型の &lt;code>path&lt;/code> 変数が定義されているものとみなされ、補完機能がうまく働きません。&lt;/p></description></item><item><title>TypeScriptで名前空間を定義する (namespace)</title><link>https://maku.blog/p/a3eh9w2/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/a3eh9w2/</guid><description>&lt;h2 id="namespace-ではなくモジュールの仕組みを使うべし">namespace ではなくモジュールの仕組みを使うべし&lt;/h2>
&lt;p>TypeScript では、&lt;strong>&lt;code>namespace&lt;/code>&lt;/strong> キーワードを使って名前空間を定義することができますが、通常はより柔軟性の高い &lt;a href="../../p/fbu8k8j">モジュールの仕組み&lt;/a> を使うようにしてください（といっても &lt;code>.ts&lt;/code> ファイルを分けるだけですが）。&lt;/p>
&lt;p>&lt;code>namespace&lt;/code> を使うと、同じファイル内で階層化された名前空間を作ることができますが、あくまでその階層構造はグローバルに共有されています。
一方、モジュールの仕組みを使うと、ファイル単位で名前空間のコンテキストを分けることができます。
大きなプロジェクトであっても、適切な単位でモジュール（ファイル）を分割している限り、名前の衝突は本質的には発生しません。&lt;/p>
&lt;p>とはいえ、これは &lt;code>namespace&lt;/code> の記事なので、ここからは &lt;code>namespace&lt;/code> の使い方の説明をします。&lt;/p>
&lt;h2 id="namespace-による名前空間の定義">namespace による名前空間の定義&lt;/h2>
&lt;p>&lt;code>namespace&lt;/code> による名前空間の定義は簡単で、&lt;code>namespace Xxx { ... }&lt;/code> というブロックで囲むだけです。
次の例では、&lt;code>First&lt;/code> と &lt;code>Second&lt;/code> という名前空間を作成し、それぞれに同じ名前の &lt;code>Person&lt;/code> というクラスを定義しています。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">namespace&lt;/span> &lt;span class="nx">First&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">greet() {&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;First.Person&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">namespace&lt;/span> &lt;span class="nx">Second&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">greet() {&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Second.Person&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">p1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">First&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">p2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Second&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">p1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">greet&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">//=&amp;gt; First.Person
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">p2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">greet&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">//=&amp;gt; Second.Person
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>namespace&lt;/code> の中で定義したクラスなどは、デフォルトではその外の名前空間からは見えないようになっています。
外からアクセスしたい場合は、上記のようにクラス定義の前に &lt;strong>&lt;code>export&lt;/code>&lt;/strong> を付けて公開しておく必要があります。&lt;/p>
&lt;p>名前空間は、ドットで区切って入れ子で定義することもできます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">namespace&lt;/span> &lt;span class="nx">First&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Third&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">greet() {&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">First&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Third&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Person&lt;/span>&lt;span class="p">();&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記は、下記のように定義するのと同等です。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">namespace&lt;/span> &lt;span class="nx">First&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="kr">namespace&lt;/span> &lt;span class="nx">Second&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="kr">namespace&lt;/span> &lt;span class="nx">Third&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">greet() {&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>内部の &lt;code>namespace&lt;/code> は、&lt;code>export&lt;/code> で公開しなければ外からアクセスできないため、上記のように &lt;code>export&lt;/code> の連続になります。&lt;/p></description></item><item><title>TypeScriptの型: 既存の JavaScript ライブラリに型情報を追加する（.d.ts ファイル）</title><link>https://maku.blog/p/s7wk5k3/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/s7wk5k3/</guid><description>&lt;h2 id="アンビエント宣言とは">アンビエント宣言とは&lt;/h2>
&lt;p>TypeScript の &lt;strong>アンビエント宣言 (Ambient Declarations)&lt;/strong> を行うと、既存の JavaScript ライブラリに型情報を付加することができます。
この仕組みを利用すると、&lt;/p>
&lt;ul>
&lt;li>サードパーティ製の JavaScript ライブラリ（npm パッケージ）や、自作の JavaScript ライブラリ（ただし TypeScript 化はしたくないもの）を TypeScript コードから使用する&lt;/li>
&lt;li>jQuery などのブラウザ上でロードされるライブラリを TypeScript コードから使用する&lt;/li>
&lt;/ul>
&lt;p>といったことが可能になります。
ようするに、TypeScript トランスパイラに対して、このオブジェクトはこういう型のものとして外から提供されているので、型チェックエラーを出さないでね、と知らせることができます。&lt;/p>
&lt;p>さらに、VisualStudio Code などのエディタを使用している場合は、アンビエント型宣言があることにより、エディタ上での補完入力ができるようになります。&lt;/p>
&lt;h2 id="アンビエント宣言-declare">アンビエント宣言 (declare)&lt;/h2>
&lt;ul>
&lt;li>参考: &lt;a href="https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html">TypeScript - Declaration Reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>どこか別の場所でロードされる予定の JavaScript モジュールに対して、自力で型情報を付けたい場合は &lt;strong>&lt;code>declare&lt;/code>&lt;/strong> キーワードを使用します。
例えば、jQuery はもともと JavaScript 用のライブラリなので、TypeScript 用の型情報は提供していませんが、次のように自力で型情報を付けることで、TypeScript コードから利用できるようになります（実際には、DefinitelyTyped プロジェクトが提供する &lt;code>@types/jquery&lt;/code> を使用するのが簡単です）。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">index.ts&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// $ という変数を参照できるようにする（実体は実行時に後付けで定義される予定）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">declare&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">$&lt;/span>: &lt;span class="kt">any&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// これで、$ という未定義の変数を参照してもエラーにならない
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;#id&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">html&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello!&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>この仕組みを使わずに、いきなり &lt;code>$&lt;/code> を参照してしまうと、そのような変数は定義されていないというエラーになってしまいます。
TypeScript トランスパイラは、&lt;code>declare&lt;/code> によって付けられた型情報を正しいものと判断するため、この型情報は間違えないように指定する必要があります。
また、実行時にはそのオブジェクトの実体がどこかで生成されていなければいけません。&lt;/p>
&lt;p>もっと明確な型付けを行うなら次のような感じで、クラスや関数などの型を定義していきます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">index.ts&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">declare&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">jQuery&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">html&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">html&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">void&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">declare&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="nx">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">query&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">jQuery&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;#id&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">html&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello!&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h3 id="型宣言ファイル-dts">型宣言ファイル (.d.ts)&lt;/h3>
&lt;p>プロジェクト全体でアンビエント宣言を共有したい場合は、次のような型宣言ファイル &lt;strong>&lt;code>.d.ts&lt;/code>&lt;/strong> をソースツリーのルートに配置します。&lt;/p></description></item><item><title>TypeScriptの型: 環境変数 (process.env) 用の型情報を定義する</title><link>https://maku.blog/p/r8iry9g/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/r8iry9g/</guid><description>&lt;p>Node.js で環境変数を参照するためのオブジェクト &lt;code>process.env&lt;/code> の型情報は、&lt;code>@types/node&lt;/code> で次のように文字列型ディクショナリ &lt;code>Dict&amp;lt;string&amp;gt;&lt;/code> として定義されています。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">node_modules/@types/node/process.d.ts（抜粋）&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">declare&lt;/span> &lt;span class="kr">module&lt;/span> &lt;span class="nx">&amp;#34;process&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">global&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">process&lt;/span>: &lt;span class="kt">NodeJS.Process&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">namespace&lt;/span> &lt;span class="nx">NodeJS&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">interface&lt;/span> &lt;span class="nx">ProcessEnv&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Dict&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">export&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">process&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>この型定義は &lt;code>@types/node&lt;/code> モジュールをインストールするだけで簡単に使用できるようになるのですが、具体的なキー名（環境変数名）が定義されていないので、Visual Studio Code などで &lt;code>process.env&lt;/code> 以降の入力補完が効きません。&lt;/p>
&lt;p>&lt;strong>VS Code 上で環境変数名を補完入力&lt;/strong> できるようにするには、次のような型定義ファイル (&lt;code>globals.d.ts&lt;/code>) をソースツリーのルートに作成します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">globals.d.ts&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">declare&lt;/span> &lt;span class="kr">namespace&lt;/span> &lt;span class="nx">NodeJS&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 環境変数名の定義
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">interface&lt;/span> &lt;span class="nx">ProcessEnv&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/** 現在の Node.js 実行環境 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">readonly&lt;/span> &lt;span class="nx">NODE_ENV&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;development&amp;#39;&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="s1">&amp;#39;production&amp;#39;&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/** GitHub アクセストークン */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">readonly&lt;/span> &lt;span class="nx">MYAPP_GITHUB_TOKEN&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>環境変数 &lt;code>NODE_ENV&lt;/code> の値は、決められた 3 種類の値 (development/production/test) のいずれかであると定義しているので、それ以外の値と比較しようとしたときに警告してくれます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">process&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">env&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NODE_ENV&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s1">&amp;#39;hoge&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 警告メッセージ ts(2367)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// This condition will always return &amp;#39;false&amp;#39; since the types
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// &amp;#39;&amp;#34;development&amp;#34; | &amp;#34;production&amp;#34; | &amp;#34;test&amp;#34;&amp;#39; and &amp;#39;&amp;#34;hoge&amp;#34;&amp;#39; have no overlap.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>また、上記の型定義のように TSDoc/JSDoc ドキュメンテーションコメントを記述しておけば、VS Code で入力補完するときにドキュメントを表示してくれます。&lt;/p></description></item><item><title>JavaScript で任意のテキストをクリップボードにコピーする</title><link>https://maku.blog/p/buk5i2o/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/buk5i2o/</guid><description>&lt;h2 id="copytoclipboard-関数">copyToClipboard 関数&lt;/h2>
&lt;p>次の &lt;code>copyToClipboard&lt;/code> 関数を使うと、引数で指定したテキストを OS のクリップボードにコピーすることができます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">copyToClipboard&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">text&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// テキストコピー用の一時要素を作成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;pre&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// テキストを選択可能にしてテキストセット
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pre&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">style&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">webkitUserSelect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;auto&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pre&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">style&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">userSelect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;auto&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pre&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">textContent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">text&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 要素を追加、選択してクリップボードにコピー
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">appendChild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pre&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getSelection&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">selectAllChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pre&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">execCommand&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;copy&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 要素を削除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">removeChild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pre&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>JavaScript からクリップボードにテキストをコピーするときは、任意の HTML 要素のテキストを選択して、&lt;code>document.execCommand('copy')&lt;/code> を実行するという流れになります。
そのため、上記の関数では、テキスト選択用の一時的な &lt;code>pre&lt;/code> 要素を作成しています。&lt;/p>
&lt;h2 id="使用例">使用例&lt;/h2>
&lt;p>例えば次のようにすると、ボタンを押したときにクリップボードにテキストをコピーできます。&lt;/p>
&lt;p>&lt;button id="copy">クリップボードにコピー&lt;/button> ← 実際に動作します&lt;/p>
&lt;script>
function copyToClipboard(text){
 const pre = document.createElement('pre');
 pre.style.webkitUserSelect = 'auto';
 pre.style.userSelect = 'auto';
 pre.textContent = text;
 document.body.appendChild(pre);
 document.getSelection().selectAllChildren(pre);
 const result = document.execCommand('copy');
 document.body.removeChild(pre);
 return result;
}
window.addEventListener('DOMContentLoaded', () => {
 document.getElementById('copy').addEventListener('click', () => {
 copyToClipboard('こんにちは！\nテキストがコピーされたよ！');
 });
});
&lt;/script>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">sample.html&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">button&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;copy&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>クリップボードにコピー&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">button&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;DOMContentLoaded&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getElementById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;copy&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;click&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">copyToClipboard&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;こんにちは！\nテキストがコピーされたよ！&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>JavaScript で現在のページの URL の構成要素を取得する (window.location)</title><link>https://maku.blog/p/j6iu6gs/</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0900</pubDate><guid>https://maku.blog/p/j6iu6gs/</guid><description>&lt;p>Web サイト上で実行される JavaScript から &lt;strong>&lt;code>window.location&lt;/code>&lt;/strong> を参照すると、カレントページの URL の構成要素をパーツごとに取得することができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">JavaScript&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">loc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">location&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.href = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">href&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.origin = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">origin&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.host = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">host&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.protocol = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">protocol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.hostname = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hostname&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.port = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">port&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.pathname = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pathname&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.search = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">search&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;location.hash = &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">loc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hash&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>例えば、次のようなアドレスにアクセスした場合は、&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>次のような結果を取得することができます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.href&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.origin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">https://example.com:8042&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">example.com:8042&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.protocol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">https:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.hostname&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">example.com&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.port&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">8042&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.pathname&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">/over/there&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.search&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">?key1=val1&amp;amp;key2=val2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">location.hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">#nose&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>TypeScriptの環境: tsc-watch で ts ファイルの変更監視＆アプリの再起動を自動化する</title><link>https://maku.blog/p/nxzsnkf/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/nxzsnkf/</guid><description>&lt;h2 id="typescript-の監視と-javascript-の監視の両立">TypeScript の監視と JavaScript の監視の両立&lt;/h2>
&lt;p>&lt;code>tsc --watch&lt;/code> コマンドを使うと、TypeScript (&lt;code>.ts&lt;/code>) ファイルの変更を監視して自動的に &lt;code>tsc&lt;/code> （トランスパイル）を実行してくれるようになります。
&lt;code>nodemon&lt;/code> コマンドを使うと、JavaScript (&lt;code>.js&lt;/code>) ファイルの変更を監視して自動的に &lt;code>node&lt;/code> コマンドを再起動してくれるようになります。&lt;/p>
&lt;p>これらを組みあわせれば、TypeScript (&lt;code>.ts&lt;/code>) ファイルの変更時に、自動的に Node.js アプリを再起動できそうな気がしますが、一連のコマンドとしてこれら 2 つを組み合わせて実行するのにはみんな苦労しているようです（もちろんコマンドシェルを 2 つ立ち上げればできますが）。&lt;/p>
&lt;p>そこで便利なのが &lt;a href="https://www.npmjs.com/package/tsc-watch">tsc-watch コマンド&lt;/a> です。&lt;/p>
&lt;h2 id="tsc-watch-パッケージでまるごと解決">tsc-watch パッケージでまるごと解決&lt;/h2>
&lt;p>&lt;strong>&lt;code>tsc-watch&lt;/code>&lt;/strong> という NPM パッケージ（コマンド）を使用すると、TypeScript の変更監視と Node アプリの再起動の連動を簡単に行えるようになります。
まず、必要なパッケージを下記のようにインストールします。
&lt;code>nodemon&lt;/code> は使わなくて済むので、ここでは依存パッケージとして &lt;code>typescript&lt;/code> と &lt;code>tsc-watch&lt;/code> をインストールしておきます。
&lt;code>--save-dev&lt;/code> オプションを付加して、&lt;code>package.json&lt;/code> の &lt;code>devDependencies&lt;/code> に登録するのを忘れないようにしましょう。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">$ npm install --save-dev typescript
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ npm install --save-dev tsc-watch&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>tsc-watch&lt;/code> コマンドはほとんど &lt;code>tsc --watch&lt;/code> のラッパーなので、そのまま実行すると、TypeScript ファイルの変更を監視してトランスパイルを実行するという動作になります。
これだけの用途であれば &lt;code>tsc&lt;/code> コマンドで十分なのですが、&lt;code>tsc-watch&lt;/code> コマンドに追加されている &lt;strong>&lt;code>--onSuccess&lt;/code>&lt;/strong> オプションを使うと、トランスパイル後に任意の追加コマンドを実行することができます。
この追加コマンドとして &lt;code>npm start&lt;/code> などを実行するように設定しておけば、TypeScript のトランスパイル後に Node.js アプリを起動するところまでを自動化することができます。
すでに Node.js アプリが起動している場合は、そのプロセスを終了してから立ち上げ直してくれるので、サーバー系の Node.js アプリを作成している場合も安心です。&lt;/p></description></item><item><title>TypeScriptの環境: 既存の JavaScript プロジェクトを TypeScript に乗り換える</title><link>https://maku.blog/p/3eccb2t/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/3eccb2t/</guid><description>&lt;h2 id="typescript-プロジェクトへの移行は簡単">TypeScript プロジェクトへの移行は簡単！&lt;/h2>
&lt;p>TypeScript の構文は、JavaScript のコードとの互換性を考慮して仕様が決められているため、既存の JavaScript プロジェクトを簡単に TypeScript プロジェクトに移行することができます。
後述するように設定をうまく行えば、JavaScript ファイルの拡張子を &lt;code>.ts&lt;/code> に変える必要すらありません。&lt;/p>
&lt;p>TypeScript の構文を使わないと意味がないのでは？と思うかもしれませんが、TypeScript のトランスパイラ (&lt;code>tsc&lt;/code>) には、強力な&lt;strong>静的解析の仕組みが備わっている&lt;/strong>ため、この機能を既存の JavaScript ファイルに適用するだけでも TypeScript を導入する価値があります。&lt;/p>
&lt;p>ここでは、&lt;code>tsc&lt;/code> コマンドは下記のようにグローバルにインストールしてあることを前提とします。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">$ npm install -g typescript&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="おすすめのディレクトリ構成">おすすめのディレクトリ構成&lt;/h2>
&lt;p>既存の JavaScript コードを TypeScript トランスパイラ (&lt;code>tsc&lt;/code>) の変換対象にする場合は、入力ファイルとなる .js ファイルと、生成される .js ファイルのディレクトリを明確に区別しておくべきです。
そうしておかないと、どのファイルが自分が作成したファイルで、どのファイルが自動生成されたファイルなのか分かりにくくなってしまいます。&lt;/p>
&lt;p>ここでは、既存の JavaScript プロジェクトのソースコード (.js) を、下記のように &lt;code>src&lt;/code> ディレクトリに格納します。
このディレクトリには、最終的に .js ファイルと .ts ファイルが混在していても構いません。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">project/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +-- tsconfig.js （設定ファイル）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +-- build/ （出力用ディレクトリ）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +-- src/ （入力用ディレクトリ）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +-- main.js
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +-- module1.js
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +-- module2.js&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記では、&lt;code>src&lt;/code> ディレクトリの直下に .js ファイルを入れていますが、ディレクトリ構造を保ったまま入れてしまって大丈夫です。
出力先のディレクトリ (&lt;code>build&lt;/code>) には、このディレクトリ階層を再現する形で JavaScript ファイルが出力されます。&lt;/p></description></item><item><title>WebGL で使う Typed Array</title><link>https://maku.blog/p/twmzpfj/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/twmzpfj/</guid><description>&lt;h2 id="typed-array-とは">Typed Array とは&lt;/h2>
&lt;p>JavaScript の配列型には、汎用型の &lt;code>Array&lt;/code> の他にも、&lt;code>Int32Array&lt;/code> のような、特定の型の値だけしか格納できない配列型が用意されています。
このような配列型のことを &lt;strong>Typed Array&lt;/strong> と呼びます。
イメージとしては、C 言語の int 配列や float 配列に近いです。&lt;/p>
&lt;p>例えば、WebGL で頂点属性（座標や色）の配列を用意するようなケースでは、その中の要素の型はすべて float 型に統一されていたりするので、汎用型の &lt;code>Array&lt;/code> ではなく、&lt;code>Float32Array&lt;/code> を使用することでメモリ効率がよくなります。&lt;/p>
&lt;p>Typed Array には下記のようなものが用意されています。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>型名&lt;/th>
 &lt;th>バイト数&lt;/th>
 &lt;th>値の範囲&lt;/th>
 &lt;th>説明（対応するC言語の型）&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>Int8Array&lt;/td>
 &lt;td>1&lt;/td>
 &lt;td>-128 ～ 127&lt;/td>
 &lt;td>8-bit sined integer (int8_t)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Uint8Array&lt;/td>
 &lt;td>1&lt;/td>
 &lt;td>0 ～ 255&lt;/td>
 &lt;td>8-bit unsigned integer (uint8_t)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Int16Array&lt;/td>
 &lt;td>2&lt;/td>
 &lt;td>-32768 ～ 32767&lt;/td>
 &lt;td>16-bit signed integer (int16_t)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Uint16Array&lt;/td>
 &lt;td>2&lt;/td>
 &lt;td>0 ～ 65535&lt;/td>
 &lt;td>16-bit unsigned integer (uint16_t)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Int32Array&lt;/td>
 &lt;td>4&lt;/td>
 &lt;td>-2147483648 ～ 2147483647&lt;/td>
 &lt;td>32-bit signed integer (int32_t)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Uint32Array&lt;/td>
 &lt;td>4&lt;/td>
 &lt;td>0 ～ 4294967295&lt;/td>
 &lt;td>32-bit unsinged integer (uint32_t)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Float32Array&lt;/td>
 &lt;td>4&lt;/td>
 &lt;td>1.2x10-38 ～ 3.4x1038&lt;/td>
 &lt;td>32-bit floating point number (float)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Float64Array&lt;/td>
 &lt;td>8&lt;/td>
 &lt;td>5.0x10-324 ～ 1.8x10308&lt;/td>
 &lt;td>64-bit floating point number (double)&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="typed-array-の使い方">Typed Array の使い方&lt;/h2>
&lt;p>Typed Array インスタンスは、型名をコンストラクタとして呼び出すことで生成することができます。
配列リテラルの形で初期値を指定することもできるし、サイズだけ指定してすべての要素が 0 に初期化された Typed Array を作成することもできます。&lt;/p></description></item></channel></rss>