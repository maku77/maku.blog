<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on まくろぐ</title><link>https://maku.blog/tags/javascript/</link><description>Recent content in JavaScript on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 20 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript とは</title><link>https://maku.blog/p/tdouo5p/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tdouo5p/</guid><description>TypeScript は、JavaScript に静的な型付けを行えるようにしたプログラミング言語です。 トランスパイラ (tsc コマンド）を使って、TypeScript で記述したコードを JavaScript のコードに変換するのが主な使い方になります。 大規模な JavaScript アプリケーションを開発するときに TypeScript を導入すると、品質の高いコードを効率よく作成できるようになります。
TypeScript はマイクロソフトによって開発が進められており、同じくマイクロソフトによって開発されている Visual Studio Code でコーディングを行うのがよいとされています。
数年前に CoffeeScript と呼ばれる同様の言語が一時的にブームになりましたが、現在は TypeScript が主流です。 TypeScript には下記のような特徴があり、しばらくは JavaScript alternative として主流であり続けるでしょう。
Microsoft により強力にサポートされており、Visual Studio Code が最新の TypeScript バージョンに迅速に対応します。 静的な型付けにより、実行前（トランスパイル時）にコーディングのミスを発見しやすくなります。型の推論がしやすくなるため、IDE（VS Code など）のプロパティ名の自動補完が効くようになります。これがほんとに便利で、特にサードパーティ製のライブラリを使っているときにありがたみが分かります。 JavaScript (ECMAScript) の新しい仕様を使ってコーディングできます。TypeScript が新しい構文で書かれたコードを過去バージョンの JavaScript コードに変換してくれるため、各ブラウザベンダーが新しい仕様に対応するのを待つ必要がありません。 JavaScript のコードは有効な TypeScript のコードとして動作します（構文に互換性があります。専門用語では JavaScript の「スーパーセット」であると言う）。そのため、既存の JavaScript プロジェクトに TypeScript を導入しようとするとき、既存の JavaScript コードを修正する必要がありません。また、これまでに身に着けた JavaScript のノウハウをそのまま活かし続けることができます。</description></item><item><title>TypeScriptの環境: tsconfig.json の基本</title><link>https://maku.blog/p/27m3brm/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/27m3brm/</guid><description>tsconfig.json があれば TypeScript プロジェクト tsconfig.json は TypeScript の設定ファイルであり、このファイルが置かれたディレクトリが TypeScript プロジェクトのルートディレクトリだとみなされます。 tsconfig.json の記述内容は空っぽ（{} の2文字）でも正しい設定ファイルであり、その場合は、すべてデフォルトの設定値で動作することになります。
TypeScript のトランスパイラである tsc コマンドを実行すると、カレントディレクトリにある tsconfig.json が読み込まれてトランスパイラの動作設定が行われます。 tsconfig.json が見つからない場合は、親ディレクトリを上りながらファイルを探します。 つまり、tsc コマンドは TypeScript のプロジェクト内であれば、どのディレクトリからでも実行できます。
変換対象とするファイルを指定する (files/include/exclude) 最も大切な設定は、TypeScript のトランスパイラがどのファイルを変換対象とみなすかの設定です。 入力ファイルの指定は、設定ファイルの最上位プロパティとして指定する files、include、exclude プロパティを使って行います。
ファイル名を 1 つずつ指定する (files) tsconfig.json { &amp;#34;files&amp;#34;: [ &amp;#34;index.ts&amp;#34;, &amp;#34;module1.ts&amp;#34;, &amp;#34;module2.ts&amp;#34; ] } files プロパティを使って、変換対象の TypeScript ファイルを 1 ファイルずつ指定することができます。
ファイル名のパターン（グロブ）で指定する (include) tsconfig.json { &amp;#34;includes&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;exclude&amp;#34;: [ &amp;#34;node_modules&amp;#34;, &amp;#34;**/*.spec.ts&amp;#34; ] } include プロパティを使用すると、ファイルグロブを使って変換対象とするファイルを指定できます。 ファイルグロブは、下記のようなワイルドカードを使ってファイル名をパターン指定する仕組みです。</description></item><item><title>TypeScriptの環境: Visual Studio Code で TypeScript の開発環境を構築する</title><link>https://maku.blog/p/ak7u3h3/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ak7u3h3/</guid><description>はじめに TypeScript は Microsoft が開発している言語で、同じく Microsoft が開発している IDE である Visual Studio Code（以下 VS Code）が TypeScript コードの編集に適しています。
VS Code による TypeScript の開発環境を構築するには、下記をインストールする必要があります。
Visual Studio Code Node.js（npm コマンド） TypeScript（tsc コマンド) 開発環境をインストールする Visual Studio Code のインストール VS Code は下記からインストーラーをダウンロードしてインストールできます。
Download Visual Studio Code TypeScript のソースコード (.ts) ファイルは、単純なテキストエディタでも編集できますが、この VS Code を使って編集すると、プロパティ名の自動補完などができて効率的に開発を行えます。
コマンドラインから code と入力して、VS Code を起動できるようになれば OK です。 VS Code をインストールしたのに code コマンドが認識されない場合は、こちらの記事 を参考にしてパスを通してください。
Node.js のインストール TypeScript のトランスパイラである tsc コマンドは、Node.js のパッケージとして提供されているため、先に Node.</description></item><item><title>TypeScriptでモジュールを作成する／インポートする (export, import)</title><link>https://maku.blog/p/fbu8k8j/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fbu8k8j/</guid><description>モジュールとは TypeScript で大きなプログラムを作成するときは、モジュールの仕組みを使って 複数のファイルに分割 していきます。 ファイルを分割することでコードを管理しやすくなるだけでなく、名前空間のコンテキストが分けられることになるので、 名前の衝突の問題も解決 することができます。
モジュールを作るのは簡単で、export キーワードを含む .ts ファイルを作ればそれがモジュールになります。 export キーワードでは、クラスやインタフェースをまるごと公開することもできるし、関数や変数の単位で公開することもできます。
export の使い方のポイントは、次のように、 クラスや変数を定義するときにプレフィックスとして付加する というところです。 基本的には、定義済みのオブジェクトを後から export するという使い方はしません。
export class &amp;hellip; export interface &amp;hellip; export const &amp;hellip; export let &amp;hellip; ここからは、具体的な export の使い方を見ていきます。
クラスやインタフェースの定義を export する 下記の lib/mylib.ts ファイルでは、MyInterface インタフェースと、MyClass クラスを公開しています。 それぞれの定義の前に export キーワードを付けるだけでよいので簡単ですね。
lib/mylib.ts export interface MyInterface { name: string; } export class MyClass implements MyInterface { constructor(public name: string) {} } 次の index.</description></item><item><title>TypeScriptのモジュールのインポートには import を使う</title><link>https://maku.blog/p/emdtiio/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/emdtiio/</guid><description>require ではなく import を使う TypeScript で型情報付きのモジュールをインポートするときは、ECMAScript 2015 の module 構文 で定義されている import を使うようにすると、VSCode などで型情報を使った補完がうまく効くようにになります。
これを使う // Good import * as mod from &amp;#39;mod&amp;#39;; 下記のように、Node.js で一般的に使用されていた CommonJS 形式の require を使ってもインポートできますが、any 型の変数を定義していることになるため、型情報を用いた補完が効きません。
これは使わない // NG const mod = require(&amp;#39;mod&amp;#39;); TypeScript でモジュールをインポートするときには、できるだけ import を使う ようにしましょう。
インポートの例（関数ベースのモジュール） Node.js のコアモジュール（os や path など）は、もともと TypeScript 用に作成されたものではありませんが、TypeScript 用の型情報が @types/node モジュールとして提供されています。
Node.js コアモジュールの型情報をインストール $ npm install --save-dev @types/node これで、Node.js のコアモジュールを下記のように型情報付きでインポートできるようになります。 これは、複数の関数を export する TypeScript モジュールをインポートする方法のよい例です。</description></item><item><title>TypeScriptで名前空間を定義する (namespace)</title><link>https://maku.blog/p/a3eh9w2/</link><pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/a3eh9w2/</guid><description>namespace ではなくモジュールの仕組みを使うべし TypeScript では、namespace キーワードを使って名前空間を定義することができますが、通常はより柔軟性の高い モジュールの仕組み を使うようにしてください（といっても .ts ファイルを分けるだけですが）。
namespace を使うと、同じファイル内で階層化された名前空間を作ることができますが、あくまでその階層構造はグローバルに共有されています。 一方、モジュールの仕組みを使うと、ファイル単位で名前空間のコンテキストを分けることができます。 大きなプロジェクトであっても、適切な単位でモジュール（ファイル）を分割している限り、名前の衝突は本質的には発生しません。
とはいえ、これは namespace の記事なので、ここからは namespace の使い方の説明をします。
namespace による名前空間の定義 namespace による名前空間の定義は簡単で、namespace Xxx { ... } というブロックで囲むだけです。 次の例では、First と Second という名前空間を作成し、それぞれに同じ名前の Person というクラスを定義しています。
namespace First { export class Person { greet() { console.log(&amp;#39;First.Person&amp;#39;); } } } namespace Second { export class Person { greet() { console.log(&amp;#39;Second.Person&amp;#39;); } } } const p1 = new First.Person(); const p2 = new Second.Person(); p1.greet(); //=&amp;gt; First.</description></item><item><title>TypeScriptの型: 既存の JavaScript ライブラリに型情報を追加する（.d.ts ファイル）</title><link>https://maku.blog/p/s7wk5k3/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s7wk5k3/</guid><description>アンビエント宣言とは TypeScript の アンビエント宣言 (Ambient Declarations) を行うと、既存の JavaScript ライブラリに型情報を付加することができます。 この仕組みを利用すると、
サードパーティ製の JavaScript ライブラリ（npm パッケージ）や、自作の JavaScript ライブラリ（ただし TypeScript 化はしたくないもの）を TypeScript コードから使用する jQuery などのブラウザ上でロードされるライブラリを TypeScript コードから使用する といったことが可能になります。 ようするに、TypeScript トランスパイラに対して、このオブジェクトはこういう型のものとして外から提供されているので、型チェックエラーを出さないでね、と知らせることができます。
さらに、VisualStudio Code などのエディタを使用している場合は、アンビエント型宣言があることにより、エディタ上での補完入力ができるようになります。
アンビエント宣言 (declare) 参考: TypeScript - Declaration Reference どこか別の場所でロードされる予定の JavaScript モジュールに対して、自力で型情報を付けたい場合は declare キーワードを使用します。 例えば、jQuery はもともと JavaScript 用のライブラリなので、TypeScript 用の型情報は提供していませんが、次のように自力で型情報を付けることで、TypeScript コードから利用できるようになります（実際には、DefinitelyTyped プロジェクトが提供する @types/jquery を使用するのが簡単です）。
index.ts // $ という変数を参照できるようにする（実体は実行時に後付けで定義される予定） declare var $: any; // これで、$ という未定義の変数を参照してもエラーにならない $(&amp;#39;#id&amp;#39;).html(&amp;#39;Hello!&amp;#39;); この仕組みを使わずに、いきなり $ を参照してしまうと、そのような変数は定義されていないというエラーになってしまいます。 TypeScript トランスパイラは、declare によって付けられた型情報を正しいものと判断するため、この型情報は間違えないように指定する必要があります。 また、実行時にはそのオブジェクトの実体がどこかで生成されていなければいけません。</description></item><item><title>TypeScriptの型: 環境変数 (process.env) 用の型情報を定義する</title><link>https://maku.blog/p/r8iry9g/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r8iry9g/</guid><description>Node.js で環境変数を参照するためのオブジェクト process.env の型情報は、@types/node で次のように文字列型ディクショナリ Dict&amp;lt;string&amp;gt; として定義されています。
node_modules/@types/node/process.d.ts（抜粋） declare module &amp;#34;process&amp;#34; { global { var process: NodeJS.Process; namespace NodeJS { interface ProcessEnv extends Dict&amp;lt;string&amp;gt; {} //... } } export = process; } この型定義は @types/node モジュールをインストールするだけで簡単に使用できるようになるのですが、具体的なキー名（環境変数名）が定義されていないので、Visual Studio Code などで process.env 以降の入力補完が効きません。
VS Code 上で環境変数名を補完入力 できるようにするには、次のような型定義ファイル (globals.d.ts) をソースツリーのルートに作成します。
globals.d.ts declare namespace NodeJS { // 環境変数名の定義 interface ProcessEnv { /** 現在の Node.js 実行環境 */ readonly NODE_ENV: &amp;#39;development&amp;#39; | &amp;#39;production&amp;#39; | &amp;#39;test&amp;#39;; /** GitHub アクセストークン */ readonly MYAPP_GITHUB_TOKEN: string; } } 環境変数 NODE_ENV の値は、決められた 3 種類の値 (development/production/test) のいずれかであると定義しているので、それ以外の値と比較しようとしたときに警告してくれます。</description></item><item><title>JavaScript で任意のテキストをクリップボードにコピーする</title><link>https://maku.blog/p/buk5i2o/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/buk5i2o/</guid><description>copyToClipboard 関数 次の copyToClipboard 関数を使うと、引数で指定したテキストを OS のクリップボードにコピーすることができます。
function copyToClipboard(text){ // テキストコピー用の一時要素を作成 const pre = document.createElement(&amp;#39;pre&amp;#39;); // テキストを選択可能にしてテキストセット pre.style.webkitUserSelect = &amp;#39;auto&amp;#39;; pre.style.userSelect = &amp;#39;auto&amp;#39;; pre.textContent = text; // 要素を追加、選択してクリップボードにコピー document.body.appendChild(pre); document.getSelection().selectAllChildren(pre); const result = document.execCommand(&amp;#39;copy&amp;#39;); // 要素を削除 document.body.removeChild(pre); return result; } JavaScript からクリップボードにテキストをコピーするときは、任意の HTML 要素のテキストを選択して、document.execCommand('copy') を実行するという流れになります。 そのため、上記の関数では、テキスト選択用の一時的な pre 要素を作成しています。
使用例 例えば次のようにすると、ボタンを押したときにクリップボードにテキストをコピーできます。
クリップボードにコピー ← 実際に動作します
function copyToClipboard(text){ const pre = document.createElement('pre'); pre.style.webkitUserSelect = 'auto'; pre.style.userSelect = 'auto'; pre.</description></item><item><title>JavaScript で現在のページの URL の構成要素を取得する (window.location)</title><link>https://maku.blog/p/j6iu6gs/</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6iu6gs/</guid><description>Web サイト上で実行される JavaScript から window.location を参照すると、カレントページの URL の構成要素をパーツごとに取得することができます。
JavaScript const loc = window.location; console.log(&amp;#39;location.href = &amp;#39; + loc.href); console.log(&amp;#39;location.origin = &amp;#39; + loc.origin); console.log(&amp;#39;location.host = &amp;#39; + loc.host); console.log(&amp;#39;location.protocol = &amp;#39; + loc.protocol); console.log(&amp;#39;location.hostname = &amp;#39; + loc.hostname); console.log(&amp;#39;location.port = &amp;#39; + loc.port); console.log(&amp;#39;location.pathname = &amp;#39; + loc.pathname); console.log(&amp;#39;location.search = &amp;#39; + loc.search); console.log(&amp;#39;location.hash = &amp;#39; + loc.hash); 例えば、次のようなアドレスにアクセスした場合は、
https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose 次のような結果を取得することができます。
location.href = https://example.com:8042/over/there?key1=val1&amp;amp;key2=val2#nose location.origin = https://example.com:8042 location.host = example.</description></item><item><title>TypeScriptの環境: tsc-watch で ts ファイルの変更監視＆アプリの再起動を自動化する</title><link>https://maku.blog/p/nxzsnkf/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nxzsnkf/</guid><description>TypeScript の監視と JavaScript の監視の両立 tsc --watch コマンドを使うと、TypeScript (.ts) ファイルの変更を監視して自動的に tsc （トランスパイル）を実行してくれるようになります。 nodemon コマンドを使うと、JavaScript (.js) ファイルの変更を監視して自動的に node コマンドを再起動してくれるようになります。
これらを組みあわせれば、TypeScript (.ts) ファイルの変更時に、自動的に Node.js アプリを再起動できそうな気がしますが、一連のコマンドとしてこれら 2 つを組み合わせて実行するのにはみんな苦労しているようです（もちろんコマンドシェルを 2 つ立ち上げればできますが）。
そこで便利なのが tsc-watch コマンド です。
tsc-watch パッケージでまるごと解決 tsc-watch という NPM パッケージ（コマンド）を使用すると、TypeScript の変更監視と Node アプリの再起動の連動を簡単に行えるようになります。 まず、必要なパッケージを下記のようにインストールします。 nodemon は使わなくて済むので、ここでは依存パッケージとして typescript と tsc-watch をインストールしておきます。 --save-dev オプションを付加して、package.json の devDependencies に登録するのを忘れないようにしましょう。
$ npm install --save-dev typescript $ npm install --save-dev tsc-watch tsc-watch コマンドはほとんど tsc --watch のラッパーなので、そのまま実行すると、TypeScript ファイルの変更を監視してトランスパイルを実行するという動作になります。 これだけの用途であれば tsc コマンドで十分なのですが、tsc-watch コマンドに追加されている --onSuccess オプションを使うと、トランスパイル後に任意の追加コマンドを実行することができます。 この追加コマンドとして npm start などを実行するように設定しておけば、TypeScript のトランスパイル後に Node.</description></item><item><title>TypeScriptの環境: 既存の JavaScript プロジェクトを TypeScript に乗り換える</title><link>https://maku.blog/p/3eccb2t/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3eccb2t/</guid><description>TypeScript プロジェクトへの移行は簡単！ TypeScript の構文は、JavaScript のコードとの互換性を考慮して仕様が決められているため、既存の JavaScript プロジェクトを簡単に TypeScript プロジェクトに移行することができます。 後述するように設定をうまく行えば、JavaScript ファイルの拡張子を .ts に変える必要すらありません。
TypeScript の構文を使わないと意味がないのでは？と思うかもしれませんが、TypeScript のトランスパイラ (tsc) には、強力な静的解析の仕組みが備わっているため、この機能を既存の JavaScript ファイルに適用するだけでも TypeScript を導入する価値があります。
ここでは、tsc コマンドは下記のようにグローバルにインストールしてあることを前提とします。
$ npm install -g typescript おすすめのディレクトリ構成 既存の JavaScript コードを TypeScript トランスパイラ (tsc) の変換対象にする場合は、入力ファイルとなる .js ファイルと、生成される .js ファイルのディレクトリを明確に区別しておくべきです。 そうしておかないと、どのファイルが自分が作成したファイルで、どのファイルが自動生成されたファイルなのか分かりにくくなってしまいます。
ここでは、既存の JavaScript プロジェクトのソースコード (.js) を、下記のように src ディレクトリに格納します。 このディレクトリには、最終的に .js ファイルと .ts ファイルが混在していても構いません。
project/ +-- tsconfig.js （設定ファイル） +-- build/ （出力用ディレクトリ） +-- src/ （入力用ディレクトリ） +-- main.js +-- module1.js +-- module2.</description></item><item><title>WebGL で使う Typed Array</title><link>https://maku.blog/p/twmzpfj/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/twmzpfj/</guid><description>Typed Array とは JavaScript の配列型には、汎用型の Array の他にも、Int32Array のような、特定の型の値だけしか格納できない配列型が用意されています。 このような配列型のことを Typed Array と呼びます。 イメージとしては、C 言語の int 配列や float 配列に近いです。
例えば、WebGL で頂点属性（座標や色）の配列を用意するようなケースでは、その中の要素の型はすべて float 型に統一されていたりするので、汎用型の Array ではなく、Float32Array を使用することでメモリ効率がよくなります。
Typed Array には下記のようなものが用意されています。
型名 バイト数 値の範囲 説明（対応するC言語の型） Int8Array 1 -128 ～ 127 8-bit sined integer (int8_t) Uint8Array 1 0 ～ 255 8-bit unsigned integer (uint8_t) Int16Array 2 -32768 ～ 32767 16-bit signed integer (int16_t) Uint16Array 2 0 ～ 65535 16-bit unsigned integer (uint16_t) Int32Array 4 -2147483648 ～ 2147483647 32-bit signed integer (int32_t) Uint32Array 4 0 ～ 4294967295 32-bit unsinged integer (uint32_t) Float32Array 4 1.</description></item></channel></rss>