<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>3D on まくろぐ</title><link>https://maku.blog/tags/3d/</link><description>Recent content in 3D on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 19 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/3d/index.xml" rel="self" type="application/rss+xml"/><item><title>WebGL入門 (1) WebGL コンテキストの取得</title><link>https://maku.blog/p/46jrh68/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/46jrh68/</guid><description>このブラウザは canvas タグに対応していません。 上記の canvas 要素は、WebGL により描画しています。 サーフェスをクリアしているだけなので、何も表示されていないのは正しいです。
WebGL のコンテキストを取得する WebGL は、Web ブラウザ上で OpenGL の機能を使用する仕組みです。 HTML の canvas 要素をレンダリング用のサーフェストとして使用します。 canvas 要素から WebGL のコンテキスト WebGLRenderingContext を取得したら、後は OpenGL ES を用いたアプリと同じ感覚で API を呼び出していけます。
下記は、WebGL でサーフェスをクリアするだけの最低限のコードです。 gl.clearColor() でクリア色を設定しています。
HTML &amp;lt;canvas id=&amp;#34;canvas&amp;#34; width=&amp;#34;300&amp;#34; height=&amp;#34;200&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; JavaScript function main() { const canvas = document.getElementById(&amp;#39;canvas&amp;#39;); const gl = canvas.getContext(&amp;#39;webgl&amp;#39;); if (!gl) { console.error(&amp;#39;Failed to obtain WebGL context&amp;#39;); return; } gl.clearColor(0, 0, 0.5, 1.0); // RGBA（暗い青） gl.</description></item><item><title>WebGL入門 (2) シェーダーを使用する</title><link>https://maku.blog/p/8s4uhzv/</link><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8s4uhzv/</guid><description>このブラウザは canvas タグに対応していません。 上記の canvas 要素は、WebGL により描画しています。 canvas の中央に 1 つの点を表示しています。
シェーダーを使うまでの手順 WebGL は OpenGL ES 2.0、WebGL 2.0 は OpenGL ES 3.0 をベースに策定されているため、プリミティブをレンダリングするには、どちらも GLSL ES 言語で記述したシェーダーコード（頂点シェーダー、フラグメントシェーダー）を用意する必要があります。
シェーダーを使用して描画するまでの流れは下記のようになります。
シェーダーオブジェクトの準備（頂点シェーダーとフラグメントシェーダー） シェーダーオブジェクトを作成する (gl.CreateShader) シェーダーコードを設定する (gl.ShaderSource) シェーダーコードをコンパイルする (gl.CompileShader) 必要があればコンパイル結果のチェック (gl.getShaderParameter) 必要があればコンパイルエラーの内容を出力 (gl.getShaderInfoLog) プログラムオブジェクトの準備 プラグラムオブジェクトを作成する (gl.CreateProgram) 2 つのシェーダーオブジェクトをアタッチする (gl.AttachShader) 2 つのシェーダーオブジェクトをリンクする (gl.LinkProgram) 必要があればリンク結果のチェック (gl.getProgramParameter) 必要があればリンクエラーの内容を出力 (el.getProgramInfoLog) レンダリング前に使用するプログラムオブジェクトを選択する (gl.UseProgram) 頂点情報などを用意して描画 (gl.drawArrays) ユーティリティ関数の作成 シェーダーオブジェクトの準備 (createShader) 指定したシェーダーコードをコンパイルしてシェーダーオブジェクトを作成する createShader 関数を作成します。</description></item><item><title>WebGL入門 (3) バッファーオブジェクトで頂点座標をシェーダーへ送る (VBO)</title><link>https://maku.blog/p/ogk9ogw/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ogk9ogw/</guid><description>このブラウザは canvas タグに対応していません。 はじめに WebGL (OpenGL) でアプリケーション側 (CPU) のコードから、シェーダー側 (GPU) へ図形の頂点情報を送るには、バッファーオブジェクト (Buffer Object) の仕組みを使用します。 WebGL 側に確保したバッファーオブジェクトに、頂点座標の配列データをまとめて書き込んでおいて、最後に描画開始要求を送ることで、CPU と GPU 間の通信回数を抑えることができます。 頂点座標を格納するために確保したバッファーオブジェクトのことを、特に VBO (Vertext Buffer Object) と呼んだりします。
WebGL でバッファーオブジェクトを使って図形を描画するまでの流れは以下のようになります。
WebGL 側にバッファーオブジェクトを作成する gl.createBuffer() バッファーオブジェクトをターゲットとバインドする gl.bindBuffer() バッファーオブジェクトに頂点情報を転送する gl.bufferData() 頂点シェーダーの attribute 変数でそのデータを1つずつ取り出せるようにする gl.getAttribLocation() gl.vertexAttribPointer() gl.enableVertexAttribArray() 描画要求を送る gl.drawArrays() 以下、単純な三角形を描画するまでの手順を示します。
バッファーオブジェクトを作成する まず、WebGL 側に頂点情報を格納するためのバッファーオブジェクトを生成します。 これは、gl.createBuffer() をパラメータなしで呼ぶだけなので簡単です。
const vertexBuffer = gl.</description></item><item><title>WebGL入門 (4) 頂点属性をインターリーブしてバッファオブジェクトに格納する</title><link>https://maku.blog/p/wqjqbpi/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wqjqbpi/</guid><description>このブラウザは canvas タグに対応していません。 インターリーブとは インターリーブ (interleave) とは、一般的なコンピュータ用語で、データを交互に配置していくことを示します。 例えば、3D モデルの各頂点の「XY座標」「RGBカラー」をインターリーブして配列に詰めると、3 つの頂点の情報は、
X Y R G B X Y Z G B X Y R G B ... のようにレイアウトされることになります。
WebGL (OpenGL) では、このようにインターリーブされた頂点属性データを扱えるようになっています。 インターリーブする主な頂点属性は、頂点座標 (XYZ)、テクスチャ座標 (UV)、頂点カラー (RGBA) などです。
ここでは、頂点座標 (XY) と頂点カラー (RGB) をインターリーブした配列を JavaScript 側の Float32Array として作成し、それを WebGL 側のバッファオブジェクトに詰める方法を示します。
シェーダー側の実装 まずは、頂点シェーダーとフラグメントシェーダーを用意します。
頂点シェーダー attribute vec4 a_Position; // 入力（XY座標） attribute vec4 a_Color; // 入力（RGAカラー） varying vec4 v_Color; // 出力（RGAカラー） void main() { gl_Position = a_Position; v_Color = a_Color; } 頂点シェーダーでは、バッファオブジェクトから XY 座標を取り出すための attribute 変数 a_Position と、RGB カラーを取り出すための a_Color を定義します。 カラー値は最終的にはフラグメントシェーダー側で必要になるので、varying 変数の v_Color を介して値をフラグメントシェーダーへ渡します。</description></item><item><title>WebGL入門 (5) 三角形の 3 つの描画モード</title><link>https://maku.blog/p/9sxkmma/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9sxkmma/</guid><description>gl.drawArrays() や gl.drawElements で図形を描画するとき、第1引数で頂点をどのように使用するかの描画モードを指定します。 OpenGL ES では、四角形を描画することはできないので、面を表現するときには、三角形の組み合わせで描画することになります。 三角形の描画モードには、下記の 3 種類があります。
gl.TRIANGLE - 各三角形は頂点を共有しない gl.TRIANGLE_STRIP - ジグザグに頂点が配置されていると想定 gl.TRIANGLE_FAN - 扇形に頂点が配置されていると想定 gl.TRIANGLE は、隣接する面の描画においても、独立した頂点データが必要です。 よって、基本的には gl.TRIANGLE_STRIP か gl.TRIANGLE_FAN を使うのがよいのですが、多くの環境では gl.TRIANGLE_STRIP の描画効率がよいようです。
下記は、gl.drawArrays() に gl.TRIANGLE_STRIP を指定して 4 つの三角形を描画した例です。
このブラウザは canvas タグに対応していません。 コードでは、下記のように頂点座標と頂点カラーを定義しています。
const vertices = new Float32Array([ -1.0, 0.5, 1.0, 0.0, 0.0, // v0 (XYRGB) 赤 -0.6, -0.5, 0.0, 1.0, 0.0, // v1 (XYRGB) 緑 0.</description></item><item><title>WebGL入門 (6) インデックスバッファを使って頂点を使い回す (drawElements)</title><link>https://maku.blog/p/wbvv3ha/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/wbvv3ha/</guid><description>インデックスバッファを用いた描画の概要 gl.drawArrays() による描画には、3 つの三角形の描画モードがあり、連なった三角形を描画するときには、gl.TRIANGLE_STRIP あるいは gl.TRIANGLE_FAN の描画モードを使用すると、頂点情報を使い回しながら効率的に描画することができます。
ただし、図形が少し複雑になってくると、一度の gl.drawArrays() 呼び出しではうまく描画できなくなってきます。 例えば次のような 3 つの三角形（トライフォース）を描画することを考えてみます。
面 A、B、C は独立した三角形に見えるので、それぞれに 3 つの頂点（合計 9 頂点）を用意して gl.drawArrays() の gl.TRIANGLES モードでレンダリングすればよさそうですが、頂点 1、2、4 に関しては座標が同じなので、本来であれば上記のように 6 つの頂点情報を用意するだけで足りそうです。 このような場合は、インデックスバッファと gl.drawElements() を使用すると、効率的な描画を行えます。
頂点バッファオブジェクト (VBO) に座標情報を入れておくのは gl.drawArrays() を使った場合と同様ですが、もう一つ別のバッファオブジェクトとして、インデックスバッファオブジェクト (IBO: Index Buffer Object) を作成します。 IBO には、VBO 内のどの頂点情報を使って図形描画を行うかを示す、頂点インデックスの情報を格納します。
頂点バッファオブジェクト (VBO) 頂点情報（座標、色など）を重複しないように格納する。 上記の例では、頂点 0～5 の 6 つの頂点情報を格納する。 インデックスバッファオブジェクト (IBO) 図形描画に VBO 内のどの頂点情報を使うかを示すインデックス配列。 上記の例では、面Aは 0,1,2、面Bは 1,3,4、面Cは 2,4,5 の頂点を使用するという情報。一次元で、0,1,2,1,3,4,2,4,5 と格納すればよい。 実装 このブラウザは canvas タグに対応していません。 ここでは、各頂点に異なる色をつけたトライフォースを描画してみます。</description></item><item><title>WebGL で使う Typed Array</title><link>https://maku.blog/p/twmzpfj/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/twmzpfj/</guid><description>Typed Array とは JavaScript の配列型には、汎用型の Array の他にも、Int32Array のような、特定の型の値だけしか格納できない配列型が用意されています。 このような配列型のことを Typed Array と呼びます。 イメージとしては、C 言語の int 配列や float 配列に近いです。
例えば、WebGL で頂点属性（座標や色）の配列を用意するようなケースでは、その中の要素の型はすべて float 型に統一されていたりするので、汎用型の Array ではなく、Float32Array を使用することでメモリ効率がよくなります。
Typed Array には下記のようなものが用意されています。
型名 バイト数 値の範囲 説明（対応するC言語の型） Int8Array 1 -128 ～ 127 8-bit sined integer (int8_t) Uint8Array 1 0 ～ 255 8-bit unsigned integer (uint8_t) Int16Array 2 -32768 ～ 32767 16-bit signed integer (int16_t) Uint16Array 2 0 ～ 65535 16-bit unsigned integer (uint16_t) Int32Array 4 -2147483648 ～ 2147483647 32-bit signed integer (int32_t) Uint32Array 4 0 ～ 4294967295 32-bit unsinged integer (uint32_t) Float32Array 4 1.</description></item><item><title>WebGL で シェーダーコードを分離する方法</title><link>https://maku.blog/p/itkdix9/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><guid>https://maku.blog/p/itkdix9/</guid><description>解決したいこと WebGL で使用する頂点シェーダーとフラグメントシェーダーの GLSL ES コードは単純な文字列データであればよいので、下記のように JavaScript のコードに埋め込んでしまう方法が最初に思いつきます。
const VSHADER_CODE = ` void main() { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); gl_PointSize = 10.0; }`; const FSHADER_CODE = ` void main() { gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); }`; しかし、これだとアプリ側のコードとシェーダーのコードが混ざってしまうので美しくありません。 ここでは、シェーダーコードを分離するいくつかの方法を示します。
script 要素内にシェーダーコードを埋め込む方法 下記のような感じで、頂点シェーダーとフラグメントシェーダー用の script 要素を用意して、そこにコードを埋め込んでしまう方法です。
HTML 抜粋 &amp;lt;script id=&amp;#34;vshader&amp;#34; type=&amp;#34;x-shader/x-vertex&amp;#34;&amp;gt; void main() { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); gl_PointSize = 10.0; } &amp;lt;/script&amp;gt; &amp;lt;script id=&amp;#34;fshader&amp;#34; type=&amp;#34;x-shader/x-fragment&amp;#34;&amp;gt; void main() { gl_FragColor = vec4(0.</description></item></channel></rss>