<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protocol Buffers on まくろぐ</title><link>https://maku.blog/tags/protocol-buffers/</link><description>Recent content in Protocol Buffers on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 16 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/protocol-buffers/index.xml" rel="self" type="application/rss+xml"/><item><title>protobuf (.proto) ファイルのコーディングスタイル</title><link>https://maku.blog/p/esbs9o5/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/esbs9o5/</guid><description>.proto ファイルでメッセージやサービスを定義するときのコーディング規約をまとめておきます。 Google が Style Guide として指針をまとめていますが、プロジェクト内に既に .proto ファイルがある場合は、一貫性を保つように記述するのがよいとされています。
.proto ファイルの例 syntax = &amp;#34;proto3&amp;#34;;package endpoints.examples.bookstore;option java_multiple_files = true;option java_outer_classname = &amp;#34;BookstoreProto&amp;#34;;option java_package = &amp;#34;com.google.endpoints.examples.bookstore&amp;#34;;import &amp;#34;google/protobuf/empty.proto&amp;#34;;service Bookstore { rpc ListShelves(google.protobuf.Empty) returns (ListShelvesResponse) {} rpc CreateShelf(CreateShelfRequest) returns (Shelf) {} rpc GetShelf(GetShelfRequest) returns (Shelf) {} rpc DeleteShelf(DeleteShelfRequest) returns (google.protobuf.Empty) {} rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) {} rpc CreateBook(CreateBookRequest) returns (Book) {} rpc GetBook(GetBookRequest) returns (Book) {} rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) {}}message Shelf { int64 id = 1; string theme = 2;}message Book { int64 id = 1; string author = 2; string title = 3;}enum FooBar { FOO_BAR_UNSPECIFIED = 0; FOO_BAR_FIRST_VALUE = 1; FOO_BAR_SECOND_VALUE = 2;} 全般 .</description></item><item><title>.proto の文法: メッセージ型 (message)</title><link>https://maku.blog/p/7h3hu8k/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7h3hu8k/</guid><description>メッセージ型とは Protocol Buffers の メッセージ型 は、基本的なデータ構造を表すもので、.proto ファイルの中で message キーワードを使って定義します。 メッセージ型は、プログラミング言語でいうところの構造体に相当するものです。
message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3;}Go 言語のコードに変換した場合の例 変換コマンド $ protoc --go_out=. --go_opt=Msample.proto=message sample.proto sample.pb.go（抜粋） type SearchRequest struct { // ... Query string `protobuf:&amp;#34;bytes,1,opt,name=query,proto3&amp;#34; json:&amp;#34;query,omitempty&amp;#34;` PageNumber int32 `protobuf:&amp;#34;varint,2,opt,name=page_number,json=pageNumber,proto3&amp;#34; json:&amp;#34;page_number,omitempty&amp;#34;` ResultPerPage int32 `protobuf:&amp;#34;varint,3,opt,name=result_per_page,json=resultPerPage,proto3&amp;#34; json:&amp;#34;result_per_page,omitempty&amp;#34;` } 自動生成されたコードの型情報には、.proto で明示的に定義したフィールド以外の情報も含まれています。 それらの情報は、各種 protobuf ライブラリが内部的に使用します。
上記の SearchRequest というメッセージ型は 3 つのフィールド（文字列 1 つと数値 2 つ）を持っています。 ここでは、protobuf が標準で用意している スカラー型 の string と int32 を使っていますが、他のメッセージ型や列挙型、マップ型などのフィールドとして定義することもできます。 このあたりは、一般的なプログラミング言語と同様です。 各フィールドの末尾には、フィールドを一意に特定する整数である フィールド番号 を割り当てる必要があります。</description></item><item><title>.proto の文法: フィールド番号について</title><link>https://maku.blog/p/w7xkvnb/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/w7xkvnb/</guid><description>フィールド番号の基本 Protocol Buffers の .proto ファイルの型定義では、各フィールドの末尾に フィールド番号 を割り当てておく必要があります。
フィールド番号の割り当て例 message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3;} = 記号が使われていますが、そのフィールドに値を代入しているわけではないので注意してください。 Protocol Buffers は、メッセージ送信用にデータをシリアライズ（バイナリ化）するとき、フィールド名の代わりにこのフィールド番号を使用します。 これにより、Protocol Buffers は効率的なデータ転送を実現しています。
フィールド番号は 1 以上の整数（最大値は 229-1 = 536,870,911）で、メッセージの定義内（同じ階層）で一意になっている必要があります。 必ずしも 1、2、3 のように連番で割り当てる必要はなく、ほぼ任意の数値を割り当てることができますが、19000 ～ 19999 の値は使えません。 これらは、Protocol Buffers ライブラリが内部実装用に予約している値です。 これらの不正な値を使用していると、protoc コマンドなどでコンパイルしようとしたときにエラーになります。
データをシリアライズするとき、フィールド番号 1～15 の数値は、わずか 1 バイトのデータに変換されるため、頻繁に使用するフィールドには 1～15 のフィールド番号を割り当てておくと効率的な通信を行えます。 とはいえ、フィールド番号が 16～2047 であっても、2 バイトのデータで表現できるので、シビアな通信速度が求められている環境でなければそれほど気にする必要はないでしょう。
reserved と deprecated reserved 一度割り当てたフィールド番号は、将来にわたって変更してはいけません。 なぜなら、過去のバージョンの .proto を使って実装されたアプリケーションは、古い .proto で割り当てられたフィールド番号で通信しようとするためです。 同じフィールド番号で異なるデータが送られてきたら、アプリケーションはうまく動作しなくなってしまいます。 .</description></item><item><title>.proto の文法: スカラー型の一覧</title><link>https://maku.blog/p/bi5jyer/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/bi5jyer/</guid><description>Protocol Buffers の .proto ファイルの中で使用可能なスカラー型と、各言語の型の対応表です。 スカラー型は、メッセージ型 の各フィールドの型として使用できます。
protobuf C++ Java/Kotlin Go Dart double double double float64 double float float float float32 double int32 int32 int int32 int int64 int64 long int64 Int64 uint32 uint32 int uint32 int uint64 uint64 long uint64 Int64 sint32 int32 int int32 int sint64 int64 long int64 Int64 fixed32 uint32 int uint32 int fixed64 uint64 long uint64 Int64 sfixed32 int32 int int32 int sfixed64 int64 long int64 Int64 bool bool boolean bool bool string string String string String bytes string ByteString []byte List 次のような repeated フィールドは、配列やリスト（Golang ではスライス）に相当するコードに置き換えられます。</description></item><item><title>.proto の文法: repeated ラベル（フィールドを配列にする）</title><link>https://maku.blog/p/b2q2jmh/</link><pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/b2q2jmh/</guid><description>Protocol Buffers (protobuf) のフィールドを配列／リスト扱いにするには、.proto ファイルのフィールド定義の先頭に repeated ラベルを付加します。 次の FindBookResponse メッセージ型は、Book 配列のフィールドを持っています。
books.proto（抜粋） message FindBookResponse { repeated Book books = 1;}message Book { string title = 1;} repeated ラベルを付けたフィールドの名前は複数形にしましょう（上記例の場合は books）。
Protocol Buffers では repeated を連続させた多次元配列は定義できませんが、任意のメッセージ型に repeated を付けることはできるので、そのメッセージ型の中に repeated フィールドを配置すれば、多次元配列と同様のデータを表現することができます。
repeated ラベルは、oneof フィールドに付加することはできません。
参考: .proto の文法: oneof 型</description></item><item><title>.proto の文法: optional ラベル（フィールドを省略可能にする）</title><link>https://maku.blog/p/sp9q7o5/</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sp9q7o5/</guid><description>.proto のフィールドを省略可能にする (option) Protocol Buffers（.proto ファイル）のフィールド定義で optional というラベルを付けると、そのフィールドへの値のセットがオプショナルであることを示すことができます。 optional ラベルは、protoc コンパイラの v3.15.0 以降で使用できます。
sample.proto syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;github.com/maku77/myapp/pb&amp;#34;;message SampleMessage { string message = 1; // 通常のフィールド optional string description = 2; // 省略可能なフィールド } 例えば、上記のような .proto ファイルから、次のように Golang コードを生成すると、
$ protoc --go_out=. --go_opt=paths=source_relative sample.proto 次のような SampleMessage 型のコードが生成されます。
sample.pb.go type SampleMessage struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Message string `protobuf:&amp;#34;bytes,1,opt,name=message,proto3&amp;#34; json:&amp;#34;message,omitempty&amp;#34;` // 通常のフィールド Description *string `protobuf:&amp;#34;bytes,2,opt,name=description,proto3,oneof&amp;#34; json:&amp;#34;description,omitempty&amp;#34;` // 省略可能なフィールド } Golang の場合は、オプショナルな string フィールドは、*string として表現されるようですね。</description></item><item><title>.proto の文法: oneof 型</title><link>https://maku.blog/p/vxixbp3/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vxixbp3/</guid><description>Protocol Buffers の oneof 型 は、定義したフィールドのうち、いずれか 1 つのフィールドのみに値が格納されていることを示す型です。 次の SampleMessage メッセージ型は、1 つの oneof 型フィールド status を持っています。
message SampleMessage { string content = 1; oneof status { int32 status_code = 2; string status_name = 3; }}上記の oneof ブロックには status_code フィールドと status_name フィールドが定義されていますが、これらのいずれかのフィールドに値が格納されることを示しています。 実際にどのフィールドに値が格納されているかを調べる方法は、各言語の protobuf ライブラリ実装によって異なります。 下記は C++ の例です。
SampleMessage message; message.set_status_code(123); if (message.has_status_code()) { // ... } oneof のフィールドに値をセットすると、同じ oneof に含まれる他のフィールドの値はクリアされることに注意してください。
oneof フィールドに、repeated ラベル や optional ラベル を設定することはできません。</description></item><item><title>.proto の文法: マップ型 (map)</title><link>https://maku.blog/p/xpbnycm/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xpbnycm/</guid><description>Protocol Buffers でマップ型のフィールドを定義するには、map&amp;lt;key_type, value_type&amp;gt; という形式で型を指定します。 次の SampleMessage メッセージ型は、string 型のキーと Project 型の値を持つマップフィールドを定義しています。
sample.proto（map 型フィールドの例） message SampleMessage { // ... map&amp;lt;string, Project&amp;gt; projects = 3;}message Project { // ... } キーの型 (key_type) には、整数あるいは文字列 を指定することができます。 浮動小数点数 (float, double) やバイトデータ (bytes) を key_type にすることはできません。
値の型 (value_type) としては、ほぼすべての型 を指定できますが、マップ型だけは value_type にすることはできません。 つまり、マップのマップは表現できないことになるのですが、value_type として他のメッセージ型を持たせることができるので（上記の例では Project）、実際にはほぼ同様の情報を表現できます。
あと、あまり困ることはないでしょうが、Protocol Buffers ではマップの配列（リスト）は表現できません（つまり、repeated map&amp;lt;xxx, yyy&amp;gt; とはできません）。</description></item><item><title>.proto の文法: 列挙型 (enum)</title><link>https://maku.blog/p/p5wjbwq/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p5wjbwq/</guid><description>列挙型とは Protocol Buffers の 列挙型 は、取り得る値が、あらかじめ定義された定数の中からのみ選択可能であることを示す型で、.proto ファイルの中で enum キーワードを使って定義します。 列挙型は、ひとことで言うと、複数の定数をグルーピングする機能です。 下記の例では、Corpus という列挙型を定義し、SearchRequest メッセージ型のフィールドとして使用しています。
sample.proto enum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7;}message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; Corpus corpus = 4;} .proto のコーディングスタイル では、すべての列挙値の名前には、型名に相当するプレフィックス を付けるべしとされています（上記の CORPUS_ の部分）。 型名が 3 語以上で構成されていたりして長い場合は、略称のプレフィックスが使われることもあるようです。
0 という値にマップされるものには、サフィックスとして _UNSPECIFIED を付けるよう推奨されています（上記の CORPUS_UNSPECIFIED）。 これは、コーディングスタイルという観点だけではなく、proto2 との互換性確保の理由もあります。</description></item><item><title>.proto の文法: 別の .proto ファイルをインポートする (import)</title><link>https://maku.blog/p/e8yeofc/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/e8yeofc/</guid><description>.proto ファイルをインポートする (import) Protocol Buffers の .proto 内で import ステートメントを使用すると、他の .proto ファイルの内容を取り込むことができます。 次の例では、main.proto から other.proto の内容をインポートして、OtherMessage というメッセージ型を参照しています。
proto/message/main.proto（インポートする側） syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;github.com/maku77/myapp/message&amp;#34;;import &amp;#34;message/other.proto&amp;#34;;message MainMessage { OtherMessage other = 1;} proto/message/other.proto（インポートされる側） syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;github.com/maku77/myapp/message&amp;#34;;message OtherMessage { string content = 1;} インポートのパスは、デフォルトでは protoc コマンドを実行したディレクトリからの相対パスで指定します。 起点となるディレクトリを変更したい場合は、protoc コマンドの --proto_path オプションで、.proto ファイルを配置したルートディレクトリを指定します。
.proto ファイルが proto ディレクトリ以下にある場合 $ protoc --go_out=. --go_opt=paths=source_relative --proto_path=proto message/main.proto 上記のように実行すると、proto/message/main.proto ファイル（およびそこからインポートされているファイル）を入力情報として、message/main.pb.go が生成されます。
参考: protoc コマンドで .</description></item><item><title>.proto の文法: サービス型 (service)</title><link>https://maku.blog/p/napwb4e/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/napwb4e/</guid><description>Protoco Buffers の サービス型 は、クライアントとサーバー間の通信方法 (RPC メソッド群) を定義するための型で、.proto ファイルの中で service キーワードを使って定義します。
次の例では、Echo メソッドを持つ EchoService サービス型を定義しています。
// Echo メソッドを持つ EchoService の定義 service EchoService { rpc Echo (EchoRequest) returns (EchoResponse);}// Echo に送るリクエストメッセージの定義 message EchoRequest { string message = 1; optional string payload = 2;}// Echo が返すレスポンスメッセージの定義 message EchoResponse { string message = 1;}引数と戻り値の方には、上記のように単一のメッセージ型を指定します。 スカラー型を指定することはできないので、単一の値を渡したいときも、独自のメッセージ型を用意する必要があります。 慣例として、引数の型には Request、戻り値の型には Response というサフィックスを付けます。
引数や戻り値が存在しない場合は、Google が用意している google.protobuf.Empty 型を使用することができます。
import &amp;#34;google/protobuf/empty.proto&amp;#34;;service HelloService { rpc Hello(google.protobuf.Empty) returns (google.protobuf.Empty);}ただ、将来的に何らかの値を渡す可能性がある場合は、独自の空っぽのメッセージ型を定義しておくのがよいでしょう。
service HelloService { rpc Hello(HelloRequest) returns (HelloResponse);}message HelloRequest {}message HelloResponse {}RPC の通信プロトコルは、独自で実装してしまうことも可能ですが、多くの場合は Google が作った gRPC というプロトコルを使います。 というより、gRPC による通信を実現するために、Protocol Buffers (protobuf) によるシリアライズを使用することになるというケースが多いと思います。 protoc コマンド本体には、gRPC 用のスタブコードを生成する機能は入っていないので、protoc のプラグイン（protoc-gen-go-grpc など）を入れてコード生成することになります。</description></item><item><title>Protocol Buffers の .proto ファイルから API ドキュメントを自動生成する (protoc-gen-doc)</title><link>https://maku.blog/p/ikw7gpz/</link><pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ikw7gpz/</guid><description>protoc-gen-doc とは？ David Muto 氏が公開している protoc-gen-doc という protoc コマンドのプラグインを使用すると、.proto ファイルから、HTML 形式や Markdown 形式のドキュメントを自動生成することができます。 複数の .proto ファイルの内容をまとめて 1 つのページとして出力してくれるので、シンプルで見通しのよいドキュメントになります。
生成されたドキュメントの例: HTML 形式 / Markdown 形式 / JSON 形式
protoc-gen-doc は protoc コマンドのプラグインとして動作するのですが、実行環境が Docker イメージとして提供されているので、docker コマンド一発で、簡単に .proto ファイルからドキュメントを生成できます。 もちろん、protoc コマンドと protoc-gen-doc を両方インストールして実行することもできますが、Docker を使った方が断然お手軽です。
Protocol Buffers Compiler（protoc コマンド）に関しては、こちらを参考にしてください。
.proto ファイルからのドキュメント生成 protoc-gen-doc コマンドの基本 protoc-gen-doc の Docker イメージを使って、.proto ファイルからドキュメントを生成してみます。 Docker の実行環境は、Docker Desktop などでインストールしてください。 .proto ファイルが手元になければ、とりあえず下記のファイルをダウンロードして試せます。
Vehicle.proto（サンプル .proto ファイル） proto/Vehicle.proto のように、proto ディレクトリに格納すれば準備完了です。 あとは次のように実行すると、docs ディレクトリに index.</description></item><item><title>Go 言語で gRPC 通信してみる（Echo サーバー＆クライアント）</title><link>https://maku.blog/p/ij4jv9k/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ij4jv9k/</guid><description>何をするか？ ここでは、Go 言語用の gRPC ライブラリである gRPC-Go (google.golang.org/grpc) を使って、簡単な gRPC サーバーとクライアントを作ってみます。 通信用のスタブコードなどは、protoc コマンド (Protocl Buffers Compiler) で .proto ファイルから自動生成するので、あらかじめ protoc コマンドをインストールしておいてください。
参考: protoc コマンドで .proto ファイルをコンパイルする (Protocol Buffers Compiler) protoc コマンドで Go 言語用のコードを生成するには、protoc-gen-go プラグインと protoc-gen-go-grpc プラグインをインストールしておく必要があります。 前者がシリアライズ用のコード、後者が gRPC 用のスタブコードを生成するための protoc プラグインです。
# バージョンを指定してインストールする方法（推奨） $ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 # 最新バージョンをインストールする方法 $ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest プロジェクトの作成と gRPC-Go のインストール まずは Go 言語用のプロジェクトを作成します。 モジュール名は com.example/grpc-sample としていますが、GitHub で管理する予定であれば、リポジトリ名に合わせて github.</description></item><item><title>protoc コマンドで .proto ファイルをコンパイルする (Protocol Buffers Compiler)</title><link>https://maku.blog/p/37e6uck/</link><pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/37e6uck/</guid><description>Protcol Buffers とは プロトコルバッファー (Protocol Buffers、または protobuf) は、Google が開発した、構造化したデータをシリアライズするためのフォーマットです。 同じく Google が開発した gRPC 通信プラットフォームで採用されており、XML や JSON などのテキストベースの API より効率的な通信を行うことができるという特徴を持っています。
データをコンパクトに表現できるため、通信やパース処理が高速 強い型付けを行うことでき、サーバー、クライアントの安全なコーディングが可能 定義変更時の互換性を考慮したフォーマット OS やプログラミング言語などに非依存 データ構造やサービス形式の定義は、.proto 拡張子を持つ プロトコル定義ファイル (Proto Definition file) で行います。 この .proto ファイルを protoc コマンド（プロトコルバッファーコンパイラ）でコンパイルすると、各言語用のソースコードを生成することができます。
図: protoc コマンドによるコード生成 protoc コマンドは各種プログラミング言語用のコードを生成するわけですが、そのためには、protoc コマンド本体 と 各言語用のプラグイン（protoc-gen-go など）がインストールされている必要があります。 C++ や C#、Kotlin、Python、Ruby などのコード生成は組み込みで対応していますが、Go 言語用のプラグインなどは別途インストールする必要があります。
protoc 本体のインストール protoc コマンド (Protocol Buffers Compiler) は、Linux（Ubuntu 系）や macOS ではパッケージマネージャーを使ってインストールしてしまうのが簡単です。 インストールするパッケージの名前は protobuf や protobuf-compiler であることに注意してください。</description></item></channel></rss>