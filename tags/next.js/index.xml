<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Next.js on まくろぐ</title><link>https://maku.blog/tags/next.js/</link><description>Recent content in Next.js on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 21 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/next.js/index.xml" rel="self" type="application/rss+xml"/><item><title>Next.js ですべてのページにグローバルな CSS を適用する (pages/_app.ts)</title><link>https://maku.blog/p/s9iry9g/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s9iry9g/</guid><description>Next.js で、すべてのページコンポーネント (pages/*.tsx) に共通のスタイルシート（いわゆるグローバル CSS）を適用したい場合は、pages/_app.tsx(js) というファイルを作成して、そこで CSS ファイルをインポートします。
例えば、グローバル CSS として次のようなファイルを用意したとします。
styles/global.css * { box-sizing: border-box; } html { margin: 0; padding: 0; } body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif; max-width: 50rem; padding: 0.5rem; margin: 0 auto; font-size: 100%; } a { color: inherit; text-decoration: none; } この CSS ファイルを pages/_app.tsx からインポートすれば、すべてのコンポーネントにスタイルが反映されます。 このファイルが存在しない場合は作成してください。
pages/_app.tsx import type { AppProps } from &amp;#39;next/app&amp;#39; import &amp;#39;.</description></item><item><title>Next.js の API Routes 機能で Web API を作成する</title><link>https://maku.blog/p/qcp2coz/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qcp2coz/</guid><description>Next.js の Web API 機能 Next.js では、pages/api ディレクトリ以下に TypeScript (JavaScript) コードを配置するだけで、クライアントサイド JavaScript から呼び出せる API を定義することができます。
例えば、次のようなファイルを作成します。
pages/api/hello.ts import type { NextApiRequest, NextApiResponse } from &amp;#39;next&amp;#39; type Response = { name: string } export default (req: NextApiRequest, res: NextApiResponse&amp;lt;Response&amp;gt;) =&amp;gt; { res.status(200).json({ name: &amp;#39;John Doe&amp;#39; }) // チェーン呼び出しせずに次のように記述しても OK // res.statusCode = 200 // res.json({ name: &amp;#39;John Doe&amp;#39;}) } あとは、Next.js サーバーを起動した状態で、/api/hello というエンドポイントにアクセスすると、次のような JSON データを取得できます。
{&amp;#34;name&amp;#34;:&amp;#34;John Doe&amp;#34;} API 機能は次のような用途に使用することができます。</description></item><item><title>Next.js で各ページの head 要素をカスタマイズする (next/head)</title><link>https://maku.blog/p/rdr4fq2/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdr4fq2/</guid><description>Next.js で各ページの head 要素をカスタマイズしたいときは、Next.js の Head コンポーネント を使用して、必要な値のみを設定していきます。 典型的なのは、次のような title 要素の設定です。
// import Head from &amp;#39;next/head&amp;#39; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;Page Title&amp;lt;/title&amp;gt; &amp;lt;/Head&amp;gt; ちなみに、head 要素ではなく、html 要素の属性値などを設定したいときは、pages/_document.tsx ファイルを作成します。</description></item><item><title>Next.js のプリレンダリング機能を使用する (getStaticProps)</title><link>https://maku.blog/p/iv4agnt/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iv4agnt/</guid><description>Pre-rendering とは ブログの記事一覧ページなどを生成する場合、なんらかの API で取得した値をもとにページのコンテンツを生成する必要があります。 例えば、次のように取得した値を使ってページを生成することになります。
Web API で取得した値 データベースのクエリ結果 ローカルファイルの内容や、ファイルの一覧情報 Next.js には、Web サイトのビルド時や、Web サーバーへのアクセス時にこういった API を呼び出して、HTML コンテンツを生成する Pre-rendering 機能が備わっています。 Pre-rendering 機能は次の 2 種類があり、どちらか一方を使うこともできますし、両方を組み合わせて使うこともできます。
SSG: Static Generation（静的サイトジェネレーション） Web サイトのビルド時に HTML ファイルを生成します。Web サーバーは静的な HTML ファイルを返すだけでよいので、パフォーマンスが非常に高くなります。すべてのページを事前に列挙できるのであれば、できるだけこの SSG を使って静的に HTML 生成してしまうことが推奨されています。静的な HTML ファイルをホスト可能なサーバー（GitHub Pages など）があれば、Web サイトを公開できます。 SSR: Server-side Rendering（サーバーサイドレンダリング） クライアントが Web サーバーにアクセスしたときに、サーバーサイドで動的に HTML を生成します。この仕組みを使うと、日々増減するデータを扱いやすくなりますが、Web サーバーとして Next.js サーバーを稼働させておく必要があります。感覚的には、PHP サーバーなどが動作しているイメージに近いです。 ちなみに、純粋に React.js のみを使用した場合とはどう違うのでしょうか？ React.js 自体には Pre-rendering 機能は備わっておらず、主に SPA (Single Page Application) を作成するライブラリとして使用されています。 React.</description></item><item><title>Next.js から AWS DynamoDB にアクセスする</title><link>https://maku.blog/p/xp8o5k2/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xp8o5k2/</guid><description>何をするか？ Next.js アプリの API routes (pages/*.ts) や、getServerSideProps などのサーバーサイドで実行される関数では、通常の Node.js モジュールを使うことができるため、AWS の DynamoDB からデータを取得する、といったことも自由に行えます。 ここでは、Next.js の API routes 機能を使って、DynamoDB から情報を取得する Web API を作ってみます。 具体的には次のようなことをします。
テスト用の DynamoDB テーブル (Books) を作成する Books テーブルを参照するためのアクセスキー（IAM ユーザー）を作成する Next.js の API routes の実装 (pages/api/books.ts) を行う AWS SDK を使って DynamoDB から情報を取得する /api/books/001 のような URL にアクセスすると JSON データを返す アクセスキーは環境変数で設定する ☝️ アクセスキーを使った AWS リソースのアクセスについて AWS のアクセスキーは、IAM ユーザーに設定されるものであり、このアクセスキーが漏洩すると、そのユーザーの権限で何でもできる ということになります。 そのため、アクセスキーを使用するときは、IAM ユーザーの権限を適切に絞ることが大切で、そもそも本当に必要なケースでのみアクセスキーを使うようにすべきです。 アクセスキーが必要になるのは、AWS の外から AWS リソースに直接アクセスするケースです。 例えば、AWS CLI のコマンドで AWS の制御を行う場合や、今回の例のように AWS 外のサーバーから AWS へアクセスするようなケースです。</description></item><item><title>Next.js でコンポーネント単位の CSS を作成する (CSS Modules)</title><link>https://maku.blog/p/seq2cmw/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/seq2cmw/</guid><description>CSS Modules とは CSS Modules は、コンポーネント（ファイル）単位で CSS ファイルを分けて管理する仕組みです（これ自体は Next.js の仕組みではありません）。 CSS の名前空間がコンポーネントごとに分離されるため、シンプルな CSS クラス名を付けても名前がコンフリクトする心配がありません。
Next.js は標準で CSS Modules の仕組みをサポートしており、CSS ファイルの拡張子を .module.css にするだけで、各コンポーネントの実装ファイルから簡単にインポートすることができます。
Next.js で CSS Modules 機能を使う Next.js で特定のコンポーネント用に CSS ファイルを用意するときは、そのコンポーネントと同じディレクトリに .module.css という拡張子を持つファイルを作成します。 この拡張子は、Next.js で CSS Modules の仕組みを使うときのルールです。
ここでは、警告メッセージを表示する Alert コンポーネント用の Alert.module.css を作成してみます。 といっても、普通に CSS ファイルを記述するだけです。 グローバルに適用する CSS ファイルと異なるのは、Alert コンポーネント用のスタイル定義しか含まれていないことです。
components/Alert.module.css .box { margin: 1em; padding: 0.5em; background: red; color: white; font-weight: bolder; border-radius: 0.5em; } この CSS ファイルを Alert コンポーネントから使用するには、次のようにインポートします。</description></item><item><title>Next.js のダイナミックルーティング機能を利用する (getStaticPaths, getStaticProps, getServerSideProps)</title><link>https://maku.blog/p/rdq3ep2/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq3ep2/</guid><description>ダイナミックルーティングとは Next.js では、pages/books/[id].tsx のようなファイル名でページを作成すると、1 つのファイルで、
/books/001 /books/002 /books/003 のようなパス (URL) によるアクセスをハンドルできます。 これを ダイナミックルーティング (Dynamic Routes) 機能と呼びます。
Next.js のページコンポーネント (/pages/xxx.tsx) は、そのページのエントリポイント（ルートコンポーネント）となるため、通常の React コンポーネントとは違って、上位のコンポーネントから props 情報を渡すことができません。 そこで Next.js では、ページコンポーネントの実装ファイル内で getStaticProps という関数を定義することで、ページコンポーネントに渡す props 情報を生成できるようにしています。 getStaticProps 内では、上記のような URL パラメータ情報（/books/[id] の id の部分の値）を取り出して、それを元に props 情報を生成できます。 この仕組みによって、Next.js のページコンポーネントは、1 つの .tsx ファイルで、複数のページ (.html) を生成できるようになっています。
ダイナミックルーティングの実装（SSG の場合） 静的ジェネレーション (SSG: Static Generation)、つまり Web サイトのビルド時にすべての HTML ファイルを生成してしまうには、あらかじめどのようなパラメーター（上記の例では id）でのアクセスが行われるかを把握した上で、各ページの内容を生成する必要があります。 これを実現するには、ページコンポーネントの実装ファイル (pages/*.tsx) で、次のような async 関数を実装して export します。
getStaticPaths 関数 URL のパラメーター部分（上記の例では id）で指定可能な値を返すように実装します。言い換えると、プリビルドすべきページの一覧情報を Next.</description></item><item><title>Next.js で全ページ共通のレイアウトを定義する（Layout コンポーネント）</title><link>https://maku.blog/p/dxamw8i/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dxamw8i/</guid><description>Next.js で Web サイトに見た目の統一感を持たせるには、Layout コンポーネントを作成して、全てのページのベースレイアウトとして使用するようにします。 Next.js の仕組みというより、React コンポーネントを作成するときの慣例のようなもので、コンポーネントに Layout という名前を付けるのも多くの人がその名前を使っているだけです。
Layout コンポーネントを定義する Layout コンポーネントを定義するために、次のようなファイルをプロジェクト内に作成します。 {children} の部分には、Layout 要素以下に配置した子要素が展開されることになります。
components/Layout.tsx import { ReactNode } from &amp;#39;react&amp;#39; type Props = { children: ReactNode; } export function Layout({ children, ...props }: Props) { return &amp;lt;div {...props}&amp;gt;{children}&amp;lt;/div&amp;gt; } この Layout コンポーネントを使用するには、各ページのコンポーネント実装において、ルート要素として配置します。
pages/about.tsx import Head from &amp;#39;next/head&amp;#39; import Link from &amp;#39;next/link&amp;#39; import { Layout } from &amp;#39;../components/Layout&amp;#39; export default () =&amp;gt; ( &amp;lt;Layout&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;About me&amp;lt;/title&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;h1&amp;gt;About me&amp;lt;/h1&amp;gt; &amp;lt;Link href=&amp;#34;/&amp;#34;&amp;gt; &amp;lt;a&amp;gt;Back to home&amp;lt;/a&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;/Layout&amp;gt; ) Layout コンポーネントに CSS を適用する styled-jsx で直接スタイルを埋め込む方法 styled-jsx の仕組み を使って、コンポーネントの定義内に直接 CSS を埋め込んでしまう方法です。</description></item><item><title>Next.js で Sass (scss/sass) を有効にする</title><link>https://maku.blog/p/2n2doyb/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2n2doyb/</guid><description>Next.js は Sass を使ったスタイルシート記述 (.scss / .sass ファイル）をサポートしています。 ほぼゼロコンフィグ（設定なし）で使用できますが、NPM の sass モジュールだけはマニュアルでインストールする必要があります。
sass のインストール ### yarn の場合 $ yarn add sass --dev ### npm の場合 $ npm install sass --save-dev 今まで .css 拡張子で作成していたファイルを、.scss に変更すれば、SCSS フォーマットでスタイル記述できます。
置換前: styles/global.css 置換後: styles/global.scss あとは、.css ファイルをインポートしている部分を、.scss に置換すれば導入完了です。
pages/_app.tsx import type { AppProps } from &amp;#39;next/app&amp;#39; import &amp;#39;../styles/global.scss&amp;#39; export default function MyApp({ Component, pageProps }: AppProps) { return &amp;lt;Component {...pageProps} /&amp;gt; } もちろん、CSS Modules の仕組み を使っている場合にも Sass を使うことができます。 その場合は、.</description></item><item><title>Next.js でコンポーネント内に直接 CSS を記述する (styled-jsx)</title><link>https://maku.blog/p/pbp2dpy/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/pbp2dpy/</guid><description>Next.js は CSS-in-JS ライブラリの一種である styled-jsx をデフォルトでサポートしています（styled-jsx も Next.js と同様に Vercel がメンテナンスしています）。 React コンポーネントの定義の中に、次のように CSS を直接記述することができます。
&amp;lt;style jsx&amp;gt;{` ... `}&amp;lt;/style&amp;gt; 下記は実際に styled-jsx を使って p 要素をスタイル設定した例です。
pages/sample.tsx export default () =&amp;gt; &amp;lt;&amp;gt; &amp;lt;p&amp;gt;only this paragraph will get the style&amp;lt;/p&amp;gt; &amp;lt;style jsx&amp;gt;{` p { color: red; } `}&amp;lt;/style&amp;gt; &amp;lt;/&amp;gt; ここで設定したスタイルのスコープは、この React コンポーネントに閉じたものになるため、他の React コンポーネントに影響を与えてしまう心配がありません。 そのため、シンプルなタグ名やクラス名でスタイル設定を行うことができます。
Next.js は、外部ファイルとして作成した .css や scss ファイルを読み込む CSS Modules の機能 もデフォルトでサポートしています（その場合は *.module.css というファイル名にするというルールがあります）。</description></item><item><title>Next.js で HelloWorld（プロジェクト作成からサーバー起動まで）</title><link>https://maku.blog/p/ubmu3bj/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ubmu3bj/</guid><description>Next.js とは Next.js は、React.js アプリ開発に必要なアレコレを詰め込んだパッケージです。 React.js を素の状態で導入すると、他にもいろいろなツールやライブラリを組み合わせていくことになるのですが、Next.js を使うとモダンな Web アプリ開発に必要なものが一気に揃えられます。
React.js は基本的に SPA（シングルページアプリ）を想定していますが、Next.js では複数ページによる構成や、サーバーサイドレンダリングなどをサポートしています。 これは、Next.js が単なる React.js 用のコンポーネントライブラリでないことを示しています。
Next.js には次のような特徴があります。
ゼロコンフィグ: 何も設定しなくても、最初から開発サーバーの立ち上げ、プロダクト用ビルドを行えるようになっています。これらは、最適なパフォーマンスが出るようメンテナンスが続けられています。カスタマイズしたいときも、複雑怪奇な webpack.config.js を作成する必要はなく、next.config.js による最小限の設定で済みます。できれば何も設定しないのが理想です。 SSR/SSG によるプリレンダリング: React.js はクライアントサイドで JavaScript を実行する CSR (Client Side Rendering) で動作しますが、Next.js は SSR (Server Side Rendering) や SSG (Static Site Generation) をサポートしています。これは、一般的な Node.js の API を利用してページを構築できることを意味します。開発元の Vercel は、パフォーマンスの面から SSG を推奨しています。 TypeScript をサポート: いまどきの Web アプリ開発では TypeScript はほぼ必須なので、標準サポートはうれしいです。空の tsconfig.js を置くだけで、TypeScript 対応は完了です（設定は自動で行われます）。 ファイルベースのルーティング: pages ディレクトリ以下の構成をそのままルーティング用のリンク名として使うことができます。例えば、pages/xxx/yyy.</description></item><item><title>Next.js のプロジェクトを TypeScript 化する</title><link>https://maku.blog/p/ny9fmty/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ny9fmty/</guid><description>何をするか？ create-next-app コマンドで Next.js プロジェクトを生成するときに --typescript (--ts) オプションをつけて実行すると、TypeScript 対応したプロジェクトを生成することができます。
$ npx create-next-app myapp --typescript # ただ、こっちのテンプレートを使う方法の方が若干洗練されてる気はする $ npx create-next-app myapp --example with-typescript また、Next.js は既存の JavaScript プロジェクトを TypeScript 化する機能も備えています。 ここから先は、その方法を説明します。
参考リンク Next.js で HelloWorld TypeScript 環境の導入 Next.js は、プロジェクトのルートに tsconfig.json ファイルがあると、自動的に TypeScript モードで動作するようになります。 次のようにして、空の tsconfig.json ファイルを作成し、TypeScript 用のパッケージをインストールします。
$ touch tsconfig.json $ npm install typescript @types/node @types/react --save-dev なんと、これだけで Next.js プロジェクトへの TypeScript 導入は完了です。 お手軽〜
自動生成される設定ファイルを見ておく 上記のステップで、TypeScript の設定ファイル (tsconfig.json) に何も記述していないことに気づいたかもしれません。 実は、Next.</description></item><item><title>Next.js アプリのソースコードを GitHub で管理する</title><link>https://maku.blog/p/xjw8it5/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjw8it5/</guid><description>Next.js のプロジェクトは、create-next-app コマンドで作成済みであるとします。
参考: Next.js で HelloWorld create-next-app コマンドで Next.js アプリを新規作成すると、アプリのトップディレクトリに、Git リポジトリ (.git/) が自動的に生成されます。 git log コマンドを実行すると、初回のコミットがすでに生成されていることがわかります。
$ git log commit 4607ecdd2f3f9f3d0d4c86442463c3b86856e88a (HEAD -&amp;gt; main) Author: maku &amp;lt;maku@example.com&amp;gt; Date: Sun Apr 18 23:28:22 2021 +0900 Initial commit from Create Next App この Next.js アプリを GitHub で管理したいときは、以下の手順で GitHub リポジトリと結びつけます。
GitHub 上に 新規リポジトリを追加 します リポジトリ名は create-next-app で指定したアプリ名と合わせましょう。 Initialize this repository with: の項目では、README.txt の作成にはチェックを入れないでください。リポジトリファイル (.git) はすでに create-next-app によって生成されているので、GitHub 側のリポジトリは空の状態で作成する必要があります。 既存の Next.</description></item><item><title>Next.js アプリを GitHub Actions でビルドして GitHub Pages で公開する</title><link>https://maku.blog/p/au8ju6g/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/au8ju6g/</guid><description>何をするか？ ここでは、Next.js アプリを次のような構成でホスティング（Web サイトとして公開）できるようにします。
create-next-app で作成した Next.js アプリのコードを GitHub で管理する main ブランチにプッシュ（マージ）したら GitHub Actions で下記を実行 Next.js アプリをビルド (npm run build, npm run export) GitHub Pages にデプロイ つまり、この設定が終わると、GitHub に Next.js アプリのコードをプッシュするだけで、自動的にビルドされて、Web サイトに反映されるようになります。
GitHub リポジトリの準備 空の GitHub リポジトリを作成し、そこに create-next-app で作成した Next.js アプリをプッシュします。 リポジトリ名は、最終的な Web サイトのアドレスをどうしたいかで、次のように作り分けます。
ユーザーサイト（あるいは Organization サイト） 公開 URL: https://&amp;lt;username&amp;gt;.github.io/ 作成するリポジトリ名: &amp;lt;username&amp;gt;.github.io プロジェクトサイト 公開 URL: https://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository&amp;gt;/ 作成するリポジトリ名: &amp;lt;repository&amp;gt; ここでは、プロジェクトサイトとして myapp というリポジトリを作成した場合の例で説明していきます。</description></item><item><title>Next.js アプリを Vercel で公開する</title><link>https://maku.blog/p/j6ht5fq/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/j6ht5fq/</guid><description>Vercel とは？ Vercel は Next.js を開発している企業であり、同名の Vercel というサービスを提供しています。
Vercel - Develop. Preview. Ship. For the best frontend teams Vercel サービスは Next.js アプリのホスティングに特化しており、GitHub などのリポジトリと連携させることにより、ビルドから Next.js サーバーによるホスティングまでを簡単に自動化することができます（実際には、Vercel サービスは、Next.js 以外で作成した Web サイト、例えば、Hugo で作成したブログなどのホスティングにも対応しています）。
Next.js アプリで SSR (Server-side Rendering) や API ルートなどの機能を使用している場合は、Next.js サーバー上で Web サイトをホスティングする必要があるのですが、現状そのような環境をサーバーレスなサービスとして提供しているのは Vercel のみです（一応 Serverless Next.js という AWS Lambda で動かすものもあったりしますが）。
Next.js の開発サーバー (next dev) で何らかのアプリをローカルで動かせているのであれば、Vercel を使って、ほぼそのままの形でネット上に公開することができます。 小規模な Web サイトであれば無料で動かせますし、とっても簡単なので、一度試してみるとよいです。
Vercel で Next.js アプリを公開する ここでは、GitHub にプッシュした Next.js アプリを Vercel を使って公開してみます。 まずは、下記を参考にして、GitHub に何らかの Next.</description></item><item><title>Vercel のウェブサイトに独自ドメインを割り当てる</title><link>https://maku.blog/p/9vakw8i/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9vakw8i/</guid><description>Vercel で公開している Web サイトに、お名前.com で取得した独自ドメインを割り当てる方法を説明します。 Vercel 上での Next.js アプリ公開までの手順は、下記の記事を参考にしてください。
参考: Next.js アプリを Vercel で公開する ここでは、独自ドメインを「お名前.com」で取得済みだと仮定しますが、別のレジストラで取得している場合もほぼ同様に設定できるはずです。 大きく分けて、次の 2 種類の設定方法があります。
Vercel の DNS サーバーを使う方法 Vercel 以外の DNS サーバーを使う方法 独自ドメインの「レジストラ」と「DNS サーバー」の関係については、下記の記事で簡単にまとめていますので参考にしてください。 後述の設定で何をしているのかが分かりやすくなると思います。
参考リンク ドメイン管理と DNS 管理の違いを理解する Vercel の DNS サーバーを使う方法 お名前.com などのレジストラで独自ドメインを取得すると、そのドメインをどの DNS サーバーで運用するかという設定を行えるはずです。 次のように Vercel 側の DNS サーバー設定を行うと、お名前.com 側に設定すべき DNS サーバー名を確認できます。
(1) Vercel のサイト から対象アプリのページを開き、Settings → Domains と選択し、取得済みの独自ドメイン名を入力して Add ボタンを押してください。ここでは、例として example.com というドメインを管理するとします（ドメイン自体は「お名前.com」で取得したものです）。
図: Vercel に独自ドメインを設定する (2) example.</description></item><item><title>ESLint (4) ESLint の設定方法まとめ (for Next.js 11)</title><link>https://maku.blog/p/dexgg8o/</link><pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/dexgg8o/</guid><description>Next.js 11 が ESLint を組み込みサポート Next.js 11 で ESLint を Next.js が組み込みでサポートしました。 これで、create-next-app で新規作成するアプリでは、ESLint に関してもゼロコンフィグで next eslint とするだけで実行できるようになります。
ただ、ESLint には色々な共有設定 (config) があるわけで、Next.js がデフォルトで設定してくれているもの以外（TypeScript や Prettier 関連）は自分で設定する必要があります。 ここでは、Next.js 11 がデフォルトで提供する .eslintrc にそれらの設定を追加します。
Next.js 11 デフォルトの ESLint 設定 Next.js 11 が生成する .eslintrc ファイルは次のようなシンプルなものです。
.eslintrc { &amp;#34;extends&amp;#34;: [&amp;#34;next&amp;#34;, &amp;#34;next/core-web-vitals&amp;#34;] } 問題はこれらがどのような共有設定を含んでいるかですが、eslint-config-next のコードを見ると、次のような感じになっています。
module.exports = { extends: [ &amp;#39;plugin:react/recommended&amp;#39;, &amp;#39;plugin:react-hooks/recommended&amp;#39;, &amp;#39;plugin:@next/next/recommended&amp;#39;, ], // ... } React 系の共有設定はここに含まれているので、&amp;quot;extends&amp;quot;: [&amp;quot;next&amp;quot;] だけでカバーできそうです。 公式ドキュメントの ESLint - Base Configuration にも同様の説明が書かれています。 逆に、TypeScript 関連や、Prettier 関連の共有設定は自分で追加しなければいけません。</description></item><item><title>Next.js アプリに Google Analytics を設定する (next/script)</title><link>https://maku.blog/p/zycmw6f/</link><pubDate>Tue, 21 Mar 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/zycmw6f/</guid><description>何をするか？ Google Analytics で Web サイトのアクセス解析を行うには、次のような感じのコードを各ページに埋め込む必要があります。
Google Analytics 用の埋め込みコード &amp;lt;!-- Google tag (gtag.js) --&amp;gt; &amp;lt;script async src=&amp;#34;https://www.googletagmanager.com/gtag/js?id=G-ABCDE12345&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(&amp;#39;js&amp;#39;, new Date()); gtag(&amp;#39;config&amp;#39;, &amp;#39;G-ABCDE12345&amp;#39;); &amp;lt;/script&amp;gt; ここでは、Next.js が提供する Script コンポーネント (next/script) を使用して、Next.js アプリに同等のコードを埋め込む方法を説明します。 HTML 標準の script ではなく、Next.js の Script コンポーネントを使用することで、Next.js アプリのレンダリング処理に合わせて実行タイミングを最適化できます。
事前準備（Google Analitics でプロパティとデータストリームを追加する） 事前準備として、Google Analytics のサイトで、サイドバーの 管理 メニューから対象アプリ用に プロパティ を追加しておいてください。 さらに、そのプロパティに対して データストリーム を追加すると、Web サイトや Android アプリの利用状況を監視できるようになります。
図: プロパティにデータストリームを追加する データストリームを追加すると、次のように 測定 ID が発行されます。 これが、前述の JavaScript コードで指定する ID になります。</description></item><item><title>Next.js でローカル開発時 (next dev) のみ有効なデバッグページを作成する (getStaticProps)</title><link>https://maku.blog/p/3vbr2bm/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/3vbr2bm/</guid><description>何をするか？ Next.js アプリを作っていると、開発中にだけ表示したいデバッグ用のページを作りたくなることがよくあります。 ここでは、ローカルサーバー (next dev) での開発中のみ有効になるデバッグページの作り方を説明します。
デバッグページの作成 Next.js の各ページのビルド時には、必要に応じてデータフェッチなどを行うための getStaticProps 関数が呼び出されます（参考: Next.js のプリレンダリング機能を使用する (getStaticProps)）。
この関数の戻り値として、notFound プロパティ を true にしたオブジェクトを返すと、そのページがないものとして扱うことができます（404 Not Found になる）。
export const getStaticProps: GetStaticProps = () =&amp;gt; { // ... return { // Return the default 404 page with a status code of 404. notFound: true } } この仕組みを利用して次のように実装すれば、ローカルサーバーでの開発中のみ表示可能なデバッグページを作ることができます。 ローカルサーバー (next dev) で実行されているかどうかは、環境変数 process.env.NODE_ENV の値で判断できます（参考: Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV)）。
src/pages/debug/info.tsx import { GetStaticProps, NextPage } from &amp;#39;next&amp;#39; type EmptyProps = { [key: string]: never } /** * デバッグページのビルド時の前処理。 * 開発サーバー (next dev) での実行時のみ、このページが存在するようにします。 * 本番サーバー (next start) での実行時は、404 Not Found になります。 */ export const getStaticProps: GetStaticProps&amp;lt;EmptyProps&amp;gt; = () =&amp;gt; { const isLocalDev = process.</description></item><item><title>Next.js でブラウザ履歴で戻るボタンを表示する (router.back)</title><link>https://maku.blog/p/m4dmu4c/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m4dmu4c/</guid><description>Next.js の next/router モジュールが提供する NextRouter オブジェクトの back メソッド を呼び出すと、ブラウザの履歴に従って 1 つ前のページに遷移することができます。 つまり、ブラウザの「戻る」ボタンを押した場合と同じ振る舞いをします。 NextRouter オブジェクトは、useRouter フックで取得することができます。
次の BackButton コンポーネントはシンプルな「戻る」ボタンを表示し、クリック時に NextRouter#back() を呼び出します。
図: 戻るボタン（標準の button 版） components/BackButton.tsx import { FC } from &amp;#39;react&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; export const BackButton: FC = () =&amp;gt; { const router = useRouter() return ( &amp;lt;button alia-label=&amp;#34;戻る&amp;#34; type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; router.back()}&amp;gt; 戻る &amp;lt;/button&amp;gt; ) } 上の例では、素の button コンポーネントを使っていますが、mui (Material-UI) などの UI ライブラリを使えばリッチなボタンを表示できます。</description></item><item><title>Next.js で Firebase: Cloud Firestore データベースを使う</title><link>https://maku.blog/p/m3bjrz7/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m3bjrz7/</guid><description>何をするか Cloud Firestore は、Firebase サービス（あるいは GCP）が提供するサーバーレスな NoSQL データベースです。 Firestore データベースには様々な環境からアクセスできますが、ここでは Web サイトからアクセスすることを想定して、Firebase が提供する JavaScript SDK（クライアントサイド SDK）を使って Firestore データベースを操作してみます。
☝️ Firebase と GCP の使い分け Firebase と GCP (Google Cloud Platform) の両方に Firestore の記載があるので混乱しますが、どちらのプロジェクトで作った Firestore データベースも内部的には共有されているようです。 Firebase プロジェクトも、GCP プロジェクトとして参照できるようになっています。 一方で、SDK は共通化されておらず、主に Firebase はクライアントサイド用の SDK を提供し、GCP はサーバーサイド用の SDK を提供しています。 前提条件として、Firebase プロジェクトの作成は完了し、FirebaseApp インスタンスの初期化コードは準備できているものとします。
参考: Next.js で Firebase: プロジェクトの作成と接続準備 Firestore データベースの作成 クライアントアプリの実装を始める前に、Firebase プロジェクトに Firestore データベースを作成します。
Firebase コンソール にサインインして、対象のプロジェクトを開く。 サイドバーから Firestore Database を選択し、データベースの作成 をクリックする。 保護ルールは 本番環境モード を選んでおけば OK ロケーションは asia-northeast1（東京）を選んでおけば OK 次のように空っぽのデータベースが作成されれば準備 OK です。</description></item><item><title>Next.js で Firebase: Authentication 機能でユーザー認証できるようにする</title><link>https://maku.blog/p/8t6gq2b/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/8t6gq2b/</guid><description>何をするか？ Firebase の Authentication 機能 を使用すると、ウェブアプリ（やモバイルアプリ）にユーザー認証機能を付けて、各種リソースへのアクセスを制御できるようになります。 例えば、「Firestore に格納されているユーザー情報の編集は、そのユーザーにのみ許可する」といったことができます。 Firebase のクライアントアプリでユーザーデータを扱う場合は、Firebase Authentication はほぼ必須の機能だといえます。
ここでは、Next.js (React) アプリで Firebase Authentication を使い、ユーザー認証を行えるようにしてみます。 ユーザー認証に使う UI は、Firebase が用意している FirebaseUI を使って表示します。
事前準備として、Firebase プロジェクトの作成は済んでおり、Next.js アプリから各種 Firestore 関連インスタンスを取得できるようになっていると想定します。
参考: Next.js で Firebase: プロジェクトの作成と接続準備 ログインプロバイダの設定 Firebase Authentication では、サインイン方法として、新規に登録するメールアドレスや電話番号を使う方法（ネイティブプロバイダ）と、既存の Google アカウントや Facebook アカウントなどを使う方法（追加のプロバイダ）が準備されています。 まずは、シンプルに「メールアドレス」でユーザー登録できるようにしてみます。
Firebase コンソール の Authentication タブを選択して機能を有効化する。
ログインプロバイダ (Sign-in method) で メール／パスワード を選択する。
有効にする にチェックを入れて 保存 をクリック。
これで、Firebase Authentication で「メールアドレス」による認証を行えるようになります。</description></item><item><title>Next.js で Firebase: プロジェクトの作成と接続準備</title><link>https://maku.blog/p/73eq2cm/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/73eq2cm/</guid><description>何をするか？ ここでは、Firebase を Next.js (React) ウェブアプリから使用するための準備 として、「Firebase プロジェクトの作成」「Next.js アプリの作成」「FirebaseApp インスタンスの初期化」までを行います。 なお、ここでは Firebase JS SDK ver.9 以降を対象とします（ver.8 以前は初期化方法が若干異なります）。
Firebase サービスを使うと、Web アプリやモバイルアプリに必要なバックエンド環境を簡単に整えることができます。 例えば、Firebase は次のような機能を提供しており、小規模のアプリであれば無料の Spark プランで動かすことができます（参考: Firebase の料金プラン）。
Firebase Authentication &amp;hellip; ユーザー管理と認証（ログイン UI もある） Firebase Hosting &amp;hellip; Web アプリのホスティング（独自ドメインにも対応） Cloud Firestore &amp;hellip; NoSQL データベース Cloud Function &amp;hellip; サーバレス関数 Cloud Storage for Firebase &amp;hellip; ファイル管理 Web アプリから上記のような機能にアクセスするには、まずは FirebaseApp インスタンスの設定（初期化）が必要になります。 以下では、Next.js アプリから各種 Firebase インスタンスにアクセスするところまでの準備を行います。
Firebase プロジェクトの作成 Firebase コンソールにサインイン して、Firebase のプロジェクトを作成します。 プロジェクト名は、自分の Google アカウント内で一意の名前になっていれば OK です。 例えば、MyApp のような名前を付けて作成してください。 Google アナリティクスは有効にしなくても OK です。</description></item><item><title>Next.js で useState とローカルストレージ (localStorage) を連動させる</title><link>https://maku.blog/p/cwdyhec/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cwdyhec/</guid><description>何をするか？ React (Next.js) の useState フックは、Web ページの状態を保持するものですが、ページのリロードや、ブラウザの再起動を行うと、その状態はリセットされてしまいます。
一方、Web ブラウザに搭載されている localStorage や sessionStorage を使用すると、キー＆バリュー（両方とも文字列のみ）の形でデータを保存することができます。
ここでは、これらを一緒に使うことで、useState で管理している状態をローカルストレージに保存・復帰できるようにしてみます。
使い方のイメージ 例えば、Web サイト上でダークモードの On/Off を行うスイッチがあるとして、その状態をローカルストレージに保存できるようにしたいとします。
図: ダークモード切り替えのイメージ ダークモードの状態は useDarkMode のようなカスタムフックを作成して、次のように扱えると便利です。
src/pages/sample.tsx import { NextPage } from &amp;#39;next&amp;#39; import { useDarkMode } from &amp;#39;../hooks/useDarkMode&amp;#39; const SamplePage: NextPage = () =&amp;gt; { // 一見 useState と同様だが localStorage と連動している const [isDark, setDark] = useDarkMode(false) return ( &amp;lt;div style={{ width: &amp;#39;100vw&amp;#39;, height: &amp;#39;100vh&amp;#39;, color: isDark ? &amp;#39;white&amp;#39; : &amp;#39;black&amp;#39;, background: isDark ?</description></item><item><title>Next.js で開発環境で実行しているときに Web サイト上に dev 表示する (TargetEnvIndicator)</title><link>https://maku.blog/p/d4p4fr4/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/d4p4fr4/</guid><description>何をするか？ Next.js (React) などで Web サイトの開発を行うとき、その開発フェーズに応じて、開発環境 (dev)、ステージング環境 (stg)、本番環境 (prod) などを分けてリリースしていくことが多いと思います。 このとき、ブラウザ上でどのフェーズのサイトを表示しているのかが分かるように、画面上に dev 環境 のようなインジケーターを表示すると便利です（上図）。
ここでは、環境変数 NEXT_PUBLIC_TARGET_ENV の値が prod 以外のときに、上記のような表示をすることにします。
参考: Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV) 実装例 次のコンポーネント TargetEnvIndicator は、画面右下に環境名（例: dev 環境）を表示します。
components/common/TargetEnvIndicator.tsx import { FC } from &amp;#39;react&amp;#39; /** * ビルド時のターゲット環境が `prod` 以外のときに、画面右下に環境名を表示します。 */ export const TargetEnvIndicator: FC = () =&amp;gt; { const target = process.env.NEXT_PUBLIC_TARGET_ENV ?? &amp;#39;dev&amp;#39; // 本番環境 (prod) の場合は何も表示しない if (target === &amp;#39;prod&amp;#39;) return null return ( &amp;lt;div style={{ position: &amp;#39;fixed&amp;#39;, right: 10, bottom: 10, padding: &amp;#39;0.</description></item><item><title>Next.js で src からの相対パスで import できるようにする (tsconfig.json)</title><link>https://maku.blog/p/qgvamzc/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/qgvamzc/</guid><description>何をするか？ Next.js (TypeScript) のプロジェクトで、src ディレクトリ以下の階層構造が深くなってくると、別のディレクトリのモジュールをインポートするときの相対パスがわかりにくくなってきます。
import { sleep } from &amp;#39;../../../../../utils/timeUtil&amp;#39; このような場合は、次に説明するような tsconfig.json の設定をしておくと、シンプルなパスでインポートできるようになります。
compilerOptions.paths プロパティ (module alias) tsconfig.json の compilerOptions.paths プロパティ（と baseUrl プロパティ）を設定すると、特定のパスに配置されたモジュール（.ts ファイル）を、エイリアス名（ここでは @）を使って参照できるようになります。
tsconfig.json { &amp;#34;compilerOptions&amp;#34;: { // ... &amp;#34;baseUrl&amp;#34;: &amp;#34;.&amp;#34;, &amp;#34;paths&amp;#34;: { &amp;#34;@/*&amp;#34;: [&amp;#34;./src/*&amp;#34;] } } } 上記のように設定すると、プロジェクトルートの src ディレクトリ以下のモジュールを、どの階層にあるコードからでも、@/moduleName という名前で参照できるようになります。 例えば、src/utils/timeUtil.ts というモジュールをインポートするとき、これまでは、次のようにカレントディレクトリからの相対パスで指定しなければいけなかったところを、
import { sleep } from &amp;#39;../../../../../utils/timeUtil&amp;#39; 次のように src ディレクトリを示すエイリアス名 @ を使って指定できるようになります。
import { sleep } from &amp;#39;@/utils/timeUtil&amp;#39; ☝️ ワンポイント 上記のようなエイリアス名を使った場合でも正しくモジュールを参照できるのは、Next.</description></item><item><title>Next.js のページコンポーネントが Client と Server どちらで実行されているか調べる (isServer, isClient, NoSsr)</title><link>https://maku.blog/p/m7is4dn/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/m7is4dn/</guid><description>Next.js のページコンポネント (src/pages/*.tsx) の関数は、静的な HTML ファイルを生成するためにビルド時にも実行されます（参考: Next.js のプリレンダリング機能を使用する）。 従来の React による SPA アプリはクライアントサイド JavaScript でしか実行されないので、同じような感覚で実装していると振る舞いの違いでハマることがあります。 例えば、ページコンポーネントから次のように window オブジェクトを参照しようとすると、Next.js によるプリレンダリング時にエラーになります。 これは、window オブジェクトは、Web ブラウザ上で JavaScript を実行しているときにしか存在しないからです。
src/pages/hello.tsx import { FC } from &amp;#39;react&amp;#39; const HelloPage: FC = () =&amp;gt; { console.log(window.location) // ReferenceError: window is not defined return &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; } 逆に言うと、実行時に window オブジェクトが存在しているかどうかを調べることによって、ページコンポーネント内のコードが、どのタイミングで実行されているかを判別できます。
const isClient = () =&amp;gt; typeof window !== &amp;#39;undefined&amp;#39; // const isServer = () =&amp;gt; typeof window === &amp;#39;undefined&amp;#39; const HelloPage: FC = () =&amp;gt; { if (isClient()) { console.</description></item><item><title>Next.js アプリでのリンク方法まとめ（mui/Material-UI との連携なども） (next/link, next/router)</title><link>https://maku.blog/p/vgs4dnw/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vgs4dnw/</guid><description>アプリ内ページへのリンク（基本） // import Link from &amp;#39;next/link&amp;#39; &amp;lt;Link href=&amp;#34;/about&amp;#34;&amp;gt;About us&amp;lt;/Link&amp;gt; Next.js でアプリ内部で閉じるページリンクを張るには、next/link モジュールを使用します。 上記のようにすると、pages/about.tsx ページコンポーネントが生成するページへのリンクになります。
☝️ a 要素は必要ない Next.js 12 以前は Link 要素の下に明示的に a 要素を配置する必要がありました。 これは、HTML 的に正しく a 要素を配置するためでしたが、Next.js 13 では自動的に a 要素を挿入するようになったので、a 要素の記述は必要ありません。 遷移前の履歴を置き換える replace オプション &amp;lt;Link href=&amp;#34;/about&amp;#34; replace&amp;gt; 上記のように replace オプションを指定すると、ページ遷移前の URL がブラウザの履歴に残りません（戻るキーで戻らなくなります）。
外部リンク https:// で始まる外部リンクを出力したい場合は、&amp;lt;a&amp;gt; コンポーネントをそのまま使用します。 next/link（や react-router) が提供する Link コンポーネントは、アプリ内のルーティング用なので使えません。 外部リンクを開く場合は、安全性のために一律で rel=&amp;quot;noopener noreferrer&amp;quot; を付けましょう。 リンククリック時に必ず別タブで開きたいときは、target=&amp;quot;_blank&amp;quot; を指定してください。
&amp;lt;a href=&amp;#34;https://example.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt; Website title &amp;lt;/a&amp;gt; mui (Material-UI) を採用したサイトの場合は、a の代わりに mui が提供する Link コンポーネントを使用することで、サイト内のデザインを統一することができます。 next/link が提供する Link コンポーネントと混同しないように、次のように別名 (MuiLink) を付けて使用すると分かりやすくなります。</description></item><item><title>Next.js の public 以下のファイルのパスを正しく扱う</title><link>https://maku.blog/p/xjjbwes/</link><pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/xjjbwes/</guid><description>Next.js アプリでは、/public ディレクトリ以下に配置した静的リソースファイル（画像ファイルなど）は、次のような感じで URL のドメイン直下に配置されたファイルとして参照できるようになります。
// import Image from &amp;#39;next/image&amp;#39; &amp;lt;Image src=&amp;#34;/me.png&amp;#34; alt=&amp;#34;Picture of the author&amp;#34; width={500} height={500} /&amp;gt; 仮に、作成した Web サイトを GitHub Pages の「プロジェクトサイト」として公開する場合は、https://username.github.io/reponame/ のように一階層深い URL パスがアプリのルートになりますが、next.config.js で次のようにベースパスを設定しておけば、Next.js の Image コンポーネントは正しいパス (/reponame/me.png) に補正して画像ファイルを参照してくれます。
next.config.js const urlPrefix = &amp;#39;/reponame&amp;#39; module.exports = { // ... assetPrefix: urlPrefix, basePath: urlPrefix, trailingSlash: true, } 参考: Next.js アプリを GitHub Actions でビルドして GitHub Pages で公開する 一方で、Next.js が提供する Image コンポーネントなどを使わず、img 要素をそのまま使った場合、このような URL プレフィックスの付加は自動では行われず、画像が参照できなくなるという問題が発生します。</description></item><item><title>Next.js アプリのディレクトリ構成を考える（Atomic Design と Presentational and Container Components）</title><link>https://maku.blog/p/4is2ahp/</link><pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/4is2ahp/</guid><description>Web サイトを構築するにあたって、よく参照されるコンポーネントの分類手法として、Atomic Design と Presetational and Container Components があります。
Atomic Design &amp;hellip; UI の粒度と具体性によって 5 レベルに分類する Presentational and Container Components &amp;hellip; 「表示」と「振る舞い」の役割で分類する ここでは、それぞれに関して概要をざっと眺めた上で、Next.js プロジェクトにどんな形で適用していけばいいかを考えてみます。
Atomic Design とは Web デザインにおける UI コンポーネントの分割粒度の考え方として、Brad Frost 氏の Atomic Design があります。
Atomic Design - Brad Frost 氏のブログ記事 Atomic Design - 書籍版（Webで読めます） Atomic Design では、UI コンポーネントを粒度の小さい順に次のように分類します。
図: Atomic Design の 5 つのレベル（Brad Frost 氏のブログより） Atoms（原子） &amp;hellip; これ以上分割できない単位（例: ラベル、入力、ボタン） Molecules（分子） &amp;hellip; 意味のある UI パーツ単位 （例: 検索フォーム (ラベル + 入力 + ボタン)） Organisms（有機体、生物） &amp;hellip; ページの一部分を構成する。Molecules をどう組み合わせるべきかという、アプリドメインの知識が入ってくる。 Templates（テンプレート） &amp;hellip; ページ全体のレイアウト。最初はプレースホルダーだらけかもしれないが、徐々に具体的な Organisms が配置されて最終形態に近づいていく。 Pages（ページ） &amp;hellip; Templates に具体的なデータを入れたもの（特定のページ）。 よく Organisms の扱いで迷うようですが、汎用性の側面から次のような感じで分類すると、プロジェクト内でコンポーネントを整理しやすくなります。 Pages に関しては、Templates に対してデータを流し込んだものなので、ここでは省略しています。</description></item><item><title>Next.js でハッシュフラグメントを扱う（useHash カスタムフック）</title><link>https://maku.blog/p/k2ahpw5/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k2ahpw5/</guid><description>ハッシュフラグメントとは URL のハッシュフラグメントというのは、下記のような URL の末尾の # 以降の部分を指します。
https://examle.com/sample#AAA 似たようなものにクエリパラメーター（?key=val のみたいなの）もありますが、ハッシュフラグメントは HTTP リクエスト時に、その文字列（上記の例では AAA）がサーバーに送られないという違いがあります。 つまり、ハッシュフラグメントの値は、クライアントサイドで使用することが意図されています。
useHash フックの実装 下記の useHash 関数は、Next.js でハッシュフラグメントを簡単に扱えるようにするカスタムフックの例です。 useState フックと同じ感覚で使えるように、ハッシュフラグメントの現在値と、設定用の関数をペアで返します。
src/libs/useHash.ts import { useCallback } from &amp;#39;react&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; /** * URL のハッシュフラグメント部分を扱うためのフックです。 * * 次のようにすると、`hash` 変数に URL の `#` 以降の値が格納されます。 * URL の `#` 以降の値を変更したいときは、`setHash` 関数を使用します。 * * ``` * const [hash, setHash] = useHash() * ``` */ export function useHash(): [string, (newHash: string) =&amp;gt; void] { const router = useRouter() const hash = extractHash(router.</description></item><item><title>Next.js で環境変数を扱う (.env, NEXT_PUBLIC, NODE_ENV)</title><link>https://maku.blog/p/gbpeyov/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/gbpeyov/</guid><description>Next.js アプリ内での環境変数の振る舞い process.env の振る舞い Node.js の process.env による環境変数の参照が有効なのは、基本的には次のようなサーバーサイドで実行されるコード内のみです。
ビルド時あるいはアクセス時に呼び出される getStaticPaths や getStaticProps 必ずアクセス時に呼び出される getServerSideProps 必ずアクセス時に呼び出される API ルートのハンドラ関数 (handler) src/pages/sample.tsx export const getStaticProps: GetStaticProps&amp;lt;PageProps&amp;gt; = async context =&amp;gt; { // このコードはビルド時に実行されるので環境変数を参照できる console.log(process.env.VAR_NAME) return { props: {} } } NEXT_PUBLIC プレフィックス ただし、例外として、NEXT_PUBLIC_ で始まる環境変数を process.env.NEXT_PUBLIC_XXX のように参照すると、next build によるビルド時に変数値がインライン展開されるので、クライアントサイドで実行されるコード（コンポーネントの実装内）から参照できます。
src/pages/sample.tsx const SamplePage: FC = () =&amp;gt; { return &amp;lt;&amp;gt; &amp;lt;p&amp;gt;Public env: {process.env.NEXT_PUBLIC_ANALYTICS_ID}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Private env: {process.env.API_SECRET_KEY} （必ず空っぽ）&amp;lt;/p&amp;gt; &amp;lt;/&amp;gt; } 上記のようにすると、process.env.NEXT_PUBLIC_ANALYTICS_ID の部分には、ビルド時の環境変数 NEXT_PUBLIC_ANALYTICS_ID の値がそこに埋め込まれ、process.</description></item><item><title>Next.js のコンポーネント内でクエリ文字列を取得する (next/router, useRouter)</title><link>https://maku.blog/p/r7fou3a/</link><pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/r7fou3a/</guid><description>クエリ文字列とは https://example.com/todos?sortby=title&amp;amp;order=asc URL のクエリ文字列（クエリパラメーター）というのは、上記のような URL の末尾の ? 以降の、sortby=title&amp;amp;order=asc の部分のことを指します。 この部分を参照する方法としては、主に次の 2 種類の方法があります。
クライアントサイド JS &amp;hellip; useRouter フックを使う サーバーサイド JS &amp;hellip; getServerSideProps に渡されるパラメーターを使う クライアントサイド JS からクエリパラメーターを参照する (router.query) Next.js の useRouter フック を使うと、上記のようなクエリパラメーター部分を簡単に抽出することができます。 次の例では、クエリパラメーターとして渡された sortby と order の値を取得しています。 値が省略された場合は、それぞれの値は undefined になります。
src/pages/todos.tsx import { NextPage } from &amp;#39;next&amp;#39; import { useRouter } from &amp;#39;next/router&amp;#39; const TodosPage: NextPage = () =&amp;gt; { const router = useRouter() const { sortby, order } = router.</description></item><item><title>MUI コンポーネント (v4) に独自のスタイルを設定する (makeStyles)</title><link>https://maku.blog/p/cw9ju6f/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cw9ju6f/</guid><description>この記事では、MUI v4 以前の makeStyles() 関数を使ったカスタムスタイル設定方法を説明しています。 MUI v5 以降のカスタムスタイル設定では sx prop や styled() 関数を使用しますので、下記の記事を参照してください。
参考: MUI コンポーネントに独自のスタイルを設定する（v5 以降の sx prop、styled 関数を使う方法） Material-UI コンポーネントのスタイル設定 Material-UI が提供する各種コンポーネントには、表示スタイルを切り替えるためのプロパティが用意されています。 例えば、Button コンポーネント は variant や color プロパティで見た目を切り替えることができます。
&amp;lt;Button&amp;gt;Default&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;contained&amp;#34; color=&amp;#34;primary&amp;#34;&amp;gt;Primary&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;contained&amp;#34; color=&amp;#34;secondary&amp;#34;&amp;gt;Secondary&amp;lt;/Button&amp;gt; &amp;lt;Button variant=&amp;#34;outlined&amp;#34; disabled&amp;gt;Disabled&amp;lt;/Button&amp;gt; 多くのケースでは、この仕組みで十分にスタイル設定できるのですが、デフォルトのスタイルから外れた表示をしたり、div 要素など Material-UI 以外のコンポーネントに対して独自の CSS を適用したいことがあります。 このような場合、コンポーネントの実装ファイル内に直接 CSS コードを記述してスタイルをカスタマイズできます（JavaScript 内に記述するので CSS-in-JS と呼びます）。 React の世界では色々な CSS 参照方法がありますが、Material-UI は次のような理由で CSS-in-JS な記述方法を採用しています。
現在のテーマ設定に基づいたスタイル設定を行える（例: 基準スペースの2倍のマージンを設定する） コンポーネントの props の値を使って動的にスタイル設定できる（例: &amp;lt;MyButton color=&amp;quot;vivid&amp;quot;&amp;gt; で派手な色のスタイルを設定する） フックによるスタイル設定 (makeStyle) Material-UI で、コンポーネントに独自スタイルを設定する方法としては、主に次の 3 種類の方法が用意されています。</description></item><item><title>Next.js で Material-UI を使う</title><link>https://maku.blog/p/s6djqw3/</link><pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/s6djqw3/</guid><description>Material-UI は、マテリアルデザインを提供する React コンポーネントライブラリです。
Material-UI のインストール Material-UI のコアパッケージ (@material-ui/core) は、npm コマンドで簡単にインストールできます。 マテリアルデザイン系のアイコン を使いたい場合は、@material-ui/icons パッケージもインストールしておきます。
### yarn の場合 $ yarn add @material-ui/core $ yarn add @material-ui/icons ### npm の場合 $ npm install @material-ui/core $ npm install @material-ui/icons Next.js の create-next-app コマンドでプロジェクトを作成済みであれば、これだけで Material-UI コンポーネントを使う準備は完了です。 Material-UI のデフォルトテーマは Roboto フォントを使用する ので、次のようなコードを head 要素内に記述する必要がありますが、これは後述の _document.tsx で設定します。
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;amp;display=swap&amp;#34; /&amp;gt; Material-UI は font weight に 300/400/500/700 のいずれかを使用するので、上記のように読み込むデータを制限することで、ロード時間を削減できます。
Material-UI のコンポーネントを使ってみる Material-UI のインストールができたら、あとは、各コンポーネントの実装ファイルから import するだけで使用できます。 次の例では、Button コンポーネントと、ButtonGroup コンポーネントを使っています。</description></item><item><title>Next.js で Bootstrap と React Bootstrap を使う</title><link>https://maku.blog/p/k8mxakw/</link><pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/k8mxakw/</guid><description>何をするか？ Next.js アプリから、CSS フレームワークの Bootstrap を使えるようにする方法を説明します。
Bootstrap を導入 各コンポーネントの実装で、Bootstrap の CSS クラスを参照できるようにします React Bootstrap を導入 Bootstrap を React コンポーネントの形で使えるようにします Bootstrap を導入する bootstrap モジュールをインストールする方法 Bootstrap は npm install で簡単にインストールできます。
$ npm install bootstrap@next --save あとは、次のような pages/_app.tsx ファイルを作成して、グローバル CSS としてインポートすれば OK です。
pages/_app.tsx import type { AppProps } from &amp;#39;next/app&amp;#39; import &amp;#39;bootstrap/dist/css/bootstrap.min.css&amp;#39; export default function MyApp({ Component, pageProps }: AppProps) { return &amp;lt;Component {.</description></item><item><title>Next.js でサーバーサイドで JSON や YAML ファイルを読み込む (fs.readFileSync)</title><link>https://maku.blog/p/iz8fnu3/</link><pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/iz8fnu3/</guid><description>何をするか？ Next.js アプリのページコンポーネントの getStaticProps / getServerSideProps 関数や、API ルート (pages/api/*.ts) の handler 関数は、クライアントからのアクセス時やビルド時に、サーバーサイドで呼び出されます。 つまり、これらの関数の中では、Node.js の fs モジュールを使った（サーバー上の）ローカルファイルの読み込みが可能です。
ここでは、例として、
ページコンポーネントの getStaticProps 関数から JSON ファイルを読み込む方法 API ルートの handler 関数から YAML ファイルを読み込む方法 を紹介します。
JSON ファイルを読み込む（in getStaticProps 関数） 使用する JSON ファイル サンプルデータとして次のような JSON ファイルをプロジェクト内に配置します。
src/data/games.json [ { &amp;#34;id&amp;#34;: &amp;#34;dq1&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;dq2&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト2&amp;#34; }, { &amp;#34;id&amp;#34;: &amp;#34;dq3&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;ドラゴンクエスト3&amp;#34; } ] JSON ファイルを読み込む 次のコードでは、getStaticProps 関数の中で src/data/games.json ファイルを読み込んで、ページコンポーネントに渡す props データを作成しています。</description></item><item><title>Next.js の Image コンポーネントで画像を表示する (next/image)</title><link>https://maku.blog/p/fw7gpx7/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/fw7gpx7/</guid><description>Image コンポーネントの特徴 Next.js が提供している Image コンポーネント (next/image) を使用すると、image 要素をそのまま配置するのに比べて次のような恩恵を受けられます。
遅延ロード (Lazy loading) Web ブラウザでその画像がビューポート内（画面内）に入って来たときに初めてダウンロードされるようになります。大きなページの末尾部分に配置された画像が、無駄にダウンロードされてしまうのを防ぐことができます。 画像の最適化 アクセスしてきたクライアントに応じて画像ファイルを最適化して配信します。例えば、圧縮効率のよい WebP フォーマットなどに変換してくれます。リクエスト時にサーバーサイドでオンデマンドで最適化するため、Image コンポーネントを使うことでビルド時間が伸びてしまうことはありません。外部サーバーの画像を間接的に表示する場合も最適化できます。 レスポンシブ 画面サイズに応じたレスポンシブ表示 (CSS) がデフォルトで行われます。 画像最適化に関しては、Next.js サーバー上でホスティングしているときしか動作しないといった制約がありますが、遅延ローディングがデフォルトで有効になるのは便利です。
Image コンポーネントの基本的な使い方 次のサンプルコンポーネントでは、Image コンポーネントを使って /public/images/avatar.png ファイルを表示しています。
components/Avatar.tsx import Image from &amp;#39;next/image&amp;#39; export const Avatar: React.FC = () =&amp;gt; ( &amp;lt;Image src=&amp;#34;/images/avatar.png&amp;#34; width={64} height={64} alt=&amp;#34;My avatar&amp;#34; /&amp;gt; ) ☝️ public ディレクトリ public ディレクトリ以下に配置したファイルは、Web サイトへのアクセス時には、ルートパス (/) からの相対パスで参照できるようになります。 public ディレクトリは、必ず Next.</description></item></channel></rss>