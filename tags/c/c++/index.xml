<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C/C++ on まくろぐ</title><link>https://maku.blog/tags/c/c++/</link><description>Recent content in C/C++ on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><atom:link href="https://maku.blog/tags/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>プロコンメモ: C++ で標準入力から vector&lt;int> を作る技</title><link>https://maku.blog/p/qzxqy3m/</link><pubDate>Mon, 16 Apr 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/qzxqy3m/</guid><description>C++ で標準入力 cin から数値を読み込みながら vector&amp;lt;int&amp;gt; に詰めて行くとき、push_back() を使うと、以下のようにテンポラリ変数が必要になってしまいます。
vector&amp;lt;int&amp;gt; v; int temp; for (int i=0; i&amp;lt;N; ++i) { cin &amp;gt;&amp;gt; temp; v.push_back(temp); } 読み出す回数が N 回、のように決まっているのであれば、vector のサイズを先に初期化してしまうことで、インデックスを使って格納していくことができます。
vector&amp;lt;int&amp;gt; v(N); for (int i=0; i&amp;lt;N; ++i) cin &amp;gt;&amp;gt; v[i];</description></item><item><title>Insertion Sort（挿入ソート）の実装練習</title><link>https://maku.blog/p/axg4xms/</link><pubDate>Tue, 10 Apr 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/axg4xms/</guid><description>Insertion Sort 実装の練習！ void insertion_sort(int vals[], int size) { for (int i = 1; i &amp;lt; size; ++i) { // Insert vals[i] into the sorted sequence vals[0..i-1]. int key = vals[i]; int j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; vals[j] &amp;gt; key) { vals[j + 1] = vals[j]; --j; } vals[j + 1] = key; } } 降順ソート (descending order) にするには、vals[j] &amp;gt; key というところを、vals[j] &amp;lt; key にするだけで OK。</description></item><item><title>プロコンメモ: C++ で vector&lt;pair&lt;int, int> > をソートするテクニック</title><link>https://maku.blog/p/k3evguf/</link><pubDate>Sat, 24 Mar 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/k3evguf/</guid><description>下記のような pair&amp;lt;int, int&amp;gt; の格納された vector があるとします。
vector&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; v; これを単純にソートすると、first メンバが等しい場合は、second メンバの値を元に昇順ソートされます。
sort(v.begin(), v.end()); ここで、second メンバに関してだけ逆順（降順）にソートしたい場合はどうすればよいでしょうか？ すぐに思いつくのは、比較関数を用意して以下のように実装することです。
#include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;utility&amp;gt; // pair, make_pair #include &amp;lt;vector&amp;gt; using namespace std; bool comp(const pair&amp;lt;int, int&amp;gt;&amp;amp; a, const pair&amp;lt;int, int&amp;gt;&amp;amp; b) { if (a.first == b.first) { return a.second &amp;gt; b.second; // descending order } return a.first &amp;lt; b.first; // ascending order } int main() { vector&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; v; v.</description></item><item><title>プロコンメモ: 2 つの数値を連結した数値を作る (123 + 456 → 123456)</title><link>https://maku.blog/p/3bhhjxu/</link><pubDate>Fri, 16 Mar 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/3bhhjxu/</guid><description>たとえば、123 と 456 という数字を連結して、123456 という数字を作りたい場合、以下のように数値計算だけで求めるのが効率的です。 引数 left の値を、「right の桁数+1」分だけ 10 倍してやって、right と足し合わせているだけです。
c&amp;#43;&amp;#43; /* * Concatnate numbers as they are strings. * Both two numbers must not be negative (i.e. 0 or larger). * * e.g.) concat_num(100, 200) =&amp;gt; 100200 */ int concat_num(int left, int right) { int r = 10; while (r &amp;lt;= right) r *= 10; return (left * r) + right; } 以下のように、連結文字列を生成して再度数値に戻す方法は、数値だけで計算するよりも数十倍時間がかかってしまいます。
// NOT good (slower) int concat_num_BAD(int a, int b) { char buf[128]; snprintf(buf, sizeof(buf), &amp;#34;%d%d&amp;#34;, a, b); return atoi(buf); } テストコード int main() { cout &amp;lt;&amp;lt; concat_num(0, 0) &amp;lt;&amp;lt; &amp;#34; = 0&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(1, 1) &amp;lt;&amp;lt; &amp;#34; = 11&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(123, 0) &amp;lt;&amp;lt; &amp;#34; = 1230&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(0, 123) &amp;lt;&amp;lt; &amp;#34; = 123&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(300, 100) &amp;lt;&amp;lt; &amp;#34; = 300100&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; concat_num(777, 999) &amp;lt;&amp;lt; &amp;#34; = 777999&amp;#34; &amp;lt;&amp;lt; endl; }</description></item><item><title>CppUnit の使い方メモ</title><link>https://maku.blog/p/nyj2hxe/</link><pubDate>Tue, 19 Aug 2008 00:00:00 +0900</pubDate><guid>https://maku.blog/p/nyj2hxe/</guid><description>CppUnit-x のダウンロード＆インストール Version: CppUnit-x 20020331 Red Hat Linux 9 SourceForge.JP: Project Info - CppUnit-x http://sourceforge.jp/projects/cppunit-x/ CppUnit-x は数多くある CppUnit の派生物の中でも移植性が高いといわれています。 2008-08-19 現在のバージョンは 20020331 です。 次のように CppUnit-x のアーカイブをダウンロードしてインストールします。
$ wget http://iij.dl.sourceforge.jp/cppunit-x/8452/cppunit-x-20020331.tar.gz $ tar xzvf cppunit-x-20020331.tar.gz $ cd cppunit-x-20020331 $ ./configure $ make $ su # make install これにより、以下のようなライブラリやヘッダファイルがインストールされます。
/usr/local/lib/libcppunit.a /usr/local/include/cppunit/*.h はじめての CppUnit-x テストが 1 つだけの場合は、TestCase のサブクラスで runTest() メソッドをオーバーライドしてテストコードを実装します。 TestRunner オブジェクトに TestCase オブジェクトを追加して TestRunner::run() でテストを実行できます。 TestRunner::run() を呼び出すと、TestRunner に登録された TestCase の runTest() が順に呼び出されます。 次の例のように、名前空間の使用宣言に、USING_NAMESPACE_CPPUNIT というマクロを使用すると、名前空間をサポートしていないコンパイラを使った場合にもそのままコンパイルできるようになります。</description></item><item><title>C/C++サンプル: TCP クライアント／サーバー</title><link>https://maku.blog/p/tgt7it6/</link><pubDate>Fri, 11 May 2001 00:00:00 +0900</pubDate><guid>https://maku.blog/p/tgt7it6/</guid><description>むかーし書いたやつ。 だっさーいコードが残ってるかも (^^;
CTcpClient / CTcpServer ライブラリ CTcpClient.h / CTcpClient.cpp CTcpServer.h / CTcpServer.cpp socket.h Makefile 使用例 SimpleTcpServer.cpp SimpleTcpClient.cpp Makefile</description></item><item><title>C/C++サンプル: TCP ポートスキャナー</title><link>https://maku.blog/p/xwfr3cm/</link><pubDate>Fri, 11 May 2001 00:00:00 +0900</pubDate><guid>https://maku.blog/p/xwfr3cm/</guid><description>むかーし書いたコードです。 だっさーいコードが残ってるかも (^^;
portscan.cpp</description></item><item><title>C/C++サンプル: エンディアンの判定</title><link>https://maku.blog/p/g9q6kyf/</link><pubDate>Fri, 11 May 2001 00:00:00 +0900</pubDate><guid>https://maku.blog/p/g9q6kyf/</guid><description>使用している PC のホストバイトオーダーが、ビッグエンディアンかリトルエンディアンかを調べるプログラムです。
endian.cpp #include &amp;lt;iostream&amp;gt; using namespace std; int main() { union { char c[2]; short s; } u; u.s = 0x0102; if (u.c[0] == 0x01 &amp;amp;&amp;amp; u.c[1] == 0x02) cout &amp;lt;&amp;lt; &amp;#34;Big-endian&amp;#34; &amp;lt;&amp;lt; endl; else if (u.c[0] == 0x02 &amp;amp;&amp;amp; u.c[1] == 0x01) cout &amp;lt;&amp;lt; &amp;#34;Little-endian&amp;#34; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &amp;#34;Unknown&amp;#34; &amp;lt;&amp;lt; endl; return 0; }</description></item></channel></rss>