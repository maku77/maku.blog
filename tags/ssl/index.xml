<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ssl on まくろぐ</title><link>https://maku.blog/tags/ssl/</link><description>Recent content in Ssl on まくろぐ</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Mon, 22 Jan 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://maku.blog/tags/ssl/index.xml" rel="self" type="application/rss+xml"/><item><title>Certbot で Let's Encrypt の SSL 証明書を取得する（Web サーバーの HTTPS 対応）</title><link>https://maku.blog/p/io4gs6h/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0900</pubDate><guid>https://maku.blog/p/io4gs6h/</guid><description>&lt;h2 id="何をするか">何をするか？&lt;/h2>
&lt;p>数年前に Google が Web サイトの常時 SSL 化を推奨し始めて、今では多くの Web サイトが HTTPS によるアクセスに対応しています。
Web サーバーを HTTPS (SSL) 対応するには、第三者機関となる認証局 (CA: Certificate Authority) から SSL 証明書を発行してもらう必要があるのですが、&lt;strong>Let&amp;rsquo;s Encrypt という認証局を使うと、SSL 証明書を無料で発行してもらえます&lt;/strong>（感謝！）。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="600" height="138" src="../../p/io4gs6h/img-001_hu17967330365113016649.png" alt="/p/io4gs6h/img-001.png" />
 &lt;figcaption>図: Let&amp;#39;s Encrypt &amp;#43; Certbot による HTTPS 対応&lt;/figcaption>
&lt;/figure>

&lt;p>レンタルサーバー側で提供されている WordPress 環境などを使用している人は、知らないうちに Let&amp;rsquo;s Encrypt を使った HTTPS 化の恩恵を受けているかもしれません。
ここでは、VPS などで自力で Web サーバーを立ち上げている人が、HTTPS (SSL) 対応する方法を説明します。&lt;/p>
&lt;p>&lt;strong>Let&amp;rsquo;s Encrypt からの SSL 証明書の発行には、Certbot というツールを使うのが一般的です&lt;/strong>。
Certbot による証明書取得や、Web サーバー (nginx) のヴァーチャルホスト設定をまとめて行ってしまう Docker イメージなども存在しますが、ここでは、Certbot の基本的な振る舞いを理解するために、&lt;code>certbot&lt;/code> コマンドを直接実行する前提で説明していきます。&lt;/p>
&lt;h2 id="certbot-とは">Certbot とは&lt;/h2>
&lt;p>&lt;a href="https://certbot.eff.org/">Certbot&lt;/a> は、Let&amp;rsquo;s Encrypt 認証局から SSL 証明書を発行してもらうためのクライアントツールで、以下のような作業を自動で行ってくれます。&lt;/p></description></item><item><title>電子証明書（SSL 証明書）申請用の CSR ファイルを作成する</title><link>https://maku.blog/p/vntjjaw/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0900</pubDate><guid>https://maku.blog/p/vntjjaw/</guid><description>&lt;h2 id="csr-ファイルとは">CSR ファイルとは&lt;/h2>
&lt;p>Web サーバーで HTTPS 通信を可能にするには、SSL 証明書を Web サーバーに設定する必要があります。
SSL 証明書は具体的には、Web サーバーの公開鍵に CA 認証局の電子署名を付けたものです。
SSL 証明書を CA 認証局に発行してもらうときに必要になるのが &lt;strong>CSR: Certificate Signing Request（証明書署名要求）&lt;/strong> ファイルです。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="../../p/fzwyf7z/">電子署名と電子証明書の基礎&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>CA 認証局にもよりますが、&lt;strong>DNS 経由でのドメインへのアクセス&lt;/strong> が可能であれば、SSL 証明書を申請することができます。
Web サーバーの立ち上げは後回しでよいということです。&lt;/p>
&lt;h2 id="csr-ファイル作成のポイント">CSR ファイル作成のポイント&lt;/h2>
&lt;p>CSR ファイルには、Web サーバー用の公開鍵と、申請者の情報（ディスティングイッシュネーム）を含める必要があります。&lt;/p>
&lt;ul>
&lt;li>CSR ファイル (&lt;code>.csr&lt;/code>) を作成するには、対象となる Web サーバーで使用する秘密鍵が必要です（ただし、生成される CSR に含まれるのは公開鍵の方です）。秘密鍵と CSR ファイルの作成には &lt;strong>&lt;code>openssl&lt;/code>&lt;/strong> コマンドを使用します。&lt;/li>
&lt;li>CSR に含める公開鍵は、&lt;strong>そのサーバー専用&lt;/strong> のものである必要があります。別のサーバー用に発行されている証明書で使われている公開鍵を使い回すことはできません。つまり、秘密鍵もそのサーバー専用のものを作るということです。ワイルドカード証明書でない場合は、サブドメインごとに秘密鍵＆証明書を作ることになります。&lt;/li>
&lt;li>電子証明書の更新時には、&lt;strong>毎回新しい秘密鍵を作成&lt;/strong> してしまえば OK です（Web サーバーに設定し直す必要はありますが）。特に推奨されるわけではありませんが、CSR のディスティングイッシュネーム（Common Name や Organization）が変化しないケースでは、秘密鍵を使い回すことが可能です。&lt;/li>
&lt;/ul>
&lt;h2 id="csr-ファイルを作成する">CSR ファイルを作成する&lt;/h2>
&lt;h3 id="秘密鍵ファイルを作成する">秘密鍵ファイルを作成する&lt;/h3>
&lt;p>CSR ファイルを作成するには、サーバー用の秘密鍵が必要になるので、まずは &lt;code>openssl&lt;/code> コマンドで秘密鍵を作成します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">秘密鍵の作成&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="cl">&lt;span class="gp">$&lt;/span> openssl genrsa -out example.com-2024.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>ここでは、秘密鍵のファイル名は &lt;code>example.com-2024.key&lt;/code> としていますが、このように &lt;strong>ホスト名と作成した年の情報&lt;/strong> を含めておくと管理しやすくなります。
出力される秘密鍵は、デフォルトでは次のような &lt;a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM 形式&lt;/a> のテキストファイルになっています。&lt;/p></description></item><item><title>Nginx の設定: http でアクセスされた場合に https にリダイレクトする</title><link>https://maku.blog/p/jowgstm/</link><pubDate>Thu, 10 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku.blog/p/jowgstm/</guid><description>&lt;p>nginx サーバの SSL 対応（https 有効化）が終わった後は、http プロトコルによるアクセスは避けてもらいたいですね。
そのような場合は、下記のように設定しておけば、http でアクセスされた場合に、https で再度アクセスしてもらうようにクライアントに応答することができます（301 という値は、Moved Permanently を示す HTTP レスポンスコードです）。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">/etc/nginx/conf.d/xxx.conf&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># http でアクセスされた場合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="cl"> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="cl"> &lt;span class="kn">server_name&lt;/span> &lt;span class="s">example.com&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="cl"> &lt;span class="kn">return&lt;/span> &lt;span class="mi">301&lt;/span> &lt;span class="s">https://&lt;/span>&lt;span class="nv">$host$request_uri&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># https でアクセスされた場合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">server_name&lt;/span> &lt;span class="s">example.com&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">443&lt;/span> &lt;span class="s">ssl&lt;/span> &lt;span class="s">http2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1"># IPv4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kn">listen&lt;/span> &lt;span class="s">[::]:443&lt;/span> &lt;span class="s">ssl&lt;/span> &lt;span class="s">http2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1"># IPv6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">ssl_certificate&lt;/span> &lt;span class="s">/etc/nginx/ssl/example.com-2024.crt&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">ssl_certificate_key&lt;/span> &lt;span class="s">/etc/nginx/ssl/example.com-2024.key&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">ssl_prefer_server_ciphers&lt;/span> &lt;span class="no">on&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1"># サーバー側の暗号スイートを優先
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="s">/&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">root&lt;/span> &lt;span class="s">/usr/share/nginx/html&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">index&lt;/span> &lt;span class="s">index.html&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>結果として、Web ブラウザから &lt;code>http://example.com/&lt;/code> にアクセスすると、Web ブラウザは自動的に &lt;code>https://example.com/&lt;/code> という URL でアクセスし直すことになります。&lt;/p></description></item><item><title>電子署名と電子証明書の基礎</title><link>https://maku.blog/p/fzwyf7z/</link><pubDate>Fri, 28 Sep 2012 00:00:00 +0900</pubDate><guid>https://maku.blog/p/fzwyf7z/</guid><description>&lt;p>電子署名と電子証明書の話がごっちゃになってることが多いので、まとめておきます。&lt;/p>
&lt;h2 id="電子署名デジタル署名digital-signature">電子署名（デジタル署名）(digital signature)&lt;/h2>
&lt;p>「電子署名」とは、送信するデータに付加されるもので、そのデータの作成者やデータが改ざんされていないことをを確認するためのものです。
別の言い方をすると、受け取ったデータが第三者によって作られた &lt;strong>偽物でないことを確認するための印&lt;/strong> です。&lt;/p>
&lt;p>以下のような手順で、データが偽物でないかを確認します。&lt;/p>
&lt;ul>
&lt;li>データ送信側の「電子署名の作成」手順
&lt;ol>
&lt;li>送信するデータのメッセージダイジェスト（ハッシュ値）を求める。&lt;/li>
&lt;li>メッセージダイジェストを非公開鍵 (private key) で暗号化し、「電子署名」とする。&lt;/li>
&lt;li>データ送信時には、データと「電子署名」を一緒に送る。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>データ受信側の「電子署名の確認」手順
&lt;ol>
&lt;li>受信したデータのメッセージダイジェスト（ハッシュ値）を求める。&lt;/li>
&lt;li>受信した「電子署名」を「送信者の公開鍵」で復号化し、メッセージダイジェストに戻す。&lt;/li>
&lt;li>1 と 2 のメッセージダイジェストが等しければ、本人が作成したデータだと分かる。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>上記の手順からも分かるように、一般的に「電子署名」の仕組みには、&lt;strong>公開鍵暗号方式&lt;/strong> が用いられます。
問題は、「送信者の公開鍵」の交換方法が定義されていないことです。
偽物の公開鍵が使われると、なりすましができてしまいます。
データの受信者は、何らかの方法で「&lt;strong>本物の送信者の公開鍵&lt;/strong>」を取得しなければいけません。&lt;/p>
&lt;p>もちろん、公開鍵を手渡しで渡すことができれば安全ですが、不特定多数のサーバーとの通信のたびにそんなことはやっていられません。
そこで、公開鍵が本物であるかを証明するための、「&lt;strong>電子証明書&lt;/strong>」が必要になってきます。
電子証明書の仕組みを使うと、通信相手の Web サーバーから、直接そのサーバーの公開鍵を取得できるようになります。&lt;/p>
&lt;h2 id="電子証明書デジタル証明書-digital-certificate">電子証明書（デジタル証明書) (digital certificate)&lt;/h2>
&lt;h3 id="電子証明書とは">電子証明書とは？&lt;/h3>
&lt;p>公開鍵が偽物であると、公開鍵暗号方式は意味をなさなくなるため、公開鍵の正当性を証明することが重要になってきます。
&lt;strong>電子証明書は、ある公開鍵が本物であることを証明する&lt;/strong> ためのものです。
大まかに書いてしまうと、公開鍵を次のようにパッケージングしたものです。&lt;/p>
&lt;div style="text-align:center; font-weight:bold;">電子証明書 = 公開鍵 &amp;#43; 本物の公開鍵であることを示す署名&lt;/div>

&lt;h3 id="電子証明書の発行公開鍵への署名">電子証明書の発行（公開鍵への署名）&lt;/h3>
&lt;p>電子証明書は、公開鍵が本物であることを示すためのものですが、その電子証明書自体が本物であることを示すために、&lt;strong>末尾に電子署名&lt;/strong> が付加されます。
その署名は、公開鍵を作成したユーザが行うこともあるし（オレオレ証明書）、信頼のおける第三者が行うこともあります。
通常は、信頼のおける第三者機関である &lt;strong>認証局 (CA: Certificate Authority)&lt;/strong> が電子証明書への署名を行い、電子証明書の発行を行います。&lt;/p>
&lt;div class="xNote">
 &lt;span class="xNote_title">☝️ CA の署名は本物か&lt;/span>
 &lt;span class="xNote_body">&lt;p>電子証明書は、そこに含まれている公開鍵が正しいものかどうかを、CA 署名で確認できるようにしたものですが、その CA 署名自体が本物なのかという問題があります。
CA 署名の真正性も電子証明書によって確かめます。
Windows や macOS などの OS には、有名どころの CA の電子証明書（ルート CA 証明書）があらかじめインストールされており、サーバー証明書内の CA 署名が本物であるかを調べられるようになっています（参考: &lt;a href="https://support.apple.com/ja-jp/HT202858">macOS で利用できるルート証明書の一覧&lt;/a>）。&lt;/p></description></item></channel></rss>