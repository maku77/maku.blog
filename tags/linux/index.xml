<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on まくろぐ</title><link>https://maku.blog/tags/linux/</link><description>Recent content in Linux on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 28 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linuxコマンド: curl コマンドのチートシート</title><link>https://maku.blog/p/2sv4bqw/</link><pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/2sv4bqw/</guid><description>コマンド 説明 curl --help all 詳細なヘルプを表示 curl https://example.com GET リクエスト curl -i https://example.com レスポンスヘッダーも表示 curl -I https://example.com レスポンスヘッダーだけ表示 curl -v https://example.com 冗長表示（リクエストとレスポンスのヘッダーを確認可能） curl -H &amp;quot;Authorization: Bearer TOKEN&amp;quot; https://example.com リクエストヘッダーの指定 curl -b &amp;quot;cookie1=value1; cookie2=value2&amp;quot; http://example.com クッキーの指定 curl -A &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&amp;quot; http://example.com ユーザーエージェントの指定 curl -L http://example.com リダイレクト (302) レスポンスを自動処理 curl -O https://example.com/file.txt ファイルのダウンロード（同名で保存） curl -o hoge.txt https://example.com/file.txt ファイルのダウンロード（別名で保存） curl -# -O http://example.com/largefile.zip ダウンロードの進捗を表示 curl -r 0-100 http://example.com/file.txt -o partial.</description></item><item><title>zsh チートシート</title><link>https://maku.blog/p/vhbe8f8/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vhbe8f8/</guid><description> 種類 キー操作 説明 移動 Ctrl + B カーソルを左へ移動 移動 Ctrl + F カーソルを右へ移動 移動 Ctrl + A カーソルを行頭へ移動 (beggining-of-line) 移動 Ctrl + E カーソルを行末へ移動 (end-of-line) 移動 Alt + ← / Esc, B カーソルを前の単語へ移動 (backward-word) 移動 Alt + → / Esc, F カーソルを後の単語へ移動 (forward-word) 削除 Ctrl + U 行全体を削除 (kill-hole-line) 削除 Ctrl + K カーソル位置から行末までを削除 (kill-line) 削除 Ctrl + H カーソルの前の 1 文字を削除 (Backspace) 削除 Ctrl + D カーソル位置の 1 文字を削除 (Del) 削除 Ctrl + W カーソル位置から単語の先頭までを削除 (backward-kill-word) 削除 Esc, D カーソル位置から単語の末尾までを削除 (kill-word) 編集 Ctrl + Y 貼り付け 編集 Ctrl + T 前の文字と 1 文字入れ替え (transpose-chars) 編集 Esc, U カーソル位置から単語末尾までを大文字にして、カーソルを単語末尾へ移動 (up-case-word) 編集 Esc, L カーソル位置から単語末尾までを小文字にして、カーソルを単語末尾へ移動 (down-case-word) 編集 Esc, C カーソル位置の 1 文字を大文字にして、カーソルを単語末尾へ移動 (capitalize-word) 編集 Esc, T 前の単語と 1 単語入れ替え (transpose-words) 履歴 Ctrl + P 1 つ前のコマンド履歴を表示 (up-line-or-history) 履歴 Ctrl + N 1 つ後のコマンド履歴を表示 (down-line-or-history) 履歴 Ctrl + R コマンド履歴のインクリメンタルサーチ (history-incremental-search-backward) 履歴 Ctrl + O コマンド履歴からコマンドを実行して次の履歴を表示 (accept-line-and-down-history) その他 Ctrl + J / Ctrl + M Enter (accept-line) その他 Ctrl + I / Tab 入力補完 その他 Ctrl + G 入力を破棄して新しい入力を開始する。インクリメンタルサーチを終了するのにも使える (send-break) その他 Ctrl + L 端末（ターミナル）のクリア その他 Ctrl + X, U Undo メモ Alt + ←/→ で単語単位で移動して、Ctrl + W で単語先頭までを削除すれば、任意の位置の単語を削除できます。 Esc の代わりに Ctrl + [ を使うことで、ホームポジションを崩さずに操作できます。 Ctrl + D はカーソル位置の文字を削除するけど、何も入力されていない状態で入力するとシェルを閉じるので注意。</description></item><item><title>Linuxコマンド: ポートを開いているプロセスを調べる (lsof)</title><link>https://maku.blog/p/i7zokcv/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku.blog/p/i7zokcv/</guid><description>迷ったらとりあえずコレ 次のように実行すると、TCP でポートを開いて LISTEN 状態になっているプロセスのコマンド名や PID の一覧を表示できます。
$ lsof -i tcp -s tcp:listen -P COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ControlCe 604 maku 24u IPv4 0xbf4647db74c55935 0t0 TCP *:7000 (LISTEN) ControlCe 604 maku 25u IPv6 0x27a96e6374c5592c 0t0 TCP *:7000 (LISTEN) ControlCe 604 maku 26u IPv4 0xbf46527374c55935 0t0 TCP *:5000 (LISTEN) ControlCe 604 maku 27u IPv6 0x27a9756374c5592c 0t0 TCP *:5000 (LISTEN) deno 8572 maku 14u IPv4 0xbc6a127374c55935 0t0 TCP *:8000 (LISTEN) hugo 10971 maku 6u IPv4 0xbcba127374c55935 0t0 TCP localhost:50001 (LISTEN) hugo 10975 maku 6u IPv4 0xbd35a81374c55935 0t0 TCP localhost:50002 (LISTEN) ruby 52070 maku 9u IPv4 0xbf461d7b74c55935 0t0 TCP localhost:4000 (LISTEN) ruby 52070 maku 12u IPv4 0xbd38681374c55935 0t0 TCP localhost:35729 (LISTEN) node 65924 maku 38u IPv6 0x27a9356374c5592c 0t0 TCP localhost:5173 (LISTEN) Dropbox 68519 maku 114u IPv4 0xbc67e81374c55935 0t0 TCP *:17500 (LISTEN) Dropbox 68519 maku 115u IPv6 0x27a8836374c5592c 0t0 TCP *:17500 (LISTEN) lsof -i の使い方 lsof (list open files) コマンドは、Linux や macOS で、現在開いているファイルやソケットの一覧を表示するコマンドです。 TCP/UDP ソケット（つまりネットワーク）に関する情報を表示するには、-i オプションを指定します。</description></item><item><title>Linuxメモ: ユーザーのデフォルトシェルを変更する (chsh)</title><link>https://maku.blog/p/cqaq7n4/</link><pubDate>Fri, 05 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cqaq7n4/</guid><description>ユーザーが Linux にログインしたときに起動するデフォルトシェルは、chsh (change login shell) コマンドで変更することができます。
カレントユーザーのログインシェルを /bin/bash に変更する $ chsh -s /bin/bash -s オプションではシェルのフルパスを指定する必要があることに注意してください。 例えば、Bash を使いたければ、bash ではなく /bin/bash と入力します。 -s オプションを省略すると、インタラクティブにシェルのパスを入力できます。
参考 Linux のユーザーを管理する (useradd, userdel, passwd) ユーザーを追加する (useradd) ときに、ついでにログインシェルを指定できます。 現在のシステムで選択可能なシェルの一覧は、/etc/shells ファイルで確認できます。
/etc/shells（Ubuntu 22.04 の場合） # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /usr/bin/sh /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen ユーザーごとのログインシェルが現在どう設定されているかは、/etc/passwd ファイルで確認できます。
$ cat /etc/passwd ...（省略）... maku:x:1000:1000::/home/maku:/bin/bash</description></item><item><title>Linux で起動しているサービスの一覧を表示する</title><link>https://maku.blog/p/co7n5jy/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/co7n5jy/</guid><description>pstree コマンドを使う方法 $ pstree systemd─┬─ModemManager───2*[{ModemManager}] ├─acpid ├─2*[agetty] ├─cron ├─dbus-daemon ├─fail2ban-server───4*[{fail2ban-server}] ├─irqbalance───{irqbalance} ├─multipathd───6*[{multipathd}] ├─networkd-dispat ├─ntpd───{ntpd} ├─packagekitd───2*[{packagekitd}] ├─polkitd───2*[{polkitd}] ├─rsyslogd───3*[{rsyslogd}] ├─snapd───10*[{snapd}] ├─sshd───sshd───sh───pstree ├─sshd───sshd───sshd ├─systemd───(sd-pam) ├─systemd-journal ├─systemd-logind ├─systemd-network ├─systemd-resolve ├─systemd-udevd ├─udisksd───4*[{udisksd}] └─unattended-upgr───{unattended-upgr} systemd で各種サービスが動作していることを確認できます。
systemctl コマンドを使う方法 $ systemctl list-unit-files --type=service UNIT FILE STATE VENDOR PRESET acpid.service enabled enabled apparmor.service enabled enabled apport-autoreport.service static - apport-forward@.service static - apport.service generated - apt-daily-upgrade.service static - apt-daily.service static - autovt@.service alias - blk-availability.service enabled enabled bolt.service static - cloud-config.</description></item><item><title>Linuxメモ: sudo で管理者権限でコマンド実行できるようにする (/etc/sudoers, visudo)</title><link>https://maku.blog/p/h5v6gqz/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/h5v6gqz/</guid><description>sudo とは？ Linux の sudo コマンドは、一時的に root ユーザー（あるいは任意のユーザー）としてコマンドを実行できるようにするためのコマンドです。 システムの管理者的な立場の人であっても、常に root ユーザーとして作業するのはリスクがあるため、必要に応じて sudo でコマンド実行することが推奨されています。
sudo コマンドは、次のような形で実行します。
$ sudo ＜管理者権限が必要なコマンド＞ 例えば、/etc/shadow ファイルの閲覧は root ユーザーにしか許可されていませんが、カレントユーザーが sudoers（後述）に登録されていれば、次のようにして読み込むことができます。
$ sudo cat /etc/shadow [sudo] password for maku: （カレントユーザーのパスワードを入力） APT パッケージのインストールでも sudo はよく使われますね。
$ sudo apt install ansible [sudo] password for maku: （カレントユーザーのパスワードを入力） sudo 経由でコマンドを実行するときにパスワードの入力を求められますが、このとき入力するパスワードは root のものではなく、カレントユーザーのパスワードであることに注意してください（OpenSUSE の場合は例外的に root のパスワード）。 つまり、sudo は一般ユーザーが自分のパスワードで実行権限を切り替えてコマンドを実行する仕組みであり、sudoers の設定は慎重に行わなければいけません。
/etc/sudoers ファイルと visudo コマンド /etc/sudoers ファイル どのユーザーが、どのコマンドを、どのユーザーとして実行できるかを管理しているのが /etc/sudoers ファイルです。 ただし、このファイルは次のように編集ができないよう権限設定されており、直接エディタで開いて編集することはできません。
$ ls -l /etc/sudoers -r--r----- 1 root root 1671 Feb 8 17:41 /etc/sudoers visudo コマンド /etc/sudoers ファイルを編集するには、特別に用意された visudo コマンドを使用する必要があります。 次のように実行すれば、デフォルトエディタで /etc/sudoers ファイルを開くことができます。</description></item><item><title>Linux ディストリビューションのバージョンの調べ方まとめ</title><link>https://maku.blog/p/vdweubq/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/vdweubq/</guid><description>Linux ディストリビューションのバージョン情報を調べる方法はいくつかありますが、/etc/os-release ファイルの内容を見るのが簡単です。
/etc/os-release ファイル Ubuntu 22.04 の場合 $ cat /etc/os-release PRETTY_NAME=&amp;#34;Ubuntu 22.04 LTS&amp;#34; NAME=&amp;#34;Ubuntu&amp;#34; VERSION_ID=&amp;#34;22.04&amp;#34; VERSION=&amp;#34;22.04 (Jammy Jellyfish)&amp;#34; VERSION_CODENAME=jammy ID=ubuntu ID_LIKE=debian HOME_URL=&amp;#34;https://www.ubuntu.com/&amp;#34; SUPPORT_URL=&amp;#34;https://help.ubuntu.com/&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.launchpad.net/ubuntu/&amp;#34; PRIVACY_POLICY_URL=&amp;#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;#34; UBUNTU_CODENAME=jammy Debian 11 の場合 $ cat /etc/os-release PRETTY_NAME=&amp;#34;Debian GNU/Linux 11 (bullseye)&amp;#34; NAME=&amp;#34;Debian GNU/Linux&amp;#34; VERSION_ID=&amp;#34;11&amp;#34; VERSION=&amp;#34;11 (bullseye)&amp;#34; VERSION_CODENAME=bullseye ID=debian HOME_URL=&amp;#34;https://www.debian.org/&amp;#34; SUPPORT_URL=&amp;#34;https://www.debian.org/support&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.debian.org/&amp;#34; Rocky Linux 8.6 の場合 $ cat /etc/os-release NAME=&amp;#34;Rocky Linux&amp;#34; VERSION=&amp;#34;8.6 (Green Obsidian)&amp;#34; ID=&amp;#34;rocky&amp;#34; ID_LIKE=&amp;#34;rhel centos fedora&amp;#34; VERSION_ID=&amp;#34;8.6&amp;#34; PLATFORM_ID=&amp;#34;platform:el8&amp;#34; PRETTY_NAME=&amp;#34;Rocky Linux 8.6 (Green Obsidian)&amp;#34; ANSI_COLOR=&amp;#34;0;32&amp;#34; CPE_NAME=&amp;#34;cpe:/o:rocky:rocky:8:GA&amp;#34; HOME_URL=&amp;#34;https://rockylinux.</description></item><item><title>Linuxメモ: Linux のユーザーを管理する (useradd, userdel, passwd)</title><link>https://maku.blog/p/7m5k3hx/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7m5k3hx/</guid><description>Linux をインストールしたばかりの状態では、通常は特権ユーザーの root でログインできる状態になっています。 システム管理以外の日常的な作業には、useradd コマンドで作成した一般ユーザーを用います。
ユーザーを作成する (useradd) 新しいユーザーを作成するには、useradd コマンドを使用します。 -m オプションを指定することで、ユーザーのホームディレクトリを同時に作成することができます。
ユーザー maku を作成する # useradd maku （ユーザーを作成するだけ） # useradd -m maku （ホームディレクトリを同時に作成する） # useradd -m -s /bin/bash maku （さらに、ログインシェルを設定する） # useradd -m -s /bin/bash -G admin maku （さらに、admin グループに所属させる） オプションの意味 -m &amp;hellip; ユーザーのホームディレクトリを同時に作成します -s /bin/bash &amp;hellip; ログインシェルを /bin/bash に設定します。省略した場合は、/etc/default/useradd ファイルで定義されているシェルが設定されます（Ubuntu 22.04 の場合は /bin/sh ですが、dash へのシンボリックリンクです）。ユーザー生成後にログインシェルを変更したい場合は、chsh コマンド を使用します。 -G admin &amp;hellip; ユーザーを admin グループに所属させます（admin は Debian/Ubuntu で管理者を表すグループです）。グループの制御 はユーザー作成後にも行うことができます。 /etc/passwd ファイルを見ると、ユーザーが追加されていることを確認できます。 デフォルトでは、最初に作成したユーザーのユーザー ID は 1000 になります（その後追加するユーザーは、1001、1002、1003 となります）。</description></item><item><title>各種 Linux のファイアウォール設定ツール</title><link>https://maku.blog/p/ceow5cj/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ceow5cj/</guid><description>従来 Linux のパケットフィルタリングの設定には、iptables が使われていましたが、現在ではより直感的な操作が可能な ufw、firewalld、nftables といったツールが使われています。
ディストリビューション ファイアウォール設定ツール Ubuntu 8.04 LTS 以降 ufw CentOS 7 以降 firewalld Fedora 18 以降 firewalld Rocky Linux firewalld および nftables 参考: ufw (Uncomplicated Firewall) によるファイアウォール設定 参考: firewalld によるファイアウォール設定 どのツールも下回りとしては Linux カーネルの Netfilter サブシステムの仕組みを利用しています。
ufw ---+ | firewalld ---+---&amp;gt; Netfilter (Linux kernel) | iptables ---+</description></item><item><title>Linuxメモ: firewalld による Linux のファイアウォール設定</title><link>https://maku.blog/p/ij6kxeq/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ij6kxeq/</guid><description>Red Hat 系 Linux のネットワークのアクセス制御には、従来 iptables が用いられていましたが、現在は firewalld に置き換えられています。 Fedora 18 や CentOS 7、および CentOS の後継的な位置付けの Rocky Linux 8、AlmaLinux 8 には firewalld が標準搭載されています（nftables というのもあります）。
CentOS 6 の頃は iptables が使われていました。 iptables のルールは /etc/sysconfig/iptables というファイルに保存され、システム再起動時にはこのファイルから設定を復帰させるという動作をしていました。 iptables はコマンド体系が煩雑すぎるという問題があり、より直感的な設定が可能な firewalld が作成されました。 firewalld では「一時的な」ルール設定などにも対応しています。
ファイアウォールの設定ツールは変化してきていますが、下回りとして Linux カーネルの Netfilter (netfilter firewall) が使用されていることに変わりはありません。
firewalld のインストール apt でのインストール $ sudo apt install firewalld firewalld の使い方 firewalld の起動・停止と自動起動設定 firewalld は、systemd のサービスとして自動起動できます。
$ systemctl status firewalld # 現在の状態を確認 $ systemctl start firewalld # 直ちに firewalld を起動 $ systemctl stop firewalld # 直ちに firewalld を停止 $ systemctl enable firewalld # 自動起動する $ systemctl disable firewalld # 自動起動しない firewalld の設定を確認する $ firewall-cmd --list-all firewalld の設定を変更する firewalld で HTTP 通信を許可するには次のようにします。</description></item><item><title>Linuxコマンド: TCP/TDP ポートの通信状態を確認する (ss)</title><link>https://maku.blog/p/sg2m6wm/</link><pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/sg2m6wm/</guid><description>関連コマンド: ip コマンド
ss コマンドとは Linux の ss コマンド (socket statistics) は、TCP ポートや UDP ポートの通信状態を確認するためのコマンドで、過去に使われていた net-tools パッケージの netstat コマンドの後継です。 Cent OS 7 ではデフォルトで ss コマンドが採用されています。
APT の iproute2 パッケージをインストールすると、ss コマンドを使用できるようになります。
ss コマンドのインストール $ apt update # パッケージリストの更新 $ apt install -y iproute2 iptable2 パッケージをインストールすると、一緒に ip コマンド などもインストールされます。
ss サブコマンド コマンド 説明 対応する旧コマンド ss -nat TCP ポートの通信状態を確認 netstat -nat ss -nlt LISTEN（待ち受け）状態の TCP ポートを確認 netstat -nlt ss -nau UDP ポートの通信状態を確認UDP ソケットの State カラムは UNCONN と表示される netstat -nau</description></item><item><title>Linux コマンド: ufw による Ubuntu のファイアウォール設定</title><link>https://maku.blog/p/drar8o4/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/drar8o4/</guid><description>ufw とは ufw (Uncomplicated Firewall) は Debian/Ubuntu 系 Linux でパケットフィルタリングの設定（ファイアウォール設定）を行うためのツールです。 従来、パケットフィルタリングのツールとしては iptables が使われていましたが、iptables は設定が煩雑で扱いづらいという問題を抱えていたため、直感的な設定を行うためのツールとして ufw が開発されました。 ufw は Ubuntu 8.04 LTS 以降で使用することができます。
ufw のサブコマンド 通常コマンド コマンド 説明 ufw enable enables the firewall ufw disable disables the firewall ufw default ARG set default policy ufw logging LEVEL set logging to LEVEL ufw allow ARGS add allow rule ufw deny ARGS add deny rule ufw reject ARGS add reject rule ufw limit ARGS add limit rule ufw delete RULE|NUM delete RULE ufw insert NUM RULE insert RULE at NUM ufw prepend RULE prepend RULE ufw route RULE add route RULE ufw route delete RULE|NUM delete route RULE ufw route insert NUM RULE insert route RULE at NUM ufw reload reload firewall ufw reset reset firewall ufw status show firewall status ufw status numbered show firewall status as numbered list of RULES ufw status verbose show verbose firewall status ufw show ARG show firewall report ufw version display version information アプリケーションプロファイル コマンド 説明 ufw app list list application profiles ufw app info PROFILE show information on PROFILE ufw app update PROFILE update PROFILE ufw app default ARG set default application policy ufw の基本的な使い方 ufw で現在の設定を確認する (ufw status) $ sudo ufw status Status: active To Action From -- ------ ---- OpenSSH ALLOW Anywhere OpenSSH (v6) ALLOW Anywhere (v6) 1 行目の表示で、ufw によるファイアウォールが有効 (Status: active) になっているか、無効 (Status: inactive) になっているかを確認することができます。</description></item><item><title>Linuxメモ: Linux のグループを管理する (groupadd, groupdel, gpasswd)</title><link>https://maku.blog/p/uexfvcs/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/uexfvcs/</guid><description>グループの作成と削除 (groupadd, groupdel) Linux でグループを作成／削除するには、groupadd および groupdel コマンドを使用します。 グループ作成時にグループ ID（数値）が自動的に割り当てられますが、-g オプションで明示することもできます。
グループ admin を作成する $ sudo groupadd admin # グループ ID は自動で割り当てる $ sudo groupadd -g 1234 admin # グループ ID を明示する グループ admin を削除する $ sudo groupdel admin ☝️ プライマリ・グループ useradd コマンドでユーザーを作成すると、デフォルトでそのユーザーは、ユーザー名と同じ名前のグループに所属することになります。 このグループをプライマリ・グループと呼びます。 例えば、useradd maku でユーザー maku を作成すると、同時に maku というプライマリ・グループが作成されます。 groupdel コマンドでプライマリ・グループを削除することはできません。 グループにユーザーを追加する (gpasswd) Linux のグループに既存のユーザーを追加／削除するには、gpasswd コマンドを使用します。
グループ admin にユーザー maku を追加する $ sudo gpasswd -a maku admin Adding user maku to group admin グループ admin からユーザー maku を削除する $ sudo gpasswd -d maku admin これらの設定を反映させるには、そのユーザーでログインし直す必要があります。</description></item><item><title>Linuxコマンド: ip コマンドの使い方</title><link>https://maku.blog/p/p7q7n4i/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p7q7n4i/</guid><description>関連コマンド: ss コマンド
ip コマンドとは Linux の ip コマンドを使うと、ネットワークデバイスやルーティングテーブル、ARP テーブルなどの確認・設定を行うことができます。 過去に net-tools パッケージで提供されていた、ifconfig、route、arp、netstat コマンドは deprecated（非推奨）扱いになっています。
ip コマンドをインストールする ip コマンドは APT の iproute2 パッケージに含まれています。 Docker の Ubuntu コンテナなどで ip コマンドが見つからない場合は、次のようにインストールできます。
$ apt update # パッケージリストの更新 $ apt install -y iproute2 iproute2 パッケージには、ip コマンド以外にもいろいろなコマンドが含まれています（参考: iproute2 に含まれるファイルのリスト ─ Debian / archlinux）。
iproute2 のインストールで使えるようになるコマンド arpd - userspace arp daemon
bridge - show / manipulate bridge addresses and devices
devlink - Devlink tool
ip - show / manipulate routing, devices, policy routing and tunnels</description></item><item><title>Linuxメモ: Bluetooth 関連コマンドのメモ (hciconfig, bluetoothctl)</title><link>https://maku.blog/p/ter3doz/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ter3doz/</guid><description>Bluetooth デバイスの情報を表示する (hciconfig) hciconfig は、Bluetooth デバイスの情報表示や設定を行うためのコマンドです。 HCI プロトコルで Bluetooth コントローラーと通信します。 hciconfig コマンドが見つからない場合は、bluez パッケージをインストールします。
Ubuntu への bluez パッケージのインストール $ apt update &amp;amp;&amp;amp; apt install -y bluez Bluetooth のデバイス名には hci0 や hci1 といった名前が付けられ、hciconfig コマンドでそれらの一覧を表示することができます。 次の実行例は、Raspberry Pi 4 に USB Bluetooth ドングルを接続した状態で hciconfig コマンドを実行したときの結果です（アドレスは一部伏せてます）。
$ hciconfig hci1: Type: Primary Bus: USB BD Address: 00:E0:4C:XX:XX:XX ACL MTU: 1021:6 SCO MTU: 255:12 UP RUNNING RX bytes:2186 acl:0 sco:0 events:105 errors:0 TX bytes:12322 acl:0 sco:0 commands:105 errors:0 hci0: Type: Primary Bus: UART BD Address: DC:A6:32:XX:XX:XX ACL MTU: 1021:8 SCO MTU: 64:1 UP RUNNING RX bytes:1514 acl:0 sco:0 events:90 errors:0 TX bytes:2061 acl:0 sco:0 commands:90 errors:0 USB ドングルの Bluetooth デバイスが hci1 (Bus: USB)、Raspberry Pi 4 組み込みの Bluetooth デバイスが hci0 (Bus: UART) として認識されているのが分かります。 hciconfig コマンドに -a (--all) オプションをつけて実行すると、詳細情報を表示できます。</description></item><item><title>Linuxメモ: Netplan で Ubuntu のネットワーク設定を行う</title><link>https://maku.blog/p/7q3dnx8/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/7q3dnx8/</guid><description>Netplan とは Netplan は Linux のネットワーク設定を簡潔な YAML ファイルで行う仕組みで、Ubuntu 18.04 以降（正確には 17 以降）で採用されています。 昔の Ubuntu/Debian で使用されていた /etc/network/interfaces という設定ファイルはもう使われていません。
実際のネットワーク管理は、バックエンドで動作する NetworkManager や systemd-networkd といったネットワークデーモンが行うのですが、Netplan は YAML 設定ファイルの内容を適切な形に変換して、これらのネットワークデーモンに渡してくれます。 つまり、バックエンドでどのようなネットワークデーモンが動いているかを意識せずに、統一されたわかりやすい YAML ファイルでネットワーク設定を行うことができます。
Netplan は次のように振る舞います。
システム起動時に Netplan が設定ファイル (/etc/netplan/*.yaml) を読み込んで、各ネットワークデーモン用の設定値を /run 以下へ書き出す 各ネットワークデーモンが渡された情報に基づいてネットワーク設定を行う 図: netplan.io のサイトより バックエンドのネットワークデーモンとして何を使うかは、設定ファイルの renderer 部分で指定できるようになっていますが、デフォルトでは次のように動作します。
Wifi や 無線 WAN/LTE の設定 &amp;hellip; NetworkManager に渡される それ以外のネットワーク（有線LANなど）の設定 &amp;hellip; networkd に渡される よって、通常はどのネットワークデーモンを使うかを明示する必要はありません。
設定ファイルの読み込まれる順序 Netplan はすべての /etc/netplan/*.yaml ファイルを読み込みます。 複数のファイルが存在する場合は、ファイル名のアルファベット順に読み込まれ、後に読み込まれたファイルの設定値が優先的に使用されます。 例えば、
/etc/netplan/50-cloud-init.yaml /etc/netplan/99-custom.yaml というファイルがある場合、50-cloud-init.yaml で設定された値は 99-custom.yaml の設定値によって上書きされます。</description></item><item><title>Linuxコマンド: date コマンドの使い方</title><link>https://maku.blog/p/ucnv5ck/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ucnv5ck/</guid><description>Linux や macOS に搭載されている date コマンドの使い方のメモです。
日時をフォーマットして出力する $ date +&amp;#39;%Y-%m-%d&amp;#39; 2021-02-23 $ date +&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39; 2021-02-23 01:08:51 Linux と macOS の date コマンドの違い Linux と macOS では、標準でインストールされている date コマンドが次のように異なります。
Linux &amp;hellip; GUN/Linux 系の date コマンド macOS &amp;hellip; BSD 系の date コマンド そのため、-d オプションと -v オプションの使い方に次のような違いがあります。
1 カ月前の日付を調べる $ date -d &amp;#39;-1 month&amp;#39; # GNU/Linux $ date -d &amp;#39;1 month ago&amp;#39; # GNU/Linux $ date -v-1m # macOS 1 日前の日付を調べる $ date -d &amp;#39;-1 day&amp;#39; # GNU/Linux $ date -v-1d # macOS</description></item><item><title>Linuxコマンド: curl コマンドの使用例（GET/POST リクエスト、ファイルのダウンロード）</title><link>https://maku.blog/p/phdp2do/</link><pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku.blog/p/phdp2do/</guid><description>curl コマンドは URL を指定してサーバー上のリソースにアクセスするためのコマンドで、Web API のテストや、ファイルのダウンロードに使用できます。 昔は curl コマンドは Linux 用のコマンドという認識でしたが、Windows 10 には標準搭載されるようになりました。 curl は様々なプロトコルで通信できますが、主に HTTP/HTTPS が使用されます。
参考: curl コマンドのチートシート curl コマンドでファイルをダウンロードする curl コマンドはデフォルトではダウンロードしたファイルを標準出力に出力します。 -o（小文字のオー）オプションや、-O（大文字のオー）オプションを指定することで、ファイルに保存する ことができます。 同時に -L オプションを指定しておくと、リダイレクトレスポンスを自動処理してくれます。
ダウンロード元と同名で保存 (-O) sample.zip という名前で保存 $ curl -L -O http://example.com/sample.zip 別名で保存 (-o) # カレントディレクトリに foo.zip という名前で保存 $ curl -L -o foo.zip http://example.com/sample.zip # 保存先を絶対パスで指定することも可能 $ curl -L -o /tmp/foo.zip http://example.com/sample.zip curl コマンドで GET/POST リクエストを送信する REST API などのテストに curl コマンドを利用できます。
GET リクエスト 特にオプションを指定しなければ、HTTP の GET リクエストが送信されます。</description></item><item><title>Linuxメモ: apt (apt-get) コマンドの使い方メモ</title><link>https://maku.blog/p/rdq2cnx/</link><pubDate>Tue, 21 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rdq2cnx/</guid><description>apt と dpkg の違い Debian/Ubuntu 系 Linux のパッケージ管理には apt (apt-get) コマンドを使いますが、 Low-Level なパッケージ管理コマンドとして dpkg コマンドも備えています。
参考: DebianPackageManagement - Debian Wiki 参考: AptCLI - Debian Wiki dpkg コマンドは純粋にシステムにパッケージをインストールする部分のみを担うため、インターネットからパッケージをダウンロードしたり、依存関係を自動解決したりする仕組みは備えていません。 そこで、apt は dpkg をラップする形でこれらの機能を提供します。
dpkg &amp;hellip; Debian/Ubuntu にパッケージをインストールする仕組み apt &amp;hellip; パッケージの依存関係を解決してダウンロードし、パッケージをインストールする仕組み（ただし、インストールには内部的に dpkg が使われる） apt と apt-get の違い 2016 年にリリースされた Ubuntu 16.04 の頃から、apt-get コマンドの代わりに apt コマンドが使われるようになりました。 2020 年にリリースされた Ubuntu 20.04 でも apt-get、apt-cache コマンドは使用可能ですが、今後は主に apt コマンドを使っていくことになりそうです。
apt はもともと Linux Mint ユーザーによって作られたコマンドで、これまで apt-get や apt-cache などに散らばっていたコマンド群を整理して使いやすくしています。</description></item><item><title>Linuxメモ: デバイスドライバ作成の雑多メモ</title><link>https://maku.blog/p/tm4iwbq/</link><pubDate>Wed, 08 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku.blog/p/tm4iwbq/</guid><description> デバイスドライバは kernel 空間で動作するプログラムで、kernel の機能を使って実装することができる。一方、通常のプログラムはユーザランドで動作する。 デバイスドライバは kernel 自体に組み込んでしまう方法と、ローダブルモジュールとして動的にロード (insmod)、アンロード (rmmod) できるようにする方法がある。 ユーザランドで動作する普通のプログラムが、デバイスドライバの機能を使うには、デバイスファイルを介してアクセスする。 デバイスファイルの操作は、open、close、read、write のような基本的なファイル操作関数を使用する。</description></item><item><title>Linuxコマンド: テンポラリディレクトリを作成する (mktemp)</title><link>https://maku.blog/p/oo32y2x/</link><pubDate>Thu, 30 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/oo32y2x/</guid><description>mktemp コマンドを使用して、一時ディレクトリを作成することができます。
$ mktemp -d /tmp/tmp.LE04SMiEzq mktemp コマンドは、作成したファイルやディレクトリのパスを表示するので、シェルスクリプト内で以下のようにすれば、そのパスを変数に格納することができます。
tempdir=`mktemp -d`</description></item><item><title>Linuxコマンド: ディレクトリのサイズを調べる (du)</title><link>https://maku.blog/p/95pkhzc/</link><pubDate>Wed, 29 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/95pkhzc/</guid><description>du コマンドを使って、ディレクトリ内のファイルの合計サイズを調べることができます。
$ du -hs mydir 685M mydir 各オプションは次のような効果があります。
-h (--human-readable) &amp;hellip; 人に読みやすい単位でサイズ表示します（例: 1K、234M、2G） -s (--summarize) &amp;hellip; 合計サイズのみを表示します サイズ部分だけを表示したい場合は、cut コマンドで 1 番目のフィールドを切り出してしまうのが手っ取り早いです。
$ du -hs mydir | cut -f1 685M</description></item><item><title>Linux の system 関数で任意のプログラムを実行する</title><link>https://maku.blog/p/neegpac/</link><pubDate>Wed, 22 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/neegpac/</guid><description>Linux の system 関数は、プログラムの起動に失敗すると -1 を返します。 また、戻り値を WEXITSTATUS マクロにかけると、呼び出したプログラム自体の終了コード（正常時は 0）を取得することができます。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; // system(), WEXITSTATUS bool doSystem(const char* command) { int ret = system(command); if (ret == -1) { fprintf(stderr, &amp;#34;ERROR: Cannot execute [%s]\n&amp;#34;, command); return false; } int exitStatus = WEXITSTATUS(ret); if (exitStatus != 0) { fprintf(stderr, &amp;#34;ERROR: [%s] returns error %d\n&amp;#34;, command, exitStatus); return false; } return true; }</description></item><item><title>Linuxコマンド: ファイルの MIME メディアタイプを調べる (file)</title><link>https://maku.blog/p/6i7dvxj/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/6i7dvxj/</guid><description>file コマンドに -i オプションを付けて実行すると、そのファイルの MIME タイプを調べることができます。
$ file -i sample.txt sample.txt: text/plain; charset=us-ascii</description></item><item><title>Linuxコマンド: ファイルの内容を8進数や16進数でダンプする (od)</title><link>https://maku.blog/p/cw7ekxc/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/cw7ekxc/</guid><description>od コマンドの基本（8 進数でダンプする） od (octal dump) コマンドを使用すると、ファイルの内容を 8 進数や 16 進数でダンプすることができます。
ファイル内容を 8 進数でダンプする $ od sample.jar | head -5 0000000 045520 002003 000024 000010 000010 122216 037257 000000 0000020 000000 000000 000000 000000 000000 000024 000000 042515 0000040 040524 044455 043116 046457 047101 043111 051505 027124 0000060 043115 106505 005313 030302 042420 001767 103771 040374 0000100 072502 121341 133273 020473 145340 106255 044315 007207 先頭のカラムはアドレスを示しています。
アドレスの後ろからは、6 文字ずつに区切って 8 進数のデータが並びます。 8 進数では 1 文字が 3 ビットなので、6 文字で最大 18 ビットを示すことができますが、od コマンドの出力では、その内の 16 ビット（= 2 バイト）を使用しています。 頭の 2 ビットは必ず 0 でパディングされているので、各カラムの先頭の数字は 0 か 1 になります（アスキーコードのテキストなら必ず 0 でしょう）。</description></item><item><title>Linuxメモ: デバイスドライバのライセンスについて</title><link>https://maku.blog/p/89tt5ie/</link><pubDate>Sun, 19 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/89tt5ie/</guid><description>デバイスドライバを Linux カーネルに直接取り込む（静的リンクする）場合は GPL になります。 Linux カーネル自体が GPL なので、ドライバも GPL になるということです。 このようなドライバはランレベル 1 でロードされます。
カーネルモジュール（ローダブルモジュール）としてドライバを動的にロードする場合は、ライセンスは開発者が決めることができます。 通常はランレベル 3 になった時点で、insmod や modprobe コマンドでロードします。
カーネルモジュールとして作成するドライバのライセンスは、 コードの中で以下のように MODULE_LICENSE マクロを使用して指定します。
MODULE_LICENSE(&amp;#34;Dual BSD/GPL&amp;#34;); ライセンスは以下のものから選択することができます。
GPL GPL v2 GPL and additional rights Dual BSD/GPL Dual MIT/GPL Dual MPL/GPL Proprietary # default</description></item><item><title>Linuxメモ: syslog のログの保存先の設定</title><link>https://maku.blog/p/rm78k9i/</link><pubDate>Sun, 20 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku.blog/p/rm78k9i/</guid><description>/etc/syslog.conf に以下のように記述されていれば、debug レベルのログは /var/log/debug に、info, notice, warn レベルのログは /var/log/messages に記録されます。
*.=debug; \ auth,authpriv.none;\ news.none;mail.none -/var/log/debug *.=info;*.=notice;*.=warn;\ auth,authpriv.none;\ cron,daemon.none;\ mail,news.none -/var/log/messages</description></item><item><title>Linuxコマンド: パッチファイルを作成・適用する (diff, patch)</title><link>https://maku.blog/p/nyehhfd/</link><pubDate>Fri, 11 May 2007 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nyehhfd/</guid><description>パッチの基本 (diff/patch) パッチファイルの作成 sample.cpp #include &amp;lt;iostraem&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;AAA&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } ew/sample.cpp #include &amp;lt;iostraem&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;BBB&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 例えば、上記のような sample.cpp の内容を new/sample.cpp に変更するためのパッチファイルを作成するには、次のように diff コマンドを実行します。
$ diff -u sample.cpp new/sample.cpp &amp;gt; sample.patch -u オプションは unified diff 形式で差分を出力することを示しています（他の形式でも出力可能ですが、patch 用のパッチファイルを作成するときは、ほとんどの場合 unified diff 形式が使用されるようです）。
これで、次のようなパッチファイルが生成されます。
sample.patch --- sample.cpp 2007-05-11 20:36:13.265625000 +0900 +++ new/sample.cpp 2007-05-11 20:26:31.875000000 +0900 @@ -1,6 +1,6 @@ #include &amp;lt;iostraem&amp;gt; int main() { - std::cout &amp;lt;&amp;lt; &amp;#34;AAA&amp;#34; &amp;lt;&amp;lt; std::endl; + std::cout &amp;lt;&amp;lt; &amp;#34;BBB&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } 差分を表示している各行の 1 文字目は次のような意味を持っています。</description></item></channel></rss>