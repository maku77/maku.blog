<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ユニットテスト on まくろぐ</title><link>https://maku.blog/tags/%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88/</link><description>Recent content in ユニットテスト on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 04 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88/index.xml" rel="self" type="application/rss+xml"/><item><title>Jest で TypeScript コードのユニットテストを記述する</title><link>https://maku.blog/p/9xxpe4t/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku.blog/p/9xxpe4t/</guid><description>Jest とは Jest は Facebook が公開した JavaScript 用のシンプルなテストフレームワークで、Node.js 環境で実行することができます。
Jest · 🃏 Delightful JavaScript Testing Jest は下記のような特徴を持っています。
ゼロコンフィグで使い始められる（設定ファイルなしで実行可能） テストを並列実行するので高速 コードカバレッジレポートの出力を標準搭載 わかりやすいマッチャー表現 (expect ～ toBe、toContain など、自然な文章として読める） TypeScript に対応（ts-jest を利用） Jest 用のテストコードは、次のようなコードジェネレーターでも採用されており、利用者は増え続けています（2022 年現在）。
create-react-app &amp;hellip; React アプリのジェネレーター cdk init app &amp;hellip; AWS のインフラ生成コードのジェネレーター Jest のインストール Jest 本体の jest モジュールをインストールします。 TypeScript を使用する場合は、Jest ライブラリの型情報である @types/jest と、Jest 用の TypeScript プロセッサ (ts-jest) もインストールする必要があります。 これらはすべてテスト時のみ使用する NPM モジュールなので、devDependencies としてインストールします。
Jest 本体と TypeScript 関連モジュールをインストール ### npm の場合 $ npm install --save-dev jest @types/jest ts-jest ### yarn の場合 $ yarn add --dev jest @types/jest ts-jest package.</description></item><item><title>JUnit のテストケースを一時的に無効にする（@Ignore/@Disabledアノテーション）</title><link>https://maku.blog/p/ow3zskd/</link><pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ow3zskd/</guid><description>JUnit で特定のテストケース（クラスや関数）を一時的に無効にしておきたい場合は、次のようなアノテーションをクラスや関数に付けます。
JUnit4 の場合: @Ignore アノテーション (org.junit.Ignore) JUnit5 の場合: @Disabled アノテーション (org.junit.jupiter.api.Disabled) Java の場合 // import org.junit.Ignore; // import org.junit.Test; public class MyClassTest { @Test @Ignore public void testSomething() { // ... } } Kotlin の場合 // import org.junit.Ignore // import org.junit.Test class MyClassTest { @Test @Ignore fun testSomething() { // ... } } @Ignore (@Disabled) に文字列パラメータを渡すと、なぜそのテストを無効にしているのかを示すことができます。
@Ignore(&amp;#34;HogeHogeのパラメータを整理中&amp;#34;) @Test fun testSomething() { // ... } このメッセージは JUnit でテストを実行したときに表示されます。 下記は、Android Studio 上で JUnit によるテストを実行したときの表示例です。 16 個のテスト関数のうち 1 つが無視され、その理由が表示されています。</description></item><item><title>private メソッドのユニットテストが書きたくなったら</title><link>https://maku.blog/p/nvetfsf/</link><pubDate>Thu, 16 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nvetfsf/</guid><description>private メソッドをテストすべきかどうかは色々意見がありますが、あるクラスの private メソッドの割合が、public メソッドに比べて非常に多くなった場合は、private メソッドのテストも書きたくなるかもしれません。
そのような場合は、クラス抽出のリファクタリングを考えるとよいです。 特定の処理がクラスとして抽出されれば、そのクラスを利用するインタフェースは public メソッドになるので、自然にテストを記述できるようになります。 もとのクラスの見通しもよくなり、一石二鳥です。
計算処理を担うようなメソッドはテストを記述するよい対象になりますが、private メソッドのままではテストが記述できません。 そのような場合は、public static なユーティリティメソッドに変更することで、テストを記述できるようにするとよいです。 そのメソッド内でフィールドにアクセスしないユーティリティメソッドになっていれば（ステートレス）、オブジェクトに副作用を与えることはないので、public メソッドにしても悪影響は出ません（カプセル化は崩れない）。
JxUnit のように private メソッドをテスト可能なフレームワークを使用するのもひとつの手です。 JxUnit は内部でリフレクションを利用して private メソッドのテストを可能にしています。</description></item><item><title>UnitTest メモ: ユニットテストの網羅レベルの種類 (C0/C1/C2)</title><link>https://maku.blog/p/aet7iu7/</link><pubDate>Fri, 04 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/aet7iu7/</guid><description> C0 &amp;hellip; 「命令網羅」 全ての処理が正しく実行される C1 &amp;hellip; 「分岐網羅」 全ての条件が正しく実行される C2 &amp;hellip; 「条件網羅」 全ての組み合わせの経路が実行される</description></item><item><title>読書メモ『レガシーコード改善ガイド』マイケル・C・フェザーズ</title><link>https://maku.blog/p/p6awy3z/</link><pubDate>Sat, 30 Oct 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p6awy3z/</guid><description>レガシーコード改善ガイド マイケル・C・フェザーズ 翔泳社 はじめに テストのないコードは悪いコード（レガシーコード）である。
これがマイケル・C・フェザーズの強いメッセージです。 どれだけうまく書かれているかは関係ない。テストが書かれていない＝悪であるとまで言い切っています。 どれだけ美しいか、オブジェクト指向か、きちんとカプセル化されているかは関係ない。テストがなきゃだめだ！
第1部 変更のメカニズム 第1章 ソフトウェアの変更 リファクタリングでは、 小さな変更を繰り返し行う。 変更を容易に行うためテストでサポートする。 機能を変更すべきではない。 コードの変更時に問題になるのは、影響範囲を把握できないこと。変更を安全に行うために最も重要なことは、影響範囲を理解すること。 変更を避けると腕がなまってしまう。大きなクラスを分割する作業は週に２，３回くらい行っていないと、困難な仕事になってしまう。頻繁に変更を行っていれば、何が分割できるかの検討をつけやすくなり、変更作業が容易になる。 第2章 フィードバックを得ながらの作業 テストを用意することには、「正しいことを確認するため」だけでなく、「変更を検出するため」という目的もある。 特定のコードにエラーがあると思ったときにテストハーネスを利用できれば、手早くテストコードを書いて、本当にそこにエラーがあるのか確認することができる。 優れた単体テストの条件 実行が速い: 速く走らないとしたら、それは単体テストではない。0.1 秒もかかっていたら遅い単体テストである。「DBアクセス」、「ネットワーク通信」、「ファイルシステムアクセス」、「実行するための環境設定」が必要なものは単体テストとは言えない。 問題個所の特定がしやすい 他のクラスと依存関係があるクラスはテストハーネスに入れられない。例えば、DbConnection に依存しているクラスをテストしたい場合は、まずはインタフェース IDbConnection を導入して依存を切る必要がある。 価値をもたらす機能的な変更を行いながら、システムのより多くの部分をテストで保護していくべき。 扱いやすくなるように大きなクラスを分割するといった些細なことによって、アプリケーションに大きな違いが出てくる。 第3章 検出と分離 テストを整備する際に依存関係を排除するのには2つの理由がある。 検出: コードの計算した値にアクセスできないときに、それを検出するために依存関係を排除する。 分離: コードをテストハーネスに入れて実行することすらできないとき、分離するために依存関係を排除する。 ソフトウェアを分離するには様々な方法があるが、検出のための主な手段は「強調クラスの擬装」のひとつしかない。 あるクラスの依存をインタフェースの導入によってなくした場合、そのクラスに FakeObject を渡してテストすることになる。FakeObject ではテスト対象のクラスから渡されたデータを記録することで、テスト対象のクラスが正しくデータを渡しているかを検証できる。依存部分を切り離すことにより、依存していたインタフェースでやりとりしているデータが正しいかどうかをテストすることができる。 public void testPrintItem() { FakePrinter printer = new FakePrinter(); Item item = new Item(printer); // テスト対象のクラス item.doSomething(100); // テスト対象のメソッド assertEquals(&amp;#34;This is a result&amp;#34;, item.getLastLine()); } オブジェクト指向以外の言語では、代替関数を定義して、その中でテストからアクセスできるグローバルなデータに値を記録する。 擬装オブジェクトに、結果が正しいかを確認する機能を追加したものが「モックオブジェクト」。モックオブジェクトは協力なツールだが、すべての言語に対応するモックオブジェクトフレームが提供されているわけではない。しかし、大抵の場合は、単純な擬装オブジェクトで十分である。 第4章 接合モデル テストが可能になるようにクラスを取り出す作業を行っていると、どのような設計が優れているかという基準が変わってくる。 ソフトウェアを接合部 (Seam) という観点から見ることで、コードにすでに含まれている依存関係を排除するための手掛かりを見出すことが可能になる。Seam とは直接その場所を変更しなくても、プログラムの振る舞いを変えられることのできる場所。 Java では同じ名前のクラスを別のディレクトリに置き、CLASSPATH を変更することで別のクラスにリンクすることができる。（リンク接合部: link seam） 第5章 ツール 自動リファクタリングツール: リファクタリングツールを使って自動リファクタリングを行う場合、振る舞いが変わっていないか注意する必要がある。例えば、リファクタリング後に、あるメソッドの呼び出し回数が変わっている場合、そのメソッドに副作用があると振る舞いが変化する。 モックオブジェクト (mock object): 他のコードを取り除いて、テスト時に自分のコードを完全に実行させるには、代わりに正しい値を返してくれるものが必要になる。オブジェクト指向のコードでは、これをモックオブジェクトと呼ぶ。 単体テストハーネス: xUnit テスティングフレームワークは、ほとんどの言語に移植されている。JUnit, CppUnit, NUnit&amp;hellip; 一般的なテストハーネス: FIT (Framework for Integrated Test) は統合テスト用のテスティングフレームワーク。システムに関する文書を書き、その中にシステムの入力と出力について記述した表を含めることができれば、FIT フレームワークがテストを実行してくれる。FitNesse は wiki 上に構築された FIT で、FIT テストを定義するときに階層構造の Web ページを使うことができる。 第2部 ソフトウェアの変更 第6章 時間がないのに変更しなければなりません 一般的に変更箇所は集中する。今日ソフトウェアを変更しているのであれば、近い将来、そのすぐ近くを変更することになる。 今すぐクラスを変更しなければならないのなら、テストハーネス内でそのクラスのインスタンス化を試みてみる。 システムに新しい要件を加えるときの方法。 スプラウトメソッド (sprout method): 新しい機能を新しいメソッドとして記述する方法。既存のコードに直接手を加えるよりも望ましい結果をもたらす。 長所: 古いコードと新しいコードを明確に区別できる。 短所: 元のコードはテストするわけでもなく、改善するわけでもない。 スプラウトクラス (sprout class): 変更部分を新しいクラスで実現する方法。変更対象の既存のクラスをテストハーネス内でインスタンス化できない場合は、テストを書けないのでスプラウトメソッドは使えない。既存クラスの依存を排除するのに時間がかかりすぎる場合、新しいクラスを導入して、そこだけテスト可能にするという方法がある。 長所: コードを直接書き換える方法よりも、確信を持って変更を進められる。 短所: 仕組みが複雑になること。 第7章 いつまで経っても変更作業が終わりません あまりに多くの依存関係を持つクラスは、大きなコードの塊を切り離し、テストで保護できるかどうかを調べるとよい。</description></item><item><title>CppUnit の使い方メモ</title><link>https://maku.blog/p/nyj2hxe/</link><pubDate>Tue, 19 Aug 2008 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nyj2hxe/</guid><description>CppUnit-x のダウンロード＆インストール Version: CppUnit-x 20020331 Red Hat Linux 9 SourceForge.JP: Project Info - CppUnit-x http://sourceforge.jp/projects/cppunit-x/ CppUnit-x は数多くある CppUnit の派生物の中でも移植性が高いといわれています。 2008-08-19 現在のバージョンは 20020331 です。 次のように CppUnit-x のアーカイブをダウンロードしてインストールします。
$ wget http://iij.dl.sourceforge.jp/cppunit-x/8452/cppunit-x-20020331.tar.gz $ tar xzvf cppunit-x-20020331.tar.gz $ cd cppunit-x-20020331 $ ./configure $ make $ su # make install これにより、以下のようなライブラリやヘッダファイルがインストールされます。
/usr/local/lib/libcppunit.a /usr/local/include/cppunit/*.h はじめての CppUnit-x テストが 1 つだけの場合は、TestCase のサブクラスで runTest() メソッドをオーバーライドしてテストコードを実装します。 TestRunner オブジェクトに TestCase オブジェクトを追加して TestRunner::run() でテストを実行できます。 TestRunner::run() を呼び出すと、TestRunner に登録された TestCase の runTest() が順に呼び出されます。 次の例のように、名前空間の使用宣言に、USING_NAMESPACE_CPPUNIT というマクロを使用すると、名前空間をサポートしていないコンパイラを使った場合にもそのままコンパイルできるようになります。</description></item></channel></rss>