<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ユニットテスト on まくろぐ</title><link>https://maku.blog/tags/%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88/</link><description>Recent content in ユニットテスト on まくろぐ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 30 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku.blog/tags/%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88/index.xml" rel="self" type="application/rss+xml"/><item><title>JUnit のテストケースを一時的に無効にする（@Ignore/@Disabledアノテーション）</title><link>https://maku.blog/p/ow3zskd/</link><pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate><guid>https://maku.blog/p/ow3zskd/</guid><description>JUnit で特定のテストケース（クラスや関数）を一時的に無効にしておきたい場合は、次のようなアノテーションをクラスや関数に付けます。
JUnit4 の場合: @Ignore アノテーション (org.junit.Ignore) JUnit5 の場合: @Disabled アノテーション (org.junit.jupiter.api.Disabled) Java の場合 // import org.junit.Ignore; // import org.junit.Test; public class MyClassTest { @Test @Ignore public void testSomething() { // ... } } Kotlin の場合 // import org.junit.Ignore // import org.junit.Test class MyClassTest { @Test @Ignore fun testSomething() { // ... } } @Ignore (@Disabled) に文字列パラメータを渡すと、なぜそのテストを無効にしているのかを示すことができます。
@Ignore(&amp;#34;HogeHogeのパラメータを整理中&amp;#34;) @Test fun testSomething() { // .</description></item><item><title>private メソッドのユニットテストが書きたくなったら</title><link>https://maku.blog/p/nvetfsf/</link><pubDate>Thu, 16 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku.blog/p/nvetfsf/</guid><description>private メソッドをテストすべきかどうかは色々意見がありますが、あるクラスの private メソッドの割合が、public メソッドに比べて非常に多くなった場合は、private メソッドのテストも書きたくなるかもしれません。
そのような場合は、クラス抽出のリファクタリングを考えるとよいです。 特定の処理がクラスとして抽出されれば、そのクラスを利用するインタフェースは public メソッドになるので、自然にテストを記述できるようになります。 もとのクラスの見通しもよくなり、一石二鳥です。
計算処理を担うようなメソッドはテストを記述するよい対象になりますが、private メソッドのままではテストが記述できません。 そのような場合は、public static なユーティリティメソッドに変更することで、テストを記述できるようにするとよいです。 そのメソッド内でフィールドにアクセスしないユーティリティメソッドになっていれば（ステートレス）、オブジェクトに副作用を与えることはないので、public メソッドにしても悪影響は出ません（カプセル化は崩れない）。
JxUnit のように private メソッドをテスト可能なフレームワークを使用するのもひとつの手です。 JxUnit は内部でリフレクションを利用して private メソッドのテストを可能にしています。</description></item><item><title>読書メモ『レガシーコード改善ガイド』マイケル・C・フェザーズ</title><link>https://maku.blog/p/p6awy3z/</link><pubDate>Sat, 30 Oct 2010 00:00:00 +0000</pubDate><guid>https://maku.blog/p/p6awy3z/</guid><description>レガシーコード改善ガイド マイケル・C・フェザーズ 翔泳社 はじめに テストのないコードは悪いコード（レガシーコード）である。
これがマイケル・C・フェザーズの強いメッセージです。 どれだけうまく書かれているかは関係ない。テストが書かれていない＝悪であるとまで言い切っています。 どれだけ美しいか、オブジェクト指向か、きちんとカプセル化されているかは関係ない。テストがなきゃだめだ！
第1部 変更のメカニズム 第1章 ソフトウェアの変更 リファクタリングでは、 小さな変更を繰り返し行う。 変更を容易に行うためテストでサポートする。 機能を変更すべきではない。 コードの変更時に問題になるのは、影響範囲を把握できないこと。変更を安全に行うために最も重要なことは、影響範囲を理解すること。 変更を避けると腕がなまってしまう。大きなクラスを分割する作業は週に２，３回くらい行っていないと、困難な仕事になってしまう。頻繁に変更を行っていれば、何が分割できるかの検討をつけやすくなり、変更作業が容易になる。 第2章 フィードバックを得ながらの作業 テストを用意することには、「正しいことを確認するため」だけでなく、「変更を検出するため」という目的もある。 特定のコードにエラーがあると思ったときにテストハーネスを利用できれば、手早くテストコードを書いて、本当にそこにエラーがあるのか確認することができる。 優れた単体テストの条件 実行が速い: 速く走らないとしたら、それは単体テストではない。0.1 秒もかかっていたら遅い単体テストである。「DBアクセス」、「ネットワーク通信」、「ファイルシステムアクセス」、「実行するための環境設定」が必要なものは単体テストとは言えない。 問題個所の特定がしやすい 他のクラスと依存関係があるクラスはテストハーネスに入れられない。例えば、DbConnection に依存しているクラスをテストしたい場合は、まずはインタフェース IDbConnection を導入して依存を切る必要がある。 価値をもたらす機能的な変更を行いながら、システムのより多くの部分をテストで保護していくべき。 扱いやすくなるように大きなクラスを分割するといった些細なことによって、アプリケーションに大きな違いが出てくる。 第3章 検出と分離 テストを整備する際に依存関係を排除するのには2つの理由がある。 検出: コードの計算した値にアクセスできないときに、それを検出するために依存関係を排除する。 分離: コードをテストハーネスに入れて実行することすらできないとき、分離するために依存関係を排除する。 ソフトウェアを分離するには様々な方法があるが、検出のための主な手段は「強調クラスの擬装」のひとつしかない。 あるクラスの依存をインタフェースの導入によってなくした場合、そのクラスに FakeObject を渡してテストすることになる。FakeObject ではテスト対象のクラスから渡されたデータを記録することで、テスト対象のクラスが正しくデータを渡しているかを検証できる。依存部分を切り離すことにより、依存していたインタフェースでやりとりしているデータが正しいかどうかをテストすることができる。 public void testPrintItem() { FakePrinter printer = new FakePrinter(); Item item = new Item(printer); // テスト対象のクラス item.</description></item></channel></rss>