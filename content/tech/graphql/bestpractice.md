---
title: "GraphQL ベストプラクティス"
url: "p/4reqy9i/"
date: "2022-09-28"
tags: ["GraphQL"]
draft: true
weight: 1
---

クライアント側（クエリ）
----

GraphQL API を使用するクライアント側で指定するドキュメント（クエリ）に関してのベストプラクティスです。

### query や mutation には操作名を付ける

操作名 (operation name) はマルチ操作ドキュメント (multi-operation document) 以外ではオプショナルとされていますが、サーバーサイドでのロギングに役立つので、なるべく記述するようにすべきです。HTTP リクエストのペイロードに `operationName` が含まれるようになるので、Chrome のデベロッパーツールを使ったクライアントサイドでのデバッグにも役立ちます。

{{< code lang="graphql" title="Not Good" >}}
query {
  books { title author }
}
{{< /code >}}

{{< code lang="graphql" title="Good" >}}
query QueryBooks {
  books { title author }
}
{{< /code >}}


サーバー側（スキーマ定義、リゾルバー実装）
----

### フィールドを Non-null にする場合は慎重に

あるフィールドを一度 Non-null 型（末尾に `!`）で定義してしまうと、後からそのフィールドを Nullable（Null 許容型）に戻すのは困難です。
サーバー側の一方的な都合で Nullable 型に変更すると、Non-null 前提で実装しているクライアントが動作しなくなってしまいます（破壊的変更）。
一般的なプログラミング言語内での関数実装では、Null 安全を考慮して、できるだけ Non-null 型を使用することが推奨されていたりしますが、GraphQL スキーマにおいてはこの考え方はあてはまらないので、Non-null 型を採用する場合は慎重になるべきです。
GraphQL において、`null` 値は次のような状態を表現するために使用されます。

- そのフィールドの値が `null` だった（データベースに格納されている値自体が `null` であるなど）
- そのフィールドのアクセス権限がなかった
- 指定された条件に一致するフィールドが見つからなかった
- その他、リゾルバー内部でエラーが発生した

特に、最後のエラー発生の可能性は軽視しがちです。
リゾルバー内でデータベースにアクセスする場合や、ネットワーク経由でデータ取得する場合は、様々な原因によるエラーが発生します。
例えば、データベースサーバー側の不具合や、ネットワーク遅延によるタイムアウトなどです。
こういったデータ取得を伴うフィールドは、デフォルトの Nullable 型として定義しておくべきです。
ただし、リスト型の戻り値の場合、`null` の代わりに空リストを返すことができるので、Non-null 型で定義しても問題になることは少ないはずです。

### 親フィールドに付随するデータのフィールドは Non-null でよい

### 暗黙的なデフォルト値をリゾルバー内部で定義しない

フィールド・パラメーターとして、ソート順序やフィルタ条件などのオプション・パラメーターを追加する場合、パラメーター省略時の振る舞いをスキーマから読み取れるようにすべきです。
次の例では、パラメーターのデフォルト値を設定することで、API の振る舞いを明確にしています。

```graphql
type Query {
  games(sort: SortOrder = DESC): [Game!]!
}
```

- 参考: [GraphQL スキーマ仕様: 列挙型 (enum type) を定義する](/p/isotm77/)

### ミューテーション操作単位で一貫性を保つ

GraphQL クライアントがミューテーション要求を行う場合、`mutation` ドキュメントには複数のミューテーション操作を含めることができます。

{{< code lang="graphql" title="Not Good（かもしれない）" >}}
mutation ConfigServer {
  setAddress(address: "192.168.0.100") {
     ...serverConfig
  }
  setPort(port: 25052) {
     ...serverConfig
  }
}
{{< /code >}}

これらのミューテーション操作は上から順番に処理されていきますが、いずれかのミューテーション操作でエラーが発生すると、その後のミューテーション処理は実行されません。
GraphQL には、リレーショナルデータベース (RDB) のようなトランザクション処理の仕組みはないため、すでに実行されてしまったミューテーション操作をロールバックすることはできません。
上記の `setAddress` 操作と `setPort` 操作が必ずセットで実行しなければいけない処理であるなら、そもそもミューテーション操作の定義を 1 つにまとめるべきです。

{{< code lang="graphql" title="Good" >}}
mutation ConfigServer {
  changeServerConfig(address: "192.168.0.100", port: 25052) {
     ...serverConfig
  }
}
{{< /code >}}

このように、ミューテーション操作は整合性を保てる単位（RDB で言うところのトランザクション単位）で実行できるようにフィールド設計します。

- 参考: [GraphQL スキーマ仕様: ミューテーションを定義する（データ更新 API）](/p/pk9c9qs/)


セキュリティ
----

### エラーレスポンスに実装の詳細情報を含めない

GraphQL API の呼び出しでエラーが発生したときに、エラー情報としてサーバー側の実装詳細（スタックトレースなど）を返してしまうと、悪意のあるユーザーに不正アクセスのヒントを与えてしまいます。
とはいえ、API の実装中はサーバー側の詳細なエラー情報を返した方が都合がよかったりします。
そのような場合は、次のように、開発中（dev 環境）でのみエラー詳細を返すようにしておくと便利です。

```ts
return config.isDev ? errorReport : { message: 'Oops! Something went wrong.' }
```


リゾルバー実装
----

* 公開 API には Rate Limit やクエリのネスト制限を設ける

* エンドポイントの URL パスは __`/graphql`__
  * エンドポイントの URL パスには多くの場合 `/graphql` が使われています。[GraphQL over HTTP](https://graphql.github.io/graphql-over-http/) の仕様でも `/graphql` を使用することが推奨されています。


